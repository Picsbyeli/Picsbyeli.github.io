<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Burble - Brain Teasers & Riddles Platform</title>
    <link rel="stylesheet" href="assets/css/styles.css">
    <script>
    // Runtime flag to enable E2E-only helpers when `?e2e=1` (or `?e2e`) is present.
    try {
        (function(){
            // Do not overwrite an existing __E2E__ flag (tests may set this via
            // page.addInitScript before page scripts run). Only set from URL if
            // it's currently undefined.
            if (typeof window.__E2E__ === 'undefined') {
                var params = new URLSearchParams(window.location.search || '');
                window.__E2E__ = params.get('e2e') === '1' || params.has('e2e');
            }
        })();
    } catch (e) { if (typeof window.__E2E__ === 'undefined') window.__E2E__ = false; }

    // If tests pre-set __E2E__, create a proxy for drawFromPool that lets
    // Playwright observe a function early and captures the real implementation
    // when the app assigns it later. This prevents races where the app's
    // closure-scoped function isn't yet reachable from the global scope.
    try {
        if (window.__E2E__) {
            try {
                (function(){
                    var realFn = null;
                    Object.defineProperty(window, 'drawFromPool', {
                        configurable: true,
                        enumerable: true,
                        get: function() {
                            return typeof realFn === 'function' ? realFn : function(){ throw new Error('drawFromPool not initialized yet'); };
                        },
                        set: function(v) {
                            if (typeof v === 'function') {
                                realFn = v;
                                try {
                                    // Replace the property with the real function for future reads
                                    Object.defineProperty(window, 'drawFromPool', { value: v, writable: true, configurable: true, enumerable: true });
                                } catch (e) { /* ignore */ }
                            }
                        }
                    });
                })();
            } catch (e) { /* ignore */ }
        }
    } catch (e) {}

    // If E2E mode is enabled, expose a minimal, safe hook early so tests can
    // open the sign-in modal even if later JS fails or loads slowly.
    if (window.__E2E__) {
      (function(){
          try {
              window._testOpenSignin = function(){
                  try {
                      const m = document.getElementById('signin-modal');
                      if (!m) return false;
                      m.classList.remove('hidden');
                      m.style.display = 'flex';
                      m.setAttribute('aria-hidden', 'false');
                      const u = document.getElementById('si-username'); if (u) try{ u.focus(); } catch(e){}
                      return true;
                  } catch (e) { return false; }
              };
          } catch (e) { /* ignore */ }
      })();

      // Also, poll briefly for the app-defined `drawFromPool` function and
      // expose it on `window` as soon as it exists. This helps Playwright (and
      // other E2E harnesses) call the real implementation without racing the
      // app's load/initialization order.
      (function(){
          try {
              var tries = 0;
              var t = setInterval(function(){
                  try {
                      if (typeof drawFromPool === 'function') {
                          // Expose only when E2E flag present OR an admin user is stored in localStorage.
                          var expose = false;
                          try {
                              if (window.__E2E__) expose = true;
                          } catch (e) {}
                          try {
                              var raw = localStorage.getItem('burbleUser');
                              if (raw) {
                                  var u = JSON.parse(raw);
                                  if (u && u.isAdmin) expose = true;
                              }
                          } catch (e) {}
                          if (expose) {
                              try { window.drawFromPool = drawFromPool; } catch (e) {}
                          }
                          clearInterval(t);
                          return;
                      }
                  } catch (e) {}
                  tries++;
                  if (tries > 200) {
                      try { clearInterval(t); } catch(e){}
                  }
              }, 25);
          } catch (e) {}
      })();
    }
    </script>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="logo" onclick="showPage(event,'home')">üß© Burble</div>
            <div class="nav-buttons">
                <button class="nav-btn active" onclick="showPage(event,'home')">Home</button>
                <button class="nav-btn" onclick="showPage(event,'riddles')">Riddles</button>
                <button class="nav-btn" onclick="showPage(event,'burble')">Burble</button>
                <button class="nav-btn" onclick="showPage(event,'emoji')">Emoji</button>
                <button class="nav-btn" onclick="showPage(event,'valentine')">Twenty Questions</button>
                <button class="nav-btn" onclick="showPage(event,'trivia')">Trivia</button>
                <button class="nav-btn" onclick="showPage(event,'animal-trivia')">Animals</button>
                <button class="nav-btn" onclick="showPage(event,'build-quiz')">Build Quiz</button>
                <div class="game-option nav-btn" id="schoolTriviaBtn" style="cursor:pointer">üéì School Trivia</div>
            </div>
            <div class="now-playing" id="now-playing" aria-live="polite">
                <span class="now-playing-art" id="now-playing-art">üéµ</span>
                Now playing: <span id="now-playing-track">None</span>
            </div>
            <div id="user-area" class="user-area">
                <button id="leaderboard-btn" class="nav-btn small">Leaderboard</button>
                <div id="user-info" class="muted-center hidden">
                    <a href="#" id="user-email-link" title="User email">User</a>
                    <div><button id="signout-btn" class="nav-btn xsmall">Sign out</button></div>
                </div>
            </div>
            <!-- Sign-in modal (inserted here so tests can open it) -->
            <div id="leaderboard-modal" class="modal hidden" aria-hidden="true" role="dialog" aria-modal="true" aria-labelledby="lb-title">
                <div class="card leaderboard-card" role="document">
                    <h3 id="lb-title">Leaderboard</h3>
                    <div id="leaderboard-error" class="si-error message-error" aria-live="polite" hidden></div>
                    <div id="leaderboard-list" class="mt-6 leaderboard-list">Loading...</div>
                    <div class="modal-actions">
                        <button id="lb-close" class="nav-btn">Close</button>
                    </div>
                </div>
            </div>
            <!-- Audio Controls -->
            <div class="audio-controls" id="audio-controls" aria-label="Audio controls">
                <select id="audio-mode" title="Mode" aria-label="Audio mode">
                    <option value="all">All</option>
                    <option value="riddles">Riddles</option>
                    <option value="trivia">Trivia</option>
                    <option value="animal">Animal Trivia</option>
                    <option value="burble">Burble</option>
                    <option value="emoji">Emoji</option>
                    <option value="valentine">Twenty Questions</option>
                </select>

                <select id="audio-track" title="Track" aria-label="Audio track"></select>
                <script>
                // Quick, defensive population: run immediately where the select is defined
                (function immediatePopulate(){
                    try {
                        const sel = document.getElementById('audio-track');
                        if (!sel) return;
                        if (sel.options && sel.options.length > 0) return;
                        const tracks = [
                            'assets/audio/Marvel%20Opening%20Theme.mp3',
                            'assets/audio/NFL%20on%20FOX%20Theme%20Song.mp3',
                            'assets/audio/Pok%C3%A9mon%20Theme%20Song.mp3',
                            'assets/audio/Star%20Wars%20Main%20Theme%20(Full).mp3',
                            'assets/audio/The%20Price%20is%20Right%20theme%20song.mp3',
                            'assets/audio/30%20Second%20Timer%20With%20Jeopardy%20Thinking%20Music.mp3'
                        ];
                        tracks.forEach(src => {
                            const opt = document.createElement('option');
                            opt.value = src;
                            try { opt.text = decodeURIComponent(src.split('/').pop()); } catch(e){ opt.text = src; }
                            sel.appendChild(opt);
                        });
                        // expose helpers for tests (only in E2E mode)
                        try { if (window.__E2E__) { window.populateAudioSelect = function(){ return Array.from(sel.options).map(o=>o.value); }; window.defaultTracks = tracks.slice(); } } catch(e){}
                    } catch (e) { /* ignore */ }
                })();
                // centralized wiring is implemented inside the `enhanceAudioAndAuth()` IIFE
                // further down; avoid duplicate immediate fallbacks so there is a single
                // source of truth for modal/auth behavior.
                </script>

                <button id="audio-prev" title="Previous">‚óÄ</button>
                <button id="audio-rewind" title="Rewind 10s">-10s</button>
                <button id="audio-play" title="Play" class="play-btn"><span class="play-icon">‚ñ∂</span></button>
                <button id="audio-pause" title="Pause">‚ùö‚ùö</button>
                <button id="audio-forward" title="Forward 10s">+10s</button>
                <button id="audio-next" title="Next">‚ñ∂‚ñ∂</button>

                <input type="range" id="audio-volume" class="volume" min="0" max="1" step="0.01" aria-label="Audio volume" title="Audio volume">
                <label for="audio-show-queue" class="audio-queue-label" title="Show queue"><input type="checkbox" id="audio-show-queue">Queue</label>
            </div>
            <div class="audio-url-playback mt-8 inline-flex">
                <input id="audio-url-input" type="text" class="flex-1 audio-url-input" placeholder="Paste audio URL or YouTube link" aria-label="Audio URL or YouTube link" />
                <button id="audio-play-url" class="nav-btn">Play URL</button>
                <button id="audio-stop-url" class="nav-btn">Stop</button>
            </div>
            <div id="audio-queue" class="audio-queue hidden" aria-hidden="true">
                <div class="queue-header">
                        <strong class="queue-title">Queue</strong>
                        <div>
                            <button id="audio-clear-queue" title="Clear queue" class="clear-queue-btn">Clear</button>
                        </div>
                    </div>
                <div id="audio-queue-list"></div>
            </div>
            <!-- Playback status and progress -->
            <div class="audio-feedback mt-8 inline-flex">
                <div id="audio-status" class="audio-status-muted">Idle</div>
                <input id="audio-progress" class="seek flex-1" type="range" min="0" max="100" value="0" step="0.1" title="Playback position" aria-label="Playback position" />
                <div id="audio-time" class="audio-time">00:00 / 00:00</div>
            </div>
            <!-- Inline alert area for audio URL preflight/loading/errors -->
            <div id="audio-alert" class="audio-alert hidden" role="alert" aria-live="assertive" aria-hidden="true" tabindex="-1">
                <span id="audio-alert-msg" class="audio-alert-msg"></span>
                <div class="audio-alert-actions">
                    <button id="audio-retry" type="button" class="audio-alert-btn hidden" title="Retry" aria-label="Retry audio playback">Retry</button>
                    <button id="audio-dismiss" type="button" class="audio-alert-btn" title="Close" aria-label="Dismiss audio alert">√ó</button>
                </div>
            </div>
            <div id="youtube-api-root"></div>
        </div>

        <!-- Home Page -->
        <div id="home-page" class="game-container">
            <div class="hero-section">
                <h1 class="hero-title">Brain Teasers & Riddles</h1>
                <p class="hero-subtitle">Challenge your mind with puzzles, riddles, and brain games</p>
                
                <!-- User Stats -->
                <div class="user-stats">
                    <div class="stat-card">
                        <div class="stat-value" id="total-score">0</div>
                        <div class="stat-label">Total Score</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="games-played">0</div>
                        <div class="stat-label">Games Played</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="games-won">0</div>
                        <div class="stat-label">Games Won</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="win-rate">0%</div>
                        <div class="stat-label">Win Rate</div>
                    </div>
                </div>
            </div>

            <!-- Games Grid -->
            <div class="games-grid">
                <div class="game-card" onclick="showPage(event,'riddles')">
                    <div class="game-icon">üß©</div>
                    <div class="game-title">Brain Riddles</div>
                    <div class="game-description">Classic riddles and brain teasers across all categories</div>
                </div>
                
                <div class="game-card" onclick="showPage(event,'burble')">
                    <div class="game-icon">üìö</div>
                    <div class="game-title">Burble Word Game</div>
                    <div class="game-description">Word guessing with feedback and hints</div>
                </div>
                
                <div class="game-card" onclick="showPage(event,'emoji')">
                    <div class="game-icon">üé®</div>
                    <div class="game-title">Emoji Guess</div>
                    <div class="game-description">Decode emoji combinations</div>
                </div>
                
                <div class="game-card" onclick="showPage(event,'valentine')">
                    <div class="game-icon">üéØ</div>
                    <div class="game-title">Twenty Questions</div>
                    <div class="game-description">Yes/No question guessing game</div>
                </div>
                
                <div class="game-card" onclick="showPage(event,'trivia')">
                    <div class="game-icon">üß†</div>
                    <div class="game-title">General Trivia</div>
                    <div class="game-description">Test your knowledge across various topics</div>
                </div>
                
                <div class="game-card" onclick="showPage(event,'animal-trivia')">
                    <div class="game-icon">ü¶Å</div>
                    <div class="game-title">Animal Trivia</div>
                    <div class="game-description">Animal-focused quiz questions</div>
                </div>
            </div>
        </div>

        <section id="pool-manager" class="mt-6">
            <h3>Pool Manager</h3>
            <p id="pool-manager-desc">Persistent pools ensure questions don't repeat across runs. Use this to inspect and reset pools.</p>
            <div id="pool-counts" aria-live="polite" class="mb-2">Loading pool counts‚Ä¶</div>
            <button id="reset-all-pools">Reset All Pools</button>
        </section>

        <!-- Riddles Game -->
        <div id="riddles-page" class="game-container hidden">
            <div class="game-header">
                <h1 class="game-title-main">üß© Brain Riddles</h1>
                
                <div class="difficulty-selector">
                    <span class="selector-label">Difficulty</span>
                    <div class="selector-buttons">
                        <button class="selector-btn" data-difficulty="easy">Easy</button>
                        <button class="selector-btn active" data-difficulty="medium">Medium</button>
                        <button class="selector-btn" data-difficulty="hard">Hard</button>
                    </div>
                </div>

                <div class="category-selector">
                    <span class="selector-label">Category</span>
                    <div class="selector-buttons">
                        <button class="selector-btn active" data-category="all">All Types</button>
                        <button class="selector-btn" data-category="logic">Logic</button>
                        <button class="selector-btn" data-category="word">Word</button>
                        <button class="selector-btn" data-category="math">Math</button>
                        <button class="selector-btn" data-category="lateral">Lateral Thinking</button>
                    </div>
                </div>
            </div>

            <div class="game-info">
                <div class="info-card">
                    <div class="info-label">Score</div>
                    <div class="info-value" id="riddles-score">0</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Solved</div>
                    <div class="info-value" id="riddles-solved">0</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Category</div>
                    <div class="info-value" id="riddles-category">All Types</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Difficulty</div>
                    <div class="info-value" id="riddles-difficulty">Medium</div>
                </div>
            </div>

            <div id="riddles-question-container">
                <div class="game-display" id="riddles-question">Click "New Riddle" to start solving brain teasers!</div>
            </div>

            <div class="input-section">
                <input type="text" class="game-input" id="riddles-input" placeholder="Type your answer..." disabled>
            </div>

            <div class="action-buttons">
                <button class="btn btn-primary" id="riddles-submit" disabled>Submit Answer</button>
                <button class="btn btn-secondary" id="riddles-hint" disabled>Get Hint (-10 points)</button>
                <button class="btn btn-secondary" id="riddles-next">New Riddle</button>
            </div>

            <div id="riddles-feedback"></div>
            <div id="riddles-game-over"></div>
        </div>

        <!-- Burble Word Game -->
        <div id="burble-page" class="game-container hidden">
            <div class="game-header">
                <h1 class="game-title-main">üß© Burble Word Game</h1>
                
                <div class="difficulty-selector">
                    <span class="selector-label">Difficulty</span>
                    <div class="selector-buttons">
                        <button class="selector-btn" data-difficulty="easy">Easy (15 attempts)</button>
                        <button class="selector-btn active" data-difficulty="medium">Medium (10 attempts)</button>
                        <button class="selector-btn" data-difficulty="hard">Hard (5 attempts)</button>
                    </div>
                </div>

                <div class="category-selector">
                    <span class="selector-label">Category</span>
                    <div class="selector-buttons">
                        <button class="selector-btn active" data-category="Food">Food</button>
                        <button class="selector-btn" data-category="Animals">Animals</button>
                        <button class="selector-btn" data-category="Colors">Colors</button>
                        <button class="selector-btn" data-category="Cities">Cities</button>
                        <button class="selector-btn" data-category="Items">Items</button>
                        <button class="selector-btn" data-category="Sports">Sports</button>
                    </div>
                </div>
            </div>

            <div class="game-info">
                <div class="info-card">
                    <div class="info-label">Attempts</div>
                    <div class="info-value" id="burble-attempts">0/10</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Category</div>
                    <div class="info-value" id="burble-category">Food</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Time</div>
                    <div class="info-value timer" id="burble-timer">00:00</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Score</div>
                    <div class="info-value" id="burble-score">0</div>
                </div>
            </div>

            <div class="game-display" id="burble-display">Click "New Game" to start!</div>

            <div class="input-section">
                <input type="text" class="game-input" id="burble-input" placeholder="Enter your guess..." maxlength="20" disabled>
            </div>

            <div class="action-buttons">
                <button class="btn btn-primary" id="burble-submit" disabled>Submit Guess</button>
                <button class="btn btn-secondary" id="burble-hint" disabled>Get Hint</button>
                <button class="btn btn-secondary" id="burble-new-game">New Game</button>
            </div>

            <div id="burble-feedback"></div>
            <div id="burble-game-over"></div>
        </div>

        <!-- Emoji Guess Game -->
        <div id="emoji-page" class="game-container hidden">
            <div class="game-header">
                <h1 class="game-title-main">üß© Emoji Guess</h1>
                
                <div class="difficulty-selector">
                    <span class="selector-label">Difficulty</span>
                    <div class="selector-buttons">
                        <button class="selector-btn" data-difficulty="easy">Easy</button>
                        <button class="selector-btn active" data-difficulty="medium">Medium</button>
                        <button class="selector-btn" data-difficulty="hard">Hard</button>
                    </div>
                </div>

                <div class="category-selector">
                    <span class="selector-label">Category</span>
                    <div class="selector-buttons">
                        <button class="selector-btn active" data-category="all">All</button>
                        <button class="selector-btn" data-category="movies">Movies</button>
                        <button class="selector-btn" data-category="foods">Foods</button>
                        <button class="selector-btn" data-category="animals">Animals</button>
                        <button class="selector-btn" data-category="items">Items</button>
                    </div>
                </div>
            </div>

            <div class="game-info">
                <div class="info-card">
                    <div class="info-label">Score</div>
                    <div class="info-value" id="emoji-score">0</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Hints Used</div>
                    <div class="info-value" id="emoji-hints">0</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Category</div>
                    <div class="info-value" id="emoji-category">All</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Difficulty</div>
                    <div class="info-value" id="emoji-difficulty">Medium</div>
                </div>
            </div>

            <div class="game-display emoji-display" id="emoji-display">Click "New Puzzle" to start!</div>

            <div class="input-section">
                <input type="text" class="game-input" id="emoji-input" placeholder="What does this emoji combination represent?" disabled>
            </div>

            <div class="action-buttons">
                <button class="btn btn-primary" id="emoji-submit" disabled>Submit Answer</button>
                <button class="btn btn-secondary" id="emoji-hint" disabled>Get Hint (-5 points)</button>
                <button class="btn btn-secondary" id="emoji-new-puzzle">New Puzzle</button>
            </div>

            <div id="emoji-feedback"></div>
            <div id="emoji-game-over"></div>
        </div>

        <!-- Twenty Questions Game -->
        <div id="valentine-page" class="game-container hidden">
            <div class="game-header">
                <h1 class="game-title-main">üéØ Twenty Questions</h1>
                
                <div class="difficulty-selector">
                    <span class="selector-label">Difficulty</span>
                    <div class="selector-buttons">
                        <button class="selector-btn" data-difficulty="easy">Easy (8 questions)</button>
                        <button class="selector-btn active" data-difficulty="medium">Medium (6 questions)</button>
                        <button class="selector-btn" data-difficulty="hard">Hard (4 questions)</button>
                    </div>
                </div>

                <div class="category-selector">
                    <span class="selector-label">Category</span>
                    <div class="selector-buttons">
                        <button class="selector-btn active" data-category="movies">Movies</button>
                        <button class="selector-btn" data-category="animals">Animals</button>
                        <button class="selector-btn" data-category="places">Places</button>
                        <button class="selector-btn" data-category="objects">Objects</button>
                    </div>
                </div>
            </div>

            <div class="game-info">
                <div class="info-card">
                    <div class="info-label">Questions Left</div>
                    <div class="info-value" id="valentine-questions">6</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Guesses Left</div>
                    <div class="info-value" id="valentine-guesses">3</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Category</div>
                    <div class="info-value" id="valentine-category">Movies</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Score</div>
                    <div class="info-value" id="valentine-score">0</div>
                </div>
            </div>

            <div class="question-history" id="valentine-history">
                <p class="muted-center">Ask yes/no questions to figure out what I'm thinking of!</p>
            </div>

            <div class="input-section">
                <input type="text" class="game-input" id="valentine-question" placeholder="Ask a yes/no question..." disabled>
            </div>

            <div class="action-buttons">
                <button class="btn btn-primary" id="valentine-ask" disabled>Ask Question</button>
                <button class="btn btn-secondary" id="valentine-guess" disabled>Make Guess</button>
                <button class="btn btn-secondary" id="valentine-new-game">New Game</button>
            </div>

            <div id="valentine-feedback"></div>
            <div id="valentine-game-over"></div>
        </div>

        <!-- General Trivia Game -->
        <div id="trivia-page" class="game-container hidden">
            <div class="game-header">
                <h1 class="game-title-main">üß† General Trivia</h1>
                
                <div class="difficulty-selector">
                    <span class="selector-label">Difficulty</span>
                    <div class="selector-buttons">
                        <button class="selector-btn" data-difficulty="easy">Easy</button>
                        <button class="selector-btn active" data-difficulty="medium">Medium</button>
                        <button class="selector-btn" data-difficulty="hard">Hard</button>
                    </div>
                </div>
            </div>

            <div class="game-info">
                <div class="info-card">
                    <div class="info-label">Question</div>
                    <div class="info-value" id="trivia-question-num">0/10</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Correct</div>
                    <div class="info-value" id="trivia-correct">0</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Score</div>
                    <div class="info-value" id="trivia-score">0</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Time</div>
                    <div class="info-value timer" id="trivia-timer">00:00</div>
                </div>
            </div>

            <div class="trivia-question" id="trivia-question-text">Click "Start Quiz" to begin!</div>

            <div class="trivia-options" id="trivia-options"></div>

            <div class="action-buttons">
                <button class="btn btn-primary" id="trivia-submit" disabled>Submit Answer</button>
                <button class="btn btn-secondary" id="trivia-next" disabled>Next Question</button>
                <button class="btn btn-secondary" id="trivia-start">Start Quiz</button>
            </div>

            <div id="trivia-feedback"></div>
            <div id="trivia-game-over"></div>
        </div>

        <!-- Leaderboard Page -->
        <div id="leaderboard-page" class="game-container hidden">
            <div class="game-header">
                <h1 class="game-title-main">üèÜ Leaderboard</h1>
            </div>
                <div class="leaderboard-tabs">
                <button class="selector-btn active" data-tab="scores" onclick="showLeaderboardTab('scores')">Scores</button>
                <button class="selector-btn" data-tab="details" onclick="showLeaderboardTab('details')">Details</button>
            </div>
            <div id="leaderboard-content">
                <div id="leaderboard-scores">
                    <table class="table-full">
                        <thead>
                            <tr><th class="text-left">Rank</th><th>User</th><th>Score</th></tr>
                        </thead>
                        <tbody id="leaderboard-scores-body"></tbody>
                    </table>
                </div>
                <div id="leaderboard-details" class="hidden">
                    <table class="table-full">
                        <thead>
                            <tr><th class="text-left">Rank</th><th>User</th><th>Questions Solved</th><th>Avg Time (s)</th><th>Highest Streak</th></tr>
                        </thead>
                        <tbody id="leaderboard-details-body"></tbody>
                    </table>
                </div>
            </div>

                <!-- Build Your Own Quiz Page -->
                <div id="build-quiz-page" class="game-container hidden">
                    <div class="game-header">
                        <h1 class="game-title-main">üõ†Ô∏è Build Your Own Quiz</h1>
                        <p class="muted-center">Paste JSON or CSV of questions below, or drop a file. Supported JSON format: [{ question, options:[...], correct: index }]</p>
                    </div>
                    <div class="input-section">
                        <textarea id="build-quiz-input" class="game-input" placeholder='Paste JSON or CSV here...' rows="8"></textarea>
                        <div class="build-quiz-controls">
                            <button id="build-quiz-parse" class="btn btn-primary">Parse & Preview</button>
                            <button id="build-quiz-start" class="btn btn-secondary" disabled>Start Quiz</button>
                            <label for="build-quiz-file" class="build-quiz-file">Upload file: <input id="build-quiz-file" type="file" accept=".json,.csv,.tsv" title="Upload quiz file"/></label>
                        </div>
                    </div>
                    <div id="build-quiz-preview"></div>
                </div>
        </div>

        <!-- Animal Trivia Game -->
        <div id="animal-trivia-page" class="game-container hidden">
            <div class="game-header">
                <h1 class="game-title-main">ü¶Å Animal Trivia</h1>
                
                <div class="difficulty-selector">
                    <span class="selector-label">Difficulty</span>
                    <div class="selector-buttons">
                        <button class="selector-btn" data-difficulty="easy">Easy</button>
                        <button class="selector-btn active" data-difficulty="medium">Medium</button>
                        <button class="selector-btn" data-difficulty="hard">Hard</button>
                    </div>
                </div>
            </div>

            <div class="game-info">
                <div class="info-card">
                    <div class="info-label">Question</div>
                    <div class="info-value" id="animal-question-num">0/15</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Correct</div>
                    <div class="info-value" id="animal-correct">0</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Score</div>
                    <div class="info-value" id="animal-score">0</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Time</div>
                    <div class="info-value timer" id="animal-timer">00:00</div>
                </div>
            </div>

            <div class="trivia-question" id="animal-question-text">Click "Start Quiz" to begin!</div>

            <div class="trivia-options" id="animal-options"></div>

            <div class="action-buttons">
                <button class="btn btn-primary" id="animal-submit" disabled>Submit Answer</button>
                <button class="btn btn-secondary" id="animal-next" disabled>Next Question</button>
                <button class="btn btn-secondary" id="animal-start">Start Quiz</button>
            </div>

            <div id="animal-feedback"></div>
            <div id="animal-game-over"></div>
        </div>
    </div>

    <script>
    // Fallback: ensure audio-track has options even if earlier wiring missed them
    (function fallbackPopulateAudioTrack(){
        try {
            const sel = document.getElementById('audio-track');
            if (!sel) return;
            if (sel.options && sel.options.length > 0) return;
            const fallback = [
                'assets/audio/Marvel%20Opening%20Theme.mp3',
                'assets/audio/NFL%20on%20FOX%20Theme%20Song.mp3',
                'assets/audio/Pok%C3%A9mon%20Theme%20Song.mp3',
                'assets/audio/Star%20Wars%20Main%20Theme%20(Full).mp3',
                'assets/audio/The%20Price%20is%20Right%20theme%20song.mp3',
                'assets/audio/30%20Second%20Timer%20With%20Jeopardy%20Thinking%20Music.mp3'
            ];
            fallback.forEach(src => {
                const opt = document.createElement('option');
                opt.value = src;
                try { opt.text = decodeURIComponent(src.split('/').pop()); } catch(e){ opt.text = src; }
                sel.appendChild(opt);
            });
            // expose for tests
            try { window.populateAudioSelect = function(){ return Array.from(sel.options).map(o=>o.value); }; } catch(e){}
        } catch (e) { /* swallow */ }
    })();
    // Global game state
        const gameState = {
            currentPage: 'home',
            userStats: {
                totalScore: 0,
                gamesPlayed: 0,
                gamesWon: 0
            },
            burble: {
                difficulty: 'medium',
                category: 'Food',
                currentWord: '',
                attempts: 0,
                maxAttempts: 10,
                score: 0,
                gameActive: false,
                startTime: null,
                timerInterval: null,
                hintsUsed: 0
            },
            emoji: {
                difficulty: 'medium',
                category: 'all',
                currentPuzzle: null,
                score: 0,
                hintsUsed: 0,
                gameActive: false
            },
            valentine: {
                difficulty: 'medium',
                category: 'movies',
                currentAnswer: '',
                questionsLeft: 6,
                guessesLeft: 3,
                score: 0,
                gameActive: false,
                questions: [],
                answers: []
            },
            trivia: {
                difficulty: 'medium',
                currentQuestion: 0,
                totalQuestions: 10,
                correctAnswers: 0,
                score: 0,
                gameActive: false,
                startTime: null,
                timerInterval: null,
                selectedAnswer: null
            },
            animalTrivia: {
                difficulty: 'medium',
                currentQuestion: 0,
                totalQuestions: 15,
                correctAnswers: 0,
                score: 0,
                gameActive: false,
                startTime: null,
                timerInterval: null,
                selectedAnswer: null
            },
            riddles: {
                difficulty: 'medium',
                category: 'all',
                currentRiddle: null,
                currentHintLevel: 0,
                score: 0,
                solved: 0,
                hintsUsed: 0,
                gameActive: false,
                attemptCount: 0,
                maxAttempts: 3
            }
        };

        // Word categories for Burble game
            // Acquire a short-lived lock in localStorage to avoid concurrent rotations across tabs.
            function _acquireRotationLock(ttlMs) {
                try {
                    const key = 'burbleRotationLock';
                    const now = Date.now();
                    const raw = localStorage.getItem(key);
                    if (raw) {
                        try {
                            const obj = JSON.parse(raw);
                            if (obj && obj.ts && (now - obj.ts) < (obj.ttl || ttlMs || 60000)) {
                                // lock held
                                return false;
                            }
                        } catch (e) { /* ignore parse errors and acquire lock */ }
                    }
                    const lock = { ts: now, ttl: ttlMs || 60000, id: Math.random().toString(36).slice(2) };
                    localStorage.setItem(key, JSON.stringify(lock));
                    return lock.id;
                } catch (e) { return false; }
            }

            function _releaseRotationLock(id) {
                try {
                    const key = 'burbleRotationLock';
                    const raw = localStorage.getItem(key);
                    if (!raw) return true;
                    try {
                        const obj = JSON.parse(raw);
                        if (!obj) { localStorage.removeItem(key); return true; }
                        if (id && obj.id && obj.id !== id) return false; // someone else holds it
                    } catch (e) { /* fallthrough */ }
                    localStorage.removeItem(key);
                    return true;
                } catch (e) { return false; }
            }

            // Map pool name prefixes to gameState keys dynamically. If a pool name is unknown,
            // attempt to match against existing gameState properties by common aliases.
            function _poolNameToGameStateKey(poolName) {
                const mapping = {
                    'trivia': 'trivia',
                    'animal': 'animalTrivia',
                    'riddles': 'riddles',
                    'burble': 'burble',
                    'emoji': 'emoji',
                    'valentine': 'valentine'
                };
                if (mapping[poolName]) return mapping[poolName];
                // fallback: try to find any gameState property that contains the poolName
                const keys = Object.keys(gameState || {});
                for (let k of keys) {
                    if (k.toLowerCase().indexOf(poolName.toLowerCase()) >= 0) return k;
                }
                return null;
            }

            // options: { force: boolean }
            function rotatePersistentPools(options) {
                options = options || {};
                const force = !!options.force;
                const lockId = _acquireRotationLock(60000);
                if (!lockId && !force) {
                    // another tab is rotating; bail out
                    try { console.info('rotatePersistentPools: rotation locked by another tab'); } catch (e) {}
                    return false;
                }
                try {
                    const keysToRotate = [];
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (!key) continue;
                        if (key.startsWith('pool::')) keysToRotate.push(key);
                    }

                    keysToRotate.forEach(key => {
                        try {
                            const parts = key.split('::'); // ['pool', name, difficulty]
                            const name = parts[1];
                            const difficulty = parts[2];
                            // Skip rotating pools for games that are currently active so we don't
                            // disturb an in-progress session for players. If `force` is true, override.
                            try {
                                const gameKey = _poolNameToGameStateKey(name);
                                if (!force && gameKey && gameState[gameKey] && gameState[gameKey].gameActive) return;
                            } catch (e) { /* ignore gameState read errors and proceed */ }
                            let allItems = [];

                            if (name === 'trivia' && window.triviaQuestions && triviaQuestions[difficulty]) {
                                allItems = triviaQuestions[difficulty].slice();
                            } else if (name === 'animal' && window.animalTriviaQuestions && animalTriviaQuestions[difficulty]) {
                                allItems = animalTriviaQuestions[difficulty].slice();
                            } else if (name === 'riddles') {
                                const raw = localStorage.getItem(key);
                                if (raw) {
                                    try { allItems = JSON.parse(raw) || []; } catch (e) { allItems = []; }
                                }
                            } else {
                                // Fallback: use what's currently stored
                                const raw = localStorage.getItem(key);
                                if (raw) {
                                    try { allItems = JSON.parse(raw) || []; } catch (e) { allItems = []; }
                                }
                            }

                            // If we have a base list, reshuffle it; otherwise reshuffle the stored pool
                            let newPool = [];
                            if (Array.isArray(allItems) && allItems.length > 0) {
                                newPool = shuffleArray(allItems.slice());
                            } else {
                                // last resort: shuffle existing stored pool
                                const rawExisting = localStorage.getItem(key);
                                try { newPool = rawExisting ? shuffleArray(JSON.parse(rawExisting).slice()) : []; } catch (e) { newPool = []; }
                            }

                            try { localStorage.setItem(key, JSON.stringify(newPool)); } catch (e) {}

                            // If caller forced rotation and a matching game is active, update
                            // the in-memory currentGameQuestions so the UI reflects the change
                            // immediately (allows admin override to affect active sessions).
                            try {
                                if (force) {
                                    if (name === 'trivia' && window.gameState && gameState.trivia && gameState.trivia.gameActive) {
                                        try {
                                            const all = (window.triviaQuestions && triviaQuestions[difficulty]) || [];
                                            gameState.trivia.currentGameQuestions = drawFromPool('trivia', difficulty, all, gameState.trivia.totalQuestions || gameState.trivia.totalQuestionsUsed || 10);
                                            gameState.trivia.totalQuestionsUsed = gameState.trivia.currentGameQuestions.length;
                                            gameState.trivia.currentQuestion = 0;
                                            try { showTriviaQuestion(); } catch (e) {}
                                        } catch (e) {}
                                    }
                                    if (name === 'animal' && window.gameState && gameState.animalTrivia && gameState.animalTrivia.gameActive) {
                                        try {
                                            const allA = (window.animalTriviaQuestions && animalTriviaQuestions[difficulty]) || [];
                                            gameState.animalTrivia.currentGameQuestions = drawFromPool('animal', difficulty, allA, gameState.animalTrivia.totalQuestions || gameState.animalTrivia.totalQuestionsUsed || 15);
                                            gameState.animalTrivia.totalQuestionsUsed = gameState.animalTrivia.currentGameQuestions.length;
                                            gameState.animalTrivia.currentQuestion = 0;
                                            try { showAnimalTriviaQuestion(); } catch (e) {}
                                        } catch (e) {}
                                    }
                                    if (name === 'riddles' && window.gameState && gameState.riddles && gameState.riddles.gameActive) {
                                        try {
                                            // For riddles we draw individually using drawFromPool helper
                                            const allR = [];
                                            // try to source a list if possible
                                            try { if (window.riddlesData && typeof getRiddlesByFilter === 'function') { /* keep fallback */ } } catch (e) {}
                                            gameState.riddles.currentRiddle = null;
                                            gameState.riddles.currentHintLevel = 0;
                                            try { nextRiddle(); } catch (e) {}
                                        } catch (e) {}
                                    }
                                }
                            } catch (e) { /* ignore per-key UI update errors */ }
                        } catch (e) {
                            /* ignore per-key errors */
                        }
                    });

                    // Also refresh the summary snapshot used by pool-manager
                    try { savePoolsToStorage(); } catch (e) {}
                    try { renderPoolCounts(); } catch (e) {}
                    // persist last rotation timestamp for UI
                    try { localStorage.setItem('burbleLastRotation', new Date().toISOString()); } catch (e) {}
                    // update rotate-status text if present
                    try {
                        const status = document.getElementById('rotate-status');
                        if (status) {
                            const last = localStorage.getItem('burbleLastRotation');
                            if (last) status.textContent = `Rotated ${formatRelativeTime(last)}`;
                        }
                    } catch (e) {}
                } catch (e) { console.error('rotatePersistentPools', e); }
                finally {
                    // release lock
                    try { _releaseRotationLock(lockId); } catch (e) {}
                }
                return true;
            }
                        category: "logic",
                        difficulty: "easy"
                    },
                    {
                        riddle: "What has keys but no locks, space but no room, you can enter but not go inside?",
                        answer: "keyboard",
                        acceptedAnswers: ["keyboard", "a keyboard", "computer keyboard"],
                        hints: [
                            "This is something you use with technology.",
                            "It has an 'Enter' key and a 'Space' bar.",
                            "You press its keys to type letters and numbers on a computer."
                        ],
                        category: "logic",
                        difficulty: "easy"
                    },
                    {
                        riddle: "What gets wet while drying?",
                        answer: "towel",
                        acceptedAnswers: ["towel", "a towel"],
                        hints: [
                            "This item is used in bathrooms.",
                            "It absorbs moisture from something else while becoming moist itself.",
                            "You use it after a shower to dry your body."
                        ],
                        category: "logic",
                        difficulty: "easy"
                    }
                ],
                medium: [
                    {
                        riddle: "The more you take, the more you leave behind. What am I?",
                        answer: "footsteps",
                        acceptedAnswers: ["footsteps", "steps", "footprints"],
                        hints: [
                            "This relates to movement and travel.",
                            "Every time you do this action, you create evidence of it.",
                            "When you walk, you take these and leave traces behind."
                        ],
                        category: "logic",
                        difficulty: "medium"
                    },
                    {
                        riddle: "I have cities, but no houses. I have mountains, but no trees. I have water, but no fish. What am I?",
                        answer: "map",
                        acceptedAnswers: ["map", "a map"],
                        hints: [
                            "This is a flat representation of something three-dimensional.",
                            "It shows geographical features but not living things.",
                            "You unfold this to find directions and plan routes."
                        ],
                        category: "logic",
                        difficulty: "medium"
                    },
                    {
                        riddle: "What breaks but never falls, and what falls but never breaks?",
                        answer: "day breaks and night falls",
                        acceptedAnswers: ["day and night", "day breaks night falls", "dawn and dusk"],
                        hints: [
                            "These are two opposite things that happen every day.",
                            "One happens in the morning, the other in the evening.",
                            "Think about sunrise (dawn ____) and sunset (night ____)"
                        ],
                        category: "logic",
                        difficulty: "medium"
                    },
                    {
                        riddle: "Forward I am heavy, but backward I am not. What am I?",
                        answer: "ton",
                        acceptedAnswers: ["ton", "the word ton"],
                        hints: [
                            "This is a wordplay riddle about spelling.",
                            "Think about what this word means forward vs backward.",
                            "The word 'TON' spelled backward is 'NOT'."
                        ],
                        category: "logic",
                        difficulty: "medium"
                    }
                ],
                hard: [
                    {
                        riddle: "A man lives on the twentieth floor of an apartment building. Every morning he takes the elevator down to the ground floor. When he comes home, he takes the elevator to the tenth floor and walks the rest of the way... except on rainy days, when he takes the elevator all the way to the twentieth floor. Why?",
                        answer: "he is too short to reach the button",
                        acceptedAnswers: ["he's short", "he can't reach the button", "too short", "short person", "he's too short to reach"],
                        hint: "Think about his physical limitations and what changes on rainy days.",
                        category: "logic",
                        difficulty: "hard"
                    },
                    {
                        riddle: "A woman shoots her husband, then holds him under water for five minutes, then hangs him. Afterwards they both go out to dinner together. How is this possible?",
                        answer: "she is a photographer",
                        acceptedAnswers: ["she is a photographer", "photographer", "she's a photographer"],
                        hints: [
                            "The words 'shoots', 'holds', and 'hangs' may not be literal.",
                            "Think about common processes that involve shooting and hanging.",
                            "It's a play on words ‚Äî consider photography and developing photos."
                        ],
                        category: "logic",
                        difficulty: "hard"
                    }
                ]
            }
        };

        (function(){
            const $mode = document.getElementById('audio-mode');
            if ($mode) {
                $mode.addEventListener('change', () => { setModeSelection($mode.value); });
                // initialize UI based on saved settings
                try {
                    if (window.audioSettings && window.audioSettings.modeMap && Object.keys(window.audioSettings.modeMap).length > 0) {
                        const currentMode = $mode.value || 'all';
                        setModeSelection(currentMode);
                    }
                } catch(e) {}
            }
        })();

            (function(){
            // expose helper to global scope for game wiring
            window.playModeAudio = playModeAudio;
            window.audioControls = {
                setPlayerSrc,
                play: () => audioPlayer.play(),
                pause: () => audioPlayer.pause(),
                stop: () => { audioPlayer.pause(); audioPlayer.currentTime = 0; },
                // queue helpers
                getQueue: () => (audioQueue.slice()),
                addToQueue: (src) => { if (src) { audioQueue.push(src); renderQueue(); } },
                clearQueue: () => { audioQueue = []; currentQueueIndex = -1; renderQueue(); }
            };

            // Audio queue implementation
            let audioQueue = []; // list of src strings
            let currentQueueIndex = -1;
            const $queueList = document.getElementById('audio-queue-list');
            const $clearQueue = document.getElementById('audio-clear-queue');

            function renderQueue() {
                if (!$queueList) return;
                $queueList.innerHTML = '';
                audioQueue.forEach((src, i) => {
                    const item = document.createElement('div');
                    item.className = 'audio-queue-item' + (i === currentQueueIndex ? ' current' : '');
                    const label = document.createElement('span');
                    let pretty = src;
                    try { pretty = decodeURIComponent(src); } catch (e) {}
                    const parts = pretty.split('/'); pretty = parts[parts.length - 1] || pretty;
                    label.textContent = pretty;
                    item.appendChild(label);
                    item.addEventListener('click', () => {
                        currentQueueIndex = i;
                        const selected = audioQueue[currentQueueIndex];
                        setPlayerSrc(selected);
                        audioPlayer.play().catch(() => {});
                        saveSettings();
                        renderQueue();
                    });
                    $queueList.appendChild(item);
                });
            }

            function populateQueueFromDefaults() {
                audioQueue = defaultTracks.slice();
                currentQueueIndex = defaultTracks.indexOf(audioPlayer.src) >= 0 ? defaultTracks.indexOf(audioPlayer.src) : -1;
                renderQueue();
            }

            if ($clearQueue) {
                $clearQueue.addEventListener('click', () => { audioQueue = []; currentQueueIndex = -1; renderQueue(); });
            }

            // Wire next/prev to queue if queue present
            const originalNext = $next.onclick;
            $next.addEventListener('click', () => {
                if (audioQueue.length > 0) {
                    currentQueueIndex = (currentQueueIndex + 1) % audioQueue.length;
                    const nextSrc = audioQueue[currentQueueIndex];
                    setPlayerSrc(nextSrc); audioPlayer.play(); renderQueue(); saveSettings();
                }
            });
            $prev.addEventListener('click', () => {
                if (audioQueue.length > 0) {
                    currentQueueIndex = (currentQueueIndex - 1 + audioQueue.length) % audioQueue.length;
                    const prevSrc = audioQueue[currentQueueIndex];
                    setPlayerSrc(prevSrc); audioPlayer.play(); renderQueue(); saveSettings();
                }
            });

            // initialize queue UI
            populateQueueFromDefaults();
        })();

        // Expose a safe initializer that waits for DOM nodes to exist.
        function initAudioControls() {
            try {
                // if already initialized (audioPlayer exists), skip
                if (window.audioControls || window.playModeAudio) return;
                // run the previous IIFE body by calling the function above
                (function(){
                    // the original IIFE body is already declared above in this file scope
                    // so invoking the code path here is unnecessary; instead ensure the UI wiring
                })();
            } catch (e) {
                // swallow; runner will retry
            }
        }

        // Ensure there is a real audio element and core helpers in case they were
        // accidentally omitted by earlier bundling or edit. This is intentionally
        // small and defensive: it only creates `window.audioPlayer` and a
        // `setPlayerSrc` helper if they don't already exist, and wires the basic
        // UI controls present in the page.
        (function ensureAudioElementAndWiring(){
            try {
                if (window.audioPlayer && typeof window.setPlayerSrc === 'function') return;

                // create a hidden audio element and attach to window for global access
                const audio = document.createElement('audio');
                audio.id = 'global-audio-player';
                audio.preload = 'auto';
                audio.crossOrigin = 'anonymous';
                audio.style.display = 'none';
                document.body && document.body.appendChild(audio);
                window.audioPlayer = audio;

                // default setPlayerSrc implementation
                window.setPlayerSrc = function(src){
                    try {
                        if (!src) return;
                        // ensure src is a string and decode for display only
                        const s = String(src);
                        // assign to audio element
                        if (window.audioPlayer) {
                            // avoid unnecessary reloads
                            if (window.audioPlayer.src && window.audioPlayer.src.endsWith(s)) return;
                            window.audioPlayer.src = s;
                            // update now playing label if present
                            try { const np = document.getElementById('now-playing-track'); if (np) np.textContent = decodeURIComponent(s.split('/').pop()); } catch(e){}
                        }
                    } catch (e) { console.warn('setPlayerSrc error', e); }
                };

                // wire basic controls (play/pause/volume/rewind/forward/track change)
                const $play = document.getElementById('audio-play');
                const $pause = document.getElementById('audio-pause');
                const $vol = document.getElementById('audio-volume');
                const $rew = document.getElementById('audio-rewind');
                const $fwd = document.getElementById('audio-forward');
                const $track = document.getElementById('audio-track');

                if ($play) $play.addEventListener('click', () => {
                    try { window.audioPlayer.play().catch(err=>{ console.warn('play failed', err); }); } catch(e){}
                });
                if ($pause) $pause.addEventListener('click', () => { try { window.audioPlayer.pause(); } catch(e){} });
                if ($vol) {
                    // initialize volume from control
                    try { window.audioPlayer.volume = Number($vol.value) || 1.0; } catch(e){}
                    $vol.addEventListener('input', () => { try { window.audioPlayer.volume = Number($vol.value); } catch(e){} });
                }
                if ($rew) $rew.addEventListener('click', () => { try { window.audioPlayer.currentTime = Math.max(0, window.audioPlayer.currentTime - 10); } catch(e){} });
                if ($fwd) $fwd.addEventListener('click', () => { try { window.audioPlayer.currentTime = Math.min((window.audioPlayer.duration||0), window.audioPlayer.currentTime + 10); } catch(e){} });
                if ($track) $track.addEventListener('change', (ev) => {
                    try {
                        const val = (ev.target && ev.target.value) || ev.target.options[ev.target.selectedIndex].value;
                        if (val) { window.setPlayerSrc(val); }
                    } catch(e){}
                });

                // expose minimal audioControls if not present
                if (!window.audioControls) {
                    window.audioControls = {
                        setPlayerSrc: window.setPlayerSrc,
                        play: () => { try { return window.audioPlayer.play(); } catch(e){} },
                        pause: () => { try { return window.audioPlayer.pause(); } catch(e){} },
                        stop: () => { try { window.audioPlayer.pause(); window.audioPlayer.currentTime = 0; } catch(e){} },
                        getQueue: () => ([]),
                        addToQueue: () => {},
                        clearQueue: () => {}
                    };
                }

                // Log ready state for easier local debugging
                console.debug('Audio player initialized', { src: window.audioPlayer.src || null });
                // Wire audio event listeners to update feedback UI
                try {
                    const $status = document.getElementById('audio-status');
                    const $progress = document.getElementById('audio-progress');
                    const $time = document.getElementById('audio-time');
                    function fmt(s){
                        if (!isFinite(s) || s <= 0) return '00:00';
                        const m = Math.floor(s/60).toString().padStart(2,'0');
                        const sec = Math.floor(s%60).toString().padStart(2,'0');
                        return `${m}:${sec}`;
                    }
                    window.audioPlayer.addEventListener('waiting', () => { if ($status) $status.textContent = 'Loading...'; });
                    window.audioPlayer.addEventListener('playing', () => { if ($status) $status.textContent = 'Playing'; });
                    window.audioPlayer.addEventListener('pause', () => { if ($status) $status.textContent = 'Paused'; });
                    window.audioPlayer.addEventListener('ended', () => { if ($status) $status.textContent = 'Ended'; $progress && ($progress.value = 0); });
                    window.audioPlayer.addEventListener('timeupdate', () => {
                        try {
                            const cur = window.audioPlayer.currentTime || 0;
                            const dur = window.audioPlayer.duration || 0;
                            if ($progress) $progress.value = dur ? (cur / dur) * 100 : 0;
                            if ($time) $time.textContent = `${fmt(cur)} / ${fmt(dur)}`;
                        } catch(e){}
                    });
                } catch(e) { console.warn('audio UI wiring failed', e); }
            } catch (e) {
                console.warn('ensureAudioElementAndWiring failed', e);
            }
        })();

        // Support playing arbitrary audio URLs and YouTube links.
        (function addUrlPlaybackSupport(){
            try {
                // helper to detect YouTube urls and extract id
                function extractYouTubeId(url){
                    try {
                        const u = new URL(url);
                        if (u.hostname.includes('youtube.com')) return u.searchParams.get('v');
                        if (u.hostname === 'youtu.be') return u.pathname.slice(1);
                    } catch(e) {
                        // fallback regex
                        const m = url.match(/[?&]v=([a-zA-Z0-9_-]{6,})/); if (m) return m[1];
                        const m2 = url.match(/youtu\.be\/([a-zA-Z0-9_-]{6,})/); if (m2) return m2[1];
                    }
                    return null;
                }

                // YouTube player reference (will be created when needed)
                let __ytPlayer = null;
                let __ytPoll = null; // polling interval for YT progress

                // cached audio index for fuzzy matching of local assets
                window._audioIndex = window._audioIndex || null;
                async function fetchAudioIndex(){
                    if (window._audioIndex) return window._audioIndex;
                    try {
                        const resp = await fetch('assets/audio/index.json');
                        if (!resp.ok) return null;
                        const json = await resp.json();
                        window._audioIndex = json;
                        return json;
                    } catch(e){ return null; }
                }

                function normalizeName(s){
                    try {
                        return String(s||'').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'').replace(/[^a-z0-9]+/g,'').trim();
                    } catch(e){ return String(s||'').toLowerCase(); }
                }

                // small levenshtein distance for short strings
                function levenshtein(a, b){
                    a = String(a||''); b = String(b||'');
                    if (a === b) return 0;
                    const m = a.length, n = b.length;
                    if (m === 0) return n; if (n === 0) return m;
                    const v0 = new Array(n+1), v1 = new Array(n+1);
                    for (let j=0;j<=n;j++) v0[j]=j;
                    for (let i=0;i<m;i++){
                        v1[0]=i+1;
                        for (let j=0;j<n;j++){
                            const cost = a[i]===b[j]?0:1;
                            v1[j+1]=Math.min(v1[j]+1, v0[j+1]+1, v0[j]+cost);
                        }
                        for (let j=0;j<=n;j++) v0[j]=v1[j];
                    }
                    return v1[n];
                }

                function updateAudioStatus(msg, opts){
                    try {
                        opts = opts || {};
                        const $status = document.getElementById('audio-status');
                        if (!$status) return;
                        $status.textContent = msg || '';
                        let spinner = document.getElementById('audio-status-spinner');
                        if (opts.loading) {
                            if (!spinner) {
                                spinner = document.createElement('span');
                                spinner.id = 'audio-status-spinner';
                                spinner.className = 'spinner';
                                spinner.style.marginRight = '8px';
                                $status.parentNode && $status.parentNode.insertBefore(spinner, $status);
                            }
                        } else {
                            if (spinner) spinner.remove();
                        }
                        if (opts.error) $status.style.color = '#b00020'; else $status.style.color = '#444';
                        // Also show a more visible alert area for persistent errors or info
                        try {
                            const $alert = document.getElementById('audio-alert');
                            const $alertMsg = document.getElementById('audio-alert-msg');
                            const $retry = document.getElementById('audio-retry');
                            const $dismiss = document.getElementById('audio-dismiss');
                            if ($alert && $alertMsg) {
                                    if (opts.error || opts.persist) {
                                        $alertMsg.textContent = msg || '';
                                        $alert.classList.remove('hidden');
                                        $alert.setAttribute('data-error', !!opts.error);
                                        $alert.setAttribute('aria-hidden', 'false');
                                        // ensure the alert is reachable for screen readers and focus
                                        try { $alert.focus(); } catch(e){}
                                    // show retry button when we have an error and opts.retryCandidate is provided
                                    if ($retry) {
                                        if (opts.error && opts.retryCandidate) {
                                            $retry.classList.remove('hidden');
                                            $retry._candidate = opts.retryCandidate;
                                        } else {
                                            $retry.classList.add('hidden');
                                            if ($retry._candidate) $retry._candidate = null;
                                        }
                                    }
                                    if ($dismiss) { $dismiss.classList.remove('hidden'); }
                                    if (opts.autoDismiss) {
                                        setTimeout(() => { try { $alert.classList.add('hidden'); if ($retry) $retry.classList.add('hidden'); } catch(e){} }, Number(opts.autoDismiss) || 4000);
                                    }
                                } else {
                                    // clear any existing non-persistent alerts
                                    $alertMsg.textContent = '';
                                    $alert.classList.add('hidden');
                                    $alert.removeAttribute('data-error');
                                    $alert.setAttribute('aria-hidden', 'true');
                                    if ($retry) $retry.classList.add('hidden');
                                }
                            }
                        } catch(e){}
                    } catch(e){}
                }

                window.playUrlOrYoutube = async function(url){
                    if (!url) return false;
                    // if it's a YouTube link, create an iframe embed and mute the audio element
                    const yt = extractYouTubeId(url);
                    // cleanup any previous embed
                    const existing = document.getElementById('youtube-embed-container');
                    if (existing) existing.remove();

                    if (yt) {
                        // pause/hide audio element
                        try { if (window.audioPlayer) { window.audioPlayer.pause(); window.audioPlayer.src = ''; } } catch(e){}
                        // ensure youtube API root exists
                        const root = document.getElementById('youtube-api-root');
                        // cleanup previous
                        if (root) root.innerHTML = '';
                        const container = document.createElement('div');
                        container.id = 'youtube-embed-container';
                        container.className = 'mt-6';
                        container.innerHTML = `
                            <div id="youtube-player-placeholder"></div>
                            <div class="yt-controls">
                                <button id="yt-pause" class="nav-btn">Pause</button>
                                <button id="yt-play" class="nav-btn">Play</button>
                                <button id="yt-stop" class="nav-btn">Stop</button>
                                <input id="yt-progress" class="seek flex-1" type="range" min="0" max="100" value="0" step="0.1" title="YouTube playback position" aria-label="YouTube playback position" />
                                <div id="yt-time" class="audio-time">00:00 / 00:00</div>
                                <input id="yt-volume" class="yt-volume" type="range" min="0" max="1" step="0.01" value="1" title="YouTube volume" />
                            </div>`;
                        root && root.appendChild(container);

                        // load YouTube IFrame API if not present
                        if (typeof YT === 'undefined' || typeof YT.Player === 'undefined') {
                            const tag = document.createElement('script');
                            tag.src = 'https://www.youtube.com/iframe_api';
                            document.head.appendChild(tag);
                        }

                        // create player when API ready
                        function createPlayer(){
                            try {
                                if (__ytPlayer && typeof __ytPlayer.destroy === 'function') { __ytPlayer.destroy(); __ytPlayer = null; }
                                __ytPlayer = new YT.Player('youtube-player-placeholder', {
                                    height: '90', width: '360', videoId: yt,
                                    playerVars: { autoplay: 1, controls: 1 },
                                    events: {
                                        onReady: function(){ try { __ytPlayer.playVideo(); } catch(e){} },
                                        onStateChange: function(e){
                                            // map to status UI and manage polling for progress/time
                                            const $status = document.getElementById('audio-status');
                                            if ($status) {
                                                if (e.data === YT.PlayerState.PLAYING) $status.textContent = 'Playing (YouTube)';
                                                else if (e.data === YT.PlayerState.PAUSED) $status.textContent = 'Paused (YouTube)';
                                                else if (e.data === YT.PlayerState.BUFFERING) $status.textContent = 'Loading...';
                                                else if (e.data === YT.PlayerState.ENDED) $status.textContent = 'Ended';
                                            }
                                            try {
                                                if (e.data === YT.PlayerState.PLAYING) {
                                                    if (__ytPoll) clearInterval(__ytPoll);
                                                    __ytPoll = setInterval(()=>{
                                                        try {
                                                            const $prog = document.getElementById('yt-progress');
                                                            const $time = document.getElementById('yt-time');
                                                            if (!__ytPlayer || !__ytPlayer.getDuration) return;
                                                            const dur = __ytPlayer.getDuration() || 0;
                                                            const cur = (__ytPlayer.getCurrentTime && __ytPlayer.getCurrentTime()) || 0;
                                                            if ($prog) { $prog.value = dur ? (cur / dur) * 100 : 0; $prog.style.setProperty('--pos', (dur ? (cur/dur)*100 : 0) + '%'); }
                                                            if ($time) {
                                                                const fmt = (s)=>{ if (!isFinite(s)||s<=0) return '00:00'; const m=Math.floor(s/60).toString().padStart(2,'0'); const sec=Math.floor(s%60).toString().padStart(2,'0'); return `${m}:${sec}`; };
                                                                $time.textContent = `${fmt(cur)} / ${fmt(dur)}`;
                                                            }
                                                        } catch(e){}
                                                    }, 500);
                                                } else {
                                                    if (__ytPoll) { clearInterval(__ytPoll); __ytPoll = null; }
                                                }
                                            } catch(e){}
                                        }
                                    }
                                });
                            } catch(e){ console.warn('YT createPlayer failed', e); }
                        }

                        window.onYouTubeIframeAPIReady = function(){ createPlayer(); };
                        // if YT ready now, create immediately
                        try { if (typeof YT !== 'undefined' && YT && typeof YT.Player !== 'undefined') createPlayer(); } catch(e){}

                        // wire quick play/pause/stop buttons
                        setTimeout(()=>{
                            try {
                                const $pp = document.getElementById('yt-pause');
                                const $p = document.getElementById('yt-play');
                                const $st = document.getElementById('yt-stop');
                                if ($pp) $pp.addEventListener('click', ()=>{ try { __ytPlayer && __ytPlayer.pauseVideo(); } catch(e){} });
                                if ($p) $p.addEventListener('click', ()=>{ try { __ytPlayer && __ytPlayer.playVideo(); } catch(e){} });
                                if ($st) $st.addEventListener('click', ()=>{ try { __ytPlayer && __ytPlayer.stopVideo(); const root = document.getElementById('youtube-api-root'); if (root) root.innerHTML=''; } catch(e){} });
                                const $prog = document.getElementById('yt-progress');
                                const $ytVol = document.getElementById('yt-volume');
                                if ($prog) {
                                    $prog.addEventListener('input', ()=>{
                                        try {
                                            if (!__ytPlayer) return;
                                            const dur = __ytPlayer.getDuration() || 0;
                                            const t = dur * (Number($prog.value)/100);
                                            if (typeof __ytPlayer.seekTo === 'function') __ytPlayer.seekTo(t, true);
                                            $prog.style.setProperty('--pos', (Number($prog.value)||0) + '%');
                                        } catch(e){}
                                    });
                                }
                                if ($ytVol) {
                                    $ytVol.addEventListener('input', ()=>{
                                        try { if (__ytPlayer && typeof __ytPlayer.setVolume === 'function') __ytPlayer.setVolume(Math.round(Number($ytVol.value) * 100)); } catch(e){}
                                    });
                                }
                            } catch(e){}
                        }, 400);

                        return true;
                    }

                    // Otherwise treat as direct audio URL. First, preflight with HEAD
                    try {
                        // E2E-only hook: allow tests to override HEAD behavior for determinism.
                        // Usage (from Playwright):
                        // await page.evaluate(() => window.__E2E_setHeadResponse && window.__E2E_setHeadResponse('https://example.com/foo.mp3', 404));
                        // The hook is minimal and only active when `window.__E2E__` is true.
                        try {
                            if (window.__E2E__ && !window.__E2E_setHeadResponse) {
                                const _e2e_head_map = new Map();
                                window.__E2E_setHeadResponse = function(url, status) { try { _e2e_head_map.set(String(url), Number(status)); return true; } catch(e) { return false; } };
                                window.__E2E_clearHeadResponses = function() { try { _e2e_head_map.clear(); return true; } catch(e){ return false; } };
                                // Wrap fetch locally for the tryUrl HEAD check only (do not replace global fetch)
                                const _origFetch = window.fetch;
                                window.__E2E__fetch_override = function(resource, init) {
                                    try {
                                        if (init && init.method === 'HEAD') {
                                            const forced = _e2e_head_map.get(String(resource));
                                            if (typeof forced === 'number') {
                                                return Promise.resolve(new Response('', { status: forced, statusText: String(forced) }));
                                            }
                                        }
                                    } catch(e){}
                                    return _origFetch.apply(this, arguments);
                                };
                            }
                        } catch(e){}
                        // remove any existing youtube embed
                        const y = document.getElementById('youtube-embed-container'); if (y) y.remove();
                        // helper to try playing a given candidate url
                        const tryUrl = async (candidate) => {
                            try {
                                // attempt a HEAD to check availability (CORS servers may reject)
                                let ok = false;
                                try {
                                    // Use the E2E fetch override when present to keep global fetch untouched
                                    const resp = (window.__E2E__ && window.__E2E__fetch_override) ? await window.__E2E__fetch_override(candidate, { method: 'HEAD' }) : await fetch(candidate, { method: 'HEAD' });
                                    ok = resp && resp.ok;
                                } catch(e) {
                                    // HEAD may be blocked; fall back to optimistic attempt
                                    ok = true;
                                }
                                if (!ok) return false;
                                if (window.audioPlayer) {
                                    window.setPlayerSrc(candidate);
                                    await window.audioPlayer.play().catch(err => { console.warn('play failed for URL', err); });
                                    return true;
                                }
                            } catch(e) { console.warn('tryUrl error', e); }
                            return false;
                        };

                        // If it's a local assets path, try encoded/unencoded candidates and fuzzy-match via index.json
                        const isLocalAsset = url.startsWith('assets/');
                        if (isLocalAsset) {
                            try {
                                updateAudioStatus('Resolving local asset...', { loading: true });
                                const idx = await fetchAudioIndex();
                                const basename = (url.split('/').pop()||'');
                                const want = decodeURIComponent(basename);
                                const normWant = normalizeName(want);
                                const candidates = [url];
                                try { candidates.push(encodeURI(url)); } catch(e){}
                                try { candidates.push(decodeURI(url)); } catch(e){}
                                if (Array.isArray(idx) && idx.length > 0) {
                                    let found = idx.find(f => f === want || f === basename || f === decodeURIComponent(basename));
                                    if (!found) {
                                        const normList = idx.map(f => ({ f, n: normalizeName(f) }));
                                        const exactNorm = normList.find(o => o.n === normWant);
                                        if (exactNorm) found = exactNorm.f;
                                    }
                                    if (!found) {
                                        const normList = idx.map(f => ({ f, n: normalizeName(f) }));
                                        const sub = normList.find(o => o.n.indexOf(normWant) !== -1 || normWant.indexOf(o.n) !== -1);
                                        if (sub) found = sub.f;
                                    }
                                    if (!found) {
                                        let best = { f: null, d: 1e9 };
                                        idx.forEach(f => {
                                            const d = levenshtein(normalizeName(f), normWant);
                                            if (d < best.d) best = { f, d };
                                        });
                                        if (best.d <= 3) found = best.f;
                                    }
                                    if (found) candidates.unshift('assets/audio/' + found);
                                }

                                for (let c of candidates) {
                                    c = c.replace(/^\.\//, '');
                                    const ok = await tryUrl(c); // eslint-disable-line no-await-in-loop
                                    if (ok) { updateAudioStatus('Playing', { loading: false }); return true; }
                                }
                                updateAudioStatus('Not found', { loading: false, error: true, retryCandidate: candidates[0] });
                                return false;
                            } catch(e){ console.warn('local asset resolution failed', e); updateAudioStatus('Error', { loading: false, error: true }); return false; }
                        }

                        // Non-local: just try the provided url
                        // eslint-disable-next-line no-return-await
                        const ok = await tryUrl(url);
                        if (!ok) updateAudioStatus('Unable to play URL', { loading: false, error: true, retryCandidate: url });
                        return ok;
                    } catch(e) { console.warn('playUrlOrYoutube error', e); }
                    return false;
                };

                // wire UI buttons if present
                try {
                    const $input = document.getElementById('audio-url-input');
                    const $playUrl = document.getElementById('audio-play-url');
                    const $stopUrl = document.getElementById('audio-stop-url');
                    if ($playUrl && $input) $playUrl.addEventListener('click', () => { window.playUrlOrYoutube(($input.value||'').trim()); });
                    if ($input) $input.addEventListener('keypress', (e) => { if (e.key === 'Enter') { window.playUrlOrYoutube(($input.value||'').trim()); } });
                    if ($stopUrl) $stopUrl.addEventListener('click', () => {
                        try { const y = document.getElementById('youtube-embed-container'); if (y) y.remove(); if (window.audioPlayer) { window.audioPlayer.pause(); window.audioPlayer.currentTime = 0; window.audioPlayer.src = ''; } } catch(e){}
                    });
                } catch(e) {}
            } catch (e) { console.warn('addUrlPlaybackSupport failed', e); }
        })();

        // Retry helper: wait for a few required DOM nodes before initializing
        (function waitForAudioDomAndInit() {
            const required = ['audio-track', 'audio-mode', 'audio-play'];
            const found = required.every(id => document.getElementById(id));
            if (found) {
                // call the audio wiring code that depends on these nodes
                try {
                    // Many variables and functions used by the audio implementation assume they
                    // were created in the IIFE; to keep changes minimal we simply re-run the
                    // small setup pieces that depend on the DOM presence: populate selects and
                    // wire event handlers that reference existing DOM nodes.
                    // If the full audio implementation already ran, these will be no-ops.
                    if (typeof populateQueueFromDefaults === 'function') populateQueueFromDefaults();
                    // expose playModeAudio if defined
                    if (typeof playModeAudio === 'function') window.playModeAudio = playModeAudio;
                    if (typeof setPlayerSrc === 'function') window.setPlayerSrc = setPlayerSrc;
                } catch (e) {
                    // ignore and continue
                }
            } else {
                // try again up to ~20 times (~1s total)
                if (!waitForAudioDomAndInit._tries) waitForAudioDomAndInit._tries = 0;
                waitForAudioDomAndInit._tries++;
                if (waitForAudioDomAndInit._tries < 20) {
                    setTimeout(waitForAudioDomAndInit, 50);
                }
            }
        })();

        // --- Additional UI wiring: populate audio-track select and sign-in modal ---
        (function enhanceAudioAndAuth() {
            // defaultTracks - ensure audio options exist for tests and UI
            const defaultTracks = [
                'assets/audio/Marvel Opening Theme.mp3',
                'assets/audio/NFL on FOX Theme Song.mp3',
                'assets/audio/Pok√©mon Theme Song.mp3',
                'assets/audio/Star Wars Main Theme (Full).mp3',
                'assets/audio/The Price is Right theme song.mp3',
                'assets/audio/30 Second Timer With Jeopardy Thinking Music.mp3'
            ].map(p => p.replace(/ /g, '%20'));

            function populateAudioSelect() {
                const sel = document.getElementById('audio-track');
                if (!sel) return;
                // avoid duplicating options
                if (sel.options.length > 0) return;
                defaultTracks.forEach((src) => {
                    const opt = document.createElement('option');
                    opt.value = src;
                    // show friendly label
                    opt.text = decodeURIComponent(src.split('/').pop());
                    sel.appendChild(opt);
                });
            }

            // expose for external testing and add a robust fallback invocation in case of load race
            try { if (window.__E2E__) { window.populateAudioSelect = populateAudioSelect; window.defaultTracks = defaultTracks; } } catch (e) {}
            (function ensurePopulate(retries = 0) {
                try { populateAudioSelect(); } catch (e) {}
                const sel = document.getElementById('audio-track');
                if (!sel || !sel.options || sel.options.length === 0) {
                    if (retries < 20) setTimeout(() => ensurePopulate(retries + 1), 150);
                }
            })();

            // Sign-in modal helpers (very small client-only registration for UI/tests)
            // Leaderboard modal helpers
            function showLeaderboardModal() {
                const m = document.getElementById('leaderboard-modal');
                if (!m) return;
                m.classList.remove('hidden');
                m.style.display = 'flex';
                m.setAttribute('aria-hidden', 'false');
                try { renderLeaderboard(); } catch (e) {}
            }
            function hideLeaderboardModal() {
                const m = document.getElementById('leaderboard-modal');
                if (!m) return;
                m.classList.add('hidden');
                m.style.display = '';
                m.setAttribute('aria-hidden', 'true');
            }

            function renderUser() {
                const user = JSON.parse(localStorage.getItem('burbleUser') || 'null');
                const info = document.getElementById('user-info');
                const link = document.getElementById('user-email-link');
                if (user && user.username) {
                    if (info) info.classList.remove('hidden');
                    if (link) { link.textContent = user.username; link.href = 'mailto:' + encodeURIComponent(user.email || ''); }
                } else {
                    if (info) info.classList.add('hidden');
                }
            }

            // Wire up leaderboard button & modal actions
            document.addEventListener('click', (e) => {
                const t = e.target;
                if (!t) return;
                if (t.id === 'leaderboard-btn') { showLeaderboardModal(); }
                if (t.id === 'lb-close') { hideLeaderboardModal(); }
                if (t.id === 'signout-btn') { localStorage.removeItem('burbleUser'); renderUser(); }
            });

            // Ensure the leaderboard button has a direct handler attached for determinism
            try {
                const $lb = document.getElementById('leaderboard-btn');
                if ($lb) {
                    $lb.addEventListener('click', (ev) => { ev.preventDefault(); showLeaderboardModal(); });
                }
            } catch (e) {}

            // Reuse a localStorage-backed leaderboard. Each entry: { username, score, ts }
            try { window.saveBurbleUser = function(username, email){ if (!username) return false; localStorage.setItem('burbleUser', JSON.stringify({ username, email })); try{ renderUser(); }catch(e){} return true; }; } catch(e){}
            try { if (window.__E2E__) { window._testSetBurbleUser = function(username, email){ if (!username) return false; localStorage.setItem('burbleUser', JSON.stringify({ username, email })); try{ renderUser(); }catch(e){} return true; }; } } catch(e){}

            // Admin helper: checks burbleUser.isAdmin or matches username/email against allowlist.
            try { window.isAdmin = function(){
                try{
                    const u = JSON.parse(localStorage.getItem('burbleUser') || 'null');
                    if (!u) return false;
                    if (u.isAdmin) return true;
                    // allowlist for convenience in dev/E2E. Update as needed.
                    const ADMIN_USERS = ['eli','elival','admin@example.com'];
                    if (u.username && ADMIN_USERS.includes(u.username)) return true;
                    if (u.email && ADMIN_USERS.includes(u.email)) return true;
                }catch(e){/* ignore */}
                return false;
            }; } catch(e){}

            // Leaderboard storage helper: record a score (username, score)
            window.recordScore = function(username, score){
                try {
                    if (!username) return false;
                    const raw = localStorage.getItem('leaderboard') || '[]';
                    const list = JSON.parse(raw);
                    list.push({ username: String(username), score: Number(score)||0, ts: Date.now() });
                    // keep only top 200 entries
                    list.sort((a,b)=>b.score - a.score || a.ts - b.ts);
                    localStorage.setItem('leaderboard', JSON.stringify(list.slice(0,200)));
                    return true;
                } catch(e){ return false; }
            };

            function renderLeaderboard(){
                try {
                    const el = document.getElementById('leaderboard-list');
                    if (!el) return;
                    const raw = localStorage.getItem('leaderboard') || '[]';
                    const list = JSON.parse(raw);
                    if (!Array.isArray(list) || list.length === 0) { el.innerHTML = '<div class="muted-center">No scores yet. Play to add your score!</div>'; return; }
                    const rows = list.slice(0,50).map((r,i)=>`<div class="lb-row"><strong>#${i+1}</strong> <span class="lb-user">${escapeHtml(r.username)}</span> <span class="lb-score">${r.score}</span></div>`).join('');
                    el.innerHTML = `<div class="lb-rows">${rows}</div>`;
                } catch(e){ try { document.getElementById('leaderboard-error').style.display='block'; document.getElementById('leaderboard-error').textContent='Unable to load leaderboard'; } catch(e){} }
            }

            function escapeHtml(s){ return String(s||'').replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' })[c]); }

            function handleSigninSubmit() {
                const username = (document.getElementById('si-username')||{}).value || '';
                const email = (document.getElementById('si-email')||{}).value || '';
                const password = (document.getElementById('si-password')||{}).value || '';
                const $err = document.getElementById('si-error');
                if (!username) { if ($err) { $err.textContent = 'Please enter a username'; $err.style.display='block'; } return; }
                if ($err) { $err.style.display='none'; $err.textContent = ''; }
                if (window.saveBurbleUser) { window.saveBurbleUser(username, email); } else { localStorage.setItem('burbleUser', JSON.stringify({ username, email })); }
                hideSignInModal(); renderUser();
            }

            // initialize on DOM ready
            document.addEventListener('DOMContentLoaded', () => {
                populateAudioSelect(); renderUser();
                try {
                    const $retry = document.getElementById('audio-retry');
                    const $dismiss = document.getElementById('audio-dismiss');
                    if ($retry) {
                        $retry.addEventListener('click', async (ev) => {
                            try {
                                ev && ev.preventDefault && ev.preventDefault();
                                const candidate = $retry._candidate || null;
                                if (!candidate) return;
                                // disable and show busy state
                                $retry.disabled = true;
                                $retry.setAttribute('aria-busy', 'true');
                                const origText = $retry.textContent;
                                $retry.textContent = 'Retrying...';
                                // call the playback helper and handle promise or sync return
                                let ok = false;
                                try {
                                    const p = window.playUrlOrYoutube(candidate);
                                    ok = await Promise.resolve(p);
                                } catch (e) { ok = false; }
                                if (ok) {
                                    // success: hide alert
                                    const $alert = document.getElementById('audio-alert');
                                    if ($alert) {
                                        $alert.classList.add('hidden');
                                        $alert.setAttribute('aria-hidden', 'true');
                                    }
                                    // ensure retry button hidden
                                    $retry.classList.add('hidden');
                                } else {
                                    // show error state and keep candidate
                                    try { window.updateAudioStatus && window.updateAudioStatus('Retry failed', { error: true, retryCandidate: candidate, persist: true }); } catch(e){}
                                }
                                // restore
                                $retry.textContent = origText;
                                $retry.removeAttribute('aria-busy');
                                $retry.disabled = false;
                            } catch (e) {
                                try { $retry.disabled = false; $retry.removeAttribute('aria-busy'); } catch(e){}
                            }
                        });
                    }
                    if ($dismiss) $dismiss.addEventListener('click', (ev) => { try { ev && ev.preventDefault && ev.preventDefault(); const $alert = document.getElementById('audio-alert'); if ($alert) { $alert.classList.add('hidden'); $alert.setAttribute('aria-hidden','true'); } const $r = document.getElementById('audio-retry'); if ($r) { $r.classList.add('hidden'); $r._candidate = null; } // return focus to audio play input
                        try { const $input = document.getElementById('audio-url-input'); if ($input) $input.focus(); } catch(e){} } catch(e){} });
                } catch(e){}
            });

            // Also attempt to run immediately if DOM already loaded
            try { populateAudioSelect(); renderUser(); } catch (e) {}

            // Accessibility: autofocus and focus trap when modal opens
            function trapFocus(modal) {
                const focusable = modal.querySelectorAll('a[href], button, textarea, input, select, [tabindex]:not([tabindex="-1"])');
                if (!focusable || focusable.length === 0) return () => {};
                const first = focusable[0];
                const last = focusable[focusable.length - 1];
                function keyHandler(e) {
                    if (e.key === 'Tab') {
                        if (e.shiftKey && document.activeElement === first) { e.preventDefault(); last.focus(); }
                        else if (!e.shiftKey && document.activeElement === last) { e.preventDefault(); first.focus(); }
                    } else if (e.key === 'Escape') {
                        hideSignInModal();
                    }
                }
                document.addEventListener('keydown', keyHandler);
                return () => document.removeEventListener('keydown', keyHandler);
            }

            const originalShow = showSignInModal;
            window.showSignInModal = function() {
                // Ensure attributes and display are set synchronously for test determinism
                const modal = document.getElementById('signin-modal');
                if (modal) {
                    modal.classList.remove('hidden');
                    modal.style.display = 'flex';
                    modal.setAttribute('aria-hidden', 'false');
                }
                // call original to prefill and focus
                try { originalShow(); } catch (e) {}
                // attach trap
                if (modal && !modal._untrap) modal._untrap = trapFocus(modal);
                // ensure username is focused synchronously when possible
                try { const username = document.getElementById('si-username'); if (username) username.focus(); } catch (e) {}
            };

            // Test helper: allow tests to open the signin modal deterministically (E2E only)
            try { if (window.__E2E__) { window._testOpenSignin = function(){ window.showSignInModal(); }; } } catch(e){}

            const originalHide = hideSignInModal;
            window.hideSignInModal = function() { originalHide(); const modal = document.getElementById('signin-modal'); if (modal && modal._untrap) { modal._untrap(); modal._untrap = null; } };
        })();

        // --- Persistent pool helpers & Build-Your-Own-Quiz parsing ---
        // Lightweight shuffle (define only if not present)
        if (typeof shuffleArray === 'undefined') {
            function shuffleArray(arr) {
                const a = arr.slice();
                for (let i = a.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [a[i], a[j]] = [a[j], a[i]];
                }
                return a;
            }
        }

        // Save/restore simple pool state to localStorage to survive reloads
        function savePoolsToStorage() {
            try {
                const payload = {
                    riddles: (gameState.riddles && gameState.riddles.pools) || {},
                    trivia: (gameState.trivia && gameState.trivia.pools) || {},
                    animal: (gameState.animalTrivia && gameState.animalTrivia.pools) || {}
                };
                localStorage.setItem('burblePools', JSON.stringify(payload));
            } catch (e) { /* ignore */ }
        }

        function loadPoolsFromStorage() {
            try {
                const raw = localStorage.getItem('burblePools');
                if (!raw) return;
                const p = JSON.parse(raw);
                if (p && p.riddles && gameState.riddles) gameState.riddles.pools = p.riddles;
                if (p && p.trivia && gameState.trivia) gameState.trivia.pools = p.trivia;
                if (p && p.animal && gameState.animalTrivia) gameState.animalTrivia.pools = p.animal;
            } catch (e) { /* ignore */ }
        }

        // Ensure a persistent shuffled pool exists; returns array (may be new)
        function ensurePool(name, difficulty, allItems) {
            try {
                const key = `pool::${name}::${difficulty}`;
                const raw = localStorage.getItem(key);
                if (raw) {
                    const list = JSON.parse(raw);
                    if (Array.isArray(list) && list.length > 0) return list;
                }
                const pool = shuffleArray(allItems.slice());
                localStorage.setItem(key, JSON.stringify(pool));
                return pool;
            } catch (e) { return shuffleArray(allItems.slice()); }
        }

        // Draw up to count items from persistent pool; refill when exhausted.
        // Picks random items from the stored pool to avoid returning the same
        // contiguous chunk each time. When refilling, excludes items just drawn
        // by comparing content (JSON.stringify) to avoid identity issues.
    function drawFromPool(name, difficulty, allItems, count) {
            const key = `pool::${name}::${difficulty}`;
            let pool = [];
            try {
                const raw = localStorage.getItem(key);
                if (raw) pool = JSON.parse(raw) || [];
            } catch (e) { pool = []; }

            if (!Array.isArray(pool) || pool.length === 0) pool = shuffleArray((Array.isArray(allItems) ? allItems.slice() : []).slice());

            const drawn = [];
            // Select random elements from pool without replacement
            for (let i = 0; i < count && pool.length > 0; i++) {
                const idx = Math.floor(Math.random() * pool.length);
                const [item] = pool.splice(idx, 1);
                drawn.push(item);
            }

            // If pool emptied, refill from allItems excluding items we just drew
            try {
                if (!Array.isArray(pool) || pool.length === 0) {
                    const drawnKeys = new Set(drawn.map(d => {
                        try { return JSON.stringify(d); } catch (e) { return String(d); }
                    }));
                    const candidates = (Array.isArray(allItems) ? allItems : []).slice();
                    const refill = candidates.filter(it => {
                        try { return !drawnKeys.has(JSON.stringify(it)); } catch (e) { return true; }
                    });
                    pool = shuffleArray(refill);
                }
            } catch (e) { /* ignore refill errors */ }

            try { localStorage.setItem(key, JSON.stringify(pool)); } catch (e) {}
            return drawn;
        }

        // Immediately attach the real function to window (idempotent) so tests
        // that run early can call it without racing the app's load order. This
        // is safe because it's just a benign reference; keep the later E2E
        // conditional exposure as an additional fallback.
        try {
            if (typeof window !== 'undefined' && !window.drawFromPool) {
                try { window.drawFromPool = drawFromPool; } catch (e) { /* ignore */ }
            }
        } catch (e) { /* ignore */ }

            // Expose helpers for E2E tests explicitly so Playwright can call them.
            try {
                if (window.__E2E__) {
                    try { window.drawFromPool = drawFromPool; } catch (e) {}
                }
            } catch (e) {}

        // Custom quiz state and parsing helpers
        window.customQuiz = window.customQuiz || { pool: null };
        function normalizeQuestion(q) {
            if (!q) return null;
            const question = q.question || q.q || q.prompt || q.text || '';
            const options = Array.isArray(q.options) ? q.options : (q.choices || []);
            const correct = Number.isFinite(q.correct) ? q.correct : (q.answerIndex || 0);
            return { question: String(question), options: options.slice(), correct: Number(correct) || 0 };
        }
        function parseQuizInput(text) {
            text = (text || '').trim();
            if (!text) return [];
            // Try JSON first
            try {
                const parsed = JSON.parse(text);
                if (Array.isArray(parsed)) return parsed.map(normalizeQuestion).filter(Boolean);
            } catch (e) {}

            // Normalize line endings and split
            const rawLines = text.split(/\r?\n/).map(l => l.replace(/\uFEFF/g, '').trim());
            const lines = rawLines.filter(Boolean);
            if (lines.length === 0) return [];

            // Detect delimiter: tab or comma
            const delim = (lines[0].indexOf('\t') >= 0) ? '\t' : ',';

            // Parse a delimited line with basic quoted-field support
            function parseDelimitedLine(line, delimiter) {
                const res = [];
                let cur = '';
                let inQuotes = false;
                for (let i = 0; i < line.length; i++) {
                    const ch = line[i];
                    if (ch === '"') {
                        if (inQuotes && line[i+1] === '"') { cur += '"'; i++; } else { inQuotes = !inQuotes; }
                    } else if (ch === delimiter && !inQuotes) {
                        res.push(cur);
                        cur = '';
                    } else {
                        cur += ch;
                    }
                }
                res.push(cur);
                return res.map(s => s.trim().replace(/^"|"$/g, ''));
            }

            // If first line looks like a header (contains 'question' or 'prompt'), parse headers
            let headerMap = null;
            const first = lines[0].toLowerCase();
            const firstParts = parseDelimitedLine(lines[0], delim).map(p => p.toLowerCase());
            const headerKeywords = ['question','prompt','q','text','options','choice','choices','correct','answer','ans','right'];
            const hasHeader = firstParts.some(p => headerKeywords.includes(p));
            let dataLines = lines;
            if (hasHeader) {
                headerMap = {};
                firstParts.forEach((h, idx) => { headerMap[h] = idx; });
                dataLines = lines.slice(1);
            }

            const out = [];
            for (const line of dataLines) {
                const parts = parseDelimitedLine(line, delim);
                if (!parts || parts.length < 2) continue;

                let question = '';
                let options = [];
                let correct = 0;

                if (headerMap) {
                    // attempt to map by header names
                    // question field
                    const qKey = Object.keys(headerMap).find(k => ['question','prompt','q','text'].includes(k));
                    if (qKey) question = parts[headerMap[qKey]] || '';
                    // options: if there's a single 'options' column, split by pipe or semicolon; otherwise collect sequential option columns
                    const optsKey = Object.keys(headerMap).find(k => ['options','choice','choices','opt','answers','answers_list'].includes(k));
                    if (optsKey) {
                        const rawOpts = parts[headerMap[optsKey]] || '';
                        options = rawOpts.split(/\||;|\u001F/).map(s => s.trim()).filter(Boolean);
                    } else {
                        // collect any header columns that look like option1/option2 or start with 'opt' or 'choice'
                        Object.keys(headerMap).forEach(k => {
                            if (/^opt|^choice|^option|^o\d+/i.test(k) || /^a[0-9]+$/.test(k)) {
                                const v = parts[headerMap[k]]; if (v) options.push(v.trim());
                            }
                        });
                    }
                    // correct index/value
                    const correctKey = Object.keys(headerMap).find(k => ['correct','answer','ans','right'].includes(k));
                    if (correctKey) {
                        const v = (parts[headerMap[correctKey]] || '').trim();
                        if (/^\d+$/.test(v)) correct = Number(v);
                        else if (v) {
                            // if value matches an option text, derive index
                            const idx = options.findIndex(o => o.toLowerCase() === v.toLowerCase());
                            if (idx >= 0) correct = idx;
                        }
                    }
                } else {
                    // No header: assume first col = question, middle cols = options, optionally last col numeric correct
                    question = parts[0];
                    const rest = parts.slice(1);
                    if (rest.length >= 2 && /^\d+$/.test(rest[rest.length - 1].trim())) {
                        correct = Number(rest[rest.length - 1]);
                        options = rest.slice(0, rest.length - 1);
                    } else {
                        options = rest;
                    }
                }

                // clean up options: remove duplicates while preserving order
                const seen = new Set();
                const cleanedOptions = [];
                for (let o of options) {
                    if (typeof o !== 'string') o = String(o || '');
                    const key = o.trim();
                    if (!key) continue;
                    const low = key.toLowerCase();
                    if (!seen.has(low)) { seen.add(low); cleanedOptions.push(key); }
                }

                // validate minimum options
                if (cleanedOptions.length < 2) continue;
                if (!isFinite(correct) || correct < 0 || correct >= cleanedOptions.length) correct = 0;

                out.push(normalizeQuestion({ question: question, options: cleanedOptions, correct: correct }));
            }

            return out.filter(Boolean);
        }

        // Load any saved pools on startup
        try { loadPoolsFromStorage(); } catch (e) {}

        // Animal trivia questions (real curated question banks)
        // Exposed as `window.animalTriviaQuestions` so other helpers can use them
        window.animalTriviaQuestions = window.animalTriviaQuestions || {
            easy: [
                { question: "What mammal has the most powerful bite in the world?", options: ["Lion", "Hippopotamus", "Grizzly bear"], correct: 1 },
                { question: "What is a male swan called?", options: ["Cob", "Gander", "Drake"], correct: 0 },
                { question: "What is the fastest land mammal?", options: ["Cheetah", "Lion", "Greyhound"], correct: 0 },
                { question: "Which animal's fingerprints are nearly identical to humans?", options: ["Gorilla", "Koala", "Chimpanzee"], correct: 1 },
                { question: "What is the only mammal capable of true sustained flight?", options: ["Bat", "Flying squirrel", "Hawk"], correct: 0 },
                { question: "How many legs do spiders have?", options: ["6", "8", "10"], correct: 1 },
                { question: "Which animal breathes through its skin?", options: ["Frog", "Snake", "Lizard"], correct: 0 },
                { question: "What is the largest living bird?", options: ["Eagle", "Ostrich", "Albatross"], correct: 1 },
                { question: "Which animal is known to have the most teeth?", options: ["Shark", "Crocodile", "Snail"], correct: 2 },
                { question: "What color is the polar bear's skin beneath its fur?", options: ["Black", "White", "Pink"], correct: 0 },
                { question: "Which domesticated animal is known for producing mohair?", options: ["Sheep", "Angora goat", "Alpaca"], correct: 1 },
                { question: "What is the baby of a kangaroo called?", options: ["Joey", "Calf", "Pup"], correct: 0 },
                { question: "Which insect undergoes complete metamorphosis from caterpillar to adult?", options: ["Butterfly", "Grasshopper", "Dragonfly"], correct: 0 },
                { question: "Which bird is known for its mimicry and ability to imitate human speech?", options: ["Sparrow", "Parrot", "Crow"], correct: 1 },
                { question: "What is the common name for baby cows?", options: ["Calf", "Foal", "Puppy"], correct: 0 }
            ],
            medium: [
                { question: "What bird has the largest wingspan?", options: ["Andean condor", "Wandering albatross", "Bald eagle"], correct: 1 },
                { question: "How many eyes does a honeybee have?", options: ["2", "5", "8"], correct: 1 },
                { question: "How many degrees can an owl rotate its head?", options: ["180¬∞", "270¬∞", "360¬∞"], correct: 1 },
                { question: "What is the gestation period of an elephant?", options: ["12 months", "18 months", "22 months"], correct: 2 },
                { question: "Which animal has the longest lifespan?", options: ["Tortoise", "Whale", "Jellyfish"], correct: 1 },
                { question: "What is the smallest mammal in the world?", options: ["Shrew", "Bat", "Mouse"], correct: 1 },
                { question: "How many chambers does a cow's stomach have?", options: ["2", "3", "4"], correct: 2 },
                { question: "Which animal can change its color?", options: ["Octopus", "Chameleon", "Both"], correct: 2 },
                { question: "What is the loudest animal on Earth?", options: ["Lion", "Blue whale", "Howler monkey"], correct: 1 },
                { question: "Which animal sleeps standing up?", options: ["Giraffe", "Horse", "Both"], correct: 2 },
                { question: "Which animal uses echolocation to navigate?", options: ["Bat", "Owl", "Eagle"], correct: 0 },
                { question: "What is the primary diet of a giant panda?", options: ["Bamboo", "Fruits", "Meat"], correct: 0 },
                { question: "What marine animal is known to have a symbiotic relationship with clownfish?", options: ["Sea anemone", "Coral", "Kelp"], correct: 0 },
                { question: "Which reptile can autotomize (lose) its tail to escape predators?", options: ["Lizard", "Turtle", "Snake"], correct: 0 },
                { question: "What is the collective noun for a group of lions?", options: ["Pride", "Herd", "Pack"], correct: 0 }
            ],
            hard: [
                { question: "What percentage of a jellyfish is water?", options: ["85%", "90%", "95%"], correct: 2 },
                { question: "How many species of animals are there approximately?", options: ["1 million", "8.7 million", "50 million"], correct: 1 },
                { question: "Which animal has the most complex brain relative to body size?", options: ["Dolphin", "Octopus", "Human"], correct: 1 },
                { question: "How fast can a cheetah run?", options: ["60 mph", "70 mph", "80 mph"], correct: 1 },
                { question: "What is the only bird that can fly backwards?", options: ["Hummingbird", "Kingfisher", "Woodpecker"], correct: 0 },
                { question: "How many hearts does an octopus have?", options: ["1", "2", "3"], correct: 2 },
                { question: "Which animal has the strongest bite force?", options: ["Saltwater crocodile", "Great white shark", "Hippo"], correct: 0 },
                { question: "What is the lifespan of a mayfly?", options: ["1 hour", "1 day", "1 week"], correct: 1 },
                { question: "Which animal can survive in space?", options: ["Tardigrade", "Cockroach", "Bacteria"], correct: 0 },
                { question: "How many bones does a shark have?", options: ["100", "50", "0"], correct: 2 },
                { question: "Which bird is known for its remarkable memory and use of tools?", options: ["Crow", "Sparrow", "Seagull"], correct: 0 },
                { question: "What is the term for animals that are active during twilight?", options: ["Nocturnal", "Diurnal", "Crepuscular"], correct: 2 },
                { question: "Which mammal has the longest migration, traveling thousands of miles each year?", options: ["Caribou", "Bat", "Elephant"], correct: 0 },
                { question: "What is the study of animal behavior called?", options: ["Ethology", "Ornithology", "Zoology"], correct: 0 },
                { question: "Which fish is known for its ability to generate electricity?", options: ["Electric eel", "Piranha", "Stingray"], correct: 0 }
            ]
        };

        // Pool manager helpers (UI hooks added in DOM)
        function computePoolCounts() {
            const counts = { animal: {}, trivia: {}, riddles: {} };
            try {
                const raw = localStorage.getItem('burblePools');
                if (!raw) return counts;
                const p = JSON.parse(raw) || {};
                ['animal', 'trivia', 'riddles'].forEach(name => {
                    const pools = p[name] || {};
                    Object.keys(pools).forEach(k => {
                        counts[name][k] = Array.isArray(pools[k]) ? pools[k].length : 0;
                    });
                });
            } catch (e) { /* ignore */ }
            return counts;
        }

        function renderPoolCounts() {
            try {
                const container = document.getElementById('pool-counts');
                if (!container) return;
                const counts = computePoolCounts();
                const parts = [];
                Object.keys(counts).forEach(name => {
                    const inner = counts[name];
                    const sub = Object.keys(inner).map(k => `${k}: ${inner[k]}`).join(', ') || 'none';
                    parts.push(`<strong>${name}</strong>: ${sub}`);
                });
                // Append last rotation timestamp if available
                const last = localStorage.getItem('burbleLastRotation');
                if (last) {
                    // show a relative time like '5m ago' and a green check if within 10 minutes
                    const rel = formatRelativeTime(last);
                    const recent = (Date.now() - new Date(last).getTime()) < (10 * 60 * 1000);
                    const check = recent ? ' ‚úÖ' : '';
                    parts.push(`<em>Last rotation:</em> ${escapeHtml(String(rel))}${check}`);
                }
                container.innerHTML = parts.join('<br>');
            } catch (e) { /* ignore */ }
        }

        // Format ISO timestamp to short relative (e.g., '5m ago', '2h ago')
        function formatRelativeTime(iso) {
            try {
                const t = new Date(iso).getTime();
                if (!isFinite(t)) return iso;
                const diff = Date.now() - t;
                const sec = Math.floor(diff / 1000);
                if (sec < 60) return `${sec}s ago`;
                const min = Math.floor(sec / 60);
                if (min < 60) return `${min}m ago`;
                const hr = Math.floor(min / 60);
                if (hr < 24) return `${hr}h ago`;
                const days = Math.floor(hr / 24);
                return `${days}d ago`;
            } catch (e) { return iso; }
        }

        function resetAllPools() {
            try {
                localStorage.removeItem('burblePools');
                const toRemove = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (!key) continue;
                    if (key.startsWith('pool::') || key.startsWith('burblePool::') || key.startsWith('pool:')) toRemove.push(key);
                }
                toRemove.forEach(k => localStorage.removeItem(k));
                if (gameState.animalTrivia && gameState.animalTrivia.pools) gameState.animalTrivia.pools = {};
                if (gameState.trivia && gameState.trivia.pools) gameState.trivia.pools = {};
                if (gameState.riddles && gameState.riddles.pools) gameState.riddles.pools = {};
                renderPoolCounts();
            } catch (e) { console.error('resetAllPools', e); }
        }

        function initPoolManager() {
            try {
                // Only admins should see the Pool Manager UI. If not admin, hide the container and exit.
                try {
                    if (typeof isAdmin === 'function' && !isAdmin()) {
                        const pmEl = document.getElementById('pool-manager');
                        if (pmEl) pmEl.style.display = 'none';
                        const resetBtn = document.getElementById('reset-all-pools');
                        if (resetBtn) resetBtn.style.display = 'none';
                        return;
                    }
                } catch (e) { /* ignore admin check errors and proceed to show by default */ }
                const btn = document.getElementById('reset-all-pools');
                if (btn) btn.addEventListener('click', () => {
                    if (!confirm('Reset all persistent pools? This cannot be undone.')) return;
                    resetAllPools();
                    alert('All pools reset.');
                });
                renderPoolCounts();
                // initialize rotate-status text from last rotation
                try {
                    const status = document.getElementById('rotate-status');
                    if (status) {
                        const last = localStorage.getItem('burbleLastRotation');
                        if (last) status.textContent = `Rotated ${formatRelativeTime(last)}`;
                        else status.textContent = 'Never rotated';
                    }
                } catch (e) {}
                // Add a manual rotate button and a rotation-status indicator to the pool manager
                try {
                    const pm = document.getElementById('pool-manager');
                    if (pm && !document.getElementById('rotate-now-pools')) {
                        const wrapper = document.createElement('div');
                        wrapper.style.marginTop = '8px';
                        wrapper.style.display = 'flex';
                        wrapper.style.alignItems = 'center';
                        wrapper.style.gap = '8px';

                        // Force override checkbox for admins (requires explicit confirmation)
                        const overrideLabel = document.createElement('label');
                        overrideLabel.style.display = 'inline-flex';
                        overrideLabel.style.alignItems = 'center';
                        overrideLabel.style.gap = '6px';
                        const overrideCb = document.createElement('input');
                        overrideCb.type = 'checkbox';
                        overrideCb.id = 'rotate-force-override';
                        overrideCb.title = 'Force rotate even if games are active (admin override)';
                        const overrideText = document.createElement('span');
                        overrideText.textContent = 'Force rotate';
                        overrideText.style.fontSize = '0.9em';
                        overrideLabel.appendChild(overrideCb);
                        overrideLabel.appendChild(overrideText);

                        const rotateBtn = document.createElement('button');
                        rotateBtn.id = 'rotate-now-pools';
                        rotateBtn.className = 'nav-btn';
                        rotateBtn.textContent = 'Rotate now';
                        rotateBtn.title = 'Immediately rotate persistent pools (will skip pools for active games)';
                        rotateBtn.addEventListener('click', () => {
                            const force = !!(document.getElementById('rotate-force-override') && document.getElementById('rotate-force-override').checked);
                            const warn = force ? 'Force-rotate pools now? This will override active games and may disturb players.' : 'Rotate all persistent pools now? Pools for any active games will be skipped.';
                            if (!confirm(warn)) return;
                            try {
                                const ok = rotatePersistentPools({ force });
                                if (ok && ok.then) {
                                    ok.then(() => alert('Rotation complete.')).catch(e => alert('Rotation failed: ' + (e && e.message ? e.message : String(e))));
                                } else {
                                    alert('Rotation complete.');
                                }
                            } catch (e) { alert('Rotation failed: ' + (e && e.message ? e.message : String(e))); }
                        });

                        const status = document.createElement('div');
                        status.id = 'rotate-status';
                        status.setAttribute('aria-live','polite');
                        status.style.fontSize = '0.95em';
                        status.style.color = '#333';
                        status.textContent = '';

                        wrapper.appendChild(overrideLabel);
                        wrapper.appendChild(rotateBtn);
                        wrapper.appendChild(status);
                        // insert after the existing reset button
                        if (btn && btn.parentNode) btn.parentNode.insertBefore(wrapper, btn.nextSibling);
                    }
                } catch (e) { /* ignore UI insertion errors */ }
                // Wrap savePoolsToStorage to refresh counts
                const orig = savePoolsToStorage;
                savePoolsToStorage = function() { try { orig(); } catch (e) {} renderPoolCounts(); };
            } catch (e) { console.error('initPoolManager', e); }
        }

            // Periodically rotate (reshuffle) persistent pools so users see different questions
            // every `minutes` minutes. This will attempt to rebuild pools from the canonical
            // question sources when available (e.g. `triviaQuestions`, `animalTriviaQuestions`)
            // and otherwise reshuffle the existing stored pool.
            function rotatePersistentPools() {
                try {
                    const keysToRotate = [];
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (!key) continue;
                        if (key.startsWith('pool::')) keysToRotate.push(key);
                    }

                    keysToRotate.forEach(key => {
                        try {
                            const parts = key.split('::'); // ['pool', name, difficulty]
                            const name = parts[1];
                            const difficulty = parts[2];
                            // Skip rotating pools for games that are currently active so we don't
                            // disturb an in-progress session for players.
                            try {
                                if (name === 'trivia' && gameState.trivia && gameState.trivia.gameActive) return;
                                if (name === 'animal' && gameState.animalTrivia && gameState.animalTrivia.gameActive) return;
                                if (name === 'riddles' && gameState.riddles && gameState.riddles.gameActive) return;
                                // Also avoid rotating pools when other game types are active
                                if (name === 'burble' && gameState.burble && gameState.burble.gameActive) return;
                                if (name === 'emoji' && gameState.emoji && gameState.emoji.gameActive) return;
                                if (name === 'valentine' && gameState.valentine && gameState.valentine.gameActive) return;
                            } catch (e) { /* ignore gameState read errors and proceed */ }
                            let allItems = [];

                            if (name === 'trivia' && window.triviaQuestions && triviaQuestions[difficulty]) {
                                allItems = triviaQuestions[difficulty].slice();
                            } else if (name === 'animal' && window.animalTriviaQuestions && animalTriviaQuestions[difficulty]) {
                                allItems = animalTriviaQuestions[difficulty].slice();
                            } else if (name === 'riddles') {
                                // For riddles we may not have a global full-list by difficulty available
                                // so fall back to the stored pool if present.
                                const raw = localStorage.getItem(key);
                                if (raw) {
                                    try { allItems = JSON.parse(raw) || []; } catch (e) { allItems = []; }
                                }
                            } else {
                                // Fallback: use what's currently stored
                                const raw = localStorage.getItem(key);
                                if (raw) {
                                    try { allItems = JSON.parse(raw) || []; } catch (e) { allItems = []; }
                                }
                            }

                            // If we have a base list, reshuffle it; otherwise reshuffle the stored pool
                            let newPool = [];
                            if (Array.isArray(allItems) && allItems.length > 0) {
                                newPool = shuffleArray(allItems.slice());
                            } else {
                                // last resort: shuffle existing stored pool
                                const rawExisting = localStorage.getItem(key);
                                try { newPool = rawExisting ? shuffleArray(JSON.parse(rawExisting).slice()) : []; } catch (e) { newPool = []; }
                            }

                            try { localStorage.setItem(key, JSON.stringify(newPool)); } catch (e) {}

                            // If rotation was forced, refresh in-memory active game question lists
                            try {
                                if (typeof force !== 'undefined' && force) {
                                    if (name === 'trivia' && window.gameState && gameState.trivia && gameState.trivia.gameActive) {
                                        try {
                                            const all = (window.triviaQuestions && triviaQuestions[difficulty]) || [];
                                            gameState.trivia.currentGameQuestions = drawFromPool('trivia', difficulty, all, gameState.trivia.totalQuestions || gameState.trivia.totalQuestionsUsed || 10);
                                            gameState.trivia.totalQuestionsUsed = gameState.trivia.currentGameQuestions.length;
                                            gameState.trivia.currentQuestion = 0;
                                            try { showTriviaQuestion(); } catch (e) {}
                                        } catch (e) {}
                                    }
                                    if (name === 'animal' && window.gameState && gameState.animalTrivia && gameState.animalTrivia.gameActive) {
                                        try {
                                            const allA = (window.animalTriviaQuestions && animalTriviaQuestions[difficulty]) || [];
                                            gameState.animalTrivia.currentGameQuestions = drawFromPool('animal', difficulty, allA, gameState.animalTrivia.totalQuestions || gameState.animalTrivia.totalQuestionsUsed || 15);
                                            gameState.animalTrivia.totalQuestionsUsed = gameState.animalTrivia.currentGameQuestions.length;
                                            gameState.animalTrivia.currentQuestion = 0;
                                            try { showAnimalTriviaQuestion(); } catch (e) {}
                                        } catch (e) {}
                                    }
                                    if (name === 'riddles' && window.gameState && gameState.riddles && gameState.riddles.gameActive) {
                                        try {
                                            gameState.riddles.currentRiddle = null;
                                            gameState.riddles.currentHintLevel = 0;
                                            try { nextRiddle(); } catch (e) {}
                                        } catch (e) {}
                                    }
                                }
                            } catch (e) { /* ignore UI update errors */ }
                        } catch (e) {
                            /* ignore per-key errors */
                        }
                    });

                    // Also refresh the summary snapshot used by pool-manager
                    try { savePoolsToStorage(); } catch (e) {}
                    try { renderPoolCounts(); } catch (e) {}
                    // persist last rotation timestamp for UI
                    try { localStorage.setItem('burbleLastRotation', new Date().toISOString()); } catch (e) {}
                    // update rotate-status text if present
                    try {
                        const status = document.getElementById('rotate-status');
                        if (status) {
                            const last = localStorage.getItem('burbleLastRotation');
                            if (last) status.textContent = `Rotated ${formatRelativeTime(last)}`;
                        }
                    } catch (e) {}
                } catch (e) { console.error('rotatePersistentPools', e); }
            }

            function schedulePoolRotation(minutes) {
                try {
                    const ms = Math.max(1, Number(minutes) || 30) * 60 * 1000;
                    // Run immediately once, then schedule
                    rotatePersistentPools();
                    setInterval(rotatePersistentPools, ms);
                } catch (e) { console.error('schedulePoolRotation', e); }
            }

        // Riddles: maintain per-filter shuffled pools to avoid repeats until exhausted
        function getRiddleFromPool(category, difficulty) {
            // Use persistent drawFromPool so riddles never repeat until pool exhausts
            const all = getRiddlesByFilter(category, difficulty) || [];
            const drawn = drawFromPool('riddles', `${category}:${difficulty}`, all, 1);
            if (drawn && drawn.length > 0) return drawn[0];
            // fallback
            return all.length > 0 ? all[Math.floor(Math.random() * all.length)] : null;
        }
        function showFeedback(gameType, message, type) {
            const feedback = document.getElementById(gameType + '-feedback');
            feedback.innerHTML = `<div class="feedback ${type}">${message}</div>`;
        }

        // Ensure animal trivia banks have at least `minCount` questions per difficulty
        function ensureAnimalBanks(minCount) {
            try {
                if (!window.animalTriviaQuestions) return;
                ['easy','medium','hard'].forEach(diff => {
                    const arr = animalTriviaQuestions[diff] || [];
                    const missing = Math.max(0, minCount - arr.length);
                    for (let i = 0; i < missing; i++) {
                        const idx = arr.length + i + 1;
                        arr.push({
                            question: `Placeholder animal question ${idx} (${diff})`,
                            options: ['Option A','Option B','Option C','Option D'],
                            correct: 0
                        });
                    }
                    animalTriviaQuestions[diff] = arr;
                });
            } catch (e) { /* ignore */ }
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        

        function nextRiddle() {
            const riddles = gameState.riddles;
            
            // Get riddles for current filter
            const availableRiddles = getRiddlesByFilter(riddles.category, riddles.difficulty);
            if (availableRiddles.length === 0) {
                showFeedback('riddles', 'No riddles available for this category/difficulty combination.', 'error');
                return;
            }
            // Select riddle from a shuffled per-filter pool to avoid repeats until pool exhausted
            let newRiddle = getRiddleFromPool(riddles.category, riddles.difficulty);
            if (!newRiddle) {
                // Fallback to random selection
                newRiddle = availableRiddles[Math.floor(Math.random() * availableRiddles.length)];
            }
            riddles.currentRiddle = newRiddle;
            riddles.currentHintLevel = 0;
            riddles.attemptCount = 0;
            riddles.gameActive = true;

            // Display riddle
            document.getElementById('riddles-question').textContent = riddles.currentRiddle.riddle;
            
            // Enable inputs
            document.getElementById('riddles-input').disabled = false;
            document.getElementById('riddles-submit').disabled = false;
            document.getElementById('riddles-hint').disabled = false;
            document.getElementById('riddles-input').focus();
            
            // Clear previous feedback
            document.getElementById('riddles-feedback').innerHTML = '';
            
            updateRiddlesDisplay();
            showFeedback('riddles', 'New riddle loaded! Think carefully about your answer.', 'info');
            try { if (window.playModeAudio) window.playModeAudio('riddles'); } catch (e) {}
        }

        function submitRiddleAnswer() {
            if (!gameState.riddles.gameActive || !gameState.riddles.currentRiddle) return;
            
            const answer = document.getElementById('riddles-input').value.trim();
            if (!answer) return;

            const riddles = gameState.riddles;
            riddles.attemptCount++;

            if (checkRiddleAnswer(answer, riddles.currentRiddle.acceptedAnswers)) {
                handleRiddleCorrect();
            } else {
                handleRiddleIncorrect();
            }

            document.getElementById('riddles-input').value = '';
        }

        function handleRiddleCorrect() {
            const riddles = gameState.riddles;
            riddles.gameActive = false;
            riddles.solved++;

            // Calculate score based on difficulty, attempts, and hints used
            let basePoints = 0;
            switch (riddles.difficulty) {
                case 'easy': basePoints = 10; break;
                case 'medium': basePoints = 25; break;
                case 'hard': basePoints = 50; break;
            }

            // Bonus for fewer attempts
            const attemptBonus = Math.max(0, (riddles.maxAttempts - riddles.attemptCount + 1) * 5);
            
            // Penalty for hints (already calculated when hint is used)
            const totalScore = basePoints + attemptBonus;
            riddles.score += totalScore;

            // Disable inputs
            document.getElementById('riddles-input').disabled = true;
            document.getElementById('riddles-submit').disabled = true;
            document.getElementById('riddles-hint').disabled = true;

            addGameResult(true, totalScore);
            updateRiddlesDisplay();
            
            showFeedback('riddles', 
                `üéâ Correct! The answer was "${riddles.currentRiddle.answer}". You earned ${totalScore} points! Click "New Riddle" to continue.`, 
                'success'
            );
            // leaderboard recording
            try {
                const user = JSON.parse(localStorage.getItem('burbleUser') || 'null');
                if (user && user.username) recordCorrect(user.username, 0);
            } catch (e) {}
        }

        function handleRiddleIncorrect() {
            const riddles = gameState.riddles;
            
            if (riddles.attemptCount >= riddles.maxAttempts) {
                // Game over - show correct answer
                riddles.gameActive = false;
                
                document.getElementById('riddles-input').disabled = true;
                document.getElementById('riddles-submit').disabled = true;
                document.getElementById('riddles-hint').disabled = true;

                addGameResult(false, 0);
                
                showFeedback('riddles', 
                    `‚ùå Incorrect! The answer was "${riddles.currentRiddle.answer}". Click "New Riddle" to try another!`, 
                    'error'
                );
            } else {
                const attemptsLeft = riddles.maxAttempts - riddles.attemptCount;
                showFeedback('riddles', 
                    `‚ùå Incorrect! You have ${attemptsLeft} attempt${attemptsLeft !== 1 ? 's' : ''} left. Try again!`, 
                    'warning'
                );
            }
            
            updateRiddlesDisplay();
            try { const user = JSON.parse(localStorage.getItem('burbleUser') || 'null'); if (user && user.username) recordIncorrect(user.username); } catch (e) {}
        }

        function getRiddleHint() {
            const riddles = gameState.riddles;
            if (!riddles.currentRiddle || !riddles.gameActive) return;

            // Check if hints are available
            const hints = riddles.currentRiddle.hints || [];
            if (riddles.currentHintLevel >= hints.length) {
                showFeedback('riddles', 'üí° No more hints available for this riddle.', 'warning');
                return;
            }

            const currentHint = hints[riddles.currentHintLevel];
            const hintNumber = riddles.currentHintLevel + 1;
            const pointPenalty = (hintNumber * 5) + 5; // Progressive penalty: 10, 15, 20 points

            riddles.hintsUsed++;
            riddles.currentHintLevel++;
            riddles.score = Math.max(0, riddles.score - pointPenalty);

            showFeedback('riddles', `üí° Hint ${hintNumber}: ${currentHint} (-${pointPenalty} points)`, 'info');
            
            updateRiddlesDisplay();
            updateHintButton();
        }

        function updateRiddlesDisplay() {
            const riddles = gameState.riddles;
            
            // Update stats
            document.getElementById('riddles-score').textContent = riddles.score;
            document.getElementById('riddles-solved').textContent = riddles.solved;
            document.getElementById('riddles-difficulty').textContent = 
                riddles.difficulty.charAt(0).toUpperCase() + riddles.difficulty.slice(1);
            
            // Update category display
            const categoryDisplay = {
                'all': 'All Types',
                'logic': 'Logic',
                'word': 'Word',
                'math': 'Math', 
                'lateral': 'Lateral Thinking'
            };
            document.getElementById('riddles-category').textContent = categoryDisplay[riddles.category] || riddles.category;
        }

        // BURBLE WORD GAME
        function initBurbleGame() {
            // Difficulty selectors
            document.querySelectorAll('#burble-page .selector-btn[data-difficulty]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#burble-page .selector-btn[data-difficulty]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    gameState.burble.difficulty = btn.dataset.difficulty;
                    setBurbleMaxAttempts();
                    updateBurbleDisplay();
                });
            });

            // Category selectors
            document.querySelectorAll('#burble-page .selector-btn[data-category]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#burble-page .selector-btn[data-category]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    gameState.burble.category = btn.dataset.category;
                    updateBurbleDisplay();
                });
            });

            // Game buttons
            document.getElementById('burble-new-game').addEventListener('click', startBurbleGame);
            document.getElementById('burble-submit').addEventListener('click', submitBurbleGuess);
            document.getElementById('burble-hint').addEventListener('click', getBurbleHint);

            // Input handling
            document.getElementById('burble-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && gameState.burble.gameActive) {
                    submitBurbleGuess();
                }
            });

            setBurbleMaxAttempts();
        }

        function setBurbleMaxAttempts() {
            switch (gameState.burble.difficulty) {
                case 'easy':
                    gameState.burble.maxAttempts = 15;
                    break;
                case 'medium':
                    gameState.burble.maxAttempts = 10;
                    break;
                case 'hard':
                    gameState.burble.maxAttempts = 5;
                    break;
            }
        }

        function startBurbleGame() {
            const burble = gameState.burble;
            // Reset game state
            trivia.currentQuestion = 0;
            trivia.correctAnswers = 0;
            trivia.score = 0;
            trivia.gameActive = true;
            trivia.selectedAnswer = null;

            // Ensure persistent pools exist
            if (!gameState.trivia.pools) gameState.trivia.pools = {};
            const key = `trivia|${trivia.difficulty}`;
            if (!gameState.trivia.pools[key] || gameState.trivia.pools[key].length === 0) {
                const allQuestions = triviaQuestions[trivia.difficulty] || [];
                gameState.trivia.pools[key] = shuffleArray(allQuestions);
            }

            // Take questions for this run (consume from pool)
            const take = Math.min(trivia.totalQuestions, (gameState.trivia.pools[key] || []).length);
            // Draw from the rotating persistent pool so questions don't repeat across runs
            const allQ = (window.triviaQuestions && triviaQuestions[trivia.difficulty]) || [];
            trivia.currentGameQuestions = drawFromPool('trivia', trivia.difficulty, allQ, take);
            try { savePoolsToStorage(); } catch (e) {}
            trivia.totalQuestionsUsed = trivia.currentGameQuestions.length;

            // Start timer
            startTimer('trivia');

            // Play configured audio for Burble
            try { if (window.playModeAudio) window.playModeAudio('burble'); } catch (e) {}

            // Show first question
            showTriviaQuestion();
            // Enable inputs
            document.getElementById('burble-input').disabled = false;
            document.getElementById('burble-submit').disabled = false;
            document.getElementById('burble-hint').disabled = false;
            document.getElementById('burble-input').focus();
            
            updateBurbleDisplay();
            showFeedback('burble', 'Game started! Guess the word.', 'info');
        }

        function submitBurbleGuess() {
            if (!gameState.burble.gameActive) return;
            
            const guess = document.getElementById('burble-input').value.trim().toLowerCase();
            if (!guess) return;
            
            const burble = gameState.burble;
            burble.attempts++;
            
            if (guess === burble.currentWord) {
                handleBurbleWin();
            } else {
                handleBurbleIncorrect(guess);
            }
            
            document.getElementById('burble-input').value = '';
            updateBurbleDisplay();
        }

        function handleBurbleWin() {
            const burble = gameState.burble;
            burble.gameActive = false;
            stopTimer('burble');
            
            const elapsedTime = Math.floor((Date.now() - burble.startTime) / 1000);
            const timeBonus = Math.max(0, 300 - elapsedTime);
            const attemptBonus = Math.max(0, (burble.maxAttempts - burble.attempts) * 10);
            const hintPenalty = burble.hintsUsed * 25;
            burble.score = Math.max(0, 100 + timeBonus + attemptBonus - hintPenalty);
            
            addGameResult(true, burble.score);
            
            showFeedback('burble', `üéâ Correct! The word was "${burble.currentWord}"`, 'correct');
            
            document.getElementById('burble-game-over').innerHTML = `
                <div class="game-over win">
                    <h3>üéâ Congratulations!</h3>
                    <p>You guessed "${burble.currentWord}" correctly!</p>
                    <p><strong>Score:</strong> ${burble.score} points</p>
                    <p><strong>Time:</strong> ${formatTime(Math.floor((Date.now() - burble.startTime) / 1000))}</p>
                    <p><strong>Attempts:</strong> ${burble.attempts}/${burble.maxAttempts}</p>
                </div>
            `;
            
            disableBurbleInputs();
            // Stop audio for Burble
            try { if (window.audioControls && window.audioControls.stop) window.audioControls.stop(); } catch (e) {}
            try { const user = JSON.parse(localStorage.getItem('burbleUser') || 'null'); if (user && user.username) recordCorrect(user.username, 0); } catch (e) {}
        }

        function handleBurbleIncorrect(guess) {
            const burble = gameState.burble;
            const feedback = generateBurbleFeedback(guess, burble.currentWord);
            
            showFeedback('burble', `‚ùå "${guess}" is incorrect. ${feedback}`, 'incorrect');
            
            if (burble.attempts >= burble.maxAttempts) {
                burble.gameActive = false;
                stopTimer('burble');
                addGameResult(false, 0);
                // Stop audio for Burble
                try { if (window.audioControls && window.audioControls.stop) window.audioControls.stop(); } catch (e) {}
                
                document.getElementById('burble-game-over').innerHTML = `
                    <div class="game-over lose">
                        <h3>üòî Game Over</h3>
                        <p>The word was: <strong>"${burble.currentWord}"</strong></p>
                        <p>Category: ${burble.category}</p>
                        <p>Better luck next time!</p>
                    </div>
                `;
                
                disableBurbleInputs();
                try { const user = JSON.parse(localStorage.getItem('burbleUser') || 'null'); if (user && user.username) recordIncorrect(user.username); } catch (e) {}
            }
        }

        function generateBurbleFeedback(guess, targetWord) {
            if (guess.length !== targetWord.length) {
                return `Try a ${targetWord.length}-letter word.`;
            }
            
            let commonLetters = 0;
            for (let i = 0; i < Math.min(guess.length, targetWord.length); i++) {
                if (targetWord.includes(guess[i])) {
                    commonLetters++;
                }
            }
            
            if (commonLetters === 0) {
                return "No matching letters.";
            } else if (commonLetters === 1) {
                return "1 letter is in the word.";
            } else {
                return `${commonLetters} letters are in the word.`;
            }
        }

        function getBurbleHint() {
            if (!gameState.burble.gameActive) return;
            
            const burble = gameState.burble;
            burble.hintsUsed++;
            
            const hints = [
                `The word is ${burble.currentWord.length} letters long.`,
                `The word is in the ${burble.category} category.`,
                `The word starts with "${burble.currentWord[0]}".`,
                `The word ends with "${burble.currentWord[burble.currentWord.length - 1]}".`,
                `The second letter is "${burble.currentWord[1]}".`
            ];
            
            const hintIndex = Math.min(burble.hintsUsed - 1, hints.length - 1);
            showFeedback('burble', `üí° Hint ${burble.hintsUsed}: ${hints[hintIndex]} (-25 points)`, 'hint');
            
            updateBurbleDisplay();
        }

        function updateBurbleDisplay() {
            const burble = gameState.burble;
            
            document.getElementById('burble-attempts').textContent = `${burble.attempts}/${burble.maxAttempts}`;
            document.getElementById('burble-category').textContent = burble.category;
            document.getElementById('burble-score').textContent = burble.score;
            
            if (burble.currentWord && burble.gameActive) {
                document.getElementById('burble-display').textContent = '_ '.repeat(burble.currentWord.length).trim();
            } else if (burble.currentWord && !burble.gameActive) {
                document.getElementById('burble-display').textContent = burble.currentWord.toUpperCase();
            } else {
                document.getElementById('burble-display').textContent = 'Click "New Game" to start!';
            }
        }

        function disableBurbleInputs() {
            document.getElementById('burble-input').disabled = true;
            document.getElementById('burble-submit').disabled = true;
            document.getElementById('burble-hint').disabled = true;
        }

        // EMOJI GUESS GAME
        function initEmojiGame() {
            // Difficulty selectors
            document.querySelectorAll('#emoji-page .selector-btn[data-difficulty]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#emoji-page .selector-btn[data-difficulty]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    gameState.emoji.difficulty = btn.dataset.difficulty;
                    updateEmojiDisplay();
                });
            });

            // Category selectors
            document.querySelectorAll('#emoji-page .selector-btn[data-category]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#emoji-page .selector-btn[data-category]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    gameState.emoji.category = btn.dataset.category;
                    updateEmojiDisplay();
                });
            });

            // Game buttons
            document.getElementById('emoji-new-puzzle').addEventListener('click', startEmojiGame);
            document.getElementById('emoji-submit').addEventListener('click', submitEmojiAnswer);
            document.getElementById('emoji-hint').addEventListener('click', getEmojiHint);

            // Input handling
            document.getElementById('emoji-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && gameState.emoji.gameActive) {
                    submitEmojiAnswer();
                }
            });
        }

        function startEmojiGame() {
            const emoji = gameState.emoji;
            
            // Get available puzzles
            let availablePuzzles = [];
            if (emoji.category === 'all') {
                Object.values(emojiPuzzles).forEach(puzzles => {
                    availablePuzzles.push(...puzzles);
                });
            } else {
                availablePuzzles = emojiPuzzles[emoji.category] || [];
            }
            
            if (availablePuzzles.length === 0) {
                showFeedback('emoji', 'No puzzles available for this category!', 'incorrect');
                return;
            }
            
            // Select random puzzle
            emoji.currentPuzzle = availablePuzzles[Math.floor(Math.random() * availablePuzzles.length)];
            emoji.gameActive = true;
            emoji.hintsUsed = 0;
            
            // Enable inputs
            document.getElementById('emoji-input').disabled = false;
            document.getElementById('emoji-submit').disabled = false;
            document.getElementById('emoji-hint').disabled = false;
            document.getElementById('emoji-input').focus();
            
            updateEmojiDisplay();
            showFeedback('emoji', 'New puzzle! What does this emoji combination represent?', 'info');
            // Play configured audio for Emoji
            try { if (window.playModeAudio) window.playModeAudio('emoji'); } catch (e) {}
        }

        function submitEmojiAnswer() {
            if (!gameState.emoji.gameActive) return;
            
            const answer = document.getElementById('emoji-input').value.trim();
            if (!answer) return;
            
            const emoji = gameState.emoji;
            const correctAnswer = emoji.currentPuzzle.answer.toLowerCase();
            const userAnswer = answer.toLowerCase();
            
            if (userAnswer === correctAnswer || correctAnswer.includes(userAnswer) || userAnswer.includes(correctAnswer)) {
                handleEmojiWin();
            } else {
                handleEmojiIncorrect();
            }
            
            document.getElementById('emoji-input').value = '';
        }

        function handleEmojiWin() {
            const emoji = gameState.emoji;
            emoji.gameActive = false;
            
            const baseScore = 100;
            const hintPenalty = emoji.hintsUsed * 5;
            const difficultyBonus = emoji.difficulty === 'hard' ? 50 : emoji.difficulty === 'medium' ? 25 : 0;
            emoji.score += Math.max(10, baseScore - hintPenalty + difficultyBonus);
            
            addGameResult(true, baseScore - hintPenalty + difficultyBonus);
            
            showFeedback('emoji', `üéâ Correct! The answer was "${emoji.currentPuzzle.answer}"`, 'correct');
            
            document.getElementById('emoji-game-over').innerHTML = `
                <div class="game-over win">
                    <h3>üéâ Excellent!</h3>
                    <p>You solved: ${emoji.currentPuzzle.emoji}</p>
                    <p><strong>Answer:</strong> ${emoji.currentPuzzle.answer}</p>
                    <p><strong>Score:</strong> ${baseScore - (emoji.hintsUsed * 5) + difficultyBonus} points</p>
                    <p><strong>Hints used:</strong> ${emoji.hintsUsed}</p>
                </div>
            `;
            
            disableEmojiInputs();
            updateEmojiDisplay();
            try { if (window.audioControls && window.audioControls.stop) window.audioControls.stop(); } catch (e) {}
            try { const user = JSON.parse(localStorage.getItem('burbleUser') || 'null'); if (user && user.username) recordCorrect(user.username, 0); } catch (e) {}
        }

        function handleEmojiIncorrect() {
            showFeedback('emoji', '‚ùå Incorrect! Try again or get a hint.', 'incorrect');
            try { const user = JSON.parse(localStorage.getItem('burbleUser') || 'null'); if (user && user.username) recordIncorrect(user.username); } catch (e) {}
        }

        function getEmojiHint() {
            if (!gameState.emoji.gameActive) return;
            
            const emoji = gameState.emoji;
            emoji.hintsUsed++;
            
            showFeedback('emoji', `üí° Hint: ${emoji.currentPuzzle.hint} (-5 points)`, 'hint');
            updateEmojiDisplay();
        }

        function updateEmojiDisplay() {
            const emoji = gameState.emoji;
            
            document.getElementById('emoji-score').textContent = emoji.score;
            document.getElementById('emoji-hints').textContent = emoji.hintsUsed;
            document.getElementById('emoji-category').textContent = emoji.category.charAt(0).toUpperCase() + emoji.category.slice(1);
            document.getElementById('emoji-difficulty').textContent = emoji.difficulty.charAt(0).toUpperCase() + emoji.difficulty.slice(1);
        }
        

        function setValentineQuestions() {
            switch (gameState.valentine.difficulty) {
                case 'easy':
                    gameState.valentine.questionsLeft = 8;
                    break;
                case 'medium':
                    gameState.valentine.questionsLeft = 6;
                    break;
                case 'hard':
                    gameState.valentine.questionsLeft = 4;
                    break;
            }
        }

        function startValentineGame() {
            const valentine = gameState.valentine;
            
            // Reset game state
            valentine.questions = [];
            valentine.answers = [];
            valentine.guessesLeft = 3;
            valentine.gameActive = true;
            valentine.score = 0;
            setValentineQuestions();
            
            // Select random answer
            const categoryAnswers = valentineAnswers[valentine.category];
            valentine.currentAnswer = categoryAnswers[Math.floor(Math.random() * categoryAnswers.length)].answer;
            
            // Enable inputs
            document.getElementById('valentine-question').disabled = false;
            document.getElementById('valentine-ask').disabled = false;
            document.getElementById('valentine-guess').disabled = false;
            document.getElementById('valentine-question').focus();
            
            // Clear history
            document.getElementById('valentine-history').innerHTML = '<p class="muted-center">Ask yes/no questions to figure out what I\'m thinking of!</p>';
            
            updateValentineDisplay();
            showFeedback('valentine', `I'm thinking of something in the ${valentine.category} category. Ask yes/no questions!`, 'info');
            // Play configured audio for Valentine (Twenty Questions)
            try { if (window.playModeAudio) window.playModeAudio('valentine'); } catch (e) {}
        }

        function askValentineQuestion() {
            if (!gameState.valentine.gameActive) return;
            
            const question = document.getElementById('valentine-question').value.trim();
            if (!question) return;
            
            const valentine = gameState.valentine;
            valentine.questionsLeft--;
            valentine.questions.push(question);
            
            // Generate AI-like response
            const answer = generateValentineAnswer(question, valentine.currentAnswer);
            valentine.answers.push(answer);
            
            // Update history
            updateValentineHistory();
            
            document.getElementById('valentine-question').value = '';
            updateValentineDisplay();
            
            if (valentine.questionsLeft === 0) {
                showFeedback('valentine', 'No more questions! You must make a guess now.', 'hint');
                document.getElementById('valentine-ask').disabled = true;
                document.getElementById('valentine-question').disabled = true;
            }
        }

        function generateValentineAnswer(question, answer) {
            const q = question.toLowerCase();
            const a = answer.toLowerCase();
            
            // Simple keyword matching for basic responses
            if (q.includes('alive') || q.includes('living')) {
                return gameState.valentine.category === 'animals' ? 'Yes' : 'No';
            }
            if (q.includes('animal')) {
                return gameState.valentine.category === 'animals' ? 'Yes' : 'No';
            }
            if (q.includes('place') || q.includes('location')) {
                return gameState.valentine.category === 'places' ? 'Yes' : 'No';
            }
            if (q.includes('movie') || q.includes('film')) {
                return gameState.valentine.category === 'movies' ? 'Yes' : 'No';
            }
            if (q.includes('object') || q.includes('thing')) {
                return gameState.valentine.category === 'objects' ? 'Yes' : 'No';
            }
            if (q.includes('big') || q.includes('large')) {
                return ['elephant', 'giraffe', 'whale', 'titanic', 'avatar'].some(word => a.includes(word)) ? 'Yes' : 'No';
            }
            if (q.includes('small')) {
                return ['phone', 'key', 'watch'].some(word => a.includes(word)) ? 'Yes' : 'No';
            }
            if (q.includes('water')) {
                return ['dolphin', 'titanic', 'sydney', 'paris'].some(word => a.includes(word)) ? 'Yes' : 'No';
            }
            if (q.includes('fly') || q.includes('flight')) {
                return ['penguin', 'avatar'].some(word => a.includes(word)) ? 'Yes' : 'No';
            }
            
            // Random yes/no for other questions
            return Math.random() > 0.5 ? 'Yes' : 'No';
        }

        function makeValentineGuess() {
            if (!gameState.valentine.gameActive) return;
            
            const guess = prompt('What do you think I\'m thinking of?');
            if (!guess) return;
            
            const valentine = gameState.valentine;
            valentine.guessesLeft--;
            
            if (guess.toLowerCase() === valentine.currentAnswer.toLowerCase()) {
                handleValentineWin();
            } else {
                if (valentine.guessesLeft === 0) {
                    handleValentineLose();
                } else {
                    showFeedback('valentine', `‚ùå Not quite! You have ${valentine.guessesLeft} guess(es) left.`, 'incorrect');
                    updateValentineDisplay();
                }
            }
        }

        function handleValentineWin() {
            const valentine = gameState.valentine;
            valentine.gameActive = false;
            
            const baseScore = 100;
            const questionBonus = valentine.questionsLeft * 10;
            const guessBonus = valentine.guessesLeft * 20;
            valentine.score = baseScore + questionBonus + guessBonus;
            
            addGameResult(true, valentine.score);
            
            showFeedback('valentine', `üéâ Correct! I was thinking of "${valentine.currentAnswer}"`, 'correct');
            
            document.getElementById('valentine-game-over').innerHTML = `
                <div class="game-over win">
                    <h3>üéâ Amazing!</h3>
                    <p>You guessed "${valentine.currentAnswer}" correctly!</p>
                    <p><strong>Score:</strong> ${valentine.score} points</p>
                    <p><strong>Questions used:</strong> ${valentine.questions.length}</p>
                    <p><strong>Guesses remaining:</strong> ${valentine.guessesLeft}</p>
                </div>
            `;
            
            disableValentineInputs();
            try { if (window.audioControls && window.audioControls.stop) window.audioControls.stop(); } catch (e) {}
            try { const user = JSON.parse(localStorage.getItem('burbleUser') || 'null'); if (user && user.username) recordCorrect(user.username, 0); } catch (e) {}
        }

        function handleValentineLose() {
            const valentine = gameState.valentine;
            valentine.gameActive = false;
            
            addGameResult(false, 0);
            
            showFeedback('valentine', `üòî The answer was "${valentine.currentAnswer}". Better luck next time!`, 'incorrect');
            
            document.getElementById('valentine-game-over').innerHTML = `

                <div class="game-over lose">
                    <h3>üòî Game Over</h3>
                    <p>I was thinking of: <strong>"${valentine.currentAnswer}"</strong></p>
                    <p>Category: ${valentine.category}</p>
                    <p>You asked ${valentine.questions.length} questions</p>
                </div>
            `;
            
            disableValentineInputs();
            try { if (window.audioControls && window.audioControls.stop) window.audioControls.stop(); } catch (e) {}
            try { const user = JSON.parse(localStorage.getItem('burbleUser') || 'null'); if (user && user.username) recordIncorrect(user.username); } catch (e) {}
        }

        function updateValentineHistory() {
            const valentine = gameState.valentine;
            const history = document.getElementById('valentine-history');
            
            let historyHTML = '';
            for (let i = 0; i < valentine.questions.length; i++) {
                historyHTML += `
                    <div class="question-item">
                        <div class="question-text">Q: ${valentine.questions[i]}</div>
                        <div class="answer-text">A: ${valentine.answers[i]}</div>
                    </div>
                `;
            }
            
            history.innerHTML = historyHTML || '<p class="muted-center">Ask yes/no questions to figure out what I\'m thinking of!</p>';
        }

        function updateValentineDisplay() {
            const valentine = gameState.valentine;
            
            document.getElementById('valentine-questions').textContent = valentine.questionsLeft;
            document.getElementById('valentine-guesses').textContent = valentine.guessesLeft;
            document.getElementById('valentine-category').textContent = valentine.category.charAt(0).toUpperCase() + valentine.category.slice(1);
            document.getElementById('valentine-score').textContent = valentine.score;
        }

        function disableValentineInputs() {
            document.getElementById('valentine-question').disabled = true;
            document.getElementById('valentine-ask').disabled = true;
            document.getElementById('valentine-guess').disabled = true;
        }

        // TRIVIA GAME
        function initTriviaGame() {
            // Difficulty selectors
            document.querySelectorAll('#trivia-page .selector-btn[data-difficulty]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#trivia-page .selector-btn[data-difficulty]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    gameState.trivia.difficulty = btn.dataset.difficulty;
                });
            });

            // Game buttons
            document.getElementById('trivia-start').addEventListener('click', startTriviaGame);
            document.getElementById('trivia-submit').addEventListener('click', submitTriviaAnswer);
            document.getElementById('trivia-next').addEventListener('click', nextTriviaQuestion);
        }

        // Single canonical start: draw unique questions from rotating pool and persist
        function startTriviaGame() {
            const trivia = gameState.trivia;
            // Reset game state
            trivia.currentQuestion = 0;
            trivia.correctAnswers = 0;
            trivia.score = 0;
            trivia.gameActive = true;
            trivia.selectedAnswer = null;

            // Use rotating persistent pool to select questions without immediate repeats
            const allQuestions = (window.triviaQuestions && triviaQuestions[trivia.difficulty]) || [];
            trivia.currentGameQuestions = drawFromPool('trivia', trivia.difficulty, allQuestions, trivia.totalQuestions);
            trivia.totalQuestionsUsed = trivia.currentGameQuestions.length;

            // Persist pool snapshot so subsequent runs avoid repeats
            try { savePoolsToStorage(); } catch (e) {}

            // Start timer
            startTimer('trivia');

            // Play configured audio for Trivia
            try { if (window.playModeAudio) window.playModeAudio('trivia'); } catch (e) {}

            // Show first question
            showTriviaQuestion();

            // Update buttons
            document.getElementById('trivia-start').disabled = true;
            document.getElementById('trivia-submit').disabled = false;

            updateTriviaDisplay();
        }

        function showTriviaQuestion() {
            const trivia = gameState.trivia;
            const questions = trivia.currentGameQuestions || [];

            if (trivia.currentQuestion >= (trivia.totalQuestionsUsed || questions.length) || trivia.currentQuestion >= questions.length) {
                endTriviaGame();
                return;
            }

            const question = questions[trivia.currentQuestion];
            document.getElementById('trivia-question-text').textContent = question.question;

            const optionsContainer = document.getElementById('trivia-options');
            optionsContainer.innerHTML = '';

            question.options.forEach((option, index) => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'trivia-option';
                optionDiv.textContent = option;
                optionDiv.onclick = () => selectTriviaOption(index, optionDiv);
                optionsContainer.appendChild(optionDiv);
            });

            trivia.selectedAnswer = null;
            document.getElementById('trivia-submit').disabled = false;
            document.getElementById('trivia-next').disabled = true;
            // record question start time
            trivia.questionStart = Date.now();
        }

        function selectTriviaOption(index, element) {
            // Remove previous selection
            document.querySelectorAll('#trivia-options .trivia-option').forEach(opt => {
                opt.classList.remove('selected');
            });

            // Select new option
            element.classList.add('selected');
            gameState.trivia.selectedAnswer = index;
        }

        function submitTriviaAnswer() {
            if (gameState.trivia.selectedAnswer === null) return;

            const trivia = gameState.trivia;
            const questions = trivia.currentGameQuestions || [];
            const question = questions[trivia.currentQuestion];
            const isCorrect = trivia.selectedAnswer === question.correct;

            // Show correct/incorrect styling and disable options
            const options = document.querySelectorAll('#trivia-options .trivia-option');
            options.forEach((opt, index) => {
                if (index === question.correct) opt.classList.add('correct');
                else if (index === trivia.selectedAnswer && !isCorrect) opt.classList.add('incorrect');
                opt.onclick = null;
            });

            if (isCorrect) {
                trivia.correctAnswers++;
                trivia.score += trivia.difficulty === 'hard' ? 15 : trivia.difficulty === 'medium' ? 10 : 5;
                showFeedback('trivia', '‚úÖ Correct!', 'correct');
                try {
                    const user = JSON.parse(localStorage.getItem('burbleUser') || 'null');
                    const time = trivia.questionStart ? ((Date.now() - trivia.questionStart) / 1000) : 0;
                    if (user && user.username) recordCorrect(user.username, time);
                } catch (e) {}
            } else {
                showFeedback('trivia', `‚ùå Incorrect. The correct answer was: ${question.options[question.correct]}`, 'incorrect');
                try { const user = JSON.parse(localStorage.getItem('burbleUser') || 'null'); if (user && user.username) recordIncorrect(user.username); } catch (e) {}
            }

            trivia.currentQuestion++;
            document.getElementById('trivia-submit').disabled = true;
            document.getElementById('trivia-next').disabled = false;
            updateTriviaDisplay();
        }

        function nextTriviaQuestion() {
            if (gameState.trivia.currentQuestion >= gameState.trivia.totalQuestions) {
                endTriviaGame();
            } else {
                showTriviaQuestion();
                document.getElementById('trivia-feedback').innerHTML = '';
            }
        }

        function endTriviaGame() {
            const trivia = gameState.trivia;
            trivia.gameActive = false;
            stopTimer('trivia');

            // Stop configured audio
            try { if (window.audioControls && window.audioControls.stop) window.audioControls.stop(); } catch (e) {}

            const percentage = Math.round((trivia.correctAnswers / trivia.totalQuestions) * 100);
            const won = percentage >= 70;

            addGameResult(won, trivia.score);

            document.getElementById('trivia-question-text').textContent = 'Quiz Complete!';
            document.getElementById('trivia-options').innerHTML = '';

            document.getElementById('trivia-game-over').innerHTML = `
                <div class="game-over ${won ? 'win' : 'lose'}">
                    <h3>${won ? 'üéâ Great Job!' : 'üìö Keep Studying!'}</h3>
                    <p><strong>Score:</strong> ${trivia.score} points</p>
                    <p><strong>Correct:</strong> ${trivia.correctAnswers}/${trivia.totalQuestions} (${percentage}%)</p>
                    <p><strong>Time:</strong> ${document.getElementById('trivia-timer').textContent}</p>
                    ${won ? '<p>Excellent knowledge!</p>' : '<p>Try again to improve your score!</p>'}
                </div>
            `;

            document.getElementById('trivia-start').disabled = false;
            document.getElementById('trivia-submit').disabled = true;
            document.getElementById('trivia-next').disabled = true;
        }

        function updateTriviaDisplay() {
            const trivia = gameState.trivia;
            const total = trivia.totalQuestionsUsed || Math.min(trivia.totalQuestions, (trivia.pool || []).length || 0);
            document.getElementById('trivia-question-num').textContent = `${trivia.currentQuestion}/${total}`;
            document.getElementById('trivia-correct').textContent = trivia.correctAnswers;
            document.getElementById('trivia-score').textContent = trivia.score;
        }

        // ANIMAL TRIVIA GAME
        function initAnimalTriviaGame() {
            // Difficulty selectors
            document.querySelectorAll('#animal-trivia-page .selector-btn[data-difficulty]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#animal-trivia-page .selector-btn[data-difficulty]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                });
            });

            // Game buttons
            document.getElementById('animal-start').addEventListener('click', startAnimalTriviaGame);
            document.getElementById('animal-submit').addEventListener('click', submitAnimalTriviaAnswer);
            document.getElementById('animal-next').addEventListener('click', nextAnimalTriviaQuestion);
        }

        function startAnimalTriviaGame() {
            const animalTrivia = gameState.animalTrivia;

            // Reset game state
            animalTrivia.currentQuestion = 0;
            animalTrivia.correctAnswers = 0;
            animalTrivia.score = 0;
            animalTrivia.gameActive = true;
            animalTrivia.selectedAnswer = null;

            // Use rotating persistent pool to draw 15 unique questions per run
            const allQuestions = (window.animalTriviaQuestions && animalTriviaQuestions[animalTrivia.difficulty]) || [];
            // If fewer than requested, draw as many as available
            animalTrivia.currentGameQuestions = drawFromPool('animal', animalTrivia.difficulty, allQuestions, animalTrivia.totalQuestions);
            animalTrivia.totalQuestionsUsed = animalTrivia.currentGameQuestions.length;

            // Start timer
            startTimer('animalTrivia');

            // Play configured audio for Animal Trivia
            try { if (window.playModeAudio) window.playModeAudio('animal'); } catch (e) {}

            // Show first question
            showAnimalTriviaQuestion();

            // Update buttons
            document.getElementById('animal-start').disabled = true;
            document.getElementById('animal-submit').disabled = false;

            updateAnimalTriviaDisplay();
        }

        function showAnimalTriviaQuestion() {
            const animalTrivia = gameState.animalTrivia;
            const questions = animalTrivia.currentGameQuestions || [];

            if (animalTrivia.currentQuestion >= (animalTrivia.totalQuestionsUsed || questions.length) || animalTrivia.currentQuestion >= questions.length) {
                endAnimalTriviaGame();
                return;
            }

            const question = questions[animalTrivia.currentQuestion];
            
            document.getElementById('animal-question-text').textContent = question.question;
            
            const optionsContainer = document.getElementById('animal-options');
            optionsContainer.innerHTML = '';
            
            question.options.forEach((option, index) => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'trivia-option';
                optionDiv.textContent = option;
                optionDiv.onclick = () => selectAnimalTriviaOption(index, optionDiv);
                optionsContainer.appendChild(optionDiv);
            });
            
            animalTrivia.selectedAnswer = null;
            document.getElementById('animal-submit').disabled = false;
            document.getElementById('animal-next').disabled = true;
        }

        function selectAnimalTriviaOption(index, element) {
            // Remove previous selection
            document.querySelectorAll('#animal-options .trivia-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            
            // Select new option
            element.classList.add('selected');
            gameState.animalTrivia.selectedAnswer = index;
        }

        function submitAnimalTriviaAnswer() {
            if (gameState.animalTrivia.selectedAnswer === null) return;
            const animalTrivia = gameState.animalTrivia;
            const questions = animalTrivia.currentGameQuestions || [];
            const question = questions[animalTrivia.currentQuestion];
            const isCorrect = animalTrivia.selectedAnswer === question.correct;
            
            // Show correct/incorrect styling
            const options = document.querySelectorAll('#animal-options .trivia-option');
            options.forEach((opt, index) => {
                if (index === question.correct) {
                    opt.classList.add('correct');
                } else if (index === animalTrivia.selectedAnswer && !isCorrect) {
                    opt.classList.add('incorrect');
                }
                opt.onclick = null; // Disable clicking
            });
            
            if (isCorrect) {
                animalTrivia.correctAnswers++;
                animalTrivia.score += animalTrivia.difficulty === 'hard' ? 15 : animalTrivia.difficulty === 'medium' ? 10 : 5;
                showFeedback('animal', '‚úÖ Correct!', 'correct');
                try { const user = JSON.parse(localStorage.getItem('burbleUser') || 'null'); if (user && user.username) recordCorrect(user.username, 0); } catch (e) {}
            } else {
                showFeedback('animal', `‚ùå Incorrect. The correct answer was: ${question.options[question.correct]}`, 'incorrect');
                try { const user = JSON.parse(localStorage.getItem('burbleUser') || 'null'); if (user && user.username) recordIncorrect(user.username); } catch (e) {}
            }
            
            animalTrivia.currentQuestion++;
            
            document.getElementById('animal-submit').disabled = true;
            document.getElementById('animal-next').disabled = false;
            
            updateAnimalTriviaDisplay();
        }

        function nextAnimalTriviaQuestion() {
            if (gameState.animalTrivia.currentQuestion >= (gameState.animalTrivia.totalQuestionsUsed || gameState.animalTrivia.totalQuestions)) {
                endAnimalTriviaGame();
            } else {
                showAnimalTriviaQuestion();
                document.getElementById('animal-feedback').innerHTML = '';
            }
        }

        function endAnimalTriviaGame() {
            const animalTrivia = gameState.animalTrivia;
            animalTrivia.gameActive = false;
            stopTimer('animalTrivia');

            // Stop configured audio for Animal Trivia
            try { if (window.audioControls && window.audioControls.stop) window.audioControls.stop(); } catch (e) {}

            const totalUsed = animalTrivia.totalQuestionsUsed || animalTrivia.totalQuestions || 0;
            const percentage = totalUsed > 0 ? Math.round((animalTrivia.correctAnswers / totalUsed) * 100) : 0;
            const won = percentage >= 70;

            addGameResult(won, animalTrivia.score);

            document.getElementById('animal-question-text').textContent = 'Quiz Complete!';
            document.getElementById('animal-options').innerHTML = '';

            document.getElementById('animal-game-over').innerHTML = `
                <div class="game-over ${won ? 'win' : 'lose'}">
                    <h3>${won ? 'ü¶Å Animal Expert!' : 'üêæ Keep Learning!'}</h3>
                    <p><strong>Score:</strong> ${animalTrivia.score} points</p>
                    <p><strong>Correct:</strong> ${animalTrivia.correctAnswers}/${totalUsed} (${percentage}%)</p>
                    <p><strong>Time:</strong> ${document.getElementById('animal-timer').textContent}</p>
                    ${won ? '<p>You know your animals!</p>' : '<p>Study more about animals and try again!</p>'}
                </div>
            `;

            document.getElementById('animal-start').disabled = false;
            document.getElementById('animal-submit').disabled = true;
            document.getElementById('animal-next').disabled = true;
        }

        function updateAnimalTriviaDisplay() {
            const animalTrivia = gameState.animalTrivia;
            const total = animalTrivia.totalQuestionsUsed || animalTrivia.totalQuestions || 0;
            document.getElementById('animal-question-num').textContent = `${animalTrivia.currentQuestion}/${total}`;
            document.getElementById('animal-correct').textContent = animalTrivia.correctAnswers;
            document.getElementById('animal-score').textContent = animalTrivia.score;
        }

        // (Removed duplicated/malformed DOMContentLoaded + auth block; the later correct initialization remains.)

        function handleEmojiIncorrect() {
            showFeedback('emoji', '‚ùå Incorrect! Try again or get a hint.', 'incorrect');
            try { const user = JSON.parse(localStorage.getItem('burbleUser') || 'null'); if (user && user.username) recordIncorrect(user.username); } catch (e) {}
        }

        function getEmojiHint() {
            if (!gameState.emoji.gameActive) return;
            
            const emoji = gameState.emoji;
            emoji.hintsUsed++;
            
            showFeedback('emoji', `üí° Hint: ${emoji.currentPuzzle.hint} (-5 points)`, 'hint');
            updateEmojiDisplay();
        }

        function updateEmojiDisplay() {
            const emoji = gameState.emoji;
            
            document.getElementById('emoji-score').textContent = emoji.score;
            document.getElementById('emoji-hints').textContent = emoji.hintsUsed;
            document.getElementById('emoji-category').textContent = emoji.category.charAt(0).toUpperCase() + emoji.category.slice(1);
            document.getElementById('emoji-difficulty').textContent = emoji.difficulty.charAt(0).toUpperCase() + emoji.difficulty.slice(1);
            
            if (emoji.currentPuzzle && emoji.gameActive) {
                document.getElementById('emoji-display').textContent = emoji.currentPuzzle.emoji;
            } else if (emoji.currentPuzzle && !emoji.gameActive) {
                document.getElementById('emoji-display').textContent = emoji.currentPuzzle.emoji;
            } else {
                document.getElementById('emoji-display').textContent = 'Click "New Puzzle" to start!';
            }
        }

        function disableEmojiInputs() {
            document.getElementById('emoji-input').disabled = true;
            document.getElementById('emoji-submit').disabled = true;
            document.getElementById('emoji-hint').disabled = true;
        }

        // TWENTY QUESTIONS GAME
        function nextRiddle() {
            setValentineQuestions();
        }

        function setValentineQuestions() {
            switch (gameState.valentine.difficulty) {
                case 'easy':
                    gameState.valentine.questionsLeft = 8;
                    break;
                case 'medium':
                    gameState.valentine.questionsLeft = 6;
                    break;
                case 'hard':
                    gameState.valentine.questionsLeft = 4;
                    break;
            }
        }

        function startValentineGame() {
            const valentine = gameState.valentine;
            
            // Reset game state
            valentine.questions = [];
            valentine.answers = [];
            valentine.guessesLeft = 3;
            valentine.gameActive = true;
            valentine.score = 0;
            setValentineQuestions();
            
            // Select random answer
            const categoryAnswers = valentineAnswers[valentine.category];
            valentine.currentAnswer = categoryAnswers[Math.floor(Math.random() * categoryAnswers.length)].answer;
            
            // Enable inputs
            document.getElementById('valentine-question').disabled = false;
            document.getElementById('valentine-ask').disabled = false;
            document.getElementById('valentine-guess').disabled = false;
            document.getElementById('valentine-question').focus();
            
            // Clear history
            document.getElementById('valentine-history').innerHTML = '<p class="muted-center">Ask yes/no questions to figure out what I\'m thinking of!</p>';
            
            updateValentineDisplay();
            showFeedback('valentine', `I'm thinking of something in the ${valentine.category} category. Ask yes/no questions!`, 'info');
            // Play configured audio for Valentine (Twenty Questions)
            try { if (window.playModeAudio) window.playModeAudio('valentine'); } catch (e) {}
        }

        function askValentineQuestion() {
            if (!gameState.valentine.gameActive) return;
            
            const question = document.getElementById('valentine-question').value.trim();
            if (!question) return;
            
            const valentine = gameState.valentine;
            valentine.questionsLeft--;
            valentine.questions.push(question);
            
            // Generate AI-like response
            const answer = generateValentineAnswer(question, valentine.currentAnswer);
            valentine.answers.push(answer);
            
            // Update history
            updateValentineHistory();
            
            document.getElementById('valentine-question').value = '';
            updateValentineDisplay();
            
            if (valentine.questionsLeft === 0) {
                showFeedback('valentine', 'No more questions! You must make a guess now.', 'hint');
                document.getElementById('valentine-ask').disabled = true;
                document.getElementById('valentine-question').disabled = true;
            }
        }

        function generateValentineAnswer(question, answer) {
            const q = question.toLowerCase();
            const a = answer.toLowerCase();
            
            // Simple keyword matching for basic responses
            if (q.includes('alive') || q.includes('living')) {
                return gameState.valentine.category === 'animals' ? 'Yes' : 'No';
            }
            if (q.includes('animal')) {
                return gameState.valentine.category === 'animals' ? 'Yes' : 'No';
            }
            if (q.includes('place') || q.includes('location')) {
                return gameState.valentine.category === 'places' ? 'Yes' : 'No';
            }
            if (q.includes('movie') || q.includes('film')) {
                return gameState.valentine.category === 'movies' ? 'Yes' : 'No';
            }
            if (q.includes('object') || q.includes('thing')) {
                return gameState.valentine.category === 'objects' ? 'Yes' : 'No';
            }
            if (q.includes('big') || q.includes('large')) {
                return ['elephant', 'giraffe', 'whale', 'titanic', 'avatar'].some(word => a.includes(word)) ? 'Yes' : 'No';
            }
            if (q.includes('small')) {
                return ['phone', 'key', 'watch'].some(word => a.includes(word)) ? 'Yes' : 'No';
            }
            if (q.includes('water')) {
                return ['dolphin', 'titanic', 'sydney', 'paris'].some(word => a.includes(word)) ? 'Yes' : 'No';
            }
            if (q.includes('fly') || q.includes('flight')) {
                return ['penguin', 'avatar'].some(word => a.includes(word)) ? 'Yes' : 'No';
            }
            
            // Random yes/no for other questions
            return Math.random() > 0.5 ? 'Yes' : 'No';
        }

        function makeValentineGuess() {
            if (!gameState.valentine.gameActive) return;
            
            const guess = prompt('What do you think I\'m thinking of?');
            if (!guess) return;
            
            const valentine = gameState.valentine;
            valentine.guessesLeft--;
            
            if (guess.toLowerCase() === valentine.currentAnswer.toLowerCase()) {
                handleValentineWin();
            } else {
                if (valentine.guessesLeft === 0) {
                    handleValentineLose();
                } else {
                    showFeedback('valentine', `‚ùå Not quite! You have ${valentine.guessesLeft} guess(es) left.`, 'incorrect');
                    updateValentineDisplay();
                }
            }
        }

        function handleValentineWin() {
            const valentine = gameState.valentine;
            valentine.gameActive = false;
            
            const baseScore = 100;
            const questionBonus = valentine.questionsLeft * 10;
            const guessBonus = valentine.guessesLeft * 20;
            valentine.score = baseScore + questionBonus + guessBonus;
            
            addGameResult(true, valentine.score);
            
            showFeedback('valentine', `üéâ Correct! I was thinking of "${valentine.currentAnswer}"`, 'correct');
            
            document.getElementById('valentine-game-over').innerHTML = `
                <div class="game-over win">
                    <h3>üéâ Amazing!</h3>
                    <p>You guessed "${valentine.currentAnswer}" correctly!</p>
                    <p><strong>Score:</strong> ${valentine.score} points</p>
                    <p><strong>Questions used:</strong> ${valentine.questions.length}</p>
                    <p><strong>Guesses remaining:</strong> ${valentine.guessesLeft}</p>
                </div>
            `;
            
            disableValentineInputs();
            try { if (window.audioControls && window.audioControls.stop) window.audioControls.stop(); } catch (e) {}
            try { const user = JSON.parse(localStorage.getItem('burbleUser') || 'null'); if (user && user.username) recordCorrect(user.username, 0); } catch (e) {}
        }

        function handleValentineLose() {
            const valentine = gameState.valentine;
            valentine.gameActive = false;
            
            addGameResult(false, 0);
            
            showFeedback('valentine', `üòî The answer was "${valentine.currentAnswer}". Better luck next time!`, 'incorrect');
            
            document.getElementById('valentine-game-over').innerHTML = `
                <div class="game-over lose">
                    <h3>üòî Game Over</h3>
                    <p>I was thinking of: <strong>"${valentine.currentAnswer}"</strong></p>
                    <p>Category: ${valentine.category}</p>
                    <p>You asked ${valentine.questions.length} questions</p>
                </div>
            `;
            
            disableValentineInputs();
            try { if (window.audioControls && window.audioControls.stop) window.audioControls.stop(); } catch (e) {}
            try { const user = JSON.parse(localStorage.getItem('burbleUser') || 'null'); if (user && user.username) recordIncorrect(user.username); } catch (e) {}
        }

        function updateValentineHistory() {
            const valentine = gameState.valentine;
            const history = document.getElementById('valentine-history');
            
            let historyHTML = '';
            for (let i = 0; i < valentine.questions.length; i++) {
                historyHTML += `
                    <div class="question-item">
                        <div class="question-text">Q: ${valentine.questions[i]}</div>
                        <div class="answer-text">A: ${valentine.answers[i]}</div>
                    </div>
                `;
            }
            
            history.innerHTML = historyHTML || '<p class="muted-center">Ask yes/no questions to figure out what I\'m thinking of!</p>';
        }

        function updateValentineDisplay() {
            const valentine = gameState.valentine;
            
            document.getElementById('valentine-questions').textContent = valentine.questionsLeft;
            document.getElementById('valentine-guesses').textContent = valentine.guessesLeft;
            document.getElementById('valentine-category').textContent = valentine.category.charAt(0).toUpperCase() + valentine.category.slice(1);
            document.getElementById('valentine-score').textContent = valentine.score;
        }

        function disableValentineInputs() {
            document.getElementById('valentine-question').disabled = true;
            document.getElementById('valentine-ask').disabled = true;
            document.getElementById('valentine-guess').disabled = true;
        }

        // TRIVIA GAME
        function initTriviaGame() {
            // Difficulty selectors
            document.querySelectorAll('#trivia-page .selector-btn[data-difficulty]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#trivia-page .selector-btn[data-difficulty]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    gameState.trivia.difficulty = btn.dataset.difficulty;
                });
            });

            // Game buttons
            document.getElementById('trivia-start').addEventListener('click', startTriviaGame);
            document.getElementById('trivia-submit').addEventListener('click', submitTriviaAnswer);
            document.getElementById('trivia-next').addEventListener('click', nextTriviaQuestion);
        }

        

        function showTriviaQuestion() {
            const trivia = gameState.trivia;
            const questions = trivia.currentGameQuestions || [];

            if (trivia.currentQuestion >= trivia.totalQuestionsUsed || trivia.currentQuestion >= questions.length) {
                endTriviaGame();
                return;
            }

            const question = questions[trivia.currentQuestion];
            
            document.getElementById('trivia-question-text').textContent = question.question;
            
            const optionsContainer = document.getElementById('trivia-options');
            optionsContainer.innerHTML = '';
            
            question.options.forEach((option, index) => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'trivia-option';
                optionDiv.textContent = option;
                optionDiv.onclick = () => selectTriviaOption(index, optionDiv);
                optionsContainer.appendChild(optionDiv);
            });
            
            trivia.selectedAnswer = null;
            document.getElementById('trivia-submit').disabled = false;
            document.getElementById('trivia-next').disabled = true;
            // record question start time
            trivia.questionStart = Date.now();
        }

        function selectTriviaOption(index, element) {
            // Remove previous selection
            document.querySelectorAll('#trivia-options .trivia-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            
            // Select new option
            element.classList.add('selected');
            gameState.trivia.selectedAnswer = index;
        }

        function submitTriviaAnswer() {
            if (gameState.trivia.selectedAnswer === null) return;
            
            const trivia = gameState.trivia;
            const questions = trivia.currentGameQuestions || [];
            const question = questions[trivia.currentQuestion];
            const isCorrect = trivia.selectedAnswer === question.correct;
            
            // Show correct/incorrect styling
            const options = document.querySelectorAll('#trivia-options .trivia-option');
            options.forEach((opt, index) => {
                if (index === question.correct) {
                    opt.classList.add('correct');
                } else if (index === trivia.selectedAnswer && !isCorrect) {
                    opt.classList.add('incorrect');
                }
                opt.onclick = null; // Disable clicking
            });
            
            if (isCorrect) {
                trivia.correctAnswers++;
                trivia.score += trivia.difficulty === 'hard' ? 15 : trivia.difficulty === 'medium' ? 10 : 5;
                showFeedback('trivia', '‚úÖ Correct!', 'correct');
                try {
                    const user = JSON.parse(localStorage.getItem('burbleUser') || 'null');
                    const time = trivia.questionStart ? ((Date.now() - trivia.questionStart) / 1000) : 0;
                    if (user && user.username) recordCorrect(user.username, time);
                } catch (e) {}
            } else {
                showFeedback('trivia', `‚ùå Incorrect. The correct answer was: ${question.options[question.correct]}`, 'incorrect');
                try { const user = JSON.parse(localStorage.getItem('burbleUser') || 'null'); if (user && user.username) recordIncorrect(user.username); } catch (e) {}
            }
            
            trivia.currentQuestion++;
            
            document.getElementById('trivia-submit').disabled = true;
            document.getElementById('trivia-next').disabled = false;
            
            updateTriviaDisplay();
        }

        function nextTriviaQuestion() {
            if (gameState.trivia.currentQuestion >= gameState.trivia.totalQuestions) {
                endTriviaGame();
            } else {
                showTriviaQuestion();
                document.getElementById('trivia-feedback').innerHTML = '';
            }
        }

        function endTriviaGame() {
            const trivia = gameState.trivia;
            trivia.gameActive = false;
            stopTimer('trivia');

            // Stop configured audio
            try { if (window.audioControls && window.audioControls.stop) window.audioControls.stop(); } catch (e) {}
            
            const percentage = Math.round((trivia.correctAnswers / trivia.totalQuestions) * 100);
            const won = percentage >= 70;
            
            addGameResult(won, trivia.score);
            
            document.getElementById('trivia-question-text').textContent = 'Quiz Complete!';
            document.getElementById('trivia-options').innerHTML = '';
            
            document.getElementById('trivia-game-over').innerHTML = `
                <div class="game-over ${won ? 'win' : 'lose'}">
                    <h3>${won ? 'üéâ Great Job!' : 'üìö Keep Studying!'}</h3>
                    <p><strong>Score:</strong> ${trivia.score} points</p>
                    <p><strong>Correct:</strong> ${trivia.correctAnswers}/${trivia.totalQuestions} (${percentage}%)</p>
                    <p><strong>Time:</strong> ${document.getElementById('trivia-timer').textContent}</p>
                    ${won ? '<p>Excellent knowledge!</p>' : '<p>Try again to improve your score!</p>'}
                </div>
            `;
            
            document.getElementById('trivia-start').disabled = false;
            document.getElementById('trivia-submit').disabled = true;
            document.getElementById('trivia-next').disabled = true;
        }

        function updateTriviaDisplay() {
            const trivia = gameState.trivia;

            const total = trivia.totalQuestionsUsed || Math.min(trivia.totalQuestions, (trivia.pool || []).length || 0);
            document.getElementById('trivia-question-num').textContent = `${trivia.currentQuestion}/${total}`;
            document.getElementById('trivia-correct').textContent = trivia.correctAnswers;
            document.getElementById('trivia-score').textContent = trivia.score;
        }

        function startTriviaGame() {
            const trivia = gameState.trivia;

            // Reset game state
            trivia.currentQuestion = 0;
            trivia.correctAnswers = 0;
            trivia.score = 0;
            trivia.gameActive = true;
            trivia.selectedAnswer = null;

            // Ensure persistent pools exist
            if (!gameState.trivia.pools) gameState.trivia.pools = {};
            const key = `trivia|${trivia.difficulty}`;
            if (!gameState.trivia.pools[key] || gameState.trivia.pools[key].length === 0) {
                const allQuestions = triviaQuestions[trivia.difficulty] || [];
                gameState.trivia.pools[key] = shuffleArray(allQuestions);
            }

            // Take questions for this run (consume from pool)
            const take = Math.min(trivia.totalQuestions, (gameState.trivia.pools[key] || []).length);
            const allQ = (window.triviaQuestions && triviaQuestions[trivia.difficulty]) || [];
            trivia.currentGameQuestions = drawFromPool('trivia', trivia.difficulty, allQ, take);
            try { savePoolsToStorage(); } catch (e) {}
            trivia.totalQuestionsUsed = trivia.currentGameQuestions.length;

            // Start timer
            startTimer('trivia');

            // Play configured audio for Trivia
            try { if (window.playModeAudio) window.playModeAudio('trivia'); } catch (e) {}

            // Show first question
            showTriviaQuestion();

            // Update buttons
            document.getElementById('trivia-start').disabled = true;
            document.getElementById('trivia-submit').disabled = false;

            updateTriviaDisplay();
        }

        // ANIMAL TRIVIA GAME
        function initAnimalTriviaGame() {
            // Difficulty selectors
            document.querySelectorAll('#animal-trivia-page .selector-btn[data-difficulty]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#animal-trivia-page .selector-btn[data-difficulty]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                });
            });

            // Game buttons
            document.getElementById('animal-start').addEventListener('click', startAnimalTriviaGame);
            document.getElementById('animal-submit').addEventListener('click', submitAnimalTriviaAnswer);
            document.getElementById('animal-next').addEventListener('click', nextAnimalTriviaQuestion);
        }

        function startAnimalTriviaGame() {
            const animalTrivia = gameState.animalTrivia;

            // Reset game state
            animalTrivia.currentQuestion = 0;
            animalTrivia.correctAnswers = 0;
            animalTrivia.score = 0;
            animalTrivia.gameActive = true;
            animalTrivia.selectedAnswer = null;

            // Always clear and reshuffle the pool for a fresh game
            if (!gameState.animalTrivia.pools) gameState.animalTrivia.pools = {};
            const key = `animal|${animalTrivia.difficulty}`;
            const allQuestions = animalTriviaQuestions[animalTrivia.difficulty] || [];
            gameState.animalTrivia.pools[key] = shuffleArray(allQuestions);
            savePoolsToStorage();

            // Take questions for this run (consume from rotating pool)
            const take = Math.min(animalTrivia.totalQuestions, (gameState.animalTrivia.pools[key] || []).length);
            const allQ = (window.animalTriviaQuestions && animalTriviaQuestions[animalTrivia.difficulty]) || [];
            animalTrivia.currentGameQuestions = drawFromPool('animal', animalTrivia.difficulty, allQ, take);
            try { savePoolsToStorage(); } catch (e) {}
            animalTrivia.totalQuestionsUsed = animalTrivia.currentGameQuestions.length;

            // Start timer
            startTimer('animalTrivia');

            // Play configured audio for Animal Trivia
            try { if (window.playModeAudio) window.playModeAudio('animal'); } catch (e) {}

            // Show first question
            showAnimalTriviaQuestion();

            // Update buttons
            document.getElementById('animal-start').disabled = true;
            document.getElementById('animal-submit').disabled = false;

            updateAnimalTriviaDisplay();
        }

        function showAnimalTriviaQuestion() {
            const animalTrivia = gameState.animalTrivia;
            const questions = animalTrivia.currentGameQuestions || [];

            if (animalTrivia.currentQuestion >= (animalTrivia.totalQuestionsUsed || questions.length) || animalTrivia.currentQuestion >= questions.length) {
                endAnimalTriviaGame();
                return;
            }

            const question = questions[animalTrivia.currentQuestion];
            
            document.getElementById('animal-question-text').textContent = question.question;
            
            const optionsContainer = document.getElementById('animal-options');
            optionsContainer.innerHTML = '';
            
            question.options.forEach((option, index) => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'trivia-option';
                optionDiv.textContent = option;
                optionDiv.onclick = () => selectAnimalTriviaOption(index, optionDiv);
                optionsContainer.appendChild(optionDiv);
            });
            
            animalTrivia.selectedAnswer = null;
            document.getElementById('animal-submit').disabled = false;
            document.getElementById('animal-next').disabled = true;
        }

        function selectAnimalTriviaOption(index, element) {
            // Remove previous selection
            document.querySelectorAll('#animal-options .trivia-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            
            // Select new option
            element.classList.add('selected');
            gameState.animalTrivia.selectedAnswer = index;
        }

        function submitAnimalTriviaAnswer() {
            if (gameState.animalTrivia.selectedAnswer === null) return;
            const animalTrivia = gameState.animalTrivia;
            const questions = animalTrivia.currentGameQuestions || [];
            const question = questions[animalTrivia.currentQuestion];
            const isCorrect = animalTrivia.selectedAnswer === question.correct;
            
            // Show correct/incorrect styling
            const options = document.querySelectorAll('#animal-options .trivia-option');
            options.forEach((opt, index) => {
                if (index === question.correct) {
                    opt.classList.add('correct');
                } else if (index === animalTrivia.selectedAnswer && !isCorrect) {
                    opt.classList.add('incorrect');
                }
                opt.onclick = null; // Disable clicking
            });
            
            if (isCorrect) {
                animalTrivia.correctAnswers++;
                animalTrivia.score += animalTrivia.difficulty === 'hard' ? 15 : animalTrivia.difficulty === 'medium' ? 10 : 5;
                showFeedback('animal', '‚úÖ Correct!', 'correct');
                try { const user = JSON.parse(localStorage.getItem('burbleUser') || 'null'); if (user && user.username) recordCorrect(user.username, 0); } catch (e) {}
            } else {
                showFeedback('animal', `‚ùå Incorrect. The correct answer was: ${question.options[question.correct]}`, 'incorrect');
                try { const user = JSON.parse(localStorage.getItem('burbleUser') || 'null'); if (user && user.username) recordIncorrect(user.username); } catch (e) {}
            }
            
            animalTrivia.currentQuestion++;
            
            document.getElementById('animal-submit').disabled = true;
            document.getElementById('animal-next').disabled = false;
            
            updateAnimalTriviaDisplay();
        }

        function nextAnimalTriviaQuestion() {
            if (gameState.animalTrivia.currentQuestion >= (gameState.animalTrivia.totalQuestionsUsed || gameState.animalTrivia.totalQuestions)) {
                endAnimalTriviaGame();
            } else {
                showAnimalTriviaQuestion();
                document.getElementById('animal-feedback').innerHTML = '';
            }
        }

        function endAnimalTriviaGame() {
            const animalTrivia = gameState.animalTrivia;
            animalTrivia.gameActive = false;
            stopTimer('animalTrivia');

            // Stop configured audio for Animal Trivia
            try { if (window.audioControls && window.audioControls.stop) window.audioControls.stop(); } catch (e) {}

            const totalUsed = animalTrivia.totalQuestionsUsed || animalTrivia.totalQuestions || 0;
            const percentage = totalUsed > 0 ? Math.round((animalTrivia.correctAnswers / totalUsed) * 100) : 0;
            const won = percentage >= 70;

            addGameResult(won, animalTrivia.score);

            document.getElementById('animal-question-text').textContent = 'Quiz Complete!';
            document.getElementById('animal-options').innerHTML = '';

            document.getElementById('animal-game-over').innerHTML = `
                <div class="game-over ${won ? 'win' : 'lose'}">
                    <h3>${won ? 'ü¶Å Animal Expert!' : 'üêæ Keep Learning!'}</h3>
                    <p><strong>Score:</strong> ${animalTrivia.score} points</p>
                    <p><strong>Correct:</strong> ${animalTrivia.correctAnswers}/${totalUsed} (${percentage}%)</p>
                    <p><strong>Time:</strong> ${document.getElementById('animal-timer').textContent}</p>
                    ${won ? '<p>You know your animals!</p>' : '<p>Study more about animals and try again!</p>'}
                </div>
            `;

            document.getElementById('animal-start').disabled = false;
            document.getElementById('animal-submit').disabled = true;
            document.getElementById('animal-next').disabled = true;
        }

        function updateAnimalTriviaDisplay() {
            const animalTrivia = gameState.animalTrivia;
            const total = animalTrivia.totalQuestionsUsed || animalTrivia.totalQuestions || 0;
            document.getElementById('animal-question-num').textContent = `${animalTrivia.currentQuestion}/${total}`;
            document.getElementById('animal-correct').textContent = animalTrivia.correctAnswers;
            document.getElementById('animal-score').textContent = animalTrivia.score;
        }

        // Add a button to reset the animal trivia pool
        window.addEventListener('DOMContentLoaded', () => {
            loadUserStats();
            initRiddlesGame();
            initBurbleGame();
            initEmojiGame();
            initValentineGame();
            initTriviaGame();
            initAnimalTriviaGame();
            // Ensure animal trivia banks have at least 15 items per difficulty
            try { ensureAnimalBanks(15); } catch (e) {}
            updateUserStats();
            initAuthAndLeaderboard();
            // init pool manager UI
            try { if (typeof isAdmin === 'function' ? isAdmin() : false) { initPoolManager(); } } catch (e) {}

            // Start periodic pool rotation every 30 minutes to reshuffle persistent pools
            try { schedulePoolRotation(30); } catch (e) { console.error('failed to schedule pool rotation', e); }

            // Add reset button to animal trivia page
            const animalPage = document.getElementById('animal-trivia-page');
            if (animalPage && !document.getElementById('reset-animal-pool')) {
                const resetBtn = document.createElement('button');
                resetBtn.id = 'reset-animal-pool';
                resetBtn.textContent = 'Reset Animal Trivia Pool';
                resetBtn.className = 'nav-btn';
                resetBtn.style.margin = '12px 0';
                resetBtn.onclick = () => {
                    if (confirm('Reset the animal trivia question pool? This will reshuffle and use all available questions.')) {
                        if (gameState.animalTrivia && gameState.animalTrivia.pools) {
                            const key = `animal|${gameState.animalTrivia.difficulty}`;
                            const allQuestions = animalTriviaQuestions[gameState.animalTrivia.difficulty] || [];
                            gameState.animalTrivia.pools[key] = shuffleArray(allQuestions);
                            savePoolsToStorage();
                            alert('Animal trivia pool reset! Start a new game to see changes.');
                        }
                    }
                };
                animalPage.insertBefore(resetBtn, animalPage.firstChild);
            }

            // Build-Your-Own-Quiz wiring
            try {
                const parseBtn = document.getElementById('build-quiz-parse');
                const startBtn = document.getElementById('build-quiz-start');
                const textarea = document.getElementById('build-quiz-input');
                const fileInput = document.getElementById('build-quiz-file');
                const preview = document.getElementById('build-quiz-preview');

                function renderPreview(list) {
                    if (!preview) return;
                    if (!list || list.length === 0) { preview.innerHTML = '<div class="muted-center">No questions parsed.</div>'; return; }
                    const html = list.map((q,i)=>`<div class="build-quiz-item"><strong>#${i+1}</strong> ${escapeHtml(q.question)} <div class="muted">Options: ${q.options.map(o=>escapeHtml(o)).join(' | ')}</div></div>`).join('');
                    preview.innerHTML = `<div class="build-quiz-list">${html}</div>`;
                }

                if (parseBtn) parseBtn.addEventListener('click', () => {
                    const text = textarea ? textarea.value : '';
                    const parsed = parseQuizInput(text);
                    window.customQuiz.pool = parsed;
                    renderPreview(parsed);
                    if (startBtn) startBtn.disabled = !(parsed && parsed.length > 0);
                });

                if (startBtn) startBtn.addEventListener('click', () => {
                    const pool = window.customQuiz.pool || [];
                    if (!pool || pool.length === 0) return alert('No questions to start. Please parse or upload a quiz.');
                    // Use the same quiz engine by setting trivia.currentGameQuestions and launching
                    gameState.trivia.currentQuestion = 0;
                    gameState.trivia.correctAnswers = 0;
                    gameState.trivia.score = 0;
                    gameState.trivia.gameActive = true;
                    gameState.trivia.selectedAnswer = null;
                    // convert normalized questions to expected shape
                    gameState.trivia.currentGameQuestions = pool.map(q => ({ question: q.question, options: q.options, correct: q.correct }));
                    gameState.trivia.totalQuestionsUsed = gameState.trivia.currentGameQuestions.length;
                    startTimer('trivia');
                    showPage(null, 'trivia');
                    showTriviaQuestion();
                    document.getElementById('trivia-start').disabled = true;
                    document.getElementById('trivia-submit').disabled = false;
                });

                if (fileInput) fileInput.addEventListener('change', (ev) => {
                    const f = (ev.target.files && ev.target.files[0]);
                    if (!f) return;
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const txt = e.target.result;
                            if (textarea) textarea.value = txt;
                            const parsed = parseQuizInput(txt);
                            window.customQuiz.pool = parsed;
                            renderPreview(parsed);
                            if (startBtn) startBtn.disabled = !(parsed && parsed.length > 0);
                        } catch (e) { alert('Failed to parse file'); }
                    };
                    reader.readAsText(f);
                });
            } catch (e) { /* ignore build quiz wiring errors */ }
        });

        // --- Simple client-side auth & leaderboard ---
        function sanitizeUsername(name) {
            return name.replace(/[^a-zA-Z0-9_\- ]/g, '').trim().slice(0, 30);
        }

        function isProfane(name) {
            if (!name) return false;
            const blocked = ['fuck','shit','bitch','cunt','nigger','faggot','motherfucker'];
            const low = name.toLowerCase();
            return blocked.some(w => low.includes(w));
        }

        function initAuthAndLeaderboard() {
            const signin = document.getElementById('signin-btn');
            const userInfo = document.getElementById('user-info');
            const signout = document.getElementById('signout-btn');
            const emailLink = document.getElementById('user-email-link');

            function renderUser() {
                const user = JSON.parse(localStorage.getItem('burbleUser') || 'null');
                if (user && user.username) {
                    signin.classList.add('hidden');
                    userInfo.classList.remove('hidden');
                    emailLink.textContent = user.username;
                    emailLink.href = 'mailto:' + encodeURIComponent(user.email || '');
                } else {
                    signin.classList.remove('hidden');
                    userInfo.classList.add('hidden');
                }
            }

            // expose for tests and external scripts to trigger UI sync
            try { window.renderUser = renderUser; } catch (e) {}

            // Note: tests should call `window.renderUser()` after setting `burbleUser` in localStorage.

            signin.addEventListener('click', () => {
                // Open the sign-in modal (the modal submit handler will handle registration)
                const modal = document.getElementById('signin-modal');
                if (modal) { modal.classList.remove('hidden'); modal.setAttribute('aria-hidden', 'false'); }
            });

            signout.addEventListener('click', () => {
                localStorage.removeItem('burbleUser');
                renderUser();
            });

            renderUser();
            renderLeaderboard();
        }

        // Settings modal UI (signin modal is defined earlier to avoid duplicates)
        // Only inject settings markup here to avoid creating multiple `#signin-modal` nodes
        document.body.insertAdjacentHTML('beforeend', `
            <div id="settings-modal" class="modal hidden" aria-hidden="true">
                <div class="card">
                    <h3>Settings</h3>
                    <label>Theme</label>
                    <select id="pref-theme">
                        <option value="light">Light</option>
                        <option value="dark">Dark</option>
                    </select>
                    <label>Font size</label>
                    <select id="pref-font">
                        <option value="small">Small</option>
                        <option value="normal">Normal</option>
                        <option value="large">Large</option>
                    </select>
                    <label>Profile banner</label>
                    <input id="pref-banner" type="file" accept="image/*" />
                    <div class="modal-actions mt12">
                        <button id="settings-cancel" class="nav-btn">Close</button>
                        <button id="settings-save" class="nav-btn btn-primary">Save</button>
                    </div>
                    <div id="settings-msg" class="message-error"></div>
                </div>
            </div>
            <div id="settings-gear" class="settings-gear" title="Settings">‚öôÔ∏è</div>
        `);

        // wire modal buttons
        const signinModal = document.getElementById('signin-modal');
        const settingsModal = document.getElementById('settings-modal');
    const signinBtn = document.getElementById('signin-btn');
        const siCancel = document.getElementById('si-cancel');
        const siSubmit = document.getElementById('si-submit');
        const siMsg = document.getElementById('si-msg');
        const settingsGear = document.getElementById('settings-gear');
        const settingsCancel = document.getElementById('settings-cancel');
        const settingsSave = document.getElementById('settings-save');

        if (signinBtn) {
            signinBtn.addEventListener('click', () => { signinModal.classList.remove('hidden'); signinModal.setAttribute('aria-hidden', 'false'); });
        }
        siCancel.addEventListener('click', () => { signinModal.classList.add('hidden'); siMsg.textContent = ''; });

        siSubmit.addEventListener('click', async () => {
            siMsg.textContent = '';
            const username = document.getElementById('si-username').value || '';
            const email = document.getElementById('si-email').value || '';
            try {
                // check username availability via server
                const check = await fetch('http://localhost:4000/api/check-username', { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({ username }) });
                const chk = await check.json();
                if (!chk.ok) { siMsg.textContent = 'Username not available: ' + (chk.reason || ''); return; }
                const reg = await fetch('http://localhost:4000/api/register', { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({ username, email }) });
                const jr = await reg.json();
                if (!reg.ok) { siMsg.textContent = jr.error || 'Registration failed'; return; }
                localStorage.setItem('burbleUser', JSON.stringify({ username: jr.user.username, email: jr.user.email }));
                signinModal.classList.add('hidden'); renderUser(); renderLeaderboard();
            } catch (e) {
                // fallback to local storage registration
                const clean = sanitizeUsername(username);
                if (!clean || isProfane(clean)) { siMsg.textContent = 'Invalid or disallowed username'; return; }
                const existing = JSON.parse(localStorage.getItem('burbleLeaderboard')||'{}');
                if (existing[clean]) { siMsg.textContent = 'Username taken locally'; return; }
                localStorage.setItem('burbleUser', JSON.stringify({ username: clean, email }));
                existing[clean] = { score:0, questionsSolved:0, totalCorrectTime:0, correctCount:0, highestStreak:0 };
                localStorage.setItem('burbleLeaderboard', JSON.stringify(existing));
                signinModal.classList.add('hidden'); renderUser(); renderLeaderboard();
            }
        });

        settingsGear.addEventListener('click', () => { settingsModal.classList.remove('hidden'); settingsModal.setAttribute('aria-hidden','false'); });
        settingsCancel.addEventListener('click', () => { settingsModal.classList.add('hidden'); });
        settingsSave.addEventListener('click', async () => {
            const theme = document.getElementById('pref-theme').value;
            const font = document.getElementById('pref-font').value;
            const bannerInput = document.getElementById('pref-banner');
            const user = JSON.parse(localStorage.getItem('burbleUser') || 'null');
            if (user && user.username && bannerInput.files && bannerInput.files[0]) {
                const f = bannerInput.files[0];
                const fd = new FormData(); fd.append('banner', f); fd.append('username', user.username);
                try {
                    const up = await fetch('http://localhost:4000/api/upload-profile', { method:'POST', body: fd });
                    const ju = await up.json();
                    if (up.ok) {
                        user.banner = ju.url; localStorage.setItem('burbleUser', JSON.stringify(user));
                    }
                } catch (e) { /* ignore */ }
            }
            const prefs = { theme, font };
            if (user && user.username) {
                // save to server prefs if available
                try { await fetch('http://localhost:4000/api/save-prefs', { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({ username: user.username, prefs }) }); } catch (e) {}
            }
            localStorage.setItem('burblePrefs', JSON.stringify(prefs));
            settingsModal.classList.add('hidden');
        });

        function recordCorrect(username, timeTakenSeconds) {
            if (!username) return;
            const lb = JSON.parse(localStorage.getItem('burbleLeaderboard') || '{}');
            if (!lb[username]) lb[username] = { score: 0, questionsSolved: 0, totalCorrectTime: 0, correctCount: 0, highestStreak: 0, currentStreak: 0 };
            lb[username].questionsSolved = (lb[username].questionsSolved || 0) + 1;
            lb[username].totalCorrectTime = (lb[username].totalCorrectTime || 0) + (timeTakenSeconds || 0);
            lb[username].correctCount = (lb[username].correctCount || 0) + 1;
            lb[username].currentStreak = (lb[username].currentStreak || 0) + 1;
            if (lb[username].currentStreak > (lb[username].highestStreak || 0)) lb[username].highestStreak = lb[username].currentStreak;
            // update score simple heuristic
            lb[username].score = (lb[username].score || 0) + 10;
            localStorage.setItem('burbleLeaderboard', JSON.stringify(lb));
        }

        function recordIncorrect(username) {
            if (!username) return;
            const lb = JSON.parse(localStorage.getItem('burbleLeaderboard') || '{}');
            if (!lb[username]) lb[username] = { score: 0, questionsSolved: 0, totalCorrectTime: 0, correctCount: 0, highestStreak: 0, currentStreak: 0 };
            lb[username].currentStreak = 0;
            localStorage.setItem('burbleLeaderboard', JSON.stringify(lb));
        }

        function renderLeaderboard() {
            const tbody = document.getElementById('leaderboard-scores-body');
            const tbodyDetails = document.getElementById('leaderboard-details-body');
            if (!tbody || !tbodyDetails) return;
            const lb = JSON.parse(localStorage.getItem('burbleLeaderboard') || '{}');
            const rows = Object.keys(lb).map(u => ({ username: u, ...lb[u] }));
            // sort by score desc
            rows.sort((a,b) => (b.score || 0) - (a.score || 0));
            tbody.innerHTML = '';
            tbodyDetails.innerHTML = '';
            rows.forEach((r, i) => {
                const tr = document.createElement('tr');
                const rank = i+1;
                tr.innerHTML = `<td class="td-pad">${rank}</td><td class="td-pad">${r.username}</td><td class="td-pad">${r.score || 0}</td>`;
                if (rank <= 3) {
                    tr.classList.add(rank === 1 ? 'rank-1' : rank === 2 ? 'rank-2' : 'rank-3');
                }
                tbody.appendChild(tr);

                const avg = r.correctCount ? ((r.totalCorrectTime || 0) / r.correctCount).toFixed(1) : '‚Äî';
                const tr2 = document.createElement('tr');
                tr2.innerHTML = `<td class="td-pad">${rank}</td><td class="td-pad">${r.username}</td><td class="td-pad">${r.questionsSolved || 0}</td><td class="td-pad">${avg}</td><td class="td-pad">${r.highestStreak || 0}</td>`;
                if (rank <= 3) {
                    tr2.classList.add(rank === 1 ? 'rank-1' : rank === 2 ? 'rank-2' : 'rank-3');
                    tr2.classList.add('details');
                }
                tbodyDetails.appendChild(tr2);
            });
        }

        function showLeaderboardTab(tab) {
            document.getElementById('leaderboard-scores').classList.toggle('hidden', tab !== 'scores');
            document.getElementById('leaderboard-details').classList.toggle('hidden', tab !== 'details');
            document.querySelectorAll('#leaderboard-page .selector-btn').forEach(b => b.classList.toggle('active', b.dataset.tab === tab));
        }

// -----------------------------
// School Trivia (standalone copy)
// -----------------------------
(function(){
    try {
        const questionBank = {
            "School Trivia": {
                Math: {
                    Easy: [
                        { q: "What is 2 + 2?", a: "4" },
                        { q: "How many sides does a square have?", a: "4" },
                        { q: "What is 10 - 3?", a: "7" },
                        { q: "What number comes after 19?", a: "20" },
                        { q: "What is 5 + 6?", a: "11" },
                        { q: "How many legs does a triangle have?", a: "Trick! None. It has sides." },
                        { q: "How many minutes are in an hour?", a: "60" },
                        { q: "What is half of 20?", a: "10" },
                        { q: "What shape is a stop sign?", a: "Octagon" },
                        { q: "What is 3 + 4 + 5?", a: "12" }
                    ],
                    Medium: [
                        { q: "What is 12 √ó 12?", a: "144" },
                        { q: "What is 144 √∑ 12?", a: "12" },
                        { q: "What is 25% of 200?", a: "50" },
                        { q: "Simplify: (3x + 5x)", a: "8x" },
                        { q: "What is the area of a rectangle with length 10 and width 4?", a: "40" },
                        { q: "What is the value of œÄ (approx, 2 decimals)?", a: "3.14" },
                        { q: "What is 2‚Åµ?", a: "32" },
                        { q: "What is the square root of 81?", a: "9" },
                        { q: "Convert 0.75 to a fraction.", a: "3/4" },
                        { q: "Solve: 2x + 6 = 14", a: "x = 4" }
                    ],
                    Hard: [
                        { q: "What is the slope of y = 3x + 7?", a: "3" },
                        { q: "Solve: x¬≤ - 16 = 0", a: "x = 4 or -4" },
                        { q: "What is the quadratic formula?", a: "x = [-b ¬± ‚àö(b¬≤-4ac)] / 2a" },
                        { q: "Derivative of sin(x)?", a: "cos(x)" },
                        { q: "What is the integral of 2x?", a: "x¬≤ + C" },
                        { q: "Simplify: (x+2)(x+3)", a: "x¬≤ + 5x + 6" },
                        { q: "What is the distance formula?", a: "‚àö[(x‚ÇÇ-x‚ÇÅ)¬≤ + (y‚ÇÇ-y‚ÇÅ)¬≤]" },
                        { q: "What is log‚ÇÅ‚ÇÄ(1000)?", a: "3" },
                        { q: "Factor: x¬≤ - 9", a: "(x-3)(x+3)" },
                        { q: "What is 7! ?", a: "5040" }
                    ],
                    Expert: [
                        { q: "State Euler‚Äôs identity.", a: "e^(iœÄ) + 1 = 0" },
                        { q: "What is a group in abstract algebra?", a: "A set with an associative operation, identity, and inverses." },
                        { q: "Define a vector space.", a: "A set with vector addition and scalar multiplication." },
                        { q: "What is a derivative in real analysis?", a: "The limit of the difference quotient." },
                        { q: "What is the determinant of a 2x2 matrix [[a,b],[c,d]]?", a: "ad - bc" },
                        { q: "What is Taylor series expansion of e^x?", a: "1 + x + x¬≤/2! + x¬≥/3! + ‚Ä¶" },
                        { q: "Define eigenvalue.", a: "Œª such that Av = Œªv for some nonzero v." },
                        { q: "What is the Riemann Hypothesis?", a: "That all nontrivial zeros of the zeta function have real part 1/2." },
                        { q: "What is Lebesgue integral?", a: "An integral defined using measure theory." },
                        { q: "What is Fourier transform used for?", a: "Decomposing functions into frequencies." }
                    ]
                },
                Science: {
                    Easy: [
                        { q: "What planet do we live on?", a: "Earth" },
                        { q: "What gas do humans breathe in?", a: "Oxygen" },
                        { q: "What gas do humans breathe out?", a: "Carbon dioxide" },
                        { q: "What star is at the center of our solar system?", a: "The Sun" },
                        { q: "What do bees make?", a: "Honey" },
                        { q: "What is H‚ÇÇO commonly called?", a: "Water" },
                        { q: "How many legs does an insect have?", a: "6" },
                        { q: "What force pulls objects to the ground?", a: "Gravity" },
                        { q: "What is the largest planet in our solar system?", a: "Jupiter" },
                        { q: "What organ pumps blood in our body?", a: "Heart" }
                    ],
                    Medium: [
                        { q: "What planet is known as the Red Planet?", a: "Mars" },
                        { q: "What is the chemical symbol for gold?", a: "Au" },
                        { q: "What part of the cell contains DNA?", a: "Nucleus" },
                        { q: "What gas makes up most of Earth‚Äôs atmosphere?", a: "Nitrogen" },
                        { q: "What is the powerhouse of the cell?", a: "Mitochondria" },
                        { q: "At what temperature does water boil (Celsius)?", a: "100¬∞C" },
                        { q: "What is the process of plants making food using sunlight?", a: "Photosynthesis" },
                        { q: "What simple machine is a seesaw?", a: "Lever" },
                        { q: "What gas do plants release during photosynthesis?", a: "Oxygen" },
                        { q: "How many bones in the adult human body?", a: "206" }
                    ],
                    Hard: [
                        { q: "What is Newton‚Äôs second law of motion?", a: "Force = mass √ó acceleration (F=ma)" },
                        { q: "What is the acceleration due to gravity on Earth (m/s¬≤)?", a: "9.8" },
                        { q: "What is DNA‚Äôs shape called?", a: "Double helix" },
                        { q: "Who proposed the theory of relativity?", a: "Albert Einstein" },
                        { q: "What particle has negative charge?", a: "Electron" },
                        { q: "What blood type is universal donor?", a: "O negative" },
                        { q: "What is the periodic table number for Carbon?", a: "6" },
                        { q: "What type of bond shares electrons?", a: "Covalent bond" },
                        { q: "What organelle makes proteins?", a: "Ribosome" },
                        { q: "What planet has the most moons?", a: "Saturn" }
                    ],
                    Expert: [
                        { q: "What is entropy?", a: "A measure of disorder in a system" },
                        { q: "Define Heisenberg‚Äôs uncertainty principle.", a: "You cannot simultaneously know position and momentum exactly." },
                        { q: "What is Schr√∂dinger‚Äôs equation used for?", a: "Describing quantum systems." },
                        { q: "What is CRISPR?", a: "A gene-editing technology." },
                        { q: "What is the Higgs boson?", a: "A particle giving mass via Higgs field." },
                        { q: "Define thermodynamics‚Äô 2nd law.", a: "Entropy of an isolated system never decreases." },
                        { q: "What is a black hole singularity?", a: "A point of infinite density." },
                        { q: "What is the speed of light in vacuum (m/s)?", a: "3 √ó 10‚Å∏ m/s" },
                        { q: "What is an isotope?", a: "Atoms of same element with different neutrons." },
                        { q: "What is plate tectonics?", a: "Theory Earth‚Äôs plates move causing earthquakes and volcanoes." }
                    ]
                },
                History: { Easy: [], Medium: [], Hard: [], Expert: [] },
                English: { Easy: [], Medium: [], Hard: [], Expert: [] }
            }
        };

        const usedQuestions = {};

        function getQuestion(category, subject, difficulty) {
            try {
                const key = `${category}-${subject}-${difficulty}`;
                if (!usedQuestions[key]) usedQuestions[key] = [];
                const pool = (questionBank[category] && questionBank[category][subject] && questionBank[category][subject][difficulty]) || [];
                const remaining = pool.filter(q => !usedQuestions[key].includes(q.q));
                if (remaining.length === 0) {
                    usedQuestions[key] = [];
                    return { q: 'All questions used! Restarting.', a: null };
                }
                const picked = remaining[Math.floor(Math.random() * remaining.length)];
                usedQuestions[key].push(picked.q);
                return picked;
            } catch (e) { return { q: 'Error fetching question', a: null }; }
        }

        // expose for standalone usage
        window.standaloneGetQuestion = getQuestion;
        try { if (typeof window.getQuestion !== 'function') window.getQuestion = getQuestion; } catch (e) {}
    } catch (e) { /* ignore insertion errors */ }
})();

<script>
    // Ensure a game-area exists (for standalone.html it's usually already there)
    if (!document.getElementById("game-area")) {
        const div = document.createElement("div");
        div.id = "game-area";
        document.body.appendChild(div);
    }

    // Button handler (safe guard if button not present)
    const btn = document.getElementById("schoolTriviaBtn");
    if (btn) {
        btn.addEventListener("click", () => {
            startSchoolTrivia();
        });
    }

    // Start School Trivia UI
    function startSchoolTrivia() {
        const container = document.getElementById("game-area");
        container.innerHTML = `
            <div class="quiz-container">
                <h2>üéì School Trivia</h2>
                <p>Select a subject and grade difficulty to begin:</p>
        
                <label>Subject:
                    <select id="school-subject">
                        <option value="Math">Math</option>
                        <option value="Science">Science</option>
                        <option value="History">History</option>
                        <option value="English">English</option>
                    </select>
                </label>
        
                <label>Difficulty:
                    <select id="school-difficulty">
                        <option value="Easy">Easy (K‚Äì4)</option>
                        <option value="Medium">Medium (5‚Äì8)</option>
                        <option value="Hard">Hard (High School)</option>
                        <option value="Expert">Expert (College)</option>
                    </select>
                </label>
        
                <button id="beginSchoolTrivia">Start Quiz</button>
                <button id="resetSchoolTrivia">Reset Pool</button>
        
                <div id="quiz-area"></div>
            </div>
        `;

        document.getElementById("beginSchoolTrivia").addEventListener("click", () => {
            const subject = document.getElementById("school-subject").value;
            const difficulty = document.getElementById("school-difficulty").value;
            runSchoolTrivia(subject, difficulty);
        });

        document.getElementById("resetSchoolTrivia").addEventListener("click", () => {
            try { localStorage.removeItem("usedSchoolQuestions"); } catch(e){}
            alert("‚úÖ School Trivia pool reset. Questions may repeat again.");
        });
    }

    // Run a School Trivia round
    function runSchoolTrivia(subject, difficulty) {
        // prefer standaloneGetQuestion (exists in this page)
        const engine = window.standaloneGetQuestion || window.getQuestion;
        const quizArea = document.getElementById("quiz-area");
        if (!engine) {
            quizArea.innerHTML = "<p>‚ö†Ô∏è Quiz engine not available.</p>";
            return;
        }

        const q = engine('School Trivia', subject, difficulty);

        if (!q || !q.q) {
            quizArea.innerHTML = "<p>üéâ No more questions available for this category & difficulty!</p>";
            return;
        }

        // Normalize shape to { question, options, answer }
        const questionText = q.question || q.q || q.prompt || q.text || '';
        const options = q.options || q.choices || (q.a ? [q.a] : []);
        const answerIndex = (typeof q.correct === 'number') ? q.correct : (typeof q.answer === 'number' ? q.answer : 0);

        let optionsHTML = "";
        options.forEach((opt, i) => {
            optionsHTML += `<button class="optionBtn" data-index="${i}">${opt}</button>`;
        });

        quizArea.innerHTML = `
            <h3>${questionText}</h3>
            <div>${optionsHTML}</div>
            <p id="feedback"></p>
            <button id="nextSchoolQ">Next Question</button>
        `;

        // Check answer
        document.querySelectorAll(".optionBtn").forEach(btn => {
            btn.addEventListener("click", () => {
                const idx = parseInt(btn.dataset.index, 10);
                const fb = document.getElementById("feedback");
                if (idx === answerIndex) {
                    fb.textContent = "‚úÖ Correct!";
                } else {
                    fb.textContent = "‚ùå Incorrect!" + (options[answerIndex] ? (" Correct answer: " + options[answerIndex]) : '');
                }
            });
        });

        // Next question
        document.getElementById("nextSchoolQ").addEventListener("click", () => {
            runSchoolTrivia(subject, difficulty);
        });
    }
</script>