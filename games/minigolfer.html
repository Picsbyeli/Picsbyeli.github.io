<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Mini Golf Mania</title>
<link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
<style>
/* ============================================================
   STYLE SYSTEM ‚Äî Neon-Retro Arcade aesthetic
   ============================================================ */
*, *::before, *::after { margin:0; padding:0; box-sizing:border-box; }

:root {
  --bg-dark: #0a0e1a;
  --bg-card: #111827;
  --bg-card-hover: #1a2340;
  --neon-green: #39ff14;
  --neon-blue: #00d4ff;
  --neon-pink: #ff2eaa;
  --neon-yellow: #ffe600;
  --neon-orange: #ff6b2b;
  --neon-purple: #a855f7;
  --gold: #ffd700;
  --text-primary: #e8eaed;
  --text-secondary: #8892a4;
  --danger: #ff4444;
  --success: #22c55e;
  --rarity-common: #9ca3af;
  --rarity-rare: #3b82f6;
  --rarity-epic: #a855f7;
  --rarity-legendary: #f59e0b;
  --radius: 12px;
  --glow-green: 0 0 20px rgba(57,255,20,0.3);
  --glow-blue: 0 0 20px rgba(0,212,255,0.3);
  --glow-pink: 0 0 20px rgba(255,46,170,0.3);
}

html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  background: var(--bg-dark);
  font-family: 'Fredoka', sans-serif;
  color: var(--text-primary);
  -webkit-tap-highlight-color: transparent;
  user-select: none;
}

/* CANVAS */
#gameCanvas {
  display: block;
  position: absolute;
  top: 0; left: 0;
  z-index: 1;
  cursor: crosshair;
}
#gameCanvas.dragging { cursor: none; }
#gameCanvas.no-shoot { cursor: default; }

/* SCREENS */
.screen {
  display: none;
  position: absolute;
  top: 0; left: 0; width: 100%; height: 100%;
  z-index: 10;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 20px;
}
.screen.active { display: flex; }

/* MAIN MENU */
#mainMenu {
  background: linear-gradient(180deg, #0a0e1a 0%, #111827 50%, #0a0e1a 100%);
  gap: 16px;
}
.menu-title {
  font-size: clamp(2.5rem, 8vw, 5rem);
  font-weight: 700;
  text-transform: uppercase;
  background: linear-gradient(135deg, var(--neon-green), var(--neon-blue));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  text-shadow: none;
  filter: drop-shadow(0 0 30px rgba(57,255,20,0.4));
  letter-spacing: 2px;
  margin-bottom: 8px;
}
.menu-subtitle {
  font-family: 'Space Mono', monospace;
  color: var(--text-secondary);
  font-size: 0.85rem;
  margin-bottom: 20px;
  letter-spacing: 3px;
  text-transform: uppercase;
}
.menu-credits {
  font-family: 'Space Mono', monospace;
  color: var(--neon-yellow);
  font-size: 1.1rem;
  margin-bottom: 10px;
  text-shadow: 0 0 10px rgba(255,230,0,0.4);
}

/* BUTTONS */
.btn {
  padding: 14px 36px;
  border: 2px solid var(--neon-green);
  background: transparent;
  color: var(--neon-green);
  font-family: 'Fredoka', sans-serif;
  font-size: 1.05rem;
  font-weight: 600;
  border-radius: var(--radius);
  cursor: pointer;
  transition: all 0.2s;
  min-width: 240px;
  text-align: center;
  letter-spacing: 1px;
  text-transform: uppercase;
}
.btn:hover, .btn:active {
  background: var(--neon-green);
  color: var(--bg-dark);
  box-shadow: var(--glow-green);
}
.btn.btn-blue { border-color: var(--neon-blue); color: var(--neon-blue); }
.btn.btn-blue:hover { background: var(--neon-blue); color: var(--bg-dark); box-shadow: var(--glow-blue); }
.btn.btn-pink { border-color: var(--neon-pink); color: var(--neon-pink); }
.btn.btn-pink:hover { background: var(--neon-pink); color: var(--bg-dark); box-shadow: var(--glow-pink); }
.btn.btn-gold { border-color: var(--gold); color: var(--gold); }
.btn.btn-gold:hover { background: var(--gold); color: var(--bg-dark); }
.btn.btn-sm { padding: 8px 20px; font-size: 0.85rem; min-width: auto; }
.btn.btn-disabled { opacity: 0.3; pointer-events: none; }

/* DIFFICULTY SELECT */
#difficultySelect { background: rgba(10,14,26,0.97); gap: 14px; }
.diff-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; max-width: 400px; width: 100%; }
.diff-card {
  background: var(--bg-card);
  border: 2px solid #1e293b;
  border-radius: var(--radius);
  padding: 20px 16px;
  text-align: center;
  cursor: pointer;
  transition: all 0.2s;
}
.diff-card:hover { border-color: var(--neon-green); box-shadow: var(--glow-green); }
.diff-card .diff-name { font-size: 1.1rem; font-weight: 600; margin-bottom: 4px; }
.diff-card .diff-mult { font-family: 'Space Mono', monospace; font-size: 0.75rem; color: var(--neon-yellow); }

/* MODE SELECT */
#modeSelect { background: rgba(10,14,26,0.97); gap: 14px; }

/* STORE */
#storeScreen { background: rgba(10,14,26,0.97); gap: 14px; overflow-y: auto; }
.store-tabs { display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; }
.store-tab {
  padding: 8px 18px;
  border: 1px solid #2a3450;
  background: transparent;
  color: var(--text-secondary);
  border-radius: 20px;
  cursor: pointer;
  font-family: 'Fredoka', sans-serif;
  font-size: 0.85rem;
  transition: all 0.2s;
}
.store-tab.active { border-color: var(--neon-blue); color: var(--neon-blue); background: rgba(0,212,255,0.1); }
.store-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
  gap: 12px;
  max-width: 700px;
  width: 100%;
  max-height: 50vh;
  overflow-y: auto;
  padding: 4px;
}
.store-item {
  background: var(--bg-card);
  border: 2px solid #1e293b;
  border-radius: var(--radius);
  padding: 14px 10px;
  text-align: center;
  cursor: pointer;
  transition: all 0.2s;
  position: relative;
}
.store-item:hover { border-color: var(--neon-blue); }
.store-item.owned { border-color: var(--success); opacity: 0.7; }
.store-item.equipped { border-color: var(--neon-yellow); opacity: 1; box-shadow: 0 0 12px rgba(255,230,0,0.2); }
.store-item.locked { border-color: var(--danger); }
.store-item .item-preview { width: 50px; height: 50px; margin: 0 auto 8px; border-radius: 50%; }
.store-item .item-name { font-size: 0.8rem; font-weight: 600; margin-bottom: 4px; }
.store-item .item-price { font-family: 'Space Mono', monospace; font-size: 0.7rem; color: var(--neon-yellow); }
.store-item .item-rarity { font-size: 0.65rem; text-transform: uppercase; letter-spacing: 1px; }
.rarity-common { color: var(--rarity-common); }
.rarity-rare { color: var(--rarity-rare); }
.rarity-epic { color: var(--rarity-epic); }
.rarity-legendary { color: var(--rarity-legendary); }
.store-item .item-badge {
  position: absolute; top: -6px; right: -6px;
  background: var(--danger); color: #fff;
  font-size: 0.55rem; padding: 2px 6px;
  border-radius: 8px; font-weight: 700;
}

/* HUD */
#hud {
  display: none;
  position: absolute;
  top: 0; left: 0; width: 100%;
  z-index: 5;
  padding: 12px 16px;
  pointer-events: none;
  font-family: 'Space Mono', monospace;
}
#hud.active { display: flex; justify-content: space-between; align-items: flex-start; }
.hud-left, .hud-right { pointer-events: auto; }
.hud-label { font-size: 0.6rem; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 2px; }
.hud-val { font-size: 1.2rem; font-weight: 700; color: var(--neon-green); text-shadow: 0 0 8px rgba(57,255,20,0.4); }
.hud-val.par { color: var(--neon-blue); }
.hud-strokes { color: var(--neon-yellow); }
.hud-row { display: flex; gap: 20px; }
#hudBack {
  font-size: 0.75rem; padding: 4px 12px;
  border: 1px solid #333; background: rgba(0,0,0,0.6);
  color: #888; border-radius: 6px; cursor: pointer;
  margin-top: 8px;
  font-family: 'Space Mono', monospace;
}
#hudBack:hover { border-color: var(--neon-pink); color: var(--neon-pink); }

/* GILMORE MODE UI */
#gilmoreTurnBar {
  display: none; position: absolute; top: 56px; left: 50%; transform: translateX(-50%);
  background: rgba(0,0,0,0.85); border: 1px solid #333; border-radius: 10px;
  padding: 6px 16px; z-index: 7; text-align: center; min-width: 180px;
  font-family: 'Space Mono', monospace;
}
.turn-name { font-size: 0.85rem; font-weight: 700; color: var(--neon-green); }
.turn-name.bot { color: var(--neon-orange); }
.turn-skin { display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-right: 6px; vertical-align: middle; }
#gilmoreAbilityBtn {
  display: none; position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%);
  background: linear-gradient(135deg, #6622aa, #aa44ee); border: 2px solid #cc66ff;
  color: #fff; padding: 8px 18px; border-radius: 20px; cursor: pointer; z-index: 7;
  font-family: 'Fredoka', sans-serif; font-size: 0.85rem; font-weight: 600;
  box-shadow: 0 0 15px rgba(170,68,238,0.3); transition: all 0.2s;
}
#gilmoreAbilityBtn:hover { box-shadow: 0 0 25px rgba(170,68,238,0.6); transform: translateX(-50%) scale(1.05); }
#gilmoreAbilityBtn.used { opacity: 0.4; pointer-events: none; border-color: #555; background: #333; box-shadow: none; }
#gilmoreAbilityBtn.cooldown { opacity: 0.6; pointer-events: none; }
#gilmoreScoreboard {
  display: none; position: absolute; top: 56px; right: 12px; background: rgba(0,0,0,0.8);
  border: 1px solid #333; border-radius: 8px; padding: 8px 12px; z-index: 7;
  font-family: 'Space Mono', monospace; font-size: 0.65rem; max-width: 160px;
}
.gs-row { display: flex; justify-content: space-between; padding: 2px 0; gap: 8px; }
.gs-row.current { color: var(--neon-green); }
.gs-name { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 90px; }
.gs-strokes { color: var(--neon-yellow); font-weight: 700; }
.gilmore-bot-select { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; margin: 12px 0; }
.bot-count-btn {
  width: 40px; height: 40px; border-radius: 50%; border: 2px solid #333;
  background: var(--bg-card); color: var(--text-primary); font-weight: 700;
  font-size: 1rem; cursor: pointer; transition: all 0.2s;
}
.bot-count-btn:hover, .bot-count-btn.active { border-color: var(--neon-green); color: var(--neon-green); background: rgba(57,255,20,0.08); }
/* ABILITY TOOLTIP */
#abilityTooltip {
  display: none; position: absolute; bottom: 115px; left: 50%; transform: translateX(-50%);
  background: rgba(0,0,0,0.92); border: 1px solid #cc66ff; border-radius: 8px;
  padding: 8px 14px; z-index: 8; max-width: 220px; text-align: center;
  font-family: 'Space Mono', monospace; font-size: 0.7rem; color: #ddd;
  pointer-events: none; white-space: normal;
}
.tooltip-name { color: var(--neon-green); font-weight: 700; font-size: 0.8rem; margin-bottom: 3px; }
/* ABILITY INFO SCREEN */
.ability-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; padding: 8px; max-height: 55vh; overflow-y: auto; }
.ability-card {
  background: var(--bg-card); border: 1px solid #333; border-radius: 8px; padding: 8px;
  text-align: left; font-family: 'Space Mono', monospace; transition: border-color 0.2s;
}
.ability-card:hover { border-color: #cc66ff; }
.ability-card .ab-icon { font-size: 1.2rem; }
.ability-card .ab-name { font-size: 0.65rem; font-weight: 700; color: var(--neon-green); }
.ability-card .ab-desc { font-size: 0.55rem; color: var(--text-secondary); margin-top: 2px; }
.ability-card .ab-skin { font-size: 0.5rem; color: #888; margin-top: 2px; }
/* GILMORE DIFFICULTY TIERS */
.gilmore-tier-grid { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; margin: 10px 0; }
.gilmore-tier-btn {
  font-family: 'Space Mono', monospace; font-size: 0.7rem; padding: 10px 14px;
  border-radius: 10px; border: 2px solid #444; background: var(--bg-card);
  color: var(--text-primary); cursor: pointer; transition: all 0.2s; text-align: center; min-width: 100px;
}
.gilmore-tier-btn:hover { border-color: var(--neon-green); }
.gilmore-tier-btn.active { border-color: var(--neon-green); background: rgba(57,255,20,0.08); }
.gilmore-tier-btn .tier-icon { font-size: 1.4rem; display: block; margin-bottom: 2px; }
.gilmore-tier-btn .tier-name { font-weight: 700; display: block; }
.gilmore-tier-btn .tier-info { font-size: 0.5rem; color: var(--text-secondary); display: block; margin-top: 2px; }
/* MAX STROKES BAR */
#maxStrokesBar {
  display: none; position: absolute; top: 90px; left: 50%; transform: translateX(-50%);
  background: rgba(0,0,0,0.7); border: 1px solid #ff4444; border-radius: 6px;
  padding: 3px 10px; z-index: 7; font-family: 'Space Mono', monospace;
  font-size: 0.65rem; color: #ff6666;
}

/* POWER METER (side bar) */
#powerMeter {
  display: none;
  position: absolute;
  right: 16px;
  top: 50%;
  transform: translateY(-50%);
  width: 28px;
  height: 200px;
  background: rgba(0,0,0,0.7);
  border: 2px solid #333;
  border-radius: 14px;
  z-index: 6;
  overflow: hidden;
}
#powerFill {
  position: absolute;
  bottom: 0; left: 0; width: 100%;
  background: linear-gradient(to top, var(--neon-green), var(--neon-yellow), var(--danger));
  border-radius: 0 0 12px 12px;
  transition: height 0.05s;
}

/* CLUB SELECTOR */
#controlToggle {
  position: absolute;
  right: 14px;
  bottom: 14px;
  z-index: 8;
  font-family: 'Space Mono', monospace;
  font-size: 0.65rem;
  padding: 6px 10px;
  border-radius: 8px;
  border: 1px solid #555;
  background: rgba(0,0,0,0.7);
  color: var(--text-primary);
  cursor: pointer;
}
#controlToggle:hover { border-color: var(--neon-green); }
#clubSelector {
  display: none;
  position: absolute;
  left: 16px;
  bottom: 16px;
  z-index: 6;
  background: rgba(0,0,0,0.8);
  border: 1px solid #2a3450;
  border-radius: var(--radius);
  padding: 8px;
}
.club-btn {
  display: block;
  padding: 6px 14px;
  background: transparent;
  border: 1px solid transparent;
  color: var(--text-secondary);
  font-family: 'Fredoka', sans-serif;
  font-size: 0.75rem;
  cursor: pointer;
  border-radius: 6px;
  transition: all 0.15s;
  width: 100%;
  text-align: left;
}
.club-btn:hover { color: var(--text-primary); border-color: #333; }
.club-btn.active { color: var(--neon-green); border-color: var(--neon-green); background: rgba(57,255,20,0.08); }

/* SCORE SUMMARY OVERLAY */
#scoreSummary {
  display: none;
  position: absolute;
  top: 0; left: 0; width: 100%; height: 100%;
  z-index: 20;
  background: rgba(10,14,26,0.92);
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 12px;
}
#scoreSummary.active { display: flex; }
.summary-title { font-size: 1.8rem; font-weight: 700; color: var(--neon-green); }
.summary-detail { font-family: 'Space Mono', monospace; font-size: 0.85rem; color: var(--text-secondary); }
.summary-credits { font-size: 1.4rem; font-weight: 700; color: var(--neon-yellow); text-shadow: 0 0 15px rgba(255,230,0,0.5); }
.summary-bonus { font-family: 'Space Mono', monospace; font-size: 0.75rem; color: var(--neon-orange); }

/* LEADERBOARD */
#leaderboard { background: rgba(10,14,26,0.97); gap: 14px; }

/* POST-GAME STATS */
#postGameStats { background: rgba(10,14,26,0.97); gap: 0; padding: 12px; }
.pgs-scroll {
  width: 100%; max-width: 560px; max-height: 90vh; overflow-y: auto;
  display: flex; flex-direction: column; align-items: center; gap: 10px;
  padding: 8px;
  scrollbar-width: thin; scrollbar-color: #333 transparent;
}
.pgs-placement {
  font-size: clamp(1.1rem, 3vw, 1.6rem); font-weight: 700;
  padding: 8px 20px; border-radius: 10px;
  font-family: 'Space Mono', monospace; text-align: center;
}
.pgs-grid {
  display: grid; grid-template-columns: 1fr 1fr; gap: 8px;
  width: 100%; max-width: 480px;
}
.pgs-stat {
  background: var(--bg-card); border: 1px solid #1e293b;
  border-radius: var(--radius); padding: 10px 12px;
  text-align: center;
}
.pgs-stat .pgs-val {
  font-size: 1.3rem; font-weight: 700; color: var(--text-primary);
  font-family: 'Space Mono', monospace;
}
.pgs-stat .pgs-label {
  font-size: 0.6rem; color: var(--text-secondary);
  font-family: 'Space Mono', monospace;
  text-transform: uppercase; letter-spacing: 1px; margin-top: 2px;
}
.pgs-stat.highlight .pgs-val { color: var(--neon-green); }
.pgs-stat.gold .pgs-val { color: var(--neon-yellow); text-shadow: 0 0 8px rgba(255,230,0,0.3); }
.pgs-section-title {
  font-family: 'Space Mono', monospace;
  font-size: 0.7rem; text-transform: uppercase; letter-spacing: 2px;
  color: var(--text-secondary); margin-top: 10px; width: 100%; max-width: 480px;
  border-bottom: 1px solid #1e293b; padding-bottom: 4px;
}
.pgs-table { width: 100%; max-width: 480px; }
.pgs-row {
  display: flex; align-items: center; padding: 6px 8px;
  border-bottom: 1px solid rgba(30,41,59,0.5);
  font-family: 'Space Mono', monospace; font-size: 0.72rem;
}
.pgs-row.header { color: var(--text-secondary); font-size: 0.6rem; text-transform: uppercase; }
.pgs-row .pgs-hole { width: 28px; color: var(--text-secondary); }
.pgs-row .pgs-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.pgs-row .pgs-par { width: 36px; text-align: center; color: var(--text-secondary); }
.pgs-row .pgs-strk { width: 42px; text-align: center; font-weight: 700; }
.pgs-row .pgs-score { width: 90px; text-align: right; font-size: 0.65rem; }
.pgs-row .pgs-score.eagle { color: #ffd700; }
.pgs-row .pgs-score.birdie { color: var(--neon-green); }
.pgs-row .pgs-score.par-score { color: var(--text-secondary); }
.pgs-row .pgs-score.bogey { color: var(--neon-orange); }
.pgs-row .pgs-score.bad { color: var(--danger); }
.lb-table { width: 100%; max-width: 500px; }
.lb-row {
  display: flex; justify-content: space-between;
  padding: 10px 16px; border-bottom: 1px solid #1e293b;
  font-family: 'Space Mono', monospace;
  font-size: 0.8rem;
}
.lb-row.header { color: var(--text-secondary); font-size: 0.7rem; text-transform: uppercase; }
.lb-row .lb-name { flex: 1; }
.lb-row .lb-score { width: 60px; text-align: right; }
.lb-row .lb-credits { width: 80px; text-align: right; color: var(--neon-yellow); }
.lb-row.player { color: var(--neon-green); }

/* ACHIEVEMENTS */
#achievementsScreen { background: rgba(10,14,26,0.97); gap: 14px; overflow-y: auto; }
.ach-grid {
  display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 10px; max-width: 700px; width: 100%; max-height: 55vh; overflow-y: auto;
}
.ach-card {
  background: var(--bg-card); border: 1px solid #1e293b;
  border-radius: var(--radius); padding: 14px;
}
.ach-card.unlocked { border-color: var(--neon-green); }
.ach-card .ach-icon { font-size: 1.5rem; margin-bottom: 6px; }
.ach-card .ach-name { font-size: 0.85rem; font-weight: 600; margin-bottom: 2px; }
.ach-card .ach-desc { font-size: 0.7rem; color: var(--text-secondary); }
.ach-card .ach-reward { font-size: 0.65rem; color: var(--neon-yellow); margin-top: 4px; font-family: 'Space Mono', monospace; }

/* SCROLLBAR */
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: #2a3450; border-radius: 3px; }

/* RESPONSIVE */
@media (max-width: 500px) {
  .btn { min-width: 200px; padding: 12px 24px; font-size: 0.9rem; }
  .diff-grid { grid-template-columns: 1fr; max-width: 280px; }
  .store-grid { grid-template-columns: repeat(auto-fill, minmax(110px, 1fr)); }
}
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<!-- ============ HUD ============ -->
<div id="hud">
  <div class="hud-left">
    <div class="hud-row">
      <div><div class="hud-label">Hole</div><div class="hud-val" id="hudHole">1</div></div>
      <div><div class="hud-label">Par</div><div class="hud-val par" id="hudPar">3</div></div>
      <div><div class="hud-label">Strokes</div><div class="hud-val hud-strokes" id="hudStrokes">0</div></div>
    </div>
    <button id="hudBack">‚Üê Menu</button>
  </div>
  <div class="hud-right">
    <div class="hud-label">Credits</div>
    <div class="hud-val" id="hudCredits" style="color:var(--neon-yellow)">0</div>
  </div>
</div>

<!-- POWER METER -->
<div id="powerMeter"><div id="powerFill"></div></div>

<!-- CONTROL MODE TOGGLE -->
<button id="controlToggle" onclick="Input.controlMode = Input.controlMode === 'drag' ? 'click' : 'drag'; this.textContent = Input.controlMode === 'drag' ? 'üéØ Drag' : 'üëÜ Click'; Input.clickAiming=false; Input.clickCharging=false; Input.clickChargePower=0; Input.aimPower=0;">üéØ Drag</button>

<!-- CLUB SELECTOR -->
<div id="clubSelector"></div>

<!-- GILMORE MODE UI -->
<div id="gilmoreTurnBar"><span class="turn-skin" id="gtSkin"></span><span class="turn-name" id="gtName">Your Turn</span></div>
<button id="gilmoreAbilityBtn" onclick="Game.activateAbility()" onmouseenter="UI.showAbilityTooltip()" onmouseleave="UI.hideAbilityTooltip()">‚ö° Ability</button>
<div id="abilityTooltip"><div class="tooltip-name" id="ttName"></div><div id="ttDesc"></div></div>
<div id="gilmoreScoreboard"></div>
<div id="maxStrokesBar"></div>

<!-- ============ SCREENS ============ -->

<!-- MAIN MENU -->
<div id="mainMenu" class="screen active">
  <div class="menu-title">Mini Golf</div>
  <div class="menu-subtitle">Mania</div>
  <div class="menu-credits">‚≠ê <span id="menuCredits">0</span> Credits</div>
  <button class="btn" onclick="UI.showScreen('modeSelect')">Play</button>
  <button class="btn btn-blue" onclick="UI.showScreen('storeScreen')">Store</button>
  <button class="btn btn-pink" onclick="UI.showScreen('achievementsScreen')">Achievements</button>
</div>

<!-- MODE SELECT -->
<div id="modeSelect" class="screen">
  <div class="menu-title" style="font-size:clamp(1.5rem,5vw,2.5rem)">Select Mode</div>
  <button class="btn" onclick="Game.setMode('single'); Game.useBots=false; UI.showScreen('difficultySelect')">‚õ≥ Solo Practice</button>
  <button class="btn btn-blue" onclick="Game.setMode('single'); Game.useBots=true; UI.showScreen('botCountSelect')">ü§ñ vs Bots</button>
  <button class="btn btn-pink" onclick="Game.setMode('tournament'); Game.useBots=false; UI.showScreen('difficultySelect')">üèÜ Tournament</button>
  <button class="btn" style="color:#ff8800" onclick="Game.setMode('tournament_online'); Game.useBots=false; UI.showScreen('difficultySelect')">üåê Online Tournament</button>
  <button class="btn btn-gold" onclick="UI.showScreen('gilmoreSetup')">üèí Happy Gilmore</button>
  <button class="btn btn-sm" onclick="UI.showScreen('mainMenu')" style="margin-top:12px">‚Üê Back</button>
</div>

<!-- BOT COUNT SELECT (for vs Bots mode) -->
<div id="botCountSelect" class="screen">
  <div class="menu-title" style="font-size:clamp(1.3rem,4vw,2rem)">ü§ñ How Many Bots?</div>
  <div class="gilmore-bot-select" id="botCountBtns"></div>
  <div style="color:var(--text-secondary);font-size:0.7rem;margin:8px 0;font-family:'Space Mono',monospace">Take turns against bot opponents!</div>
  <button class="btn btn-blue" onclick="UI.showScreen('difficultySelect')" style="margin-top:8px">Next ‚Üí</button>
  <button class="btn btn-sm" onclick="UI.showScreen('modeSelect')" style="margin-top:8px">‚Üê Back</button>
</div>

<!-- GILMORE SETUP -->
<div id="gilmoreSetup" class="screen">
  <div class="menu-title" style="font-size:clamp(1.3rem,4vw,2.2rem)">üèí Happy Gilmore</div>
  <div class="menu-subtitle">CHOOSE YOUR BATTLE</div>
  <button class="btn btn-gold" onclick="Game.setMode('gilmore_bots'); UI.showScreen('gilmoreDiffSelect')">‚öîÔ∏è vs Bots</button>
  <button class="btn btn-pink" onclick="Game.setMode('gilmore_local'); UI.showScreen('gilmoreDiffSelect')">üë• Local Multiplayer</button>
  <button class="btn" style="opacity:0.5;pointer-events:none">üåê Online (Coming Soon)</button>
  <button class="btn btn-sm" onclick="UI.showScreen('modeSelect')" style="margin-top:12px">‚Üê Back</button>
</div>

<!-- GILMORE DIFFICULTY SELECT -->
<div id="gilmoreDiffSelect" class="screen">
  <div class="menu-title" style="font-size:clamp(1.2rem,3.5vw,1.8rem)">üèí Choose Difficulty</div>
  <div class="gilmore-tier-grid" id="gilmoreTierGrid"></div>
  <button class="btn btn-gold" onclick="UI.showScreen('gilmoreBotSelect')" style="margin-top:8px">Next ‚Üí</button>
  <button class="btn btn-sm" onclick="UI.showScreen('gilmoreSetup')" style="margin-top:6px">‚Üê Back</button>
</div>

<!-- GILMORE BOT/PLAYER COUNT -->
<div id="gilmoreBotSelect" class="screen">
  <div class="menu-title" style="font-size:clamp(1.3rem,4vw,2rem)" id="gilmoreBotTitle">How Many Opponents?</div>
  <div class="gilmore-bot-select" id="gilmoreBotBtns"></div>
  <div style="color:var(--text-secondary);font-size:0.75rem;margin:8px 0;font-family:'Space Mono',monospace" id="gilmoreBotInfo">Bots use abilities and have unique skins!</div>
  <button class="btn btn-gold" onclick="UI.showScreen('gilmoreAbilityInfo')" style="margin-top:8px">Start Match!</button>
  <button class="btn btn-sm" onclick="UI.showScreen('gilmoreDiffSelect')" style="margin-top:8px">‚Üê Back</button>
</div>

<!-- GILMORE ABILITY INFO -->
<div id="gilmoreAbilityInfo" class="screen">
  <div class="menu-title" style="font-size:clamp(1.1rem,3.5vw,1.8rem)">‚ö° Abilities Guide</div>
  <div style="color:var(--text-secondary);font-size:0.65rem;font-family:'Space Mono',monospace;margin-bottom:6px">Each ball skin has a unique power! Use it once per hole.</div>
  <div class="ability-grid" id="abilityGrid"></div>
  <button class="btn btn-gold" onclick="Game.startGilmore()" style="margin-top:10px">üèí Let's Go!</button>
  <button class="btn btn-sm" onclick="UI.showScreen('gilmoreBotSelect')" style="margin-top:6px">‚Üê Back</button>
</div>

<!-- DIFFICULTY SELECT -->
<div id="difficultySelect" class="screen">
  <div class="menu-title" style="font-size:clamp(1.5rem,5vw,2.5rem)">Difficulty</div>
  <div class="diff-grid">
    <div class="diff-card" onclick="Game.setDifficulty('easy'); Game.start()">
      <div class="diff-name" style="color:var(--success)">Easy</div>
      <div class="diff-mult">1.0x Credits</div>
    </div>
    <div class="diff-card" onclick="Game.setDifficulty('medium'); Game.start()">
      <div class="diff-name" style="color:var(--neon-blue)">Medium</div>
      <div class="diff-mult">1.5x Credits</div>
    </div>
    <div class="diff-card" onclick="Game.setDifficulty('hard'); Game.start()">
      <div class="diff-name" style="color:var(--neon-orange)">Hard</div>
      <div class="diff-mult">2.0x Credits</div>
    </div>
    <div class="diff-card" onclick="Game.setDifficulty('expert'); Game.start()">
      <div class="diff-name" style="color:var(--danger)">Expert</div>
      <div class="diff-mult">3.0x Credits</div>
    </div>
  </div>
  <button class="btn btn-sm" onclick="UI.showScreen('modeSelect')" style="margin-top:12px">‚Üê Back</button>
</div>

<!-- STORE -->
<div id="storeScreen" class="screen">
  <div class="menu-title" style="font-size:clamp(1.5rem,5vw,2.5rem)">Store</div>
  <div class="menu-credits">‚≠ê <span id="storeCredits">0</span> Credits</div>
  <div class="store-tabs" id="storeTabs"></div>
  <div class="store-grid" id="storeGrid"></div>
  <button class="btn btn-sm" onclick="UI.showScreen('mainMenu')" style="margin-top:12px">‚Üê Back</button>
</div>

<!-- ACHIEVEMENTS -->
<div id="achievementsScreen" class="screen">
  <div class="menu-title" style="font-size:clamp(1.3rem,4vw,2rem)">Achievements</div>
  <div class="ach-grid" id="achGrid"></div>
  <button class="btn btn-sm" onclick="UI.showScreen('mainMenu')" style="margin-top:12px">‚Üê Back</button>
</div>

<!-- LEADERBOARD -->
<div id="leaderboard" class="screen">
  <div class="menu-title" style="font-size:clamp(1.3rem,4vw,2rem)">Leaderboard</div>
  <div class="lb-table" id="lbTable"></div>
  <button class="btn" onclick="Game.start()" style="margin-top:12px">Next Course</button>
  <button class="btn btn-sm" onclick="UI.showScreen('mainMenu')">Main Menu</button>
</div>

<!-- POST-GAME STATS -->
<div id="postGameStats" class="screen">
  <div class="pgs-scroll">
    <div class="menu-title" style="font-size:clamp(1.3rem,4vw,2rem)" id="pgsTitle">üìä Game Complete!</div>
    <div class="pgs-placement" id="pgsPlacement" style="display:none"></div>
    <div class="pgs-grid" id="pgsGrid"></div>
    <div class="pgs-section-title">Hole-by-Hole</div>
    <div class="pgs-table" id="pgsTable"></div>
    <div class="pgs-section-title" id="pgsLbTitle" style="display:none">Standings</div>
    <div class="lb-table" id="pgsLbTable" style="display:none"></div>
    <button class="btn btn-gold" onclick="UI.showScreen('modeSelect')" style="margin-top:16px">üè† Return to Lobby</button>
  </div>
</div>

<!-- SCORE SUMMARY -->
<div id="scoreSummary">
  <div class="summary-title" id="sumTitle">Hole Complete!</div>
  <div class="summary-detail" id="sumStrokes">Strokes: 3</div>
  <div class="summary-detail" id="sumPar">Par: 3 ‚Äî Even!</div>
  <div class="summary-bonus" id="sumBonuses"></div>
  <div class="summary-credits" id="sumCredits">+50 ‚≠ê</div>
  <button class="btn" id="sumNext" onclick="Game.nextHole()">Next Hole</button>
</div>

<script>
/* =============================================================
   MINI GOLF MANIA ‚Äî Complete Game Engine
   =============================================================
   Architecture:
   - Persistence  ‚Üí localStorage save/load
   - Data         ‚Üí Levels, Cosmetics, Achievements definitions
   - Physics      ‚Üí Fixed-timestep ball simulation
   - Renderer     ‚Üí Canvas drawing
   - Input        ‚Üí Mouse/touch aiming
   - Particles    ‚Üí Visual effects
   - Credits      ‚Üí Economy calculations
   - Store        ‚Üí Purchase/equip logic
   - Achievements ‚Üí Track & unlock
   - AI           ‚Üí Bot players for tournaments
   - Game         ‚Üí State machine tying it all together
   - UI           ‚Üí Screen management
   ============================================================= */

// ‚îÄ‚îÄ‚îÄ PERSISTENCE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// This module handles saving/loading ALL player data to localStorage.
// Everything (credits, owned skins, achievements, stats) persists between sessions.
const Persistence = {
  KEY: 'minigolf_mania_save',

  defaults() {
    return {
      credits: 100,                     // Starting credits so new players can buy something
      totalCreditsEarned: 0,
      ownedBalls: ['ball_classic'],        // Default ball skin
      ownedClubs: ['club_classic'],       // Default club
      ownedEffects: ['fx_none'],         // No effect default
      equippedBall: 'ball_classic',
      equippedClub: 'club_classic',
      equippedEffect: 'fx_none',
      achievements: {},                  // { achId: true }
      stats: {
        holesPlayed: 0,
        holeInOnes: 0,
        totalStrokes: 0,
        tournamentsWon: 0,
        tournamentsPlayed: 0,
        perfectCourses: 0,              // No resets on a full course
        gamesPlayed: 0,
        winStreak: 0,
        bestWinStreak: 0,
        difficultiesCompleted: {}       // { easy: true, ... }
      }
    };
  },

  load() {
    try {
      const raw = localStorage.getItem(this.KEY);
      if (raw) {
        const saved = JSON.parse(raw);
        // Merge with defaults so new fields get added on update
        const def = this.defaults();
        const data = this._deepMerge(def, saved);
        // Migrate old skin IDs to new ones
        const idMap = { ball_white:'ball_classic', ball_red:'ball_flame', ball_blue:'ball_neon', ball_green:'ball_camo',
          ball_gold:'ball_royal', ball_fire:'ball_skull', ball_rainbow:'ball_sports', ball_void:'ball_ancient',
          ball_champion:'ball_royal', club_putter:'club_classic', club_iron:'club_flame', club_wedge:'club_fossil',
          club_driver:'club_skull', club_laser:'club_royal' };
        if (idMap[data.equippedBall]) data.equippedBall = idMap[data.equippedBall];
        if (idMap[data.equippedClub]) data.equippedClub = idMap[data.equippedClub];
        data.ownedBalls = data.ownedBalls.map(id => idMap[id] || id).filter((v,i,a) => a.indexOf(v)===i);
        data.ownedClubs = data.ownedClubs.map(id => idMap[id] || id).filter((v,i,a) => a.indexOf(v)===i);
        if (!data.ownedBalls.includes('ball_classic')) data.ownedBalls.unshift('ball_classic');
        if (!data.ownedClubs.includes('club_classic')) data.ownedClubs.unshift('club_classic');
        return data;
      }
    } catch(e) { console.warn('Save load failed:', e); }
    return this.defaults();
  },

  save(data) {
    try { localStorage.setItem(this.KEY, JSON.stringify(data)); }
    catch(e) { console.warn('Save failed:', e); }
  },

  _deepMerge(target, source) {
    const out = { ...target };
    for (const key in source) {
      if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
        out[key] = this._deepMerge(target[key] || {}, source[key]);
      } else {
        out[key] = source[key];
      }
    }
    return out;
  }
};

// ‚îÄ‚îÄ‚îÄ DATA: COSMETICS CATALOG ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 16 themed skin sets inspired by painted golf club/ball concept art.
// Each ball has: base/grad colors, pattern, glow, detail, built-in trail.
// Each club has: shaft/head colors, shape, pattern, glow.
// "price: null" means achievement-locked.
const CosmeticsCatalog = {
  balls: [
    // Row 1
    { id:'ball_classic',  name:'Classic',       color:'#ffffff', price:0,    rarity:'common',
      base:'#f0f0f0', grad:'#ffffff', pattern:'dimples', glow:null, detail:null,
      trail:null },
    { id:'ball_flame',    name:'Inferno',       color:'#ff4400', price:100,  rarity:'common',
      base:'#ff4400', grad:'#ff8800', pattern:'flames', glow:'#ff4400', detail:null,
      trail:{ colors:['#ff4400','#ff8800','#ffcc00'], speed:0.8, life:15, size:2.5, gravity:-0.08 } },
    { id:'ball_camo',     name:'Camo',          color:'#4a7a32', price:100,  rarity:'common',
      base:'#5a8a3a', grad:'#3a6a22', pattern:'camo', glow:null, detail:null,
      trail:{ colors:['#4a7a32','#6a9a52','#2a5a12'], speed:0.3, life:10, size:1.5, gravity:0.02 } },
    { id:'ball_neon',     name:'Neon Chrome',   color:'#00aaff', price:150,  rarity:'rare',
      base:'#0088dd', grad:'#00ccff', pattern:'chrome', glow:'#00ccff', glowPulse:true, detail:null,
      trail:{ colors:['#00ccff','#0088ff','#ffffff'], speed:0.5, life:18, size:2, gravity:0 } },
    // Row 2
    { id:'ball_wooden',   name:'Wooden',        color:'#c8943e', price:100,  rarity:'common',
      base:'#c8943e', grad:'#a07030', pattern:'woodgrain', glow:null, detail:null,
      trail:{ colors:['#c8943e','#e0b060','#8a6020'], speed:0.4, life:8, size:1, gravity:0.05 } },
    { id:'ball_galaxy',   name:'Galaxy',        color:'#8833cc', price:300,  rarity:'rare',
      base:'#6622aa', grad:'#aa44ee', pattern:'stars', glow:'#aa44ee', glowPulse:true, detail:null,
      trail:{ colors:['#aa44ee','#cc66ff','#ffffff','#ffd700'], speed:0.6, life:22, size:2, gravity:-0.03 } },
    { id:'ball_thunder',  name:'Thunder',       color:'#ffd700', price:300,  rarity:'rare',
      base:'#222222', grad:'#444444', pattern:'bolt', glow:'#ffd700', detail:'bolt',
      trail:{ colors:['#ffd700','#ffee55','#ffffff'], speed:1, life:10, size:2.5, gravity:0 } },
    { id:'ball_candy',    name:'Candy',         color:'#ff88cc', price:200,  rarity:'rare',
      base:'#ff66bb', grad:'#ffaadd', pattern:'swirl', glow:null, detail:null,
      trail:{ colors:['#ff66bb','#ff99dd','#ffffff','#ffcc00'], speed:0.5, life:14, size:2, gravity:-0.02 } },
    // Row 3
    { id:'ball_fossil',   name:'Fossil',        color:'#8a8070', price:200,  rarity:'rare',
      base:'#7a7060', grad:'#9a9080', pattern:'cracks', glow:null, detail:null,
      trail:{ colors:['#8a8070','#6a6050','#aaa090'], speed:0.6, life:10, size:2, gravity:0.1 } },
    { id:'ball_ice',      name:'Frostbite',     color:'#88ddff', price:400,  rarity:'epic',
      base:'#66ccee', grad:'#aaeeff', pattern:'crystal', glow:'#88ddff', detail:null,
      trail:{ colors:['#88ddff','#aaeeff','#ffffff'], speed:0.4, life:20, size:2, gravity:-0.02 } },
    { id:'ball_tiki',     name:'Beach Ball',    color:'#ff8844', price:400,  rarity:'epic',
      base:'#ffffff', grad:'#ffeecc', pattern:'beach', glow:null, detail:null,
      trail:{ colors:['#ff4444','#ffcc00','#44cc44','#4488ff','#ff44aa'], speed:0.7, life:16, size:2.5, gravity:-0.04 } },
    { id:'ball_skull',    name:'Skull Fire',    color:'#ff6600', price:500,  rarity:'epic',
      base:'#e8dcc8', grad:'#c8b8a0', pattern:null, glow:'#ff4400', detail:'skull',
      trail:{ colors:['#ff4400','#ff8800','#ffcc00','#333'], speed:0.8, life:18, size:3, gravity:-0.06 } },
    // Row 4
    { id:'ball_royal',    name:'Royal Gold',    color:'#ffd700', price:500,  rarity:'epic',
      base:'#daa520', grad:'#ffd700', pattern:'ornate', glow:'#ffd700', detail:null,
      trail:{ colors:['#ffd700','#ffee88','#ffffff'], speed:0.5, life:20, size:2, gravity:-0.01 } },
    { id:'ball_alien',    name:'Alien',         color:'#33cc44', price:600,  rarity:'epic',
      base:'#22aa33', grad:'#44dd55', pattern:null, glow:'#33ff44', detail:'eyes',
      trail:{ colors:['#33ff44','#88ff99','#aaffbb'], speed:0.5, life:16, size:2, gravity:-0.03 } },
    { id:'ball_sports',   name:'Sports',        color:'#ffffff', price:null, rarity:'legendary', achievement:'ach_100holes',
      base:'#f0f0f0', grad:'#ffffff', pattern:'stitches', glow:null, detail:'cap',
      trail:{ colors:['#ff3333','#ffffff'], speed:1.2, life:8, size:1.5, gravity:0 } },
    { id:'ball_ancient',  name:'Ancient Relic', color:'#22ccaa', price:null, rarity:'legendary', achievement:'ach_expert',
      base:'#1a9988', grad:'#22ccaa', pattern:'runes', glow:'#22ccaa', glowPulse:true, detail:null,
      trail:{ colors:['#22ccaa','#44eedd','#ffd700','#ffffff'], speed:0.6, life:25, size:2.5, gravity:-0.04 } },
  ],
  clubs: [
    // Row 1
    { id:'club_classic',  name:'Classic Iron',      power:1.0, accuracy:1.0,  price:0,    rarity:'common',
      shaftColor:'#aaaaaa', shaftAccent:null, headColor:'#c0c0c0', headAccent:'#888', headShape:'iron', glow:null },
    { id:'club_flame',    name:'Flame Driver',      power:1.3, accuracy:0.85, price:100,  rarity:'common',
      shaftColor:'#333', shaftAccent:'#ff2200', headColor:'#cc2200', headAccent:'#ff8800', headShape:'driver', glow:'#ff4400' },
    { id:'club_camo',     name:'Camo Iron',         power:1.1, accuracy:0.95, price:100,  rarity:'common',
      shaftColor:'#3a5a2a', shaftAccent:'#5a8a3a', headColor:'#4a7a32', headAccent:'#2a5a12', headShape:'driver', glow:null },
    { id:'club_neon',     name:'Neon Putter',       power:1.0, accuracy:1.15, price:150,  rarity:'rare',
      shaftColor:'#333', shaftAccent:null, headColor:'#0066cc', headAccent:'#00ccff', headShape:'iron', glow:'#00ccff' },
    // Row 2
    { id:'club_wooden',   name:'Wooden Club',       power:1.15, accuracy:0.9, price:100,  rarity:'common',
      shaftColor:'#8B5A2B', shaftAccent:'#a07040', headColor:'#a07030', headAccent:'#c8943e', headShape:'driver', glow:null },
    { id:'club_galaxy',   name:'Galaxy Putter',     power:1.0, accuracy:1.2,  price:300,  rarity:'rare',
      shaftColor:'#5511aa', shaftAccent:'#8833cc', headColor:'#7722bb', headAccent:'#cc66ff', headShape:'putter', glow:'#aa44ee' },
    { id:'club_thunder',  name:'Thunder Iron',      power:1.4, accuracy:0.8,  price:300,  rarity:'rare',
      shaftColor:'#222', shaftAccent:'#ffd700', headColor:'#333', headAccent:'#ffd700', headShape:'iron', glow:'#ffd700' },
    { id:'club_candy',    name:'Candy Cane',        power:0.9, accuracy:1.1,  price:200,  rarity:'rare',
      shaftColor:'#ff3333', shaftAccent:'#ffffff', headColor:'#ff4466', headAccent:'#ffffff', headShape:'putter', shaftPattern:'striped', glow:null },
    // Row 3
    { id:'club_fossil',   name:'Fossil Wedge',      power:1.2, accuracy:0.95, price:200,  rarity:'rare',
      shaftColor:'#6a5a4a', shaftAccent:'#8a7a6a', headColor:'#8a7a6a', headAccent:'#5a4a3a', headShape:'wedge', glow:null },
    { id:'club_ice',      name:'Ice Putter',        power:1.0, accuracy:1.25, price:400,  rarity:'epic',
      shaftColor:'#88ccee', shaftAccent:'#aaeeff', headColor:'#66bbdd', headAccent:'#ccf0ff', headShape:'putter', glow:'#88ddff' },
    { id:'club_tiki',     name:'Tiki Club',         power:1.1, accuracy:1.0,  price:400,  rarity:'epic',
      shaftColor:'#228833', shaftAccent:'#ff4444', headColor:'#b8882e', headAccent:'#daa530', headShape:'driver', glow:null },
    { id:'club_skull',    name:'Skull Driver',      power:1.5, accuracy:0.7,  price:500,  rarity:'epic',
      shaftColor:'#222', shaftAccent:'#ff6600', headColor:'#1a1a1a', headAccent:'#ff4400', headShape:'driver', glow:'#ff4400' },
    // Row 4
    { id:'club_royal',    name:'Royal Putter',      power:1.0, accuracy:1.3,  price:500,  rarity:'epic',
      shaftColor:'#b8860b', shaftAccent:'#ffd700', headColor:'#daa520', headAccent:'#ffd700', headShape:'putter', glow:'#ffd700' },
    { id:'club_alien',    name:'Alien Driver',      power:1.3, accuracy:1.0,  price:600,  rarity:'epic',
      shaftColor:'#333', shaftAccent:'#8833cc', headColor:'#2a8833', headAccent:'#44dd55', headShape:'driver', glow:'#33ff44' },
    { id:'club_sports',   name:'Sports Club',       power:1.2, accuracy:1.1,  price:null, rarity:'legendary', achievement:'ach_100holes',
      shaftColor:'#cc3333', shaftAccent:'#ffffff', headColor:'#cc2222', headAccent:'#ffffff', headShape:'iron', glow:null },
    { id:'club_gilmore',  name:'Gilmore Special',   power:1.8, accuracy:0.6,  price:null, rarity:'legendary', achievement:'ach_gilmore',
      shaftColor:'#1a6a5a', shaftAccent:'#ffd700', headColor:'#22ccaa', headAccent:'#ffd700', headShape:'driver', glow:'#22ccaa' },
  ],
  effects: [
    { id:'fx_none',     name:'None',          price:0,    rarity:'common' },
    { id:'fx_spark',    name:'Spark Trail',   price:100,  rarity:'common' },
    { id:'fx_flame',    name:'Flame Trail',   price:200,  rarity:'rare' },
    { id:'fx_ice',      name:'Ice Trail',     price:200,  rarity:'rare' },
    { id:'fx_rainbow',  name:'Rainbow Trail', price:400,  rarity:'epic' },
    { id:'fx_stardust', name:'Stardust',      price:null, rarity:'legendary', achievement:'ach_perfect' },
  ]
};

// ‚îÄ‚îÄ‚îÄ DATA: ACHIEVEMENTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Each achievement has an ID, display info, and what triggers it.
// Rewards can be credits, cosmetic unlocks, or both.
const AchievementsDef = [
  { id:'ach_first_hole',    name:'First Putt',        desc:'Complete your first hole',           icon:'‚õ≥', reward:50,  check: s => s.holesPlayed >= 1 },
  { id:'ach_10holes',       name:'Getting Warmed Up',  desc:'Complete 10 holes',                  icon:'üèåÔ∏è', reward:100, check: s => s.holesPlayed >= 10 },
  { id:'ach_100holes',      name:'Course Veteran',     desc:'Complete 100 holes',                 icon:'üèÜ', reward:500, check: s => s.holesPlayed >= 100 },
  { id:'ach_first_hio',     name:'Ace!',               desc:'Get your first hole-in-one',         icon:'üéØ', reward:200, check: s => s.holeInOnes >= 1 },
  { id:'ach_10_hio',        name:'Ace Machine',        desc:'Get 10 hole-in-ones',                icon:'üíé', reward:500, check: s => s.holeInOnes >= 10 },
  { id:'ach_expert',        name:'Expert Golfer',      desc:'Complete Expert difficulty',          icon:'üî•', reward:1000, check: s => s.difficultiesCompleted.expert },
  { id:'ach_tourney_hard',  name:'Hard Champion',      desc:'Win a tournament on Hard+',           icon:'üëë', reward:800, check: s => s.tournamentsWon >= 1 },
  { id:'ach_perfect',       name:'Flawless',           desc:'Complete a course with no resets',    icon:'‚ú®', reward:600, check: s => s.perfectCourses >= 1 },
  { id:'ach_gilmore',       name:'Happy Gilmore!',     desc:'Complete Happy Gilmore mode',         icon:'üèí', reward:400, check: s => s.difficultiesCompleted.happygilmore },
  { id:'ach_streak5',       name:'On Fire',            desc:'Win 5 tournaments in a row',          icon:'üî•', reward:1000, check: s => s.bestWinStreak >= 5 },
];

// ‚îÄ‚îÄ‚îÄ DATA: CREDIT ECONOMY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// This is the exact reward formula. Each component is calculated separately
// then summed. The difficulty multiplier scales everything up for harder modes.
//
// FORMULA:
//   Total = floor((BaseReward + ScoreBonus + SpecialBonuses) √ó DifficultyMultiplier)
//
// BaseReward       = 20 per hole completed
// ScoreBonus       = max(0, (par - strokes) √ó 15)    ‚Üê rewards under-par play
// HoleInOneBonus   = 100 (if strokes === 1)
// BirdieBonus      = 30  (if strokes === par - 1)
// EagleBonus       = 60  (if strokes === par - 2 and strokes > 1)
// AlbatrossBonus   = 120 (if strokes <= par - 3 and strokes > 1)
// TourneyWinBonus  = 500
// TourneyPlaceBonus= [500, 250, 100, 50][placement] for top 4
// WinStreakBonus    = streak √ó 20 (capped at 200)
//
// DifficultyMultiplier = { easy:1.0, medium:1.5, hard:2.0, expert:3.0 }
//
// ANTI-EXPLOIT:
// - Max credits per hole capped at 500 (before multiplier)
// - Minimum 1 stroke required (can't skip)
// - Reset penalty: each reset costs -10 from that hole's reward
const CreditEconomy = {
  DIFF_MULTIPLIER: { easy:1.0, medium:1.5, hard:2.0, expert:3.0 },
  MAX_PER_HOLE: 500,

  calcHoleReward(strokes, par, difficulty, resets) {
    let base = 20;                                        // Base reward for completing
    let scoreBonus = Math.max(0, (par - strokes) * 15);   // Under-par bonus
    let special = 0;

    // Special bonuses (only one applies ‚Äî best one)
    if (strokes === 1) {
      special = 100;   // Hole-in-one
    } else if (strokes <= par - 3) {
      special = 120;   // Albatross or better
    } else if (strokes === par - 2) {
      special = 60;    // Eagle
    } else if (strokes === par - 1) {
      special = 30;    // Birdie
    }

    let subtotal = base + scoreBonus + special;
    subtotal -= resets * 10;                               // Reset penalty
    subtotal = Math.min(subtotal, this.MAX_PER_HOLE);      // Anti-exploit cap
    subtotal = Math.max(subtotal, 5);                       // Minimum 5 credits

    const mult = this.DIFF_MULTIPLIER[difficulty] || 1;
    return Math.floor(subtotal * mult);
  },

  calcTournamentBonus(placement, difficulty) {
    const placementRewards = [500, 250, 100, 50];
    const base = placementRewards[placement] || 0;
    const mult = this.DIFF_MULTIPLIER[difficulty] || 1;
    return Math.floor(base * mult);
  },

  calcWinStreakBonus(streak) {
    return Math.min(streak * 20, 200);
  },

  // Returns breakdown object for display
  getBreakdown(strokes, par, difficulty, resets) {
    const bonuses = [];
    if (strokes === 1) bonuses.push('üéØ Hole-in-One! +100');
    else if (strokes <= par - 3) bonuses.push('ü¶Ö Albatross! +120');
    else if (strokes === par - 2) bonuses.push('ü¶Ö Eagle! +60');
    else if (strokes === par - 1) bonuses.push('üê¶ Birdie! +30');
    if (strokes <= par) bonuses.push(`üìä Under/At Par +${Math.max(0,(par-strokes)*15)}`);
    if (resets > 0) bonuses.push(`‚ö†Ô∏è Resets: -${resets * 10}`);
    const total = this.calcHoleReward(strokes, par, difficulty, resets);
    const mult = this.DIFF_MULTIPLIER[difficulty];
    if (mult > 1) bonuses.push(`üî• ${mult}x Difficulty Bonus`);
    return { total, bonuses };
  }
};

// ‚îÄ‚îÄ‚îÄ DATA: LEVEL DEFINITIONS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Levels are JSON objects. Each defines: walls, hazards, tee position, hole position, par.
// The system generates 20 levels per difficulty procedurally from templates.
//
// LEVEL SCHEMA:
// {
//   id: number,
//   name: string,
//   theme: string,         // 'grass'|'desert'|'snow'|'neon'|'haunted'|'tropical'|'canyon'|'rooftop'|'volcano'|'space'
//   par: number,
//   tee: { x, y },        // Ball start position (normalized 0-1, scaled to canvas)
//   hole: { x, y, r },    // Hole position + radius
//   walls: [{ x1,y1, x2,y2 }],                    // Line segments
//   rects: [{ x,y, w,h }],                          // Rectangle obstacles
//   hazards: [{ type, x,y, w,h, ...extra }],        // sand, water, ice, lava, portal, fan, moving
//   decorations: [{ type, x,y, ...extra }],          // Visual only
// }

const THEMES = {
  grass:    { bg:'#1e5420', wall:'#6a4420', ground:'#2d7a2a', accent:'#8dd34a' },
  desert:   { bg:'#b8953a', wall:'#7a5520', ground:'#d0a850', accent:'#ffb020' },
  snow:     { bg:'#b0c8d8', wall:'#5a6a7a', ground:'#d0e0ee', accent:'#88bbee' },
  neon:     { bg:'#120828', wall:'#cc00cc', ground:'#1a0a38', accent:'#00ffee' },
  haunted:  { bg:'#151528', wall:'#5a3570', ground:'#1e1240', accent:'#bb44ee' },
  tropical: { bg:'#126a52', wall:'#8a5a22', ground:'#1a8a62', accent:'#ffe040' },
  canyon:   { bg:'#7a3a1a', wall:'#4a2008', ground:'#9a4a28', accent:'#ff6622' },
  rooftop:  { bg:'#2a3848', wall:'#5a6878', ground:'#3a4858', accent:'#78a0b8' },
  volcano:  { bg:'#2a0808', wall:'#8a2208', ground:'#3a1208', accent:'#ff4400' },
  space:    { bg:'#080818', wall:'#3a3a5a', ground:'#101028', accent:'#7c4dff' },
  castle:   { bg:'#2a2a3a', wall:'#6a6a7a', ground:'#3a3a4a', accent:'#c0c0d0' },
  pirate:   { bg:'#1a3040', wall:'#6a4a20', ground:'#2a4a5a', accent:'#ddaa44' },
  pyramid:  { bg:'#c4a848', wall:'#8a6a30', ground:'#d8b860', accent:'#fff0a0' },
  monster:  { bg:'#1a2810', wall:'#4a6030', ground:'#2a3818', accent:'#88ff44' },
  dragon:   { bg:'#280808', wall:'#882200', ground:'#3a1010', accent:'#ff6600' },
  dungeon:  { bg:'#101018', wall:'#4a4a5a', ground:'#181820', accent:'#6688aa' },
};

// Theme decorations ‚Äî drawn as emojis/shapes on the course
const THEME_DECORATIONS = {
  castle:  { emojis: ['üè∞','‚öîÔ∏è','üõ°Ô∏è','üó°Ô∏è','üëë'], decor: 'flags' },
  pirate:  { emojis: ['üè¥‚Äç‚ò†Ô∏è','‚öì','ü¶ú','üí∞','üó∫Ô∏è'], decor: 'waves' },
  pyramid: { emojis: ['üè∫','üê´','üêç','‚òÄÔ∏è','ü™≤'],   decor: 'sand' },
  monster: { emojis: ['üëæ','üßü','üï∑Ô∏è','ü¶á','üíÄ'],   decor: 'fog' },
  dragon:  { emojis: ['üêâ','üî•','üíé','üèîÔ∏è','‚ö°'],   decor: 'lava' },
  dungeon: { emojis: ['üïØÔ∏è','üóùÔ∏è','üö™','üï∏Ô∏è','üíÄ'],  decor: 'dark' },
  haunted: { emojis: ['üëª','üéÉ','ü¶á','üï∏Ô∏è','üíÄ'],   decor: 'fog' },
  volcano: { emojis: ['üåã','üî•','üíé','‚òÑÔ∏è','ü™®'],   decor: 'lava' },
  space:   { emojis: ['üåü','üõ∏','ü™ê','‚òÑÔ∏è','üåå'],   decor: 'stars' },
  tropical:{ emojis: ['üå¥','ü¶©','üå∫','ü••','ü¶é'],   decor: 'leaves' },
};

const THEME_NAMES = Object.keys(THEMES);

// ‚îÄ‚îÄ COURSE BORDER ‚îÄ‚îÄ
// The playable area is inset from the canvas edges.
// This creates a visible border around every course.
// All positions (tee, hole, walls, hazards) live inside this border.
const BORDER = 0.05;  // 5% margin on each side (normalized 0-1)
const INNER_MIN = BORDER + 0.02;  // safe inner zone for placing objects
const INNER_MAX = 1 - BORDER - 0.02;

// Helper: test if two line segments intersect (used to protect hole-in-one paths)
function segmentsIntersect(ax1,ay1,ax2,ay2, bx1,by1,bx2,by2) {
  const d = (bx2-bx1)*(ay1-ay2) - (ax1-ax2)*(by2-by1);
  if (Math.abs(d) < 1e-10) return false;
  const t = ((by1-by2)*(ax1-bx1) + (bx2-bx1)*(ay1-by1)) / d;
  const u = ((ax1-ax2)*(ay1-by1) - (ay1-ay2)*(ax1-bx1)) / d;
  return t > 0 && t < 1 && u > 0 && u < 1;
}

// Helper: test if a line segment comes within "margin" distance of a point
function segmentNearPoint(x1,y1,x2,y2, px,py, margin) {
  const dx = x2-x1, dy = y2-y1;
  const len2 = dx*dx + dy*dy;
  if (len2 === 0) return Math.hypot(px-x1, py-y1) < margin;
  let t = ((px-x1)*dx + (py-y1)*dy) / len2;
  t = Math.max(0, Math.min(1, t));
  const nearX = x1 + t*dx, nearY = y1 + t*dy;
  return Math.hypot(px-nearX, py-nearY) < margin;
}

// Level generator ‚Äî creates 20 levels per difficulty.
// Higher difficulty = more walls, hazards, smaller hole, longer distance.
// GUARANTEES: 1) All content inside visible borders. 2) Direct tee‚Üíhole path is never
// blocked by a wall, so a hole-in-one is always theoretically possible.
function generateLevels(difficulty) {
  const diffConfig = {
    easy:   { wallCount:[2,4],  hazardCount:[0,1], holeSizeMult:1.3,  parBase:3, parVar:2  },
    medium: { wallCount:[3,6],  hazardCount:[1,2], holeSizeMult:1.0,  parBase:3, parVar:3  },
    hard:   { wallCount:[4,8],  hazardCount:[2,3], holeSizeMult:0.85, parBase:4, parVar:3  },
    expert: { wallCount:[5,10], hazardCount:[3,5], holeSizeMult:0.7,  parBase:4, parVar:4  },
  };
  const cfg = diffConfig[difficulty] || diffConfig.easy;
  const levels = [];

  // Seeded random for consistency
  let seed = difficulty.charCodeAt(0) * 1000;
  const rand = () => { seed = (seed * 16807) % 2147483647; return (seed - 1) / 2147483646; };
  const randInt = (a,b) => Math.floor(rand() * (b - a + 1)) + a;
  const randF = (a,b) => a + rand() * (b - a);

  for (let i = 0; i < 20; i++) {
    const theme = THEME_NAMES[i % THEME_NAMES.length];
    const par = cfg.parBase + randInt(0, cfg.parVar);

    // Place tee and hole INSIDE the border with minimum distance between them
    let tee, hole;
    do {
      tee  = { x: randF(INNER_MIN, 0.35), y: randF(0.6, INNER_MAX) };
      hole = { x: randF(0.55, INNER_MAX), y: randF(INNER_MIN, 0.4), r: 0.025 * cfg.holeSizeMult };
    } while (Math.hypot(hole.x - tee.x, hole.y - tee.y) < 0.3);

    // Generate walls ‚Äî each wall is checked against the tee‚Üíhole line.
    // If a wall blocks the direct shot, we reject it and try a new one.
    // This guarantees every level has a possible hole-in-one.
    const walls = [];
    const numWalls = randInt(cfg.wallCount[0], cfg.wallCount[1]);
    const HIO_MARGIN = 0.025;  // keep walls this far from the tee‚Üíhole line

    for (let w = 0; w < numWalls; w++) {
      let attempts = 0;
      let wall;
      do {
        const cx = randF(INNER_MIN, INNER_MAX);
        const cy = randF(INNER_MIN, INNER_MAX);
        const len = randF(0.08, 0.22);
        const angle = rand() * Math.PI;
        wall = {
          x1: cx - Math.cos(angle)*len/2, y1: cy - Math.sin(angle)*len/2,
          x2: cx + Math.cos(angle)*len/2, y2: cy + Math.sin(angle)*len/2
        };
        // Clamp wall endpoints inside the border
        wall.x1 = Math.max(BORDER, Math.min(1-BORDER, wall.x1));
        wall.y1 = Math.max(BORDER, Math.min(1-BORDER, wall.y1));
        wall.x2 = Math.max(BORDER, Math.min(1-BORDER, wall.x2));
        wall.y2 = Math.max(BORDER, Math.min(1-BORDER, wall.y2));
        attempts++;
      } while (
        attempts < 20 && (
          // Reject if wall crosses the tee‚Üíhole line
          segmentsIntersect(wall.x1,wall.y1,wall.x2,wall.y2, tee.x,tee.y,hole.x,hole.y) ||
          // Reject if wall is too close to the tee or hole
          segmentNearPoint(wall.x1,wall.y1,wall.x2,wall.y2, tee.x,tee.y, HIO_MARGIN) ||
          segmentNearPoint(wall.x1,wall.y1,wall.x2,wall.y2, hole.x,hole.y, HIO_MARGIN + hole.r)
        )
      );
      // Only add if we found a valid placement
      if (attempts < 20) {
        walls.push(wall);
      }
    }

    // Generate hazards (placed inside borders, NOT on tee or hole)
    const hazards = [];
    const hazardTypes = ['sand','water','sand','ice','water','lava','fan','moving','mud','boost','slope'];
    const numHaz = randInt(cfg.hazardCount[0], cfg.hazardCount[1]);
    for (let h = 0; h < numHaz; h++) {
      const type = hazardTypes[randInt(0, Math.min(h + 3, hazardTypes.length - 1))];
      const hw = randF(0.06, 0.13);
      const hh = randF(0.06, 0.10);
      const haz = {
        type,
        x: randF(INNER_MIN, INNER_MAX - hw),
        y: randF(INNER_MIN, INNER_MAX - hh),
        w: hw,
        h: hh
      };
      if (type === 'moving') {
        haz.dx = randF(-0.002, 0.002);
        haz.dy = randF(-0.002, 0.002);
      }
      if (type === 'fan') {
        haz.forceX = randF(-0.3, 0.3);
        haz.forceY = randF(-0.3, 0.3);
      }
      if (type === 'boost') {
        // Directional boost pad
        const bAng = rand() * Math.PI * 2;
        haz.forceX = Math.cos(bAng) * 0.5;
        haz.forceY = Math.sin(bAng) * 0.5;
        haz.w = randF(0.04, 0.08);
        haz.h = randF(0.04, 0.08);
      }
      if (type === 'slope') {
        // Gentle slope push
        const sAng = rand() * Math.PI * 2;
        haz.forceX = Math.cos(sAng) * 0.25;
        haz.forceY = Math.sin(sAng) * 0.25;
      }
      // Add croc to water hazards in hard/expert
      if (type === 'water' && (difficulty === 'hard' || difficulty === 'expert') && rand() > 0.5) {
        haz.croc = true;
      }
      hazards.push(haz);
    }

    // Add breakable walls on medium+ (with alternate path always available)
    if (difficulty !== 'easy' && rand() > 0.4) {
      const bwAngle = rand() * Math.PI;
      const bwCx = randF(0.25, 0.75);
      const bwCy = randF(0.25, 0.75);
      const bwLen = randF(0.06, 0.14);
      const bw = {
        x1: bwCx - Math.cos(bwAngle) * bwLen/2,
        y1: bwCy - Math.sin(bwAngle) * bwLen/2,
        x2: bwCx + Math.cos(bwAngle) * bwLen/2,
        y2: bwCy + Math.sin(bwAngle) * bwLen/2,
        breakable: true
      };
      // Don't block direct path
      if (!segmentsIntersect(bw.x1,bw.y1,bw.x2,bw.y2, tee.x,tee.y,hole.x,hole.y)) {
        walls.push(bw);
      }
    }

    // Portal pair for later levels
    if (i >= 10 && rand() > 0.5) {
      const p1 = { x: randF(INNER_MIN, 0.45), y: randF(INNER_MIN, INNER_MAX) };
      const p2 = { x: randF(0.55, INNER_MAX), y: randF(INNER_MIN, INNER_MAX) };
      hazards.push({ type:'portal', x:p1.x, y:p1.y, w:0.04, h:0.04, targetX:p2.x, targetY:p2.y });
      hazards.push({ type:'portal', x:p2.x, y:p2.y, w:0.04, h:0.04, targetX:p1.x, targetY:p1.y });
    }

    levels.push({
      id: i + 1,
      name: `Hole ${i+1}`,
      theme: THEME_NAMES[i % THEME_NAMES.length],
      par, tee, hole, walls, hazards,
      rects: [],
      decorations: []
    });
  }

  // Post-process: assign themed names, monsters, and decorations
  const THEMED_NAMES = {
    castle:  ['Drawbridge','Throne Room','Tower Keep','Knight\'s Court','Royal Garden'],
    pirate:  ['Shipwreck Cove','Treasure Island','Captain\'s Deck','Plank Walk','Skull Reef'],
    pyramid: ['Pharaoh\'s Tomb','Sand Temple','Sphinx Path','Oasis Run','Scarab Den'],
    monster: ['Swamp Thing','Spider Nest','Zombie Lawn','Bat Cave','Goblin Hole'],
    dragon:  ['Fire Pit','Dragon\'s Lair','Lava Bridge','Scale Ridge','Inferno Peak'],
    dungeon: ['Cell Block','Trap Room','Crypt','Torch Hallway','Bone Pit'],
    haunted: ['Ghost Alley','Witch\'s Brew','Graveyard Shift','Haunted Manor','Phantom Putt'],
    tropical:['Tiki Bar','Flamingo Bay','Coconut Cove','Reef Run','Jungle Path'],
    volcano: ['Lava Flow','Magma Court','Ash Field','Eruption','Crater Edge'],
    space:   ['Asteroid Belt','Nebula Nine','Space Station','Wormhole','Lunar Links'],
    neon:    ['Neon Alley','Cyber Grid','Glow Club','Pixel Path','Laser Lane'],
  };

  // Assign themed name and add monsters + decorations
  const themeKeys = ['castle','pirate','pyramid','monster','dragon','dungeon',
                     'haunted','tropical','volcano','space','neon','grass','desert','snow','canyon','rooftop'];
  for (let i = 0; i < 20; i++) {
    const theme = themeKeys[i % themeKeys.length];
    levels[i].theme = theme;
    const names = THEMED_NAMES[theme];
    if (names) levels[i].name = names[i % names.length];

    // Add theme-appropriate monsters on medium+ for themed levels
    const td = THEME_DECORATIONS[theme];
    if (td && difficulty !== 'easy') {
      const monsterEmojis = { monster:'üëæ', dragon:'üêâ', dungeon:'üíÄ', haunted:'üëª', pirate:'ü¶ú',
                               castle:'‚öîÔ∏è', pyramid:'üêç', volcano:'üåã', space:'üëΩ', tropical:'ü¶é' };
      const emoji = monsterEmojis[theme];
      if (emoji && rand() > 0.35) {
        levels[i].hazards.push({
          type: 'monster',
          x: randF(0.25, 0.65),
          y: randF(0.25, 0.65),
          w: 0.06, h: 0.06,
          speed: difficulty === 'expert' ? 0.0014 : difficulty === 'hard' ? 0.001 : 0.0006,
          emoji: emoji
        });
      }
    }

    // Add decorative emojis scattered on the course
    if (td) {
      const decos = [];
      const numDecos = 3 + Math.floor(rand() * 4);
      for (let d = 0; d < numDecos; d++) {
        decos.push({
          x: randF(INNER_MIN + 0.02, INNER_MAX - 0.02),
          y: randF(INNER_MIN + 0.02, INNER_MAX - 0.02),
          emoji: td.emojis[Math.floor(rand() * td.emojis.length)],
          size: 12 + Math.floor(rand() * 12)
        });
      }
      levels[i].decorations = decos;
    }
  }

  return levels;
}

// Happy Gilmore levels ‚Äî different tiers of chaos
function generateHappyGilmoreLevels(tier) {
  const tierConfig = {
    rookie:  { base: 'easy',   holes: 9,  extraHazards: 0, themes: ['grass','desert','canyon','rooftop'] },
    pro:     { base: 'medium', holes: 12, extraHazards: 1, themes: ['neon','canyon','rooftop','desert'] },
    legend:  { base: 'hard',   holes: 15, extraHazards: 2, themes: ['neon','volcano','space','haunted'] },
    chaos:   { base: 'expert', holes: 20, extraHazards: 3, themes: ['neon','volcano','space','haunted'] }
  };
  const cfg = tierConfig[tier] || tierConfig.pro;
  const allLevels = generateLevels(cfg.base);
  const levels = allLevels.slice(0, cfg.holes);

  const funNames = [
    'Parking Lot Par-Tee','Stadium Slugger','Ice Rink Putt','Batting Cage Bounce',
    'Highway Havoc','Roller Coaster Roll','Pinball Panic','Clown Town','Bouncy Castle',
    'Slapshot Serenade','Zamboni Zone','Bar Fight Birdie','Construction Chaos',
    'Trampoline Tee','Fireworks Finale','Bull Run','Cannon Alley','Wrecking Ball',
    'Hockey Rink Hero','Grand Slam Gilmore'
  ];
  levels.forEach((l, i) => {
    l.name = funNames[i] || `Gilmore ${i+1}`;
    l.theme = cfg.themes[i % cfg.themes.length];
    // Add chaos proportional to tier
    for (let e = 0; e < cfg.extraHazards; e++) {
      if (e === 0 || cfg.extraHazards >= 2) {
        l.hazards.push({ type:'fan', x:0.2+Math.random()*0.5, y:0.2+Math.random()*0.5, w:0.1, h:0.1,
          forceX: (Math.random()-0.5)*0.6, forceY: (Math.random()-0.5)*0.6 });
      }
      if (e >= 1) {
        l.hazards.push({ type:'moving', x:0.3+Math.random()*0.3, y:0.2+Math.random()*0.4, w:0.1, h:0.05,
          dx: (Math.random()-0.5)*0.006, dy: (Math.random()-0.5)*0.003 });
      }
      if (e >= 2) {
        const sAng = Math.random() * Math.PI * 2;
        l.hazards.push({ type:'boost', x:0.3+Math.random()*0.3, y:0.3+Math.random()*0.3, w:0.06, h:0.06,
          forceX: Math.cos(sAng)*0.5, forceY: Math.sin(sAng)*0.5 });
      }
    }
  });
  return levels;
}

// Pre-generate all level sets
const LevelSets = {
  easy:   generateLevels('easy'),
  medium: generateLevels('medium'),
  hard:   generateLevels('hard'),
  expert: generateLevels('expert'),
  gilmore_rookie: generateHappyGilmoreLevels('rookie'),
  gilmore_pro:    generateHappyGilmoreLevels('pro'),
  gilmore_legend: generateHappyGilmoreLevels('legend'),
  gilmore_chaos:  generateHappyGilmoreLevels('chaos'),
  happygilmore:   null // set dynamically
};

// ‚îÄ‚îÄ‚îÄ PHYSICS ENGINE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Fixed-timestep simulation at 60 FPS.
// Ball has: position (x,y), velocity (vx,vy), radius.
// Physics handles: movement, friction, wall collision (reflection), hazard effects.
const Physics = {
  TIMESTEP: 1/60,
  FRICTION: 0.985,           // Per-frame velocity multiplier (1 = no friction)
  RESTITUTION: 0.7,          // Bounce factor off walls
  BALL_RADIUS: 10,            // In pixels
  STOP_THRESHOLD: 0.15,      // Below this speed, ball stops
  SAND_FRICTION: 0.95,       // Much higher friction
  ICE_FRICTION: 0.998,       // Almost no friction
  MUD_FRICTION: 0.92,        // Very heavy friction
  BOOST_MULT: 1.4,           // Speed boost multiplier
  MAX_STROKES: 10,           // Max putts per hole

  // Update a single ball. Returns events array (e.g., ['water','hole'])
  update(ball, level, canvasW, canvasH) {
    const events = [];
    if (ball.sunk || ball.frozen) return events;

    // Apply velocity
    ball.x += ball.vx;
    ball.y += ball.vy;

    // Determine terrain under ball
    let friction = this.FRICTION;
    let onHazard = null;

    for (const h of level.hazards) {
      const hx = h.x * canvasW, hy = h.y * canvasH;
      const hw = h.w * canvasW, hh = h.h * canvasH;

      // Moving hazards update position (stay inside course border)
      if (h.type === 'moving') {
        h.x += h.dx;
        h.y += h.dy;
        if (h.x < BORDER + 0.01 || h.x + h.w > 1 - BORDER - 0.01) h.dx *= -1;
        if (h.y < BORDER + 0.01 || h.y + h.h > 1 - BORDER - 0.01) h.dy *= -1;
      }

      // Monster chase AI ‚Äî slowly pursues the nearest ball
      if (h.type === 'monster') {
        const mcx = (h.x + h.w/2) * canvasW, mcy = (h.y + h.h/2) * canvasH;
        const mdx = ball.x - mcx, mdy = ball.y - mcy;
        const mDist = Math.hypot(mdx, mdy);
        if (mDist > 5) {
          const mSpeed = h.speed || 0.0008;
          h.x += (mdx / mDist) * mSpeed;
          h.y += (mdy / mDist) * mSpeed;
        }
        h.x = Math.max(BORDER + 0.01, Math.min(1 - BORDER - h.w - 0.01, h.x));
        h.y = Math.max(BORDER + 0.01, Math.min(1 - BORDER - h.h - 0.01, h.y));
      }

      if (ball.x > hx && ball.x < hx + hw && ball.y > hy && ball.y < hy + hh) {
        onHazard = h;
        if (h.type === 'sand') friction = this.SAND_FRICTION;
        if (h.type === 'ice') friction = this.ICE_FRICTION;
        if (h.type === 'mud') friction = this.MUD_FRICTION;
        if (h.type === 'water') { events.push(h.croc ? 'croc' : 'water'); }
        if (h.type === 'lava') { events.push('water'); } // Lava = same as water mechanically
        if (h.type === 'fan') {
          ball.vx += h.forceX;
          ball.vy += h.forceY;
        }
        if (h.type === 'boost') {
          // Speed boost pad ‚Äî push ball in the arrow direction
          ball.vx += h.forceX * 0.4;
          ball.vy += h.forceY * 0.4;
          friction = this.FRICTION; // Normal friction on boost pads
        }
        if (h.type === 'slope') {
          // Gentle constant push in a direction
          ball.vx += h.forceX * 0.12;
          ball.vy += h.forceY * 0.12;
        }
        if (h.type === 'portal' && Math.hypot(ball.vx, ball.vy) > 0.5) {
          ball.x = h.targetX * canvasW;
          ball.y = h.targetY * canvasH;
          events.push('portal');
        }
        // Monster hazard ‚Äî resets ball like water
        if (h.type === 'monster') {
          events.push('monster');
        }
      }
    }

    // Apply friction
    ball.vx *= friction;
    ball.vy *= friction;

    // Wall collisions (COURSE BORDER ‚Äî the visible boundary)
    const r = this.BALL_RADIUS;
    const bL = BORDER * canvasW;
    const bR = (1 - BORDER) * canvasW;
    const bT = BORDER * canvasH;
    const bB = (1 - BORDER) * canvasH;

    if (ball.x - r < bL)  { ball.x = bL + r; ball.vx = Math.abs(ball.vx) * this.RESTITUTION; events.push('wall'); }
    if (ball.x + r > bR)  { ball.x = bR - r; ball.vx = -Math.abs(ball.vx) * this.RESTITUTION; events.push('wall'); }
    if (ball.y - r < bT)  { ball.y = bT + r; ball.vy = Math.abs(ball.vy) * this.RESTITUTION; events.push('wall'); }
    if (ball.y + r > bB)  { ball.y = bB - r; ball.vy = -Math.abs(ball.vy) * this.RESTITUTION; events.push('wall'); }

    // Level wall collisions (line segments)
    for (let wi = level.walls.length - 1; wi >= 0; wi--) {
      const w = level.walls[wi];
      const wx1 = w.x1 * canvasW, wy1 = w.y1 * canvasH;
      const wx2 = w.x2 * canvasW, wy2 = w.y2 * canvasH;
      const collision = this._lineCircleCollision(ball.x, ball.y, r, wx1, wy1, wx2, wy2);
      if (collision) {
        const speed = Math.hypot(ball.vx, ball.vy);

        // Breakable wall ‚Äî shatters if hit hard enough
        if (w.breakable && speed > 6) {
          // Shatter effect
          const mx = (wx1 + wx2) / 2, my = (wy1 + wy2) / 2;
          Particles.emit(mx, my, 18, {
            colors: ['#c8943e','#e0b060','#8a6a30','#fff'], speed: 5, life: 20, size: 3, spread: Math.PI*2, angle: 0, gravity: 0.08
          });
          level.walls.splice(wi, 1);
          // Ball loses some speed but continues through
          ball.vx *= 0.6;
          ball.vy *= 0.6;
          events.push('break');
          continue;
        }

        // Normal wall reflection
        const nx = collision.nx, ny = collision.ny;
        const dot = ball.vx * nx + ball.vy * ny;
        ball.vx -= 2 * dot * nx;
        ball.vy -= 2 * dot * ny;
        ball.vx *= this.RESTITUTION;
        ball.vy *= this.RESTITUTION;
        ball.x = collision.cx + nx * (r + 1);
        ball.y = collision.cy + ny * (r + 1);
        events.push('wall');
      }
    }

    // Check if ball is in the hole
    const holeX = level.hole.x * canvasW;
    const holeY = level.hole.y * canvasH;
    const hr = level.hole.r * canvasW;
    const dist = Math.hypot(ball.x - holeX, ball.y - holeY);
    const speed = Math.hypot(ball.vx, ball.vy);

    if (dist < hr) {
      // Ball is inside the hole ‚Äî always sinks!
      // Apply gravity pull toward center (stronger as ball enters)
      const pullStrength = 0.35;
      const dx = holeX - ball.x, dy = holeY - ball.y;
      ball.vx += dx * pullStrength;
      ball.vy += dy * pullStrength;
      // Heavy deceleration inside the hole
      ball.vx *= 0.6;
      ball.vy *= 0.6;
      // Snap to center once slow enough or close enough
      if (speed < 12 || dist < hr * 0.5) {
        ball.sunk = true;
        ball.x = holeX;
        ball.y = holeY;
        ball.vx = 0;
        ball.vy = 0;
        events.push('hole');
      }
    } else if (dist < hr * 1.5) {
      // Near the hole ‚Äî gentle gravity pull draws ball toward center
      const pullNear = 0.06;
      ball.vx += (holeX - ball.x) / dist * pullNear * speed;
      ball.vy += (holeY - ball.y) / dist * pullNear * speed;
    }

    // Stop if moving very slowly
    if (speed < this.STOP_THRESHOLD) {
      ball.vx = 0;
      ball.vy = 0;
    }

    return events;
  },

  // Ball-ball collision for multiplayer
  collideBalls(a, b) {
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const dist = Math.hypot(dx, dy);
    const minDist = this.BALL_RADIUS * 2;
    if (dist < minDist && dist > 0) {
      // Elastic collision
      const nx = dx / dist, ny = dy / dist;
      const relVx = a.vx - b.vx, relVy = a.vy - b.vy;
      const relDot = relVx * nx + relVy * ny;
      if (relDot > 0) {
        a.vx -= relDot * nx;
        a.vy -= relDot * ny;
        b.vx += relDot * nx;
        b.vy += relDot * ny;
        // Separate
        const overlap = minDist - dist;
        a.x -= nx * overlap / 2;
        a.y -= ny * overlap / 2;
        b.x += nx * overlap / 2;
        b.y += ny * overlap / 2;
      }
      return true;
    }
    return false;
  },

  // Line-circle collision detection. Returns { cx, cy, nx, ny } or null.
  _lineCircleCollision(cx, cy, r, x1, y1, x2, y2) {
    const dx = x2 - x1, dy = y2 - y1;
    const len2 = dx*dx + dy*dy;
    if (len2 === 0) return null;
    let t = ((cx - x1)*dx + (cy - y1)*dy) / len2;
    t = Math.max(0, Math.min(1, t));
    const nearX = x1 + t*dx, nearY = y1 + t*dy;
    const dist = Math.hypot(cx - nearX, cy - nearY);
    if (dist < r) {
      const nx = (cx - nearX) / dist, ny = (cy - nearY) / dist;
      return { cx: nearX, cy: nearY, nx, ny };
    }
    return null;
  },

  isMoving(ball) {
    return Math.hypot(ball.vx, ball.vy) > this.STOP_THRESHOLD;
  }
};

// ‚îÄ‚îÄ‚îÄ PARTICLE SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Lightweight particle emitter for hit effects, trails, and celebrations.
const Particles = {
  pool: [],
  MAX: 300,

  emit(x, y, count, config) {
    for (let i = 0; i < count && this.pool.length < this.MAX; i++) {
      const angle = config.angle != null ? config.angle + (Math.random()-0.5)*config.spread : Math.random()*Math.PI*2;
      const speed = config.speed * (0.5 + Math.random()*0.5);
      this.pool.push({
        x, y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: config.life || 30,
        maxLife: config.life || 30,
        color: config.colors[Math.floor(Math.random() * config.colors.length)],
        size: config.size || 3,
        gravity: config.gravity || 0,
      });
    }
  },

  update() {
    for (let i = this.pool.length - 1; i >= 0; i--) {
      const p = this.pool[i];
      p.x += p.vx;
      p.y += p.vy;
      p.vy += p.gravity;
      p.vx *= 0.97;
      p.vy *= 0.97;
      p.life--;
      if (p.life <= 0) this.pool.splice(i, 1);
    }
  },

  draw(ctx) {
    for (const p of this.pool) {
      const alpha = p.life / p.maxLife;
      ctx.globalAlpha = alpha;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  },

  clear() { this.pool.length = 0; },

  // Preset effects
  hitEffect(x, y, effectId) {
    const presets = {
      'fx_none':    { count:8,  colors:['#fff','#ddd'],                       speed:3, life:20, size:2, spread:Math.PI*2 },
      'fx_spark':   { count:15, colors:['#ffd700','#ffaa00','#fff'],           speed:5, life:25, size:3, spread:Math.PI*2 },
      'fx_flame':   { count:15, colors:['#ff4400','#ff8800','#ffcc00'],        speed:4, life:30, size:4, spread:Math.PI*2, gravity:-0.1 },
      'fx_ice':     { count:15, colors:['#88ddff','#aaeeff','#ffffff'],        speed:3, life:35, size:3, spread:Math.PI*2 },
      'fx_rainbow': { count:20, colors:['#ff0000','#ff8800','#ffff00','#00ff00','#0088ff','#8800ff'], speed:5, life:30, size:3, spread:Math.PI*2 },
      'fx_stardust':{ count:25, colors:['#ffd700','#fff','#ffe0a0'],           speed:4, life:40, size:2.5, spread:Math.PI*2, gravity:-0.05 },
    };
    const cfg = presets[effectId] || presets['fx_none'];
    this.emit(x, y, cfg.count, cfg);
  },

  trailEffect(x, y, effectId, ballId) {
    // Ball-specific trail (always active when ball is moving)
    if (ballId) {
      const ballInfo = CosmeticsCatalog.balls.find(b => b.id === ballId);
      if (ballInfo && ballInfo.trail) {
        const bt = ballInfo.trail;
        this.emit(x, y, 1, { colors: bt.colors, speed: bt.speed, life: bt.life, size: bt.size, gravity: bt.gravity || 0, spread: Math.PI * 2, angle: 0 });
      }
    }
    // Additional equipped trail effect stacks on top
    if (effectId === 'fx_none') return;
    const presets = {
      'fx_spark':   { colors:['#ffd700'], speed:0.5, life:10, size:1.5 },
      'fx_flame':   { colors:['#ff4400','#ff8800'], speed:0.3, life:12, size:2, gravity:-0.05 },
      'fx_ice':     { colors:['#88ddff','#fff'], speed:0.3, life:15, size:1.5 },
      'fx_rainbow': { colors:['#ff0000','#ff8800','#ffff00','#00ff00','#0088ff'], speed:0.2, life:12, size:2 },
      'fx_stardust':{ colors:['#ffd700','#fff'], speed:0.5, life:18, size:1, gravity:-0.03 },
    };
    const cfg = presets[effectId] || null;
    if (!cfg) return;
    this.emit(x, y, 1, { ...cfg, spread: Math.PI * 2, angle: 0 });
  },

  celebration(x, y) {
    this.emit(x, y, 40, {
      colors: ['#ffd700','#ff4444','#39ff14','#00d4ff','#ff2eaa','#fff'],
      speed: 6, life: 50, size: 4, spread: Math.PI * 2, angle: 0, gravity: 0.08
    });
  }
};

// ‚îÄ‚îÄ‚îÄ RENDERER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Draws everything to the canvas: course, ball, hole, hazards, UI overlays.
const Renderer = {
  canvas: null,
  ctx: null,

  init() {
    this.canvas = document.getElementById('gameCanvas');
    this.ctx = this.canvas.getContext('2d');
    this.resize();
    window.addEventListener('resize', () => this.resize());
  },

  resize() {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
  },

  get W() { return this.canvas.width; },
  get H() { return this.canvas.height; },

  clear(theme) {
    const t = THEMES[theme] || THEMES.grass;
    const W = this.W, H = this.H;
    const ctx = this.ctx;
    const bL = BORDER * W, bT = BORDER * H;
    const bW = (1 - 2*BORDER) * W, bH = (1 - 2*BORDER) * H;

    // ‚îÄ‚îÄ OUTER FRAME (dark surround) ‚îÄ‚îÄ
    ctx.fillStyle = '#040608';
    ctx.fillRect(0, 0, W, H);
    // Subtle vignette gradient on outer area
    const vig = ctx.createRadialGradient(W/2, H/2, Math.min(W,H)*0.3, W/2, H/2, Math.max(W,H)*0.7);
    vig.addColorStop(0, 'rgba(20,25,40,0)');
    vig.addColorStop(1, 'rgba(0,0,0,0.5)');
    ctx.fillStyle = vig;
    ctx.fillRect(0, 0, W, H);

    // ‚îÄ‚îÄ PLAYABLE AREA BASE ‚îÄ‚îÄ
    // Multi-stop gradient for depth
    const bgGrad = ctx.createRadialGradient(bL + bW/2, bT + bH/2, 0, bL + bW/2, bT + bH/2, Math.max(bW,bH)*0.7);
    bgGrad.addColorStop(0, t.ground);
    bgGrad.addColorStop(0.6, t.bg);
    bgGrad.addColorStop(1, t.bg);
    ctx.fillStyle = bgGrad;
    ctx.fillRect(bL, bT, bW, bH);

    // ‚îÄ‚îÄ TERRAIN TEXTURE ‚îÄ‚îÄ
    ctx.save();
    ctx.beginPath();
    ctx.rect(bL, bT, bW, bH);
    ctx.clip();

    // Layer 1: Large soft blotches for color variation
    ctx.globalAlpha = 0.12;
    for (let i = 0; i < 20; i++) {
      const x = bL + ((i * 237.7 + 31) % bW);
      const y = bT + ((i * 173.1 + 47) % bH);
      const sz = 30 + (i % 7) * 10;
      const rg = ctx.createRadialGradient(x, y, 0, x, y, sz);
      rg.addColorStop(0, t.ground);
      rg.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = rg;
      ctx.fillRect(x - sz, y - sz, sz * 2, sz * 2);
    }

    // Layer 2: Fine grain texture dots
    ctx.globalAlpha = 0.08;
    ctx.fillStyle = t.accent;
    for (let i = 0; i < 120; i++) {
      const x = bL + ((i * 97.3 + 17) % bW);
      const y = bT + ((i * 67.9 + 23) % bH);
      ctx.beginPath();
      ctx.arc(x, y, 1 + (i % 3), 0, Math.PI * 2);
      ctx.fill();
    }

    // Layer 3: Subtle grid lines for depth perception
    ctx.globalAlpha = 0.04;
    ctx.strokeStyle = t.accent;
    ctx.lineWidth = 0.5;
    const gridSize = 40;
    for (let x = bL; x < bL + bW; x += gridSize) {
      ctx.beginPath();
      ctx.moveTo(x, bT);
      ctx.lineTo(x, bT + bH);
      ctx.stroke();
    }
    for (let y = bT; y < bT + bH; y += gridSize) {
      ctx.beginPath();
      ctx.moveTo(bL, y);
      ctx.lineTo(bL + bW, y);
      ctx.stroke();
    }

    ctx.restore();
    ctx.globalAlpha = 1;

    // ‚îÄ‚îÄ INNER AMBIENT LIGHT ‚îÄ‚îÄ (soft center glow)
    const amb = ctx.createRadialGradient(bL + bW/2, bT + bH * 0.4, 0, bL + bW/2, bT + bH/2, Math.max(bW,bH) * 0.5);
    amb.addColorStop(0, 'rgba(255,255,255,0.04)');
    amb.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = amb;
    ctx.fillRect(bL, bT, bW, bH);

    // ‚îÄ‚îÄ COURSE BORDER (3D beveled look) ‚îÄ‚îÄ
    // Drop shadow outside border
    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,0.6)';
    ctx.shadowBlur = 12;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 2;
    ctx.strokeStyle = t.wall;
    ctx.lineWidth = 8;
    ctx.lineJoin = 'round';
    ctx.strokeRect(bL, bT, bW, bH);
    ctx.restore();

    // Main border
    ctx.strokeStyle = t.wall;
    ctx.lineWidth = 7;
    ctx.lineJoin = 'round';
    ctx.strokeRect(bL, bT, bW, bH);

    // Highlight edge (top & left ‚Äî simulates light from top-left)
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(bL, bT + bH);
    ctx.lineTo(bL, bT);
    ctx.lineTo(bL + bW, bT);
    ctx.stroke();
    ctx.globalAlpha = 1;

    // Shadow edge (bottom & right)
    ctx.globalAlpha = 0.3;
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(bL + bW, bT);
    ctx.lineTo(bL + bW, bT + bH);
    ctx.lineTo(bL, bT + bH);
    ctx.stroke();
    ctx.globalAlpha = 1;

    // Inner accent line
    ctx.strokeStyle = t.accent;
    ctx.lineWidth = 1.5;
    ctx.globalAlpha = 0.4;
    ctx.strokeRect(bL + 4, bT + 4, bW - 8, bH - 8);
    ctx.globalAlpha = 1;

    // Corner jewels
    const corners = [[bL,bT],[bL+bW,bT],[bL+bW,bT+bH],[bL,bT+bH]];
    for (const [cx,cy] of corners) {
      // Outer ring
      ctx.fillStyle = t.accent;
      ctx.beginPath();
      ctx.arc(cx, cy, 6, 0, Math.PI*2);
      ctx.fill();
      // Inner dot
      ctx.fillStyle = '#ffffff';
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.arc(cx, cy, 2.5, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  },

  drawLevel(level) {
    const ctx = this.ctx;
    const W = this.W, H = this.H;
    const t = THEMES[level.theme] || THEMES.grass;
    const time = Date.now() / 1000;

    // ‚îÄ‚îÄ HAZARDS ‚îÄ‚îÄ
    for (const h of level.hazards) {
      const hx = h.x * W, hy = h.y * H, hw = h.w * W, hh = h.h * H;
      ctx.save();

      if (h.type === 'sand') {
        // Sandy bunker with gradient and grain
        const sg = ctx.createRadialGradient(hx+hw/2, hy+hh/2, 0, hx+hw/2, hy+hh/2, Math.max(hw,hh)*0.7);
        sg.addColorStop(0, '#e0c060');
        sg.addColorStop(1, '#c49a38');
        ctx.fillStyle = sg;
        ctx.globalAlpha = 0.75;
        ctx.beginPath();
        ctx.ellipse(hx + hw/2, hy + hh/2, hw/2, hh/2, 0, 0, Math.PI*2);
        ctx.fill();
        // Sand grain dots
        ctx.fillStyle = '#b88828';
        ctx.globalAlpha = 0.4;
        for (let d = 0; d < 12; d++) {
          const dx = hx + hw * ((d * 0.37 + 0.1) % 1);
          const dy = hy + hh * ((d * 0.61 + 0.15) % 1);
          ctx.beginPath();
          ctx.arc(dx, dy, 1 + (d % 2), 0, Math.PI * 2);
          ctx.fill();
        }
        // Inner shadow
        ctx.globalAlpha = 0.15;
        ctx.strokeStyle = '#6a4a10';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(hx + hw/2, hy + hh/2, hw/2 - 2, hh/2 - 2, 0, 0, Math.PI*2);
        ctx.stroke();
      } else if (h.type === 'water') {
        // Animated water with waves
        const wg = ctx.createRadialGradient(hx+hw/2, hy+hh/2, 0, hx+hw/2, hy+hh/2, Math.max(hw,hh)*0.7);
        wg.addColorStop(0, '#3366cc');
        wg.addColorStop(1, '#1a3388');
        ctx.fillStyle = wg;
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.ellipse(hx + hw/2, hy + hh/2, hw/2, hh/2, 0, 0, Math.PI*2);
        ctx.fill();
        // Animated ripples
        ctx.strokeStyle = '#5599ee';
        ctx.lineWidth = 1;
        for (let r = 0; r < 3; r++) {
          const rr = (time * 0.5 + r * 0.33) % 1;
          ctx.globalAlpha = 0.3 * (1 - rr);
          ctx.beginPath();
          ctx.arc(hx + hw/2, hy + hh/2, Math.max(hw,hh) * 0.15 * (0.5 + rr * 0.5), 0, Math.PI * 2);
          ctx.stroke();
        }
        // Specular highlight
        ctx.globalAlpha = 0.15;
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.ellipse(hx + hw * 0.35, hy + hh * 0.35, hw * 0.15, hh * 0.1, -0.3, 0, Math.PI * 2);
        ctx.fill();
        // Croc indicator
        if (h.croc) {
          ctx.globalAlpha = 0.85;
          const cx = hx + hw/2, cy = hy + hh/2;
          ctx.fillStyle = '#2a7a2a';
          ctx.beginPath();
          ctx.ellipse(cx, cy - 3, 7, 4, 0, 0, Math.PI*2);
          ctx.fill();
          ctx.fillStyle = '#ffee00';
          ctx.beginPath(); ctx.arc(cx - 3, cy - 6, 2, 0, Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc(cx + 3, cy - 6, 2, 0, Math.PI*2); ctx.fill();
          ctx.fillStyle = '#111';
          ctx.beginPath(); ctx.arc(cx - 3, cy - 6, 0.8, 0, Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc(cx + 3, cy - 6, 0.8, 0, Math.PI*2); ctx.fill();
        }
      } else if (h.type === 'ice') {
        ctx.fillStyle = '#bbddff';
        ctx.globalAlpha = 0.5;
        ctx.fillRect(hx, hy, hw, hh);
        // Frost cracks
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 0.5;
        ctx.globalAlpha = 0.4;
        ctx.beginPath();
        ctx.moveTo(hx + hw*0.2, hy + hh*0.3);
        ctx.lineTo(hx + hw*0.5, hy + hh*0.5);
        ctx.lineTo(hx + hw*0.8, hy + hh*0.2);
        ctx.moveTo(hx + hw*0.5, hy + hh*0.5);
        ctx.lineTo(hx + hw*0.4, hy + hh*0.8);
        ctx.stroke();
        // Sparkle
        ctx.fillStyle = '#fff';
        ctx.globalAlpha = 0.3 + 0.2 * Math.sin(time * 3);
        ctx.beginPath();
        ctx.arc(hx + hw * 0.3, hy + hh * 0.3, 1.5, 0, Math.PI * 2);
        ctx.fill();
      } else if (h.type === 'lava') {
        const lg = ctx.createRadialGradient(hx+hw/2, hy+hh/2, 0, hx+hw/2, hy+hh/2, Math.max(hw,hh)*0.6);
        lg.addColorStop(0, '#ff6600');
        lg.addColorStop(1, '#cc1100');
        ctx.fillStyle = lg;
        ctx.globalAlpha = 0.7;
        ctx.fillRect(hx, hy, hw, hh);
        // Bubbling animation
        ctx.fillStyle = '#ffcc00';
        ctx.globalAlpha = 0.5;
        for (let b = 0; b < 3; b++) {
          const bx = hx + hw * ((Math.sin(time + b * 2) * 0.3) + 0.5);
          const by = hy + hh * ((Math.cos(time * 1.3 + b) * 0.3) + 0.5);
          const bs = 2 + Math.sin(time * 2 + b) * 1;
          ctx.beginPath();
          ctx.arc(bx, by, bs, 0, Math.PI * 2);
          ctx.fill();
        }
        // Heat glow
        ctx.globalAlpha = 0.15;
        ctx.shadowColor = '#ff4400';
        ctx.shadowBlur = 15;
        ctx.fillStyle = '#ff4400';
        ctx.fillRect(hx, hy, hw, hh);
        ctx.shadowBlur = 0;
      } else if (h.type === 'fan') {
        ctx.fillStyle = '#4a5a6a';
        ctx.globalAlpha = 0.5;
        ctx.fillRect(hx, hy, hw, hh);
        // Animated wind arrows
        ctx.strokeStyle = '#aaccee';
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.6;
        const mx = hx+hw/2, my = hy+hh/2;
        const fx = h.forceX * 35, fy = h.forceY * 35;
        for (let a = 0; a < 3; a++) {
          const offset = ((time * 2 + a * 0.6) % 1.8) - 0.9;
          const ax = mx + fx * offset;
          const ay = my + fy * offset;
          ctx.globalAlpha = 0.3 + 0.3 * (1 - Math.abs(offset));
          ctx.beginPath(); ctx.moveTo(ax - fx*0.15, ay - fy*0.15); ctx.lineTo(ax + fx*0.15, ay + fy*0.15); ctx.stroke();
          // Arrow tip
          const alen = 4;
          const aang = Math.atan2(fy, fx);
          ctx.beginPath();
          ctx.moveTo(ax + fx*0.15, ay + fy*0.15);
          ctx.lineTo(ax + fx*0.15 - Math.cos(aang-0.5)*alen, ay + fy*0.15 - Math.sin(aang-0.5)*alen);
          ctx.stroke();
        }
      } else if (h.type === 'portal') {
        // Swirling portal
        ctx.globalAlpha = 0.4 + 0.15 * Math.sin(time * 2);
        const pg = ctx.createRadialGradient(hx+hw/2, hy+hh/2, 0, hx+hw/2, hy+hh/2, hw/2);
        pg.addColorStop(0, '#dd88ff');
        pg.addColorStop(0.5, '#8800cc');
        pg.addColorStop(1, 'rgba(100,0,180,0)');
        ctx.fillStyle = pg;
        ctx.beginPath();
        ctx.arc(hx + hw/2, hy + hh/2, hw/2, 0, Math.PI*2);
        ctx.fill();
        // Spiral lines
        ctx.strokeStyle = '#dd88ff';
        ctx.lineWidth = 1.5;
        ctx.globalAlpha = 0.4;
        for (let s = 0; s < 2; s++) {
          ctx.beginPath();
          for (let a = 0; a < Math.PI * 2; a += 0.2) {
            const sr = hw * 0.05 + (a / (Math.PI*2)) * hw * 0.4;
            const sa = a + time * 2 + s * Math.PI;
            const sx = hx + hw/2 + Math.cos(sa) * sr;
            const sy = hy + hh/2 + Math.sin(sa) * sr;
            if (a === 0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
          }
          ctx.stroke();
        }
      } else if (h.type === 'moving') {
        ctx.fillStyle = t.wall;
        ctx.globalAlpha = 0.8;
        ctx.save();
        ctx.shadowColor = 'rgba(0,0,0,0.4)';
        ctx.shadowBlur = 6;
        ctx.shadowOffsetY = 2;
        ctx.fillRect(hx, hy, hw, hh);
        ctx.restore();
        ctx.strokeStyle = t.accent;
        ctx.lineWidth = 1;
        ctx.globalAlpha = 0.4;
        ctx.setLineDash([3, 3]);
        ctx.beginPath();
        ctx.moveTo(hx + hw/2, hy + hh/2);
        ctx.lineTo(hx + hw/2 + (h.speedX || 0) * W * 5, hy + hh/2 + (h.speedY || 0) * H * 5);
        ctx.stroke();
        ctx.setLineDash([]);
      } else if (h.type === 'mud') {
        // Dark muddy terrain
        const mg = ctx.createRadialGradient(hx+hw/2, hy+hh/2, 0, hx+hw/2, hy+hh/2, Math.max(hw,hh)*0.7);
        mg.addColorStop(0, '#5a3a1a');
        mg.addColorStop(1, '#3a2008');
        ctx.fillStyle = mg;
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.ellipse(hx + hw/2, hy + hh/2, hw/2, hh/2, 0, 0, Math.PI*2);
        ctx.fill();
        // Mud splatter dots
        ctx.fillStyle = '#4a2a0a';
        ctx.globalAlpha = 0.4;
        for (let d = 0; d < 8; d++) {
          const dx = hx + hw * ((d * 0.41 + 0.15) % 1);
          const dy = hy + hh * ((d * 0.67 + 0.2) % 1);
          ctx.beginPath();
          ctx.arc(dx, dy, 2 + (d % 3), 0, Math.PI*2);
          ctx.fill();
        }
        // Label
        ctx.globalAlpha = 0.3;
        ctx.font = '9px "Space Mono"';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#c89050';
        ctx.fillText('MUD', hx + hw/2, hy + hh/2 + 3);
      } else if (h.type === 'boost') {
        // Speed boost pad ‚Äî bright arrow
        ctx.globalAlpha = 0.5;
        const bg = ctx.createRadialGradient(hx+hw/2, hy+hh/2, 0, hx+hw/2, hy+hh/2, hw/2);
        bg.addColorStop(0, '#44ff88');
        bg.addColorStop(1, '#22aa44');
        ctx.fillStyle = bg;
        ctx.beginPath();
        ctx.ellipse(hx + hw/2, hy + hh/2, hw/2, hh/2, 0, 0, Math.PI*2);
        ctx.fill();
        // Arrow pointing in boost direction
        ctx.globalAlpha = 0.7;
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        const bAng = Math.atan2(h.forceY, h.forceX);
        const mx = hx + hw/2, my = hy + hh/2;
        const al = Math.min(hw, hh) * 0.3;
        ctx.beginPath();
        ctx.moveTo(mx - Math.cos(bAng)*al, my - Math.sin(bAng)*al);
        ctx.lineTo(mx + Math.cos(bAng)*al, my + Math.sin(bAng)*al);
        ctx.stroke();
        // Arrowhead
        ctx.beginPath();
        ctx.moveTo(mx + Math.cos(bAng)*al, my + Math.sin(bAng)*al);
        ctx.lineTo(mx + Math.cos(bAng+2.5)*al*0.5, my + Math.sin(bAng+2.5)*al*0.5);
        ctx.moveTo(mx + Math.cos(bAng)*al, my + Math.sin(bAng)*al);
        ctx.lineTo(mx + Math.cos(bAng-2.5)*al*0.5, my + Math.sin(bAng-2.5)*al*0.5);
        ctx.stroke();
        // Animated pulse ring
        const pulse = (time * 1.5) % 1;
        ctx.globalAlpha = 0.3 * (1 - pulse);
        ctx.strokeStyle = '#44ff88';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.ellipse(mx, my, hw/2 * (0.5+pulse*0.5), hh/2 * (0.5+pulse*0.5), 0, 0, Math.PI*2);
        ctx.stroke();
      } else if (h.type === 'slope') {
        // Slope zone ‚Äî gradient with chevrons
        const sAng = Math.atan2(h.forceY, h.forceX);
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = '#667788';
        ctx.beginPath();
        ctx.ellipse(hx + hw/2, hy + hh/2, hw/2, hh/2, 0, 0, Math.PI*2);
        ctx.fill();
        // Chevrons showing slope direction
        ctx.strokeStyle = '#99aabb';
        ctx.lineWidth = 1.5;
        ctx.globalAlpha = 0.4;
        const mx = hx + hw/2, my = hy + hh/2;
        for (let c = -1; c <= 1; c++) {
          const cx = mx + Math.cos(sAng) * c * 8;
          const cy = my + Math.sin(sAng) * c * 8;
          const perpX = Math.cos(sAng + Math.PI/2);
          const perpY = Math.sin(sAng + Math.PI/2);
          ctx.beginPath();
          ctx.moveTo(cx - perpX * 6, cy - perpY * 6);
          ctx.lineTo(cx + Math.cos(sAng) * 4, cy + Math.sin(sAng) * 4);
          ctx.lineTo(cx + perpX * 6, cy + perpY * 6);
          ctx.stroke();
        }
      }
      ctx.restore();
    }

    // ‚îÄ‚îÄ MONSTER HAZARDS ‚îÄ‚îÄ
    for (const h of level.hazards) {
      if (h.type !== 'monster') continue;
      const hx = h.x * W, hy = h.y * H, hw = h.w * W, hh = h.h * H;
      const cx = hx + hw/2, cy = hy + hh/2;
      const bounce = Math.sin(time * 3) * 3;
      ctx.save();
      ctx.translate(cx, cy + bounce);
      // Shadow
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.ellipse(0, hh/2 + 5, hw/2.5, 4, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
      // Monster emoji (based on theme decoration)
      const emoji = h.emoji || 'üëæ';
      const sz = Math.max(hw, hh) * 0.8;
      ctx.font = `${sz}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(emoji, 0, 0);
      // Red angry eyes glow
      ctx.shadowColor = '#ff0000';
      ctx.shadowBlur = 12 + Math.sin(time * 5) * 5;
      ctx.globalAlpha = 0.3;
      ctx.fillText(emoji, 0, 0);
      ctx.restore();
    }

    // ‚îÄ‚îÄ THEME DECORATIONS ‚îÄ‚îÄ
    const td = THEME_DECORATIONS[level.theme];
    if (td && level.decorations && level.decorations.length > 0) {
      ctx.save();
      for (const d of level.decorations) {
        const dx = d.x * W, dy = d.y * H;
        ctx.globalAlpha = 0.5;
        ctx.font = `${d.size || 16}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(d.emoji, dx, dy);
      }
      ctx.restore();
    }

    // ‚îÄ‚îÄ WALLS (3D beveled) ‚îÄ‚îÄ
    for (const w of level.walls) {
      const x1 = w.x1 * W, y1 = w.y1 * H, x2 = w.x2 * W, y2 = w.y2 * H;

      if (w.breakable) {
        // Breakable wall ‚Äî cracked/dashed with amber glow
        ctx.save();
        // Shadow
        ctx.strokeStyle = 'rgba(0,0,0,0.2)';
        ctx.lineWidth = 8;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(x1+1, y1+2);
        ctx.lineTo(x2+1, y2+2);
        ctx.stroke();
        // Main body ‚Äî dashed
        ctx.strokeStyle = '#c8943e';
        ctx.lineWidth = 6;
        ctx.setLineDash([6, 4]);
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        ctx.setLineDash([]);
        // Crack marks
        const mx = (x1+x2)/2, my = (y1+y2)/2;
        ctx.strokeStyle = '#5a3a10';
        ctx.lineWidth = 1;
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.moveTo(mx-3, my-4); ctx.lineTo(mx+2, my+3);
        ctx.moveTo(mx+4, my-2); ctx.lineTo(mx-1, my+4);
        ctx.stroke();
        // Amber glow hint
        ctx.globalAlpha = 0.15 + 0.08 * Math.sin(time * 2);
        ctx.shadowColor = '#ffaa00';
        ctx.shadowBlur = 10;
        ctx.strokeStyle = '#ffaa00';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(x1, y1); ctx.lineTo(x2, y2);
        ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
        // Label
        ctx.font = '7px "Space Mono"';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#ffcc44';
        ctx.globalAlpha = 0.5;
        ctx.fillText('üí•', mx, my - 6);
        ctx.globalAlpha = 1;
        ctx.restore();
        continue;
      }

      // Shadow under wall
      ctx.save();
      ctx.strokeStyle = 'rgba(0,0,0,0.3)';
      ctx.lineWidth = 9;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(x1 + 1, y1 + 2);
      ctx.lineTo(x2 + 1, y2 + 2);
      ctx.stroke();
      ctx.restore();

      // Main wall body
      ctx.strokeStyle = t.wall;
      ctx.lineWidth = 7;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();

      // Top highlight edge
      ctx.strokeStyle = 'rgba(255,255,255,0.2)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x1, y1 - 1);
      ctx.lineTo(x2, y2 - 1);
      ctx.stroke();

      // Accent glow
      ctx.strokeStyle = t.accent;
      ctx.lineWidth = 1.5;
      ctx.globalAlpha = 0.3;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      ctx.globalAlpha = 1;

      // End caps (small circles at wall endpoints)
      ctx.fillStyle = t.wall;
      ctx.beginPath();
      ctx.arc(x1, y1, 3.5, 0, Math.PI * 2);
      ctx.arc(x2, y2, 3.5, 0, Math.PI * 2);
      ctx.fill();
    }

    // ‚îÄ‚îÄ TEE MARKER ‚îÄ‚îÄ
    const tx = level.tee.x * W, ty = level.tee.y * H;
    // Tee circle
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(tx, ty, 12, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 0.15;
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(tx, ty, 16, 0, Math.PI * 2);
    ctx.stroke();
    ctx.globalAlpha = 1;

    // ‚îÄ‚îÄ HOLE (rich 3D look) ‚îÄ‚îÄ
    const holeCx = level.hole.x * W;
    const holeCy = level.hole.y * H;
    const holeR = level.hole.r * W;

    // Outer ring shadow
    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,0.5)';
    ctx.shadowBlur = 8;
    ctx.fillStyle = '#222';
    ctx.beginPath();
    ctx.arc(holeCx, holeCy, holeR + 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // Outer rim (silver ring)
    const rimGrad = ctx.createRadialGradient(holeCx - 2, holeCy - 2, holeR - 2, holeCx, holeCy, holeR + 4);
    rimGrad.addColorStop(0, '#666');
    rimGrad.addColorStop(0.5, '#999');
    rimGrad.addColorStop(1, '#444');
    ctx.fillStyle = rimGrad;
    ctx.beginPath();
    ctx.arc(holeCx, holeCy, holeR + 3, 0, Math.PI * 2);
    ctx.fill();

    // Hole interior (dark with depth gradient)
    const holeGrad = ctx.createRadialGradient(holeCx, holeCy, 0, holeCx, holeCy, holeR);
    holeGrad.addColorStop(0, '#000000');
    holeGrad.addColorStop(0.7, '#0a0a0a');
    holeGrad.addColorStop(1, '#222222');
    ctx.fillStyle = holeGrad;
    ctx.beginPath();
    ctx.arc(holeCx, holeCy, holeR, 0, Math.PI * 2);
    ctx.fill();

    // Rim highlight
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(holeCx, holeCy, holeR + 2, -Math.PI * 0.8, -Math.PI * 0.2);
    ctx.stroke();

    // ‚îÄ‚îÄ FLAG ‚îÄ‚îÄ
    const flagX = holeCx;
    const flagY = holeCy;
    const poleH = 28;
    const waveOffset = Math.sin(time * 3) * 2;

    // Pole shadow
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(flagX + 2, flagY - holeR - poleH + 2, 2, poleH);

    // Pole
    const poleGrad = ctx.createLinearGradient(flagX - 1, 0, flagX + 2, 0);
    poleGrad.addColorStop(0, '#eee');
    poleGrad.addColorStop(0.5, '#fff');
    poleGrad.addColorStop(1, '#bbb');
    ctx.fillStyle = poleGrad;
    ctx.fillRect(flagX - 0.5, flagY - holeR - poleH, 2, poleH);

    // Flag fabric (waving)
    const fTop = flagY - holeR - poleH;
    ctx.fillStyle = '#ee2222';
    ctx.beginPath();
    ctx.moveTo(flagX + 2, fTop);
    ctx.quadraticCurveTo(flagX + 9 + waveOffset, fTop + 3, flagX + 15 + waveOffset * 0.5, fTop + 6);
    ctx.quadraticCurveTo(flagX + 9 + waveOffset * 0.3, fTop + 9, flagX + 2, fTop + 12);
    ctx.closePath();
    ctx.fill();
    // Flag highlight
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.beginPath();
    ctx.moveTo(flagX + 2, fTop);
    ctx.quadraticCurveTo(flagX + 7 + waveOffset, fTop + 2, flagX + 10, fTop + 4);
    ctx.lineTo(flagX + 2, fTop + 5);
    ctx.closePath();
    ctx.fill();

    // Pole ball (top)
    ctx.fillStyle = '#ffd700';
    ctx.beginPath();
    ctx.arc(flagX + 0.5, fTop - 2, 2.5, 0, Math.PI * 2);
    ctx.fill();
  },

  drawBall(ball, cosmetic) {
    const ctx = this.ctx;
    const r = Physics.BALL_RADIUS;
    const info = CosmeticsCatalog.balls.find(b => b.id === cosmetic) || CosmeticsCatalog.balls[0];
    const t = Date.now() / 1000;

    ctx.save();

    // Ball shadow
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.beginPath();
    ctx.ellipse(ball.x + 2, ball.y + 3, r, r * 0.6, 0, 0, Math.PI*2);
    ctx.fill();

    // ‚îÄ‚îÄ Outer glow (before ball) ‚îÄ‚îÄ
    if (info.glow) {
      const ga = info.glowPulse ? (0.2 + 0.15 * Math.sin(t * 3)) : 0.25;
      const gs = info.glowPulse ? (r + 5 + Math.sin(t * 3) * 2) : (r + 5);
      ctx.globalAlpha = ga;
      ctx.shadowColor = info.glow;
      ctx.shadowBlur = 15;
      ctx.fillStyle = info.glow;
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, gs, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
    }

    // ‚îÄ‚îÄ Base ball (radial gradient) ‚îÄ‚îÄ
    const grad = ctx.createRadialGradient(ball.x - r*0.3, ball.y - r*0.3, r*0.1, ball.x, ball.y, r);
    grad.addColorStop(0, info.grad || info.base || '#fff');
    grad.addColorStop(1, info.base || '#ccc');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, r, 0, Math.PI * 2);
    ctx.fill();

    // ‚îÄ‚îÄ Pattern overlays ‚îÄ‚îÄ
    ctx.save();
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, r, 0, Math.PI * 2);
    ctx.clip();

    const pat = info.pattern;

    if (pat === 'dimples') {
      // Classic golf ball dimples
      ctx.fillStyle = 'rgba(0,0,0,0.08)';
      for (let i = 0; i < 8; i++) {
        const a = (i / 8) * Math.PI * 2;
        const dr = r * 0.6;
        ctx.beginPath();
        ctx.arc(ball.x + Math.cos(a) * dr, ball.y + Math.sin(a) * dr, 1.2, 0, Math.PI * 2);
        ctx.fill();
      }
    } else if (pat === 'flames') {
      // Animated flame streaks
      ctx.globalAlpha = 0.5;
      for (let i = 0; i < 4; i++) {
        const fa = t * 2 + i * 1.5;
        const fx = ball.x + Math.sin(fa) * r * 0.4;
        const fy = ball.y + Math.cos(fa) * r * 0.3;
        const fg = ctx.createRadialGradient(fx, fy, 0, fx, fy, r * 0.6);
        fg.addColorStop(0, '#ffcc00');
        fg.addColorStop(1, 'rgba(255,68,0,0)');
        ctx.fillStyle = fg;
        ctx.beginPath();
        ctx.arc(fx, fy, r * 0.6, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    } else if (pat === 'camo') {
      // Irregular camo blotches
      ctx.globalAlpha = 0.6;
      const spots = [[0.3,0.2,'#2a5a12'],[-0.2,0.4,'#6a9a52'],[0.4,-0.3,'#3a4a22'],[-0.3,-0.2,'#5a8a3a'],[0,-0.5,'#2a5a12']];
      for (const [ox, oy, c] of spots) {
        ctx.fillStyle = c;
        ctx.beginPath();
        ctx.ellipse(ball.x + ox * r, ball.y + oy * r, r * 0.45, r * 0.3, ox * 2, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    } else if (pat === 'chrome') {
      // Chrome/metallic reflection band
      ctx.globalAlpha = 0.4;
      const cg = ctx.createLinearGradient(ball.x - r, ball.y, ball.x + r, ball.y);
      cg.addColorStop(0, 'rgba(255,255,255,0)');
      cg.addColorStop(0.4, 'rgba(255,255,255,0.6)');
      cg.addColorStop(0.6, 'rgba(255,255,255,0.6)');
      cg.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = cg;
      ctx.fillRect(ball.x - r, ball.y - r, r * 2, r * 2);
      ctx.globalAlpha = 1;
    } else if (pat === 'woodgrain') {
      // Horizontal wood lines
      ctx.globalAlpha = 0.3;
      ctx.strokeStyle = '#6a4a20';
      ctx.lineWidth = 0.8;
      for (let i = -3; i <= 3; i++) {
        ctx.beginPath();
        ctx.moveTo(ball.x - r, ball.y + i * 2.5);
        ctx.quadraticCurveTo(ball.x, ball.y + i * 2.5 + Math.sin(i) * 1.5, ball.x + r, ball.y + i * 2.5);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
    } else if (pat === 'stars') {
      // Twinkling stars on dark background
      ctx.globalAlpha = 0.8;
      for (let i = 0; i < 6; i++) {
        const sa = i * 1.1 + t * 0.5;
        const sx = ball.x + Math.cos(sa * 3) * r * 0.6;
        const sy = ball.y + Math.sin(sa * 2) * r * 0.6;
        const ss = 0.5 + Math.sin(t * 3 + i) * 0.5;
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(sx, sy, ss, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    } else if (pat === 'bolt') {
      // Lightning bolt stamp
      ctx.fillStyle = '#ffd700';
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.moveTo(ball.x + 1, ball.y - r * 0.7);
      ctx.lineTo(ball.x - 2, ball.y);
      ctx.lineTo(ball.x + 1, ball.y - 1);
      ctx.lineTo(ball.x - 1, ball.y + r * 0.7);
      ctx.lineTo(ball.x + 2, ball.y);
      ctx.lineTo(ball.x - 1, ball.y + 1);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 1;
    } else if (pat === 'swirl') {
      // Candy swirl pattern
      ctx.globalAlpha = 0.5;
      for (let i = 0; i < 3; i++) {
        const sa = t + i * (Math.PI * 2 / 3);
        ctx.strokeStyle = i % 2 === 0 ? '#ffffff' : '#ff3399';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, r * (0.3 + i * 0.2), sa, sa + Math.PI * 1.2);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
    } else if (pat === 'cracks') {
      // Stone crack lines
      ctx.strokeStyle = '#4a4030';
      ctx.lineWidth = 0.8;
      ctx.globalAlpha = 0.6;
      const cracks = [[-0.5,-0.3,0.3,0.5],[0.2,-0.6,-0.1,0.4],[-0.3,0.1,0.6,-0.2]];
      for (const [x1,y1,x2,y2] of cracks) {
        ctx.beginPath();
        ctx.moveTo(ball.x + x1 * r, ball.y + y1 * r);
        ctx.lineTo(ball.x + x2 * r, ball.y + y2 * r);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
    } else if (pat === 'crystal') {
      // Ice crystal facets
      ctx.globalAlpha = 0.3;
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 0.8;
      for (let i = 0; i < 6; i++) {
        const a = i * Math.PI / 3;
        ctx.beginPath();
        ctx.moveTo(ball.x, ball.y);
        ctx.lineTo(ball.x + Math.cos(a) * r * 0.9, ball.y + Math.sin(a) * r * 0.9);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
    } else if (pat === 'beach') {
      // Beach ball colored segments
      const segs = ['#ff3333','#ffffff','#ffcc00','#ffffff','#3388ff','#ffffff'];
      for (let i = 0; i < segs.length; i++) {
        const a1 = (i / segs.length) * Math.PI * 2 + t * 0.3;
        const a2 = ((i + 1) / segs.length) * Math.PI * 2 + t * 0.3;
        ctx.fillStyle = segs[i];
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.moveTo(ball.x, ball.y);
        ctx.arc(ball.x, ball.y, r, a1, a2);
        ctx.closePath();
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    } else if (pat === 'ornate') {
      // Gold filigree circles
      ctx.strokeStyle = '#b8860b';
      ctx.lineWidth = 0.8;
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, r * 0.5, 0, Math.PI * 2);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, r * 0.75, 0, Math.PI * 2);
      ctx.stroke();
      for (let i = 0; i < 4; i++) {
        const a = i * Math.PI / 2 + t * 0.2;
        ctx.beginPath();
        ctx.arc(ball.x + Math.cos(a) * r * 0.6, ball.y + Math.sin(a) * r * 0.6, 1, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    } else if (pat === 'stitches') {
      // Baseball stitching
      ctx.strokeStyle = '#cc2222';
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.7;
      // Curved stitch line left
      for (let i = 0; i < 5; i++) {
        const sy = ball.y - r * 0.5 + i * (r * 0.25);
        ctx.beginPath();
        ctx.moveTo(ball.x - r * 0.35, sy);
        ctx.lineTo(ball.x - r * 0.15, sy);
        ctx.stroke();
      }
      // Curved stitch line right
      for (let i = 0; i < 5; i++) {
        const sy = ball.y - r * 0.5 + i * (r * 0.25);
        ctx.beginPath();
        ctx.moveTo(ball.x + r * 0.15, sy);
        ctx.lineTo(ball.x + r * 0.35, sy);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
    } else if (pat === 'runes') {
      // Mystic floating rune symbols
      ctx.globalAlpha = 0.5 + 0.2 * Math.sin(t * 2);
      ctx.strokeStyle = '#ffd700';
      ctx.lineWidth = 0.8;
      for (let i = 0; i < 3; i++) {
        const a = t * 0.5 + i * (Math.PI * 2 / 3);
        const rx = ball.x + Math.cos(a) * r * 0.5;
        const ry = ball.y + Math.sin(a) * r * 0.5;
        ctx.beginPath();
        ctx.moveTo(rx - 1.5, ry - 1.5);
        ctx.lineTo(rx + 1.5, ry + 1.5);
        ctx.moveTo(rx + 1.5, ry - 1.5);
        ctx.lineTo(rx - 1.5, ry + 1.5);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
    }

    ctx.restore(); // End pattern clip

    // ‚îÄ‚îÄ Detail overlays (on top of ball) ‚îÄ‚îÄ
    if (info.detail === 'skull') {
      // Mini skull face
      ctx.fillStyle = '#222';
      ctx.globalAlpha = 0.7;
      // Eyes
      ctx.beginPath();
      ctx.arc(ball.x - r * 0.25, ball.y - r * 0.15, 1.5, 0, Math.PI * 2);
      ctx.arc(ball.x + r * 0.25, ball.y - r * 0.15, 1.5, 0, Math.PI * 2);
      ctx.fill();
      // Nose
      ctx.beginPath();
      ctx.moveTo(ball.x, ball.y + r * 0.05);
      ctx.lineTo(ball.x - 1, ball.y + r * 0.2);
      ctx.lineTo(ball.x + 1, ball.y + r * 0.2);
      ctx.fill();
      // Mouth
      ctx.strokeStyle = '#222';
      ctx.lineWidth = 0.8;
      ctx.beginPath();
      ctx.moveTo(ball.x - r * 0.3, ball.y + r * 0.4);
      ctx.lineTo(ball.x + r * 0.3, ball.y + r * 0.4);
      ctx.stroke();
      for (let i = 0; i < 3; i++) {
        const tx = ball.x - r * 0.2 + i * r * 0.2;
        ctx.beginPath();
        ctx.moveTo(tx, ball.y + r * 0.35);
        ctx.lineTo(tx, ball.y + r * 0.45);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
    } else if (info.detail === 'eyes') {
      // Alien eyes
      ctx.fillStyle = '#111';
      ctx.beginPath();
      ctx.ellipse(ball.x - r * 0.3, ball.y - r * 0.1, 2, 2.5, -0.2, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(ball.x + r * 0.3, ball.y - r * 0.1, 2, 2.5, 0.2, 0, Math.PI * 2);
      ctx.fill();
      // Pupils
      ctx.fillStyle = '#33ff44';
      ctx.beginPath();
      ctx.arc(ball.x - r * 0.3, ball.y - r * 0.1, 0.8, 0, Math.PI * 2);
      ctx.arc(ball.x + r * 0.3, ball.y - r * 0.1, 0.8, 0, Math.PI * 2);
      ctx.fill();
    } else if (info.detail === 'cap') {
      // Baseball cap on top
      ctx.fillStyle = '#cc2222';
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, r, -Math.PI, 0);
      ctx.fill();
      // Brim
      ctx.fillStyle = '#aa1111';
      ctx.beginPath();
      ctx.ellipse(ball.x + r * 0.3, ball.y - r * 0.15, r * 0.9, r * 0.2, -0.1, -Math.PI, 0);
      ctx.fill();
      // Cap button
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(ball.x, ball.y - r * 0.9, 1, 0, Math.PI * 2);
      ctx.fill();
    }

    // ‚îÄ‚îÄ Specular highlight ‚îÄ‚îÄ
    ctx.fillStyle = 'rgba(255,255,255,0.35)';
    ctx.beginPath();
    ctx.arc(ball.x - r * 0.3, ball.y - r * 0.3, r * 0.3, 0, Math.PI * 2);
    ctx.fill();

    // ‚îÄ‚îÄ Outline ‚îÄ‚îÄ
    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
    ctx.lineWidth = 0.5;
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, r, 0, Math.PI * 2);
    ctx.stroke();

    ctx.restore();
  },

  // Speed-based visual effects drawn around/behind the ball
  drawBallMotionEffects(ball, cosmetic) {
    const ctx = this.ctx;
    const r = Physics.BALL_RADIUS;
    const speed = Math.hypot(ball.vx || 0, ball.vy || 0);
    if (speed < 1) return; // No effects when nearly still

    const info = CosmeticsCatalog.balls.find(b => b.id === cosmetic) || CosmeticsCatalog.balls[0];
    const t = Date.now() / 1000;
    const moveAngle = Math.atan2(ball.vy, ball.vx);
    const speedNorm = Math.min(speed / 15, 1); // 0-1 normalized speed

    ctx.save();

    // ‚îÄ‚îÄ Motion blur trail (ghosting behind ball) ‚îÄ‚îÄ
    if (speedNorm > 0.15) {
      const trailCount = Math.floor(speedNorm * 4) + 1;
      for (let i = 1; i <= trailCount; i++) {
        const frac = i / (trailCount + 1);
        const gx = ball.x - ball.vx * frac * 2;
        const gy = ball.y - ball.vy * frac * 2;
        ctx.globalAlpha = (1 - frac) * 0.15 * speedNorm;
        ctx.fillStyle = info.base || info.color || '#fff';
        ctx.beginPath();
        ctx.arc(gx, gy, r * (1 - frac * 0.2), 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // ‚îÄ‚îÄ Speed lines (drawn behind ball) ‚îÄ‚îÄ
    if (speedNorm > 0.3) {
      const lineCount = Math.floor(speedNorm * 5);
      ctx.strokeStyle = info.glow || info.base || '#ffffff';
      ctx.lineWidth = 1;
      for (let i = 0; i < lineCount; i++) {
        const offset = (Math.random() - 0.5) * r * 2;
        const perpX = Math.cos(moveAngle + Math.PI / 2) * offset;
        const perpY = Math.sin(moveAngle + Math.PI / 2) * offset;
        const startDist = r + 4 + Math.random() * 6;
        const lineLen = 8 + speedNorm * 20 + Math.random() * 10;
        const sx = ball.x - Math.cos(moveAngle) * startDist + perpX;
        const sy = ball.y - Math.sin(moveAngle) * startDist + perpY;
        const ex = sx - Math.cos(moveAngle) * lineLen;
        const ey = sy - Math.sin(moveAngle) * lineLen;
        ctx.globalAlpha = 0.2 + speedNorm * 0.3;
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(ex, ey);
        ctx.stroke();
      }
    }

    // ‚îÄ‚îÄ High-speed glow halo ‚îÄ‚îÄ
    if (speedNorm > 0.5 && info.glow) {
      ctx.globalAlpha = (speedNorm - 0.5) * 0.4;
      ctx.shadowColor = info.glow;
      ctx.shadowBlur = 10 + speedNorm * 15;
      ctx.fillStyle = info.glow;
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, r + 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    // ‚îÄ‚îÄ Per-skin special moving effects ‚îÄ‚îÄ
    if (cosmetic === 'ball_flame' && speedNorm > 0.2) {
      // Fire trail behind ball
      ctx.globalAlpha = speedNorm * 0.6;
      for (let i = 0; i < 3; i++) {
        const fx = ball.x - ball.vx * (0.3 + i * 0.3) + (Math.random()-0.5) * 4;
        const fy = ball.y - ball.vy * (0.3 + i * 0.3) + (Math.random()-0.5) * 4;
        const fs = r * (0.8 - i * 0.2);
        const fg = ctx.createRadialGradient(fx, fy, 0, fx, fy, fs);
        fg.addColorStop(0, '#ffcc00');
        fg.addColorStop(0.5, '#ff6600');
        fg.addColorStop(1, 'rgba(255,34,0,0)');
        ctx.fillStyle = fg;
        ctx.beginPath();
        ctx.arc(fx, fy, fs, 0, Math.PI * 2);
        ctx.fill();
      }
    } else if (cosmetic === 'ball_ice' && speedNorm > 0.15) {
      // Frost sparkle trail
      ctx.globalAlpha = speedNorm * 0.5;
      ctx.fillStyle = '#ffffff';
      for (let i = 0; i < 4; i++) {
        const sx = ball.x - ball.vx * (i * 0.4) + (Math.random()-0.5) * 6;
        const sy = ball.y - ball.vy * (i * 0.4) + (Math.random()-0.5) * 6;
        ctx.beginPath();
        // Star sparkle shape
        for (let p = 0; p < 4; p++) {
          const a = p * Math.PI / 2 + t * 3;
          ctx.moveTo(sx, sy);
          ctx.lineTo(sx + Math.cos(a) * 3, sy + Math.sin(a) * 3);
        }
        ctx.stroke();
      }
    } else if (cosmetic === 'ball_thunder' && speedNorm > 0.25) {
      // Lightning arcs
      ctx.strokeStyle = '#ffd700';
      ctx.lineWidth = 1.5;
      ctx.globalAlpha = 0.5 + Math.random() * 0.3;
      for (let i = 0; i < 2; i++) {
        const startA = Math.random() * Math.PI * 2;
        let lx = ball.x + Math.cos(startA) * r;
        let ly = ball.y + Math.sin(startA) * r;
        ctx.beginPath();
        ctx.moveTo(lx, ly);
        for (let s = 0; s < 3; s++) {
          lx += (Math.random() - 0.5) * 12;
          ly += (Math.random() - 0.5) * 12;
          ctx.lineTo(lx, ly);
        }
        ctx.stroke();
      }
    } else if (cosmetic === 'ball_galaxy' && speedNorm > 0.1) {
      // Stardust sparkles
      ctx.globalAlpha = speedNorm * 0.6;
      ctx.fillStyle = '#ffffff';
      for (let i = 0; i < 3; i++) {
        const sx = ball.x - ball.vx * (i * 0.5) + (Math.random()-0.5) * 8;
        const sy = ball.y - ball.vy * (i * 0.5) + (Math.random()-0.5) * 8;
        const ss = 1 + Math.random() * 1.5;
        ctx.beginPath();
        ctx.arc(sx, sy, ss, 0, Math.PI * 2);
        ctx.fill();
      }
    } else if (cosmetic === 'ball_neon' && speedNorm > 0.2) {
      // Electric glow streak
      ctx.globalAlpha = speedNorm * 0.4;
      const ng = ctx.createLinearGradient(
        ball.x, ball.y,
        ball.x - ball.vx * 3, ball.y - ball.vy * 3
      );
      ng.addColorStop(0, info.glow || '#00ccff');
      ng.addColorStop(1, 'rgba(0,204,255,0)');
      ctx.strokeStyle = ng;
      ctx.lineWidth = r * 1.5;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(ball.x, ball.y);
      ctx.lineTo(ball.x - ball.vx * 3, ball.y - ball.vy * 3);
      ctx.stroke();
    } else if (cosmetic === 'ball_skull' && speedNorm > 0.2) {
      // Ember/smoke trail
      ctx.globalAlpha = speedNorm * 0.5;
      for (let i = 0; i < 3; i++) {
        const ex = ball.x - ball.vx * (0.4 + i * 0.4) + (Math.random()-0.5) * 5;
        const ey = ball.y - ball.vy * (0.4 + i * 0.4) - Math.random() * 4;
        const eg = ctx.createRadialGradient(ex, ey, 0, ex, ey, 4);
        eg.addColorStop(0, '#ff6600');
        eg.addColorStop(1, 'rgba(50,50,50,0)');
        ctx.fillStyle = eg;
        ctx.beginPath();
        ctx.arc(ex, ey, 4 + i, 0, Math.PI * 2);
        ctx.fill();
      }
    } else if (cosmetic === 'ball_ancient' && speedNorm > 0.15) {
      // Rune symbols float up
      ctx.strokeStyle = '#ffd700';
      ctx.lineWidth = 1;
      ctx.globalAlpha = speedNorm * 0.5;
      for (let i = 0; i < 2; i++) {
        const rx = ball.x - ball.vx * (i * 0.6) + (Math.random()-0.5) * 10;
        const ry = ball.y - ball.vy * (i * 0.6) - 3 - Math.random() * 6;
        const rs = 3;
        ctx.beginPath();
        ctx.moveTo(rx - rs, ry); ctx.lineTo(rx + rs, ry);
        ctx.moveTo(rx, ry - rs); ctx.lineTo(rx, ry + rs);
        ctx.stroke();
      }
    } else if (cosmetic === 'ball_alien' && speedNorm > 0.2) {
      // Green glow aura
      ctx.globalAlpha = speedNorm * 0.3;
      ctx.shadowColor = '#33ff44';
      ctx.shadowBlur = 15;
      ctx.fillStyle = '#33ff44';
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, r + 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    } else if (cosmetic === 'ball_royal' && speedNorm > 0.15) {
      // Gold sparkle trail
      ctx.fillStyle = '#ffd700';
      ctx.globalAlpha = speedNorm * 0.6;
      for (let i = 0; i < 4; i++) {
        const gx = ball.x - ball.vx * (i * 0.4) + (Math.random()-0.5) * 6;
        const gy = ball.y - ball.vy * (i * 0.4) + (Math.random()-0.5) * 6;
        ctx.beginPath();
        ctx.arc(gx, gy, 1 + Math.random(), 0, Math.PI * 2);
        ctx.fill();
      }
    }

    ctx.globalAlpha = 1;
    ctx.restore();
  },

  drawAimLine(ball, angle, power) {
    const ctx = this.ctx;
    const maxLen = 140;
    const len = maxLen * power;
    const endX = ball.x + Math.cos(angle) * len;
    const endY = ball.y + Math.sin(angle) * len;

    ctx.save();

    // Color shifts from white ‚Üí yellow ‚Üí red as power increases
    let lineColor, arrowColor;
    if (power < 0.5) {
      lineColor = `rgba(255,255,255,${0.4 + power * 0.3})`;
      arrowColor = `rgba(255,255,255,${0.5 + power * 0.3})`;
    } else if (power < 0.8) {
      const t = (power - 0.5) / 0.3;
      const r = 255, g = Math.round(255 - t * 100), b = Math.round(255 - t * 200);
      lineColor = `rgba(${r},${g},${b},0.7)`;
      arrowColor = `rgba(${r},${g},${b},0.8)`;
    } else {
      const t = (power - 0.8) / 0.2;
      const pulse = 0.7 + Math.sin(Date.now() / 80) * 0.15;
      lineColor = `rgba(255,${Math.round(80 - t * 60)},${Math.round(40 - t * 40)},${pulse})`;
      arrowColor = `rgba(255,${Math.round(60 - t * 60)},0,0.9)`;
    }

    // Dotted preview line
    ctx.strokeStyle = lineColor;
    ctx.lineWidth = power > 0.8 ? 3 : 2;
    ctx.setLineDash([6, 4]);
    ctx.beginPath();
    ctx.moveTo(ball.x, ball.y);
    ctx.lineTo(endX, endY);
    ctx.stroke();
    ctx.setLineDash([]);

    // Arrow head
    const arrowSize = 8 + power * 4;
    ctx.fillStyle = arrowColor;
    ctx.beginPath();
    ctx.moveTo(endX, endY);
    ctx.lineTo(endX - Math.cos(angle - 0.3) * arrowSize, endY - Math.sin(angle - 0.3) * arrowSize);
    ctx.lineTo(endX - Math.cos(angle + 0.3) * arrowSize, endY - Math.sin(angle + 0.3) * arrowSize);
    ctx.fill();

    // ‚ö† Overshoot warning at high power
    if (power > 0.8) {
      ctx.font = 'bold 11px "Space Mono", monospace';
      ctx.textAlign = 'center';
      ctx.fillStyle = `rgba(255,60,40,${0.6 + Math.sin(Date.now()/100) * 0.3})`;
      ctx.fillText('‚ö° POWER SHOT', ball.x + Math.cos(angle) * 40, ball.y + Math.sin(angle) * 40 - 14);
    }

    ctx.restore();
  },

  drawClub(ball, angle, clubId) {
    const ctx = this.ctx;
    const club = CosmeticsCatalog.clubs.find(c => c.id === clubId);
    if (!club) return;

    ctx.save();
    ctx.translate(ball.x, ball.y);
    ctx.rotate(angle + Math.PI);

    const shaftLen = 32;
    const startX = Physics.BALL_RADIUS + 3;
    const endX = startX + shaftLen;

    // ‚îÄ‚îÄ Club glow (drawn first, behind everything) ‚îÄ‚îÄ
    if (club.glow) {
      ctx.globalAlpha = 0.2 + 0.1 * Math.sin(Date.now() / 300);
      ctx.shadowColor = club.glow;
      ctx.shadowBlur = 12;
      ctx.strokeStyle = club.glow;
      ctx.lineWidth = 8;
      ctx.beginPath();
      ctx.moveTo(endX - 5, -6);
      ctx.lineTo(endX + 5, -6);
      ctx.lineTo(endX + 5, 6);
      ctx.lineTo(endX - 5, 6);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
    }

    // ‚îÄ‚îÄ Shaft ‚îÄ‚îÄ
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';

    if (club.shaftPattern === 'striped' && club.shaftAccent) {
      // Candy-cane / barber pole stripes
      const stripeW = 4;
      for (let i = 0; i < shaftLen; i += stripeW) {
        ctx.strokeStyle = (Math.floor(i / stripeW) % 2 === 0) ? club.shaftColor : club.shaftAccent;
        ctx.beginPath();
        ctx.moveTo(startX + i, 0);
        ctx.lineTo(startX + Math.min(i + stripeW, shaftLen), 0);
        ctx.stroke();
      }
    } else {
      // Solid shaft with optional accent line
      ctx.strokeStyle = club.shaftColor;
      ctx.beginPath();
      ctx.moveTo(startX, 0);
      ctx.lineTo(endX, 0);
      ctx.stroke();
      if (club.shaftAccent) {
        ctx.strokeStyle = club.shaftAccent;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(startX, 0);
        ctx.lineTo(endX, 0);
        ctx.stroke();
      }
    }

    // ‚îÄ‚îÄ Grip (end of shaft near ball) ‚îÄ‚îÄ
    ctx.fillStyle = '#222';
    ctx.fillRect(startX - 1, -2.5, 6, 5);

    // ‚îÄ‚îÄ Club Head ‚îÄ‚îÄ
    const hx = endX;
    const shape = club.headShape || 'putter';

    // Head fill gradient
    const hGrad = ctx.createLinearGradient(hx - 4, -8, hx + 8, 8);
    hGrad.addColorStop(0, club.headAccent || club.headColor);
    hGrad.addColorStop(1, club.headColor);
    ctx.fillStyle = hGrad;

    if (shape === 'driver') {
      // Big rounded driver head
      ctx.beginPath();
      ctx.ellipse(hx + 2, 0, 5, 8, 0.1, 0, Math.PI * 2);
      ctx.fill();
      // Face line
      ctx.strokeStyle = club.headAccent || '#fff';
      ctx.lineWidth = 0.8;
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      ctx.moveTo(hx - 2, -6);
      ctx.lineTo(hx - 2, 6);
      ctx.stroke();
      ctx.globalAlpha = 1;
    } else if (shape === 'iron') {
      // Angular iron head
      ctx.beginPath();
      ctx.moveTo(hx - 1, -7);
      ctx.lineTo(hx + 4, -6);
      ctx.lineTo(hx + 4, 6);
      ctx.lineTo(hx - 1, 7);
      ctx.closePath();
      ctx.fill();
      // Grooves
      ctx.strokeStyle = 'rgba(0,0,0,0.2)';
      ctx.lineWidth = 0.5;
      for (let i = -4; i <= 4; i += 2) {
        ctx.beginPath();
        ctx.moveTo(hx, i);
        ctx.lineTo(hx + 3, i);
        ctx.stroke();
      }
    } else if (shape === 'wedge') {
      // Triangular wedge
      ctx.beginPath();
      ctx.moveTo(hx, -5);
      ctx.lineTo(hx + 9, 0);
      ctx.lineTo(hx, 5);
      ctx.closePath();
      ctx.fill();
    } else {
      // Putter - flat blade
      ctx.beginPath();
      ctx.fillRect(hx - 1, -5, 4, 10);
      // Edge highlight
      ctx.strokeStyle = club.headAccent || '#fff';
      ctx.lineWidth = 0.5;
      ctx.globalAlpha = 0.4;
      ctx.beginPath();
      ctx.moveTo(hx, -4);
      ctx.lineTo(hx, 4);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // ‚îÄ‚îÄ Head outline ‚îÄ‚îÄ
    ctx.strokeStyle = 'rgba(0,0,0,0.3)';
    ctx.lineWidth = 0.5;
    if (shape === 'driver') {
      ctx.beginPath();
      ctx.ellipse(hx + 2, 0, 5, 8, 0.1, 0, Math.PI * 2);
      ctx.stroke();
    }

    ctx.restore();
  }
};

// ‚îÄ‚îÄ‚îÄ INPUT SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Handles mouse + touch input for aiming and shooting.
// Drag from ball ‚Üí opposite direction = aim. Distance = power.
const Input = {
  dragging: false,
  startX: 0, startY: 0,
  currentX: 0, currentY: 0,
  aimAngle: 0,
  aimPower: 0,
  controlMode: 'drag', // 'drag' or 'click'

  // Click-to-aim state
  clickAiming: false,     // Phase 1: direction set, charging power
  clickTargetX: 0,
  clickTargetY: 0,
  clickCharging: false,
  clickChargePower: 0,

  // Happy Gilmore timing bar
  gilmoreActive: false,
  gilmoreTimer: 0,
  gilmorePower: 0,

  init(canvas) {
    const getPos = (e) => {
      const r = canvas.getBoundingClientRect();
      const touch = e.touches ? e.touches[0] : e;
      return { x: touch.clientX - r.left, y: touch.clientY - r.top };
    };

    const onDown = (e) => {
      if (!Game.canShoot()) return;
      e.preventDefault();
      const pos = getPos(e);
      const ball = Game.getPlayerBall();
      if (!ball) return;

      if (this.controlMode === 'click') {
        if (!this.clickAiming) {
          // Phase 1: Set direction ‚Äî click where you want to aim
          this.clickTargetX = pos.x;
          this.clickTargetY = pos.y;
          this.aimAngle = Math.atan2(pos.y - ball.y, pos.x - ball.x);
          this.clickAiming = true;
          this.clickCharging = true;
          this.clickChargePower = 0;
        }
      } else {
        // Drag mode (original)
        this.dragging = true;
        this.startX = pos.x;
        this.startY = pos.y;
        this.currentX = pos.x;
        this.currentY = pos.y;
        canvas.classList.add('dragging');
      }
    };

    const onMove = (e) => {
      if (this.controlMode === 'click') {
        // In click mode, mouse position updates direction before holding
        if (!this.clickCharging && !this.clickAiming) {
          // Not aiming yet, do nothing on move
        }
        return;
      }

      // Drag mode
      if (!this.dragging) {
        if (Game.canShoot()) {
          canvas.classList.remove('no-shoot');
        } else {
          canvas.classList.add('no-shoot');
        }
        return;
      }
      e.preventDefault();
      const pos = getPos(e);
      this.currentX = Math.max(0, Math.min(canvas.width, pos.x));
      this.currentY = Math.max(0, Math.min(canvas.height, pos.y));
      const dx = this.startX - this.currentX;
      const dy = this.startY - this.currentY;
      this.aimAngle = Math.atan2(dy, dx);
      this.aimPower = Math.min(Math.hypot(dx, dy) / 150, 1);
      this.aimPowerCurve = this.aimPower * this.aimPower;
    };

    const onUp = (e) => {
      if (this.controlMode === 'click') {
        if (this.clickCharging && this.clickAiming) {
          // Release to shoot with charged power
          if (this.clickChargePower > 0.05) {
            this.aimPower = this.clickChargePower;
            if (Game.isGilmoreMode() && Gilmore.turnPhase === 'ability_targeting') {
              const ball = Game.getPlayerBall();
              if (ball) {
                Gilmore.handleAbilityClick(this.clickTargetX, this.clickTargetY, Game.balls);
              }
            } else {
              Game.shoot(this.aimAngle, this.aimPower);
            }
          }
          this.clickAiming = false;
          this.clickCharging = false;
          this.clickChargePower = 0;
          this.aimPower = 0;
        }
        return;
      }

      // Drag mode
      if (!this.dragging) return;
      this.dragging = false;
      canvas.classList.remove('dragging');
      if (this.aimPower > 0.05) {
        if (Game.isGilmoreMode() && Gilmore.turnPhase === 'ability_targeting') {
          const ball = Game.getPlayerBall();
          if (ball) {
            const clickX = ball.x + Math.cos(this.aimAngle) * this.aimPower * 150;
            const clickY = ball.y + Math.sin(this.aimAngle) * this.aimPower * 150;
            Gilmore.handleAbilityClick(clickX, clickY, Game.balls);
          }
        } else {
          Game.shoot(this.aimAngle, this.aimPower);
        }
      }
      this.aimPower = 0;
    };

    const onLeave = (e) => {
      if (this.controlMode === 'click') return;
      if (this.dragging && this.aimPower > 0.05) {
        this.dragging = false;
        canvas.classList.remove('dragging');
        Game.shoot(this.aimAngle, this.aimPower);
        this.aimPower = 0;
      } else if (this.dragging) {
        this.dragging = false;
        canvas.classList.remove('dragging');
        this.aimPower = 0;
      }
    };

    canvas.addEventListener('mousedown', onDown);
    canvas.addEventListener('mousemove', onMove);
    canvas.addEventListener('mouseup', onUp);
    canvas.addEventListener('mouseleave', onLeave);
    document.addEventListener('mouseup', onUp);
    canvas.addEventListener('touchstart', onDown, { passive: false });
    canvas.addEventListener('touchmove', onMove, { passive: false });
    canvas.addEventListener('touchend', onUp);
  },

  // Update click-to-aim power charging (called every frame)
  updateClickAim() {
    if (this.controlMode !== 'click' || !this.clickCharging) return;
    this.clickChargePower = Math.min(this.clickChargePower + 0.012, 1);
    this.aimPower = this.clickChargePower;
  },

  // Update Gilmore timing bar
  updateGilmore() {
    if (!this.gilmoreActive) return;
    this.gilmoreTimer += 0.04;
    this.gilmorePower = Math.abs(Math.sin(this.gilmoreTimer));
    // Auto-trigger on second cycle (player must tap to lock in timing)
    if (this.gilmoreTimer > Math.PI * 2) {
      this.gilmoreActive = false;
      Game.shoot(this.aimAngle, this.gilmorePower * this.aimPower);
    }
  },

  tapGilmore() {
    if (this.gilmoreActive) {
      this.gilmoreActive = false;
      Game.shoot(this.aimAngle, this.gilmorePower);
    }
  }
};

// ‚îÄ‚îÄ‚îÄ AI SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Bot players for tournament and Gilmore modes. Smarter bots avoid water and plan shots.
const AI = {
  // Check if a shot path would cross a water/lava hazard
  wouldHitWater(ball, angle, power, level, canvasW, canvasH) {
    const maxPower = 16;
    const pCurve = power * power;
    let testX = ball.x, testY = ball.y;
    let tvx = Math.cos(angle) * pCurve * maxPower;
    let tvy = Math.sin(angle) * pCurve * maxPower;
    // Simulate 40 steps along the path
    for (let s = 0; s < 40; s++) {
      testX += tvx;
      testY += tvy;
      tvx *= 0.985;
      tvy *= 0.985;
      // Check water/lava
      for (const h of level.hazards) {
        if (h.type !== 'water' && h.type !== 'lava') continue;
        const hx = h.x * canvasW, hy = h.y * canvasH;
        const hw = h.w * canvasW, hh = h.h * canvasH;
        if (testX > hx && testX < hx + hw && testY > hy && testY < hy + hh) {
          return true;
        }
      }
    }
    return false;
  },

  // Generate a shot for a bot towards the hole ‚Äî avoids water
  calcShot(ball, level, canvasW, canvasH, accuracy) {
    const hx = level.hole.x * canvasW;
    const hy = level.hole.y * canvasH;
    const dx = hx - ball.x;
    const dy = hy - ball.y;
    let angle = Math.atan2(dy, dx);
    const dist = Math.hypot(dx, dy);

    // Base power calculation
    let power = Math.min(dist / (canvasW * 0.5), 1);
    power *= 0.6 + Math.random() * 0.35;
    power = Math.sqrt(power);

    // Add accuracy wobble
    const wobble = (1 - accuracy) * 1.2;
    let bestAngle = angle + (Math.random() - 0.5) * wobble;
    let bestPower = power;

    // Smart bots (accuracy >= 0.6) check for water and try alternate angles
    if (accuracy >= 0.6) {
      // Try the direct shot first
      if (this.wouldHitWater(ball, bestAngle, bestPower, level, canvasW, canvasH)) {
        // Try up to 8 alternate angles to find a safe path
        let foundSafe = false;
        for (let attempt = 0; attempt < 8; attempt++) {
          const testAngle = angle + (attempt % 2 === 0 ? 1 : -1) * ((Math.floor(attempt/2) + 1) * 0.25);
          const testPower = power * (0.8 + Math.random() * 0.4);
          if (!this.wouldHitWater(ball, testAngle, testPower, level, canvasW, canvasH)) {
            bestAngle = testAngle + (Math.random() - 0.5) * wobble * 0.5;
            bestPower = testPower;
            foundSafe = true;
            break;
          }
        }
        // If no safe path found, use very low power to stay safe
        if (!foundSafe) {
          bestPower = Math.min(power * 0.35, 0.3);
          bestAngle = angle + (Math.random() - 0.5) * 0.5;
        }
      }

      // Smart power control near the hole ‚Äî don't overshoot
      if (dist < canvasW * 0.15) {
        bestPower = Math.min(bestPower, 0.45);
      }
    }

    return { angle: bestAngle, power: bestPower };
  },

  // Simulate a full hole for a bot, returns stroke count
  simulateHole(level, canvasW, canvasH, difficulty) {
    const accuracyMap = { easy: 0.5, medium: 0.6, hard: 0.75, expert: 0.9 };
    const accuracy = accuracyMap[difficulty] || 0.6;

    const ball = {
      x: level.tee.x * canvasW,
      y: level.tee.y * canvasH,
      vx: 0, vy: 0, sunk: false
    };

    let strokes = 0;
    const maxStrokes = Physics.MAX_STROKES;

    while (!ball.sunk && strokes < maxStrokes) {
      const shot = this.calcShot(ball, level, canvasW, canvasH, accuracy);
      const maxPower = 16;
      const powerCurve = shot.power * shot.power;
      ball.vx = Math.cos(shot.angle) * powerCurve * maxPower;
      ball.vy = Math.sin(shot.angle) * powerCurve * maxPower;
      strokes++;

      // Simulate until ball stops
      let steps = 0;
      while ((Math.hypot(ball.vx, ball.vy) > Physics.STOP_THRESHOLD || steps < 2) && steps < 500) {
        const events = Physics.update(ball, level, canvasW, canvasH);
        if (events.includes('hole')) break;
        if (events.includes('water') || events.includes('croc')) {
          ball.x = level.tee.x * canvasW;
          ball.y = level.tee.y * canvasH;
          ball.vx = 0; ball.vy = 0;
          strokes++;
          break;
        }
        steps++;
      }
      ball.vx = 0; ball.vy = 0;
    }
    return strokes;
  }
};

// ‚îÄ‚îÄ‚îÄ STORE SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Handles purchasing and equipping cosmetics.
const Store = {
  currentTab: 'balls',

  canBuy(itemId, playerData) {
    const item = this._findItem(itemId);
    if (!item) return false;
    if (item.price === null) return false;  // Achievement-locked
    if (item.price === 0) return false;     // Free/default
    if (this._ownsItem(itemId, playerData)) return false;
    return playerData.credits >= item.price;
  },

  buy(itemId, playerData) {
    if (!this.canBuy(itemId, playerData)) return false;
    const item = this._findItem(itemId);
    playerData.credits -= item.price;
    this._addOwned(itemId, playerData);
    Persistence.save(playerData);
    return true;
  },

  equip(itemId, playerData) {
    if (!this._ownsItem(itemId, playerData)) return false;
    if (itemId.startsWith('ball_'))  playerData.equippedBall = itemId;
    if (itemId.startsWith('club_'))  playerData.equippedClub = itemId;
    if (itemId.startsWith('fx_'))    playerData.equippedEffect = itemId;
    Persistence.save(playerData);
    return true;
  },

  unlockAchievementItem(achId, playerData) {
    // Find any items locked behind this achievement and unlock them
    const allItems = [...CosmeticsCatalog.balls, ...CosmeticsCatalog.clubs, ...CosmeticsCatalog.effects];
    for (const item of allItems) {
      if (item.achievement === achId) {
        this._addOwned(item.id, playerData);
      }
    }
  },

  _findItem(id) {
    return [...CosmeticsCatalog.balls, ...CosmeticsCatalog.clubs, ...CosmeticsCatalog.effects].find(i => i.id === id);
  },

  _ownsItem(id, pd) {
    return pd.ownedBalls.includes(id) || pd.ownedClubs.includes(id) || pd.ownedEffects.includes(id);
  },

  _addOwned(id, pd) {
    if (id.startsWith('ball_') && !pd.ownedBalls.includes(id)) pd.ownedBalls.push(id);
    if (id.startsWith('club_') && !pd.ownedClubs.includes(id)) pd.ownedClubs.push(id);
    if (id.startsWith('fx_')   && !pd.ownedEffects.includes(id)) pd.ownedEffects.push(id);
  }
};

// ‚îÄ‚îÄ‚îÄ ACHIEVEMENT TRACKER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const AchievementTracker = {
  checkAll(playerData) {
    const newlyUnlocked = [];
    for (const ach of AchievementsDef) {
      if (!playerData.achievements[ach.id] && ach.check(playerData.stats)) {
        playerData.achievements[ach.id] = true;
        playerData.credits += ach.reward;
        playerData.totalCreditsEarned += ach.reward;
        Store.unlockAchievementItem(ach.id, playerData);
        newlyUnlocked.push(ach);
      }
    }
    if (newlyUnlocked.length > 0) Persistence.save(playerData);
    return newlyUnlocked;
  }
};

// ‚îÄ‚îÄ‚îÄ GILMORE ABILITIES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Each ball skin has a unique ability usable once per hole in Happy Gilmore mode.
const GilmoreAbilities = {
  ball_classic:  { name:'Hole In One',     icon:'üéØ', desc:'Hole grows 50% bigger for 1 turn',       type:'hole_grow',    color:'#ffffff' },
  ball_flame:    { name:'Inferno',         icon:'üî•', desc:'Scorch trail that slows enemies',         type:'fire_trail',   color:'#ff4400' },
  ball_camo:     { name:'Camouflage',      icon:'üåø', desc:'Ball becomes invisible for 2 turns',      type:'stealth',      color:'#4a7a32' },
  ball_neon:     { name:'EMP Blast',       icon:'‚ö°', desc:'Stun nearest opponent for 1 turn',        type:'stun',         color:'#00ccff' },
  ball_wooden:   { name:'Root Wall',       icon:'ü™µ', desc:'Place a temporary wall near your ball',   type:'wall_place',   color:'#c8943e' },
  ball_galaxy:   { name:'Black Hole',      icon:'üåÄ', desc:'Place a black hole that traps enemies',   type:'black_hole',   color:'#8822cc' },
  ball_thunder:  { name:'Lightning Bolt',  icon:'‚ö°', desc:'Zap nearest enemy back to their last pos', type:'zap_enemy',    color:'#ffd700' },
  ball_candy:    { name:'Sugar Rush',      icon:'üç¨', desc:'Next shot gets 2x power',                 type:'power_boost',  color:'#ff66bb' },
  ball_fossil:   { name:'Earthquake',      icon:'üíé', desc:'Shake all enemies off course slightly',   type:'quake',        color:'#8a8070' },
  ball_ice:      { name:'Freeze Ray',      icon:'‚ùÑÔ∏è', desc:'Freeze an enemy in place for 2 turns',    type:'freeze',       color:'#88ddff' },
  ball_tiki:     { name:'Party Time',      icon:'üéâ', desc:'Confetti explosion pushes enemies away',  type:'push_all',     color:'#ff4444' },
  ball_skull:    { name:'Death Putt',      icon:'üíÄ', desc:'Your next shot phases through walls',     type:'phase',        color:'#ff6600' },
  ball_royal:    { name:'Royal Decree',    icon:'üëë', desc:'Swap positions with the leader',          type:'swap_leader',  color:'#ffd700' },
  ball_alien:    { name:'Abduction',       icon:'üëΩ', desc:'Click an enemy ball to swap positions!', type:'swap_target',  color:'#33ff44' },
  ball_sports:   { name:'Grand Slam',      icon:'‚öæ', desc:'Hit ball at max power with perfect aim',  type:'auto_shot',    color:'#ff3333' },
  ball_ancient:  { name:'Time Warp',       icon:'üîÆ', desc:'Undo your last shot',                     type:'undo',         color:'#22ccaa' },
};

// ‚îÄ‚îÄ‚îÄ GILMORE SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Turn-based competitive minigolf with abilities, bots, and hazards.
const Gilmore = {
  active: false,
  subMode: 'bots',           // 'bots' | 'local'
  botCount: 3,
  players: [],               // [{name, skin, club, isBot, difficulty, ballIndex, strokes, totalStrokes, abilityUsed, lastPos, stunTurns, frozenTurns, stealthTurns, phaseActive, powerBoost}]
  currentTurnIndex: 0,
  turnPhase: 'waiting',      // 'waiting' | 'aiming' | 'moving' | 'bot_thinking' | 'bot_shooting' | 'ability_targeting'
  blackHoles: [],            // [{x, y, owner, turnsLeft}]
  tempWalls: [],             // [{x1, y1, x2, y2, turnsLeft}]
  fireTrails: [],            // [{x, y, turnsLeft}]
  holeGrowTurns: 0,          // Turns remaining for hole grow effect
  holeGrowOwner: -1,
  allSunk: false,
  turnDelay: 0,              // Frame delay between turns
  botThinkTimer: 0,
  firstTurnTaken: false,     // Bots hidden until player's first shot
  tier: 'pro',               // Current difficulty tier

  BOT_NAMES: ['Chip Shot Charlie','Sandy McPutt','Fairway Fiona','Bogey Bob',
              'Ace Anderson','Divot Dave','Birdie Betty','Slice Steve','Putter Pete'],
  BOT_SKINS: ['ball_flame','ball_galaxy','ball_thunder','ball_ice','ball_skull',
              'ball_neon','ball_candy','ball_royal','ball_alien'],

  reset() {
    this.active = false;
    this.players = [];
    this.currentTurnIndex = 0;
    this.turnPhase = 'waiting';
    this.blackHoles = [];
    this.tempWalls = [];
    this.fireTrails = [];
    this.holeGrowTurns = 0;
    this.holeGrowOwner = -1;
    this.allSunk = false;
    this.turnDelay = 0;
    this.botThinkTimer = 0;
    this.firstTurnTaken = false;
    this._pendingSpawn = false;
    this.noAbilities = false;
    this.targetingType = null; // 'black_hole' | 'swap' ‚Äî what the click targets
  },

  initMatch(botCount, subMode, tier) {
    this.reset();
    this.active = true;
    this.subMode = subMode;
    this.botCount = botCount;
    this.tier = tier || 'pro';

    // Bot difficulty scales with tier
    const tierDiffMap = {
      rookie: { diffs: ['easy','medium'], accuracy: [0.45, 0.55] },
      pro:    { diffs: ['medium','hard'], accuracy: [0.6, 0.72] },
      legend: { diffs: ['hard','hard'],   accuracy: [0.72, 0.82] },
      chaos:  { diffs: ['hard','expert'], accuracy: [0.8, 0.9] }
    };
    const tierDiff = tierDiffMap[this.tier] || tierDiffMap.pro;

    // Player is always first
    this.players = [{
      name: 'You',
      skin: Game.playerData.equippedBall,
      club: Game.playerData.equippedClub,
      isBot: false,
      difficulty: 'hard',
      ballIndex: 0,
      strokes: 0,
      totalStrokes: 0,
      abilityUsed: false,
      lastPos: null,
      stunTurns: 0,
      frozenTurns: 0,
      stealthTurns: 0,
      phaseActive: false,
      powerBoost: false
    }];

    // Add bots
    const shuffledSkins = [...this.BOT_SKINS].sort(() => Math.random() - 0.5);
    for (let i = 0; i < botCount; i++) {
      const diff = Math.random() < 0.5 ? tierDiff.diffs[0] : tierDiff.diffs[1];
      this.players.push({
        name: this.BOT_NAMES[i] || `Bot ${i+1}`,
        skin: shuffledSkins[i % shuffledSkins.length],
        club: 'club_classic',
        isBot: true,
        difficulty: diff,
        ballIndex: i + 1,
        strokes: 0,
        totalStrokes: 0,
        abilityUsed: false,
        lastPos: null,
        stunTurns: 0,
        frozenTurns: 0,
        stealthTurns: 0,
        phaseActive: false,
        powerBoost: false
      });
    }
  },

  loadHoleBalls(level, W, H) {
    const balls = [];
    const teeX = level.tee.x * W;
    const teeY = level.tee.y * H;

    this.firstTurnTaken = false;
    this._pendingSpawn = false;

    for (let i = 0; i < this.players.length; i++) {
      const isBot = this.players[i].isBot;
      // Stagger positions slightly so balls don't overlap
      const offsetX = (i % 4) * 14 - 21;
      const offsetY = Math.floor(i / 4) * 14;
      balls.push({
        x: teeX + offsetX,
        y: teeY + offsetY,
        vx: 0, vy: 0,
        sunk: false, frozen: false,
        hidden: isBot,  // Bot balls start hidden
        owner: this.players[i].name,
        skinId: this.players[i].skin
      });
      this.players[i].ballIndex = i;
      this.players[i].strokes = 0;
      this.players[i].abilityUsed = false;
      this.players[i].lastPos = { x: teeX + offsetX, y: teeY + offsetY };
      this.players[i].stunTurns = 0;
      this.players[i].frozenTurns = 0;
      this.players[i].stealthTurns = 0;
      this.players[i].phaseActive = false;
      this.players[i].powerBoost = false;
    }

    this.blackHoles = [];
    this.tempWalls = [];
    this.fireTrails = [];
    this.holeGrowTurns = 0;
    this.allSunk = false;
    this.currentTurnIndex = 0;
    this.turnPhase = 'waiting';
    this.turnDelay = 30;

    return balls;
  },

  // Called after the player's first shot ‚Äî reveal and activate all bot balls
  spawnBots(balls) {
    if (this.firstTurnTaken) return;
    this.firstTurnTaken = true;
    for (let i = 0; i < balls.length; i++) {
      if (balls[i].hidden) {
        balls[i].hidden = false;
        // Spawn particles at each bot's position
        Particles.emit(balls[i].x, balls[i].y, 12, {
          colors: ['#ff4444','#ffaa00','#ffffff','#ff66bb'], speed: 3, life: 18, size: 2.5, spread: Math.PI*2, angle: 0
        });
      }
    }
  },

  getCurrentPlayer() { return this.players[this.currentTurnIndex]; },
  getCurrentBall(balls) {
    const p = this.getCurrentPlayer();
    return p ? balls[p.ballIndex] : null;
  },

  isPlayerTurn() {
    const p = this.getCurrentPlayer();
    return p && !p.isBot;
  },

  advanceTurn(balls) {
    // Save current ball position as lastPos
    const curPlayer = this.getCurrentPlayer();
    const curBall = balls[curPlayer.ballIndex];
    if (curBall && !curBall.sunk) {
      curPlayer.lastPos = { x: curBall.x, y: curBall.y };
    }

    // Decrement status effects
    curPlayer.stealthTurns = Math.max(0, curPlayer.stealthTurns - 1);
    curPlayer.phaseActive = false;
    curPlayer.powerBoost = false;

    // Decrement global effects
    if (this.holeGrowTurns > 0) this.holeGrowTurns--;

    // Decrement black holes
    this.blackHoles = this.blackHoles.filter(bh => { bh.turnsLeft--; return bh.turnsLeft > 0; });
    this.tempWalls = this.tempWalls.filter(tw => { tw.turnsLeft--; return tw.turnsLeft > 0; });
    this.fireTrails = this.fireTrails.filter(ft => { ft.turnsLeft--; return ft.turnsLeft > 0; });

    // Find next non-sunk player
    let attempts = 0;
    do {
      this.currentTurnIndex = (this.currentTurnIndex + 1) % this.players.length;
      attempts++;
    } while (balls[this.players[this.currentTurnIndex].ballIndex]?.sunk && attempts < this.players.length + 1);

    // Check if all sunk
    const activePlayers = this.players.filter(p => !balls[p.ballIndex]?.sunk);
    if (activePlayers.length === 0) {
      this.allSunk = true;
      return;
    }

    // Handle stunned player ‚Äî skip their turn
    const nextPlayer = this.getCurrentPlayer();
    if (nextPlayer.stunTurns > 0) {
      nextPlayer.stunTurns--;
      this.turnDelay = 40;
      this.turnPhase = 'waiting';
      // Will auto-advance after delay
      return;
    }

    if (nextPlayer.frozenTurns > 0) {
      nextPlayer.frozenTurns--;
    }

    this.turnPhase = nextPlayer.isBot ? 'bot_thinking' : 'waiting';
    this.turnDelay = nextPlayer.isBot ? 70 : 30;
    this.botThinkTimer = 0;
  },

  // Execute a bot's turn
  botShoot(balls, level, W, H) {
    const player = this.getCurrentPlayer();
    const ball = balls[player.ballIndex];
    if (!ball || ball.sunk) { this.advanceTurn(balls); return; }

    // Max strokes ‚Äî auto-sink the bot
    if (player.strokes >= Physics.MAX_STROKES) {
      ball.sunk = true; ball.vx = 0; ball.vy = 0;
      this.advanceTurn(balls); return;
    }

    // Bot may use ability (30% chance if not used, skip if noAbilities)
    if (!this.noAbilities && !player.abilityUsed && Math.random() < 0.3) {
      this.botUseAbility(player, balls, level, W, H);
    }

    const shot = AI.calcShot(ball, level, W, H, player.difficulty === 'hard' ? 0.75 : 0.6);
    let power = shot.power;

    // Power boost from candy ability
    if (player.powerBoost) {
      power = Math.min(power * 1.5, 1);
      player.powerBoost = false;
    }

    const powerCurve = power * power;
    const maxSpeed = 18;
    ball.vx = Math.cos(shot.angle) * powerCurve * maxSpeed;
    ball.vy = Math.sin(shot.angle) * powerCurve * maxSpeed;

    player.strokes++;
    player.lastPos = { x: ball.x, y: ball.y };

    Particles.emit(ball.x, ball.y, 10, {
      colors: ['#fff','#aaa','#ccc'], speed: 3, life: 12, size: 2, spread: Math.PI*2, angle: 0
    });

    this.turnPhase = 'moving';
  },

  botUseAbility(player, balls, level, W, H) {
    const ability = GilmoreAbilities[player.skin];
    if (!ability) return;
    player.abilityUsed = true;

    const ball = balls[player.ballIndex];
    const hx = level.hole.x * W, hy = level.hole.y * H;

    switch(ability.type) {
      case 'hole_grow':
        this.holeGrowTurns = 2;
        this.holeGrowOwner = this.currentTurnIndex;
        break;
      case 'black_hole': {
        // Place between ball and hole
        const mx = (ball.x + hx) / 2 + (Math.random()-0.5) * 50;
        const my = (ball.y + hy) / 2 + (Math.random()-0.5) * 50;
        this.blackHoles.push({ x: mx, y: my, owner: this.currentTurnIndex, turnsLeft: 5, radius: 50 });
        Particles.emit(mx, my, 20, { colors:['#8822cc','#aa44ee','#ffffff'], speed:3, life:25, size:3, spread:Math.PI*2, angle:0 });
        break;
      }
      case 'stun': {
        const nearest = this.findNearestEnemy(player, balls);
        if (nearest) nearest.stunTurns += 1;
        break;
      }
      case 'freeze': {
        const nearest = this.findNearestEnemy(player, balls);
        if (nearest) nearest.frozenTurns += 2;
        break;
      }
      case 'zap_enemy': {
        const nearest = this.findNearestEnemy(player, balls);
        if (nearest && nearest.lastPos) {
          const nb = balls[nearest.ballIndex];
          Particles.emit(nb.x, nb.y, 15, { colors:['#ffd700','#ffee55','#fff'], speed:5, life:15, size:3, spread:Math.PI*2, angle:0 });
          nb.x = nearest.lastPos.x;
          nb.y = nearest.lastPos.y;
          nb.vx = 0; nb.vy = 0;
        }
        break;
      }
      case 'power_boost':
        player.powerBoost = true;
        break;
      case 'quake':
        this.players.forEach((p, i) => {
          if (i === this.currentTurnIndex) return;
          const b = balls[p.ballIndex];
          if (b && !b.sunk) {
            b.vx += (Math.random()-0.5) * 4;
            b.vy += (Math.random()-0.5) * 4;
          }
        });
        break;
      case 'push_all':
        this.players.forEach((p, i) => {
          if (i === this.currentTurnIndex) return;
          const b = balls[p.ballIndex];
          if (b && !b.sunk) {
            const dx = b.x - ball.x, dy = b.y - ball.y;
            const dist = Math.hypot(dx, dy) || 1;
            b.vx += (dx / dist) * 5;
            b.vy += (dy / dist) * 5;
          }
        });
        Particles.celebration(ball.x, ball.y);
        break;
      case 'swap_target': {
        // Bot swaps with nearest enemy
        const nearest = this.findNearestEnemy(player, balls);
        if (nearest) {
          const nb = balls[nearest.ballIndex];
          const oldX = ball.x, oldY = ball.y;
          Particles.emit(ball.x, ball.y, 15, { colors:['#33ff44','#88ff99','#fff'], speed:4, life:18, size:3, spread:Math.PI*2, angle:0 });
          Particles.emit(nb.x, nb.y, 15, { colors:['#33ff44','#88ff99','#fff'], speed:4, life:18, size:3, spread:Math.PI*2, angle:0 });
          ball.x = nb.x; ball.y = nb.y;
          nb.x = oldX; nb.y = oldY;
          ball.vx = 0; ball.vy = 0;
          nb.vx = 0; nb.vy = 0;
        }
        break;
      }
    }
  },

  findNearestEnemy(player, balls) {
    const myBall = balls[player.ballIndex];
    let nearest = null, minDist = Infinity;
    this.players.forEach((p, i) => {
      if (i === this.currentTurnIndex || balls[p.ballIndex]?.sunk) return;
      const b = balls[p.ballIndex];
      const d = Math.hypot(b.x - myBall.x, b.y - myBall.y);
      if (d < minDist) { minDist = d; nearest = p; }
    });
    return nearest;
  },

  // Check black hole collisions for a ball
  checkBlackHoles(ball, ballOwnerIndex, balls) {
    for (const bh of this.blackHoles) {
      if (ballOwnerIndex === bh.owner) continue; // Don't eat own ball
      const dist = Math.hypot(ball.x - bh.x, ball.y - bh.y);
      if (dist < bh.radius) {
        // Suck toward center
        const pull = 0.3 * (1 - dist / bh.radius);
        ball.vx += (bh.x - ball.x) * pull * 0.05;
        ball.vy += (bh.y - ball.y) * pull * 0.05;

        // If very close, eat them
        if (dist < 15) {
          const player = this.players[ballOwnerIndex];
          if (player && player.lastPos) {
            Particles.emit(ball.x, ball.y, 25, {
              colors:['#8822cc','#aa44ee','#000000','#ffffff'], speed:6, life:30, size:3, spread:Math.PI*2, angle:0
            });
            ball.x = player.lastPos.x;
            ball.y = player.lastPos.y;
            ball.vx = 0; ball.vy = 0;
            player.stunTurns += 1;
            return true;
          }
        }
      }
    }
    return false;
  },

  // Check fire trail effects
  checkFireTrails(ball, ballOwnerIndex) {
    for (const ft of this.fireTrails) {
      const dist = Math.hypot(ball.x - ft.x, ball.y - ft.y);
      if (dist < 20 && ft.owner !== ballOwnerIndex) {
        ball.vx *= 0.7;
        ball.vy *= 0.7;
      }
    }
  },

  // Execute player ability
  usePlayerAbility(balls, level, W, H) {
    const player = this.getCurrentPlayer();
    if (!player || player.isBot || player.abilityUsed) return false;

    const ability = GilmoreAbilities[player.skin];
    if (!ability) return false;

    const ball = balls[player.ballIndex];
    const hx = level.hole.x * W, hy = level.hole.y * H;

    player.abilityUsed = true;

    switch(ability.type) {
      case 'hole_grow':
        this.holeGrowTurns = 3;
        this.holeGrowOwner = this.currentTurnIndex;
        Game._screenShake = { intensity: 4, duration: 10 };
        Particles.emit(hx, hy, 20, { colors:['#ffffff','#ffee88','#ffd700'], speed:3, life:20, size:3, spread:Math.PI*2, angle:0 });
        break;
      case 'fire_trail':
        // Drop fire zones along path behind ball
        for (let i = 0; i < 5; i++) {
          this.fireTrails.push({
            x: ball.x - ball.vx * i * 0.5 + (Math.random()-0.5)*10,
            y: ball.y - ball.vy * i * 0.5 + (Math.random()-0.5)*10,
            owner: this.currentTurnIndex,
            turnsLeft: 4
          });
        }
        Particles.emit(ball.x, ball.y, 15, { colors:['#ff2200','#ff6600','#ffcc00'], speed:4, life:20, size:3, spread:Math.PI*2, angle:0 });
        break;
      case 'stealth':
        player.stealthTurns = 3;
        Particles.emit(ball.x, ball.y, 12, { colors:['#4a7a32','#2a5a12','#000'], speed:2, life:15, size:2, spread:Math.PI*2, angle:0 });
        break;
      case 'stun': {
        const nearest = this.findNearestEnemy(player, balls);
        if (nearest) {
          nearest.stunTurns += 1;
          const nb = balls[nearest.ballIndex];
          Particles.emit(nb.x, nb.y, 18, { colors:['#00ccff','#0088ff','#ffffff'], speed:5, life:20, size:3, spread:Math.PI*2, angle:0 });
          Game._screenShake = { intensity: 5, duration: 8 };
        }
        break;
      }
      case 'wall_place':
        // Place a short wall near the ball
        this.tempWalls.push({
          x1: (ball.x + 30) / W, y1: (ball.y - 25) / H,
          x2: (ball.x + 30) / W, y2: (ball.y + 25) / H,
          turnsLeft: 5
        });
        Particles.emit(ball.x + 30, ball.y, 10, { colors:['#c8943e','#a07030'], speed:2, life:15, size:3, spread:Math.PI*2, angle:0 });
        break;
      case 'black_hole':
        this.targetingType = 'black_hole';
        this.turnPhase = 'ability_targeting';
        return true; // Special: needs click to place
      case 'zap_enemy': {
        const nearest = this.findNearestEnemy(player, balls);
        if (nearest && nearest.lastPos) {
          const nb = balls[nearest.ballIndex];
          Particles.emit(nb.x, nb.y, 20, { colors:['#ffd700','#ffee55','#ffffff'], speed:6, life:18, size:3, spread:Math.PI*2, angle:0 });
          nb.x = nearest.lastPos.x;
          nb.y = nearest.lastPos.y;
          nb.vx = 0; nb.vy = 0;
          Game._screenShake = { intensity: 6, duration: 10 };
        }
        break;
      }
      case 'power_boost':
        player.powerBoost = true;
        Particles.emit(ball.x, ball.y, 15, { colors:['#ff66bb','#ff99dd','#ffcc00'], speed:3, life:15, size:3, spread:Math.PI*2, angle:0 });
        break;
      case 'quake':
        this.players.forEach((p, i) => {
          if (i === this.currentTurnIndex) return;
          const b = balls[p.ballIndex];
          if (b && !b.sunk) {
            b.vx += (Math.random()-0.5) * 5;
            b.vy += (Math.random()-0.5) * 5;
          }
        });
        Game._screenShake = { intensity: 8, duration: 15 };
        break;
      case 'freeze': {
        const nearest = this.findNearestEnemy(player, balls);
        if (nearest) {
          nearest.frozenTurns += 2;
          const nb = balls[nearest.ballIndex];
          Particles.emit(nb.x, nb.y, 18, { colors:['#88ddff','#aaeeff','#ffffff'], speed:3, life:25, size:3, spread:Math.PI*2, angle:0 });
        }
        break;
      }
      case 'push_all':
        this.players.forEach((p, i) => {
          if (i === this.currentTurnIndex) return;
          const b = balls[p.ballIndex];
          if (b && !b.sunk) {
            const dx = b.x - ball.x, dy = b.y - ball.y;
            const dist = Math.hypot(dx, dy) || 1;
            b.vx += (dx / dist) * 6;
            b.vy += (dy / dist) * 6;
          }
        });
        Particles.celebration(ball.x, ball.y);
        Game._screenShake = { intensity: 5, duration: 10 };
        break;
      case 'phase':
        player.phaseActive = true;
        Particles.emit(ball.x, ball.y, 15, { colors:['#ff6600','#ff8800','#222'], speed:3, life:15, size:3, spread:Math.PI*2, angle:0 });
        break;
      case 'swap_leader': {
        // Find the player closest to the hole (leader)
        let best = null, bestDist = Infinity;
        this.players.forEach((p, i) => {
          if (i === this.currentTurnIndex) return;
          const b = balls[p.ballIndex];
          if (b && !b.sunk) {
            const d = Math.hypot(b.x - hx, b.y - hy);
            if (d < bestDist) { bestDist = d; best = p; }
          }
        });
        if (best) {
          const ob = balls[best.ballIndex];
          const tmpX = ball.x, tmpY = ball.y;
          ball.x = ob.x; ball.y = ob.y;
          ob.x = tmpX; ob.y = tmpY;
          Particles.emit(ball.x, ball.y, 15, { colors:['#ffd700','#fff'], speed:4, life:15, size:3, spread:Math.PI*2, angle:0 });
          Particles.emit(ob.x, ob.y, 15, { colors:['#ffd700','#fff'], speed:4, life:15, size:3, spread:Math.PI*2, angle:0 });
        }
        break;
      }
      case 'swap_target':
        // Enter click-targeting mode ‚Äî player must click an enemy ball
        this.targetingType = 'swap';
        this.turnPhase = 'ability_targeting';
        return true; // Special: needs click to select enemy
      case 'auto_shot': {
        // Aim directly at hole with high power
        const ang = Math.atan2(hy - ball.y, hx - ball.x);
        const dist = Math.hypot(hx - ball.x, hy - ball.y);
        const pwr = Math.min(dist / (W * 0.4), 0.85);
        ball.vx = Math.cos(ang) * pwr * pwr * 20;
        ball.vy = Math.sin(ang) * pwr * pwr * 20;
        player.strokes++;
        Particles.emit(ball.x, ball.y, 20, { colors:['#ff3333','#ffffff','#ff6666'], speed:5, life:15, size:3, spread:Math.PI*2, angle:0 });
        Game._screenShake = { intensity: 6, duration: 10 };
        this.turnPhase = 'moving';
        return true;
      }
      case 'undo':
        if (player.lastPos) {
          ball.x = player.lastPos.x;
          ball.y = player.lastPos.y;
          ball.vx = 0; ball.vy = 0;
          if (player.strokes > 0) player.strokes--;
          Particles.emit(ball.x, ball.y, 15, { colors:['#22ccaa','#44eedd','#ffd700'], speed:3, life:20, size:3, spread:Math.PI*2, angle:0 });
        }
        break;
    }
    return true;
  },

  // Handle click during ability_targeting phase ‚Äî routes to the right ability
  handleAbilityClick(x, y, balls) {
    if (this.targetingType === 'black_hole') {
      this.placeBlackHole(x, y, balls);
    } else if (this.targetingType === 'swap') {
      this.executeSwap(x, y, balls);
    } else {
      // Fallback ‚Äî treat as black hole
      this.placeBlackHole(x, y, balls);
    }
    this.targetingType = null;
  },

  // Execute swap ‚Äî find closest enemy ball to click point and swap positions
  executeSwap(x, y, balls) {
    const player = this.getCurrentPlayer();
    const ball = balls[player.ballIndex];

    // Find the enemy ball closest to the click
    let bestDist = Infinity;
    let bestEnemy = null;
    let bestBall = null;
    for (const p of this.players) {
      if (p === player) continue;
      const b = balls[p.ballIndex];
      if (!b || b.sunk || b.hidden) continue;
      const d = Math.hypot(b.x - x, b.y - y);
      if (d < bestDist) {
        bestDist = d;
        bestEnemy = p;
        bestBall = b;
      }
    }

    // Must click reasonably close to an enemy ball (within 60px)
    if (!bestBall || bestDist > 60) {
      // Missed ‚Äî cancel targeting, refund ability
      player.abilityUsed = false;
      this.turnPhase = 'waiting';
      return;
    }

    // Swap positions!
    const oldX = ball.x, oldY = ball.y;
    Particles.emit(ball.x, ball.y, 18, { colors:['#33ff44','#88ff99','#ffffff'], speed:5, life:20, size:3, spread:Math.PI*2, angle:0 });
    Particles.emit(bestBall.x, bestBall.y, 18, { colors:['#33ff44','#88ff99','#ffffff'], speed:5, life:20, size:3, spread:Math.PI*2, angle:0 });

    ball.x = bestBall.x;
    ball.y = bestBall.y;
    bestBall.x = oldX;
    bestBall.y = oldY;
    ball.vx = 0; ball.vy = 0;
    bestBall.vx = 0; bestBall.vy = 0;

    Particles.emit(ball.x, ball.y, 12, { colors:['#33ff44','#00ff88'], speed:3, life:15, size:2, spread:Math.PI*2, angle:0 });
    Particles.emit(bestBall.x, bestBall.y, 12, { colors:['#ff4444','#ff8844'], speed:3, life:15, size:2, spread:Math.PI*2, angle:0 });
    Game._screenShake = { intensity: 5, duration: 10 };
    this.turnPhase = 'waiting';
  },

  // Place black hole at click position
  placeBlackHole(x, y, balls) {
    const player = this.getCurrentPlayer();
    const ball = balls[player.ballIndex];
    const dist = Math.hypot(x - ball.x, y - ball.y);
    // Must be within 150px radius
    if (dist > 150) {
      x = ball.x + (x - ball.x) / dist * 150;
      y = ball.y + (y - ball.y) / dist * 150;
    }
    this.blackHoles.push({ x, y, owner: this.currentTurnIndex, turnsLeft: 6, radius: 50 });
    Particles.emit(x, y, 25, { colors:['#8822cc','#aa44ee','#000000','#ffffff'], speed:4, life:30, size:3, spread:Math.PI*2, angle:0 });
    Game._screenShake = { intensity: 5, duration: 10 };
    this.turnPhase = 'waiting';
  },

  // Render Gilmore-specific elements
  draw(ctx, W, H, level) {
    // Draw fire trails
    for (const ft of this.fireTrails) {
      ctx.save();
      ctx.globalAlpha = 0.4;
      const fg = ctx.createRadialGradient(ft.x, ft.y, 0, ft.x, ft.y, 15);
      fg.addColorStop(0, '#ff6600');
      fg.addColorStop(0.5, '#ff2200');
      fg.addColorStop(1, 'rgba(255,34,0,0)');
      ctx.fillStyle = fg;
      ctx.beginPath();
      ctx.arc(ft.x, ft.y, 15, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // Draw temp walls
    for (const tw of this.tempWalls) {
      ctx.save();
      ctx.strokeStyle = '#c8943e';
      ctx.lineWidth = 6;
      ctx.lineCap = 'round';
      ctx.globalAlpha = 0.7;
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.moveTo(tw.x1 * W, tw.y1 * H);
      ctx.lineTo(tw.x2 * W, tw.y2 * H);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }

    // Draw black holes
    const t = Date.now() / 1000;
    for (const bh of this.blackHoles) {
      ctx.save();
      // Outer pull ring
      ctx.globalAlpha = 0.15 + 0.05 * Math.sin(t * 2);
      ctx.strokeStyle = '#8822cc';
      ctx.lineWidth = 2;
      for (let r = 0; r < 3; r++) {
        const rr = bh.radius * (0.5 + r * 0.2);
        ctx.beginPath();
        ctx.arc(bh.x, bh.y, rr, 0, Math.PI*2);
        ctx.stroke();
      }

      // Swirl
      ctx.globalAlpha = 0.4;
      ctx.strokeStyle = '#aa44ee';
      ctx.lineWidth = 2;
      for (let s = 0; s < 2; s++) {
        ctx.beginPath();
        for (let a = 0; a < Math.PI * 4; a += 0.15) {
          const sr = 5 + a * 3;
          const sx = bh.x + Math.cos(a + t * 3 + s * Math.PI) * sr;
          const sy = bh.y + Math.sin(a + t * 3 + s * Math.PI) * sr;
          if (a === 0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
        }
        ctx.stroke();
      }

      // Dark center
      const bhg = ctx.createRadialGradient(bh.x, bh.y, 0, bh.x, bh.y, 20);
      bhg.addColorStop(0, '#000000');
      bhg.addColorStop(0.6, '#220044');
      bhg.addColorStop(1, 'rgba(34,0,68,0)');
      ctx.globalAlpha = 0.8;
      ctx.fillStyle = bhg;
      ctx.beginPath();
      ctx.arc(bh.x, bh.y, 20, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // Draw hole grow indicator
    if (this.holeGrowTurns > 0) {
      const hx = level.hole.x * W, hy = level.hole.y * H, hr = level.hole.r * W;
      ctx.save();
      ctx.globalAlpha = 0.2 + 0.1 * Math.sin(t * 3);
      ctx.strokeStyle = '#ffd700';
      ctx.lineWidth = 2;
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.arc(hx, hy, hr * 1.5 + 3, 0, Math.PI*2);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }

    // Draw frozen indicators on frozen balls
    const balls = Game.balls;
    for (let i = 0; i < this.players.length; i++) {
      const p = this.players[i];
      const b = balls[p.ballIndex];
      if (!b || b.sunk) continue;

      if (p.frozenTurns > 0) {
        ctx.save();
        ctx.globalAlpha = 0.4;
        ctx.strokeStyle = '#88ddff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(b.x, b.y, 14, 0, Math.PI*2);
        ctx.stroke();
        ctx.fillStyle = 'rgba(136,221,255,0.15)';
        ctx.beginPath();
        ctx.arc(b.x, b.y, 14, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      if (p.stunTurns > 0) {
        ctx.save();
        ctx.globalAlpha = 0.6;
        ctx.font = '10px "Space Mono"';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#ffcc00';
        ctx.fillText('üí´', b.x, b.y - 16);
        ctx.restore();
      }
    }
  },

  // Update scoreboard HTML
  updateScoreboard() {
    const el = document.getElementById('gilmoreScoreboard');
    if (!this.active) { el.style.display = 'none'; return; }
    el.style.display = 'block';

    let html = '<div style="color:#888;font-size:0.6rem;margin-bottom:4px;text-transform:uppercase;letter-spacing:1px">Scoreboard</div>';
    const sorted = [...this.players].sort((a, b) => a.totalStrokes + a.strokes - (b.totalStrokes + b.strokes));
    for (const p of sorted) {
      // Hide bots before player's first turn
      if (p.isBot && !this.firstTurnTaken) {
        html += `<div class="gs-row" style="opacity:0.3">
          <span class="gs-name">‚ùì ???</span>
          <span class="gs-strokes">-</span>
        </div>`;
        continue;
      }
      const isCurrent = p === this.getCurrentPlayer();
      html += `<div class="gs-row${isCurrent ? ' current' : ''}">
        <span class="gs-name">${p.isBot ? 'ü§ñ' : 'üë§'} ${p.name}</span>
        <span class="gs-strokes">${p.totalStrokes + p.strokes}</span>
      </div>`;
    }
    el.innerHTML = html;
  },

  updateTurnUI() {
    const bar = document.getElementById('gilmoreTurnBar');
    const abilityBtn = document.getElementById('gilmoreAbilityBtn');

    if (!this.active) {
      bar.style.display = 'none';
      abilityBtn.style.display = 'none';
      return;
    }

    bar.style.display = 'block';

    const player = this.getCurrentPlayer();
    if (!player) return;

    const ability = GilmoreAbilities[player.skin];
    const nameEl = document.getElementById('gtName');
    const skinEl = document.getElementById('gtSkin');

    const ballInfo = CosmeticsCatalog.balls.find(b => b.id === player.skin);
    skinEl.style.background = ballInfo ? ballInfo.base : '#fff';

    if (player.isBot) {
      nameEl.textContent = `${player.name}'s Turn`;
      nameEl.className = 'turn-name bot';
      abilityBtn.style.display = 'none';
    } else {
      nameEl.textContent = 'Your Turn';
      nameEl.className = 'turn-name';
      if (this.noAbilities) {
        abilityBtn.style.display = 'none';
      } else if (ability && !player.abilityUsed) {
        abilityBtn.style.display = 'block';
        abilityBtn.textContent = `${ability.icon} ${ability.name}`;
        abilityBtn.className = '';
        abilityBtn.title = ability.desc;
      } else if (player.abilityUsed) {
        abilityBtn.style.display = 'block';
        abilityBtn.textContent = '‚úì Ability Used';
        abilityBtn.className = 'used';
      } else {
        abilityBtn.style.display = 'none';
      }
    }
  }
};


// ‚îÄ‚îÄ‚îÄ MAIN GAME STATE MACHINE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Controls the entire game flow:
// menu ‚Üí select mode ‚Üí select difficulty ‚Üí playing ‚Üí hole complete ‚Üí next hole ‚Üí course complete
const Game = {
  state: 'menu',           // menu | playing | summary | leaderboard
  mode: 'single',          // single | tournament | tournament_online | gilmore_bots | gilmore_local
  useBots: false,           // Use turn-based bots in non-Gilmore modes
  botCountForMode: 3,       // Number of bots when useBots is true
  difficulty: 'easy',
  currentHoleIndex: 0,
  levels: [],
  playerData: null,

  // Current hole state
  balls: [],               // All balls on the course (player + bots/other players)
  playerBallIndex: 0,
  strokes: 0,
  resets: 0,
  holeComplete: false,
  courseResets: 0,          // Total resets across the course (for perfect achievement)

  // Tournament
  tournamentScores: [],    // [{name, totalStrokes, totalCredits}]

  // Per-game stats (reset each game, used for post-game screen)
  gameStats: {
    holeData: [],        // [{hole, name, theme, strokes, par, scoreName, credits}]
    totalStrokes: 0,
    totalPar: 0,
    totalCredits: 0,
    holeInOnes: 0,
    eagles: 0,
    birdies: 0,
    pars: 0,
    bogeys: 0,
    doubleBogeys: 0,
    worse: 0,
    bestHole: null,      // {hole, strokes}
    worstHole: null,     // {hole, strokes}
    placement: -1,       // -1 if no leaderboard
    startTime: 0,
  },

  // Multiplayer
  multiplayerBalls: [],

  // Gilmore bot count selection
  gilmoreBotCount: 3,
  gilmoreDifficulty: 'pro',

  isGilmoreMode() { return this.mode === 'gilmore_bots' || this.mode === 'gilmore_local'; },
  hasBots() { return this.isGilmoreMode() || (this.useBots && Gilmore.active); },

  init() {
    this.playerData = Persistence.load();
    Renderer.init();
    Input.init(Renderer.canvas);
    UI.init();
    this.updateCreditsDisplay();

    // Gilmore tap handler
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space' && Input.gilmoreActive) {
        Input.tapGilmore();
      }
    });
    Renderer.canvas.addEventListener('click', () => {
      if (Input.gilmoreActive) Input.tapGilmore();
    });

    // Start game loop
    this._lastTime = performance.now();
    this._accumulator = 0;
    requestAnimationFrame((t) => this.loop(t));
  },

  setMode(mode) { this.mode = mode; },
  setDifficulty(diff) { this.difficulty = diff; },

  startGilmore() {
    Gilmore.initMatch(this.gilmoreBotCount, this.mode === 'gilmore_bots' ? 'bots' : 'local', this.gilmoreDifficulty);
    this.resetGameStats();
    const tierKey = 'gilmore_' + this.gilmoreDifficulty;
    this.levels = LevelSets[tierKey] || LevelSets.gilmore_pro;
    this.currentHoleIndex = 0;
    this.courseResets = 0;
    this.state = 'playing';
    this.loadHole();
    UI.showGameplay();
    Gilmore.updateTurnUI();
    Gilmore.updateScoreboard();
  },

  activateAbility() {
    if (!Gilmore.active || !Gilmore.isPlayerTurn()) return;
    const result = Gilmore.usePlayerAbility(this.balls, this.levels[this.currentHoleIndex], Renderer.W, Renderer.H);
    Gilmore.updateTurnUI();
  },

  resetGameStats() {
    this.gameStats = {
      holeData: [], totalStrokes: 0, totalPar: 0, totalCredits: 0,
      holeInOnes: 0, eagles: 0, birdies: 0, pars: 0, bogeys: 0, doubleBogeys: 0, worse: 0,
      bestHole: null, worstHole: null, placement: -1, startTime: Date.now(),
    };
  },

  // Record a hole result into gameStats
  recordHole(holeNum, name, theme, strokes, par, credits) {
    const diff = strokes - par;
    let scoreName = 'Bogey+';
    if (strokes === 1) scoreName = 'Hole-in-One!';
    else if (diff <= -3) scoreName = 'Albatross';
    else if (diff === -2) scoreName = 'Eagle';
    else if (diff === -1) scoreName = 'Birdie';
    else if (diff === 0) scoreName = 'Par';
    else if (diff === 1) scoreName = 'Bogey';
    else if (diff === 2) scoreName = 'Double Bogey';
    else scoreName = `+${diff}`;

    const gs = this.gameStats;
    gs.holeData.push({ hole: holeNum, name, theme, strokes, par, scoreName, credits, diff });
    gs.totalStrokes += strokes;
    gs.totalPar += par;
    gs.totalCredits += credits;
    if (strokes === 1) gs.holeInOnes++;
    if (diff <= -2) gs.eagles++;
    else if (diff === -1) gs.birdies++;
    else if (diff === 0) gs.pars++;
    else if (diff === 1) gs.bogeys++;
    else if (diff === 2) gs.doubleBogeys++;
    else if (diff > 2) gs.worse++;

    if (!gs.bestHole || strokes < gs.bestHole.strokes) gs.bestHole = { hole: holeNum, strokes, name };
    if (!gs.worstHole || strokes > gs.worstHole.strokes) gs.worstHole = { hole: holeNum, strokes, name };
  },

  start() {
    if (this.isGilmoreMode()) { this.startGilmore(); return; }
    this.resetGameStats();
    const diffKey = this.difficulty;
    let allLevels = [...(LevelSets[diffKey] || LevelSets.easy)];

    // Determine hole count by mode
    let holeCount = 5;
    if (this.mode === 'tournament' || this.mode === 'tournament_online') {
      holeCount = 7 + Math.floor(Math.random() * 4); // 7-10 holes
    }
    // Shuffle and slice levels
    allLevels.sort(() => Math.random() - 0.5);
    this.levels = allLevels.slice(0, Math.min(holeCount, allLevels.length));
    this.currentHoleIndex = 0;
    this.courseResets = 0;
    this.state = 'playing';

    // Tournament setup
    if (this.mode === 'tournament' || this.mode === 'tournament_online') {
      const botNames = ['Chip Shot Charlie','Sandy McPutt','Fairway Fiona','Bogey Bob',
                         'Ace Anderson','Divot Dave','Birdie Betty','Slice Steve'];
      const onlineNames = ['xX_PuttMaster_Xx','GolfGuru99','BirdieBandit','HoleHunter',
                            'FairwayFreak','AceOfClubs','PuttPirate','SandStorm',
                            'GreenDemon','LuckyChip','IronWill','EagleEye'];
      const namePool = this.mode === 'tournament_online'
        ? onlineNames.sort(() => Math.random() - 0.5)
        : botNames;

      this.tournamentScores = [
        { name: 'You', totalStrokes: 0, totalCredits: 0, isPlayer: true }
      ];
      const opponentCount = this.mode === 'tournament_online' ? 7 : 5;
      for (let i = 0; i < opponentCount; i++) {
        this.tournamentScores.push({
          name: namePool[i % namePool.length],
          totalStrokes: 0,
          totalCredits: 0,
          isPlayer: false,
          isOnline: this.mode === 'tournament_online'
        });
      }
    }

    // VS Bots mode ‚Äî use Gilmore system without abilities
    if (this.useBots) {
      Gilmore.initMatch(this.botCountForMode, 'bots', 'pro');
      Gilmore.noAbilities = true; // Disable abilities for non-Gilmore bot mode
    }

    this.loadHole();
    UI.showGameplay();
  },

  loadHole() {
    const level = this.levels[this.currentHoleIndex];
    const W = Renderer.W, H = Renderer.H;

    // Any mode with bots ‚Äî multiple competitive balls via Gilmore system
    if (this.hasBots() && Gilmore.active) {
      this.balls = Gilmore.loadHoleBalls(level, W, H);
      this.playerBallIndex = 0;
      this.strokes = 0;
      this.resets = 0;
      this.holeComplete = false;
      UI.updateHUD(this.currentHoleIndex + 1, level.par, 0);
      Gilmore.updateTurnUI();
      Gilmore.updateScoreboard();
      return;
    }

    this.balls = [{
      x: level.tee.x * W,
      y: level.tee.y * H,
      vx: 0, vy: 0,
      sunk: false,
      frozen: false,
      owner: 'player'
    }];
    this.playerBallIndex = 0;

    // Multiplayer extra balls
    if (this.mode === 'multiplayer') {
      const colors = ['#ff4444','#4488ff','#ffaa00'];
      for (let i = 0; i < 2; i++) {
        this.balls.push({
          x: level.tee.x * W + (i+1) * 20,
          y: level.tee.y * H,
          vx: 0, vy: 0,
          sunk: false, frozen: false,
          owner: `player${i+2}`,
          color: colors[i]
        });
      }
    }

    this.strokes = 0;
    this.resets = 0;
    this.holeComplete = false;
    this._maxStrokesPending = false;
    document.getElementById('maxStrokesBar').style.display = 'none';

    UI.updateHUD(this.currentHoleIndex + 1, level.par, 0);
  },

  getPlayerBall() {
    if (this.hasBots() && Gilmore.active) {
      return Gilmore.getCurrentBall(this.balls);
    }
    return this.balls[this.playerBallIndex];
  },

  canShoot() {
    if (this.state !== 'playing') return false;
    if (this.holeComplete) return false;
    if (this.strokes >= Physics.MAX_STROKES && !this.hasBots()) return false;

    // Gilmore mode ‚Äî must be player's turn and in aiming phase
    if (this.hasBots() && Gilmore.active) {
      if (!Gilmore.isPlayerTurn()) return false;
      if (Gilmore.turnPhase !== 'waiting' && Gilmore.turnPhase !== 'ability_targeting') return false;
      if (Gilmore.turnDelay > 0) return false;
      const ball = Gilmore.getCurrentBall(this.balls);
      if (!ball || ball.sunk) return false;
      // Check Gilmore player max strokes
      const gp = Gilmore.getCurrentPlayer();
      if (gp && gp.strokes >= Physics.MAX_STROKES) return false;
      // Make sure all balls have stopped
      for (const b of this.balls) {
        if (!b.hidden && Physics.isMoving(b)) return false;
      }
      return true;
    }

    const ball = this.getPlayerBall();
    if (!ball || ball.sunk) return false;
    return !Physics.isMoving(ball);
  },

  shoot(angle, power) {
    const ball = this.getPlayerBall();
    if (!ball) return;

    // Gilmore: handle ability targeting click (black hole placement, swap, etc.)
    if (this.hasBots() && Gilmore.turnPhase === 'ability_targeting') {
      const clickX = ball.x + Math.cos(angle) * power * 140;
      const clickY = ball.y + Math.sin(angle) * power * 140;
      Gilmore.handleAbilityClick(clickX, clickY, this.balls);
      return;
    }

    // Apply club stats
    const club = CosmeticsCatalog.clubs.find(c => c.id === this.playerData.equippedClub) || CosmeticsCatalog.clubs[0];

    // Power curve: quadratic for responsive feel
    const powerCurve = power * power;
    let maxSpeed = 20 * club.power;

    // Gilmore power boost (candy ability)
    if (this.hasBots() && Gilmore.active) {
      const gPlayer = Gilmore.getCurrentPlayer();
      if (gPlayer && gPlayer.powerBoost) {
        maxSpeed *= 1.8;
        gPlayer.powerBoost = false;
      }
    }

    // Accuracy wobble (less at low power, more at high power)
    const wobble = (1 - club.accuracy) * power * (Math.random() - 0.5) * 0.35;
    angle += wobble;

    const shotSpeed = powerCurve * maxSpeed;
    ball.vx = Math.cos(angle) * shotSpeed;
    ball.vy = Math.sin(angle) * shotSpeed;

    this.strokes++;
    UI.updateHUD(this.currentHoleIndex + 1, this.levels[this.currentHoleIndex].par, this.strokes);

    // Max strokes check ‚Äî auto-complete hole at 10
    if (this.strokes >= Physics.MAX_STROKES && !this.hasBots()) {
      // Let the ball finish moving, then force-complete
      this._maxStrokesPending = true;
    }

    // Show max strokes warning
    const msBar = document.getElementById('maxStrokesBar');
    if (this.strokes >= Physics.MAX_STROKES - 2) {
      msBar.style.display = 'block';
      msBar.textContent = this.strokes >= Physics.MAX_STROKES
        ? '‚õ≥ MAX STROKES REACHED (10)'
        : `‚ö†Ô∏è ${Physics.MAX_STROKES - this.strokes} putts remaining`;
    } else {
      msBar.style.display = 'none';
    }

    // Gilmore: track player strokes and set turn to moving
    if (this.hasBots() && Gilmore.active) {
      const gPlayer = Gilmore.getCurrentPlayer();
      if (gPlayer) {
        gPlayer.strokes++;
        gPlayer.lastPos = { x: ball.x - ball.vx, y: ball.y - ball.vy };

        // First shot by player ‚Äî mark for spawn when ball stops
        if (!gPlayer.isBot && !Gilmore.firstTurnTaken) {
          Gilmore._pendingSpawn = true;
        }

        // Max strokes in Gilmore mode ‚Äî auto-sink the ball
        if (gPlayer.strokes >= Physics.MAX_STROKES) {
          ball.sunk = true;
          ball.vx = 0; ball.vy = 0;
        }
      }
      Gilmore.turnPhase = 'moving';
    }

    // ‚îÄ‚îÄ Per-skin hit effects ‚îÄ‚îÄ
    const skinHitEffects = {
      ball_classic:  { count:8,  colors:['#fff','#ddd','#bbb'],                        speed:3, life:15, size:2 },
      ball_flame:    { count:18, colors:['#ff2200','#ff6600','#ffcc00','#fff'],          speed:5, life:25, size:3.5, gravity:-0.12 },
      ball_camo:     { count:12, colors:['#4a7a32','#6a9a52','#8ab862','#2a5a12'],      speed:3, life:20, size:2.5, gravity:0.05 },
      ball_neon:     { count:16, colors:['#00ccff','#0088ff','#00ffff','#ffffff'],       speed:4, life:22, size:2.5 },
      ball_wooden:   { count:10, colors:['#c8943e','#a07030','#e0b060'],                speed:3, life:15, size:2, gravity:0.08 },
      ball_galaxy:   { count:20, colors:['#aa44ee','#cc66ff','#ffffff','#ffd700'],       speed:5, life:30, size:2.5, gravity:-0.04 },
      ball_thunder:  { count:15, colors:['#ffd700','#ffee55','#ffffff','#ffffaa'],       speed:7, life:12, size:3 },
      ball_candy:    { count:14, colors:['#ff66bb','#ff99dd','#ffcc00','#66ff66','#fff'], speed:4, life:20, size:3 },
      ball_fossil:   { count:10, colors:['#8a8070','#6a6050','#aaa090','#555'],          speed:4, life:15, size:3, gravity:0.1 },
      ball_ice:      { count:16, colors:['#88ddff','#aaeeff','#ffffff','#cceeff'],       speed:3, life:28, size:2.5, gravity:-0.03 },
      ball_tiki:     { count:20, colors:['#ff4444','#ffcc00','#44cc44','#4488ff','#ff44aa','#fff'], speed:5, life:25, size:3 },
      ball_skull:    { count:18, colors:['#ff4400','#ff8800','#ffcc00','#222'],          speed:5, life:25, size:3.5, gravity:-0.08 },
      ball_royal:    { count:16, colors:['#ffd700','#ffee88','#ffffff','#daa520'],       speed:4, life:25, size:2.5, gravity:-0.02 },
      ball_alien:    { count:14, colors:['#33ff44','#88ff99','#aaffbb','#00ff00'],       speed:4, life:20, size:2.5, gravity:-0.05 },
      ball_sports:   { count:12, colors:['#ff3333','#ffffff','#ff6666'],                speed:6, life:12, size:2 },
      ball_ancient:  { count:22, colors:['#22ccaa','#44eedd','#ffd700','#ffffff','#88ffdd'], speed:5, life:30, size:3, gravity:-0.05 },
    };
    const hitCfg = skinHitEffects[this.playerData.equippedBall] || skinHitEffects.ball_classic;
    // Scale particle count with power
    const hitCount = Math.ceil(hitCfg.count * (0.5 + power * 0.8));
    Particles.emit(ball.x, ball.y, hitCount, {
      ...hitCfg,
      count: hitCount,
      speed: hitCfg.speed * (0.6 + power * 0.6),
      spread: Math.PI * 2,
      angle: 0
    });

    // Also fire effect particles
    Particles.hitEffect(ball.x, ball.y, this.playerData.equippedEffect);

    // Screen shake for powerful shots
    if (power > 0.6) {
      this._screenShake = { intensity: power * 6, duration: 8 + power * 6 };
    }
  },

  resetBall() {
    const level = this.levels[this.currentHoleIndex];
    const ball = this.getPlayerBall();
    ball.x = level.tee.x * Renderer.W;
    ball.y = level.tee.y * Renderer.H;
    ball.vx = 0; ball.vy = 0;
    ball.sunk = false;
    this.resets++;
    this.courseResets++;
    this.strokes++;
    UI.updateHUD(this.currentHoleIndex + 1, level.par, this.strokes);
  },

  onHoleComplete() {
    this.holeComplete = true;
    const level = this.levels[this.currentHoleIndex];
    const ball = this.getPlayerBall();

    // Celebration particles
    Particles.celebration(ball.x, ball.y);

    // Calculate credits
    const breakdown = CreditEconomy.getBreakdown(this.strokes, level.par, this.difficulty, this.resets);
    this.playerData.credits += breakdown.total;
    this.playerData.totalCreditsEarned += breakdown.total;

    // Update stats
    this.playerData.stats.holesPlayed++;
    this.playerData.stats.totalStrokes += this.strokes;
    if (this.strokes === 1) this.playerData.stats.holeInOnes++;

    // Track for post-game stats screen
    this.recordHole(this.currentHoleIndex + 1, level.name, level.theme, this.strokes, level.par, breakdown.total);

    // Tournament scoring
    if (this.mode === 'tournament' || this.mode === 'tournament_online') {
      this.tournamentScores[0].totalStrokes += this.strokes;
      this.tournamentScores[0].totalCredits += breakdown.total;
      // Simulate bots
      for (let i = 1; i < this.tournamentScores.length; i++) {
        const botStrokes = AI.simulateHole(level, Renderer.W, Renderer.H, this.difficulty);
        this.tournamentScores[i].totalStrokes += botStrokes;
      }
    }

    // Check achievements
    const newAchs = AchievementTracker.checkAll(this.playerData);
    Persistence.save(this.playerData);
    this.updateCreditsDisplay();

    // Show summary
    UI.showScoreSummary(this.strokes, level.par, breakdown, newAchs, this.currentHoleIndex >= this.levels.length - 1);
  },

  onGilmoreHoleComplete() {
    this.holeComplete = true;
    const level = this.levels[this.currentHoleIndex];

    // Accumulate strokes for all players
    for (const p of Gilmore.players) {
      const b = this.balls[p.ballIndex];
      if (!b.sunk) p.strokes += 5; // Penalty for not finishing
      p.totalStrokes += p.strokes;
    }

    // Player credit calc
    const playerP = Gilmore.players[0];
    const breakdown = CreditEconomy.getBreakdown(playerP.strokes, level.par, 'hard', 0);
    this.playerData.credits += breakdown.total;
    this.playerData.totalCreditsEarned += breakdown.total;
    this.playerData.stats.holesPlayed++;
    this.playerData.stats.totalStrokes += playerP.strokes;
    if (playerP.strokes === 1) this.playerData.stats.holeInOnes++;

    // Track for post-game stats screen
    this.recordHole(this.currentHoleIndex + 1, level.name, level.theme, playerP.strokes, level.par, breakdown.total);

    Persistence.save(this.playerData);
    this.updateCreditsDisplay();
    Gilmore.updateScoreboard();

    UI.showScoreSummary(playerP.strokes, level.par, breakdown, [], this.currentHoleIndex >= this.levels.length - 1);
  },

  nextHole() {
    this.currentHoleIndex++;
    if (this.currentHoleIndex >= this.levels.length) {
      this.onCourseComplete();
      return;
    }
    this.loadHole();
    UI.hideScoreSummary();
    if (this.hasBots() && Gilmore.active) {
      Gilmore.updateTurnUI();
      Gilmore.updateScoreboard();
    }
  },

  onCourseComplete() {
    // Check for perfect course
    if (this.courseResets === 0) {
      this.playerData.stats.perfectCourses++;
    }

    // Difficulty completion
    const diffKey = this.isGilmoreMode() ? 'happygilmore' : this.difficulty;
    this.playerData.stats.difficultiesCompleted[diffKey] = true;
    this.playerData.stats.gamesPlayed++;

    if (this.hasBots() && Gilmore.active) {
      // Show final Gilmore leaderboard
      const scores = Gilmore.players.map(p => ({
        name: p.name,
        totalStrokes: p.totalStrokes,
        totalCredits: 0,
        isPlayer: !p.isBot
      }));
      scores.sort((a, b) => a.totalStrokes - b.totalStrokes);
      const placement = scores.findIndex(s => s.isPlayer);
      const bonus = CreditEconomy.calcTournamentBonus(placement, 'hard');
      this.playerData.credits += bonus;
      this.playerData.totalCreditsEarned += bonus;

      if (placement === 0) {
        this.playerData.stats.tournamentsWon++;
      }

      this.gameStats.placement = placement;
      AchievementTracker.checkAll(this.playerData);
      Persistence.save(this.playerData);
      this.updateCreditsDisplay();
      Gilmore.reset();
      UI.showPostGameStats(scores, placement);
    } else if (this.mode === 'tournament' || this.mode === 'tournament_online') {
      this.playerData.stats.tournamentsPlayed++;
      // Sort by strokes
      this.tournamentScores.sort((a, b) => a.totalStrokes - b.totalStrokes);
      const placement = this.tournamentScores.findIndex(s => s.isPlayer);
      const bonus = CreditEconomy.calcTournamentBonus(placement, this.difficulty);
      this.playerData.credits += bonus;
      this.playerData.totalCreditsEarned += bonus;

      if (placement === 0) {
        this.playerData.stats.tournamentsWon++;
        this.playerData.stats.winStreak++;
        this.playerData.stats.bestWinStreak = Math.max(this.playerData.stats.bestWinStreak, this.playerData.stats.winStreak);
        const streakBonus = CreditEconomy.calcWinStreakBonus(this.playerData.stats.winStreak);
        this.playerData.credits += streakBonus;
      } else {
        this.playerData.stats.winStreak = 0;
      }

      this.gameStats.placement = placement;
      AchievementTracker.checkAll(this.playerData);
      Persistence.save(this.playerData);
      this.updateCreditsDisplay();
      UI.showPostGameStats(this.tournamentScores, placement);
    } else {
      AchievementTracker.checkAll(this.playerData);
      Persistence.save(this.playerData);
      this.updateCreditsDisplay();
      UI.showPostGameStats(null, -1);
    }
  },

  updateCreditsDisplay() {
    document.getElementById('menuCredits').textContent = this.playerData.credits;
    document.getElementById('storeCredits').textContent = this.playerData.credits;
    document.getElementById('hudCredits').textContent = this.playerData.credits;
  },

  // ‚îÄ‚îÄ‚îÄ GAME LOOP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  loop(timestamp) {
    const dt = (timestamp - this._lastTime) / 1000;
    this._lastTime = timestamp;
    this._accumulator += dt;

    // Fixed timestep physics
    while (this._accumulator >= Physics.TIMESTEP) {
      this._accumulator -= Physics.TIMESTEP;
      if (this.state === 'playing') {
        this._physicsStep();
      }
    }

    // Render
    this._render();

    requestAnimationFrame((t) => this.loop(t));
  },

  _physicsStep() {
    if (this.holeComplete) return;
    const level = this.levels[this.currentHoleIndex];
    const W = Renderer.W, H = Renderer.H;
    const isGilmore = this.hasBots() && Gilmore.active;

    // ‚îÄ‚îÄ GILMORE TURN MANAGEMENT ‚îÄ‚îÄ
    if (isGilmore) {
      // Global check: are ANY balls still moving?
      let anyBallMoving = false;
      for (const b of this.balls) {
        if (!b.sunk && !b.hidden && Physics.isMoving(b)) { anyBallMoving = true; break; }
      }

      // Turn delay countdown (only tick when no balls are moving)
      if (Gilmore.turnDelay > 0 && !anyBallMoving) {
        Gilmore.turnDelay--;
        if (Gilmore.turnDelay === 0) {
          // If stunned player's turn ended, advance
          const cp = Gilmore.getCurrentPlayer();
          if (cp && cp.stunTurns > 0 && Gilmore.turnPhase === 'waiting') {
            Gilmore.advanceTurn(this.balls);
            Gilmore.updateTurnUI();
            Gilmore.updateScoreboard();
          }
        }
      }

      // Bot thinking ‚Üí shoot (ONLY after turnDelay finishes AND no balls moving)
      if (Gilmore.turnPhase === 'bot_thinking' && Gilmore.turnDelay <= 0 && !anyBallMoving) {
        Gilmore.botThinkTimer++;
        if (Gilmore.botThinkTimer >= 45) {
          Gilmore.botShoot(this.balls, level, W, H);
        }
      }

      // Check if all balls have stopped (to advance turn)
      if (Gilmore.turnPhase === 'moving' && !anyBallMoving) {
        // Spawn bots after player's first shot ball stops
        if (Gilmore._pendingSpawn && !Gilmore.firstTurnTaken) {
          Gilmore.spawnBots(this.balls);
          Gilmore._pendingSpawn = false;
          Gilmore.updateScoreboard();
        }
        // Check if all players sunk (ignore hidden)
        const allDone = Gilmore.allSunk || Gilmore.players.every(p => {
          const b = this.balls[p.ballIndex];
          return b?.sunk || b?.hidden;
        });
        if (allDone && Gilmore.firstTurnTaken) {
          this.onGilmoreHoleComplete();
        } else {
          Gilmore.advanceTurn(this.balls);
          Gilmore.updateTurnUI();
          Gilmore.updateScoreboard();
        }
      }

      // Safety: if phase is 'waiting' but balls are still moving from abilities, switch to 'moving'
      if (Gilmore.turnPhase === 'waiting' && anyBallMoving && Gilmore.turnDelay <= 0) {
        Gilmore.turnPhase = 'moving';
      }

      // Temp wall collisions
      for (const tw of Gilmore.tempWalls) {
        level.walls.push(tw);
      }
    }

    // Modify hole radius for hole_grow effect
    let origHoleR = level.hole.r;
    if (isGilmore && Gilmore.holeGrowTurns > 0) {
      level.hole.r = origHoleR * 1.5;
    }

    for (let bi = 0; bi < this.balls.length; bi++) {
      const ball = this.balls[bi];
      if (ball.sunk || ball.hidden) continue;
      let phaseActive = false;
      if (isGilmore) {
        const owner = Gilmore.players.find(p => p.ballIndex === bi);
        if (owner && owner.phaseActive) phaseActive = true;
      }

      // Temporarily remove walls for phase
      const savedWalls = phaseActive ? level.walls : null;
      if (phaseActive) level.walls = [];

      const events = Physics.update(ball, level, W, H);

      if (phaseActive) level.walls = savedWalls;

      // Handle events for ALL balls in Gilmore mode
      for (const evt of events) {
        if (evt === 'hole') {
          if (isGilmore) {
            // Any ball can sink
            const owner = Gilmore.players.find(p => p.ballIndex === bi);
            if (owner) {
              Particles.celebration(ball.x, ball.y);
            }
            // Check if player ball
            if (bi === 0) {
              // Don't call onHoleComplete yet ‚Äî wait for all to stop
            }
          } else if (ball === this.getPlayerBall()) {
            this.onHoleComplete();
          }
        }
        if (evt === 'water' || evt === 'croc' || evt === 'monster') {
          if (isGilmore) {
            const owner = Gilmore.players.find(p => p.ballIndex === bi);
            if (owner && owner.lastPos) {
              Particles.emit(ball.x, ball.y, 15, {
                colors: evt === 'monster' ? ['#88ff44','#ff4444','#000'] : evt === 'croc' ? ['#33aa33','#ff4444','#2244aa'] : ['#2244aa','#4488cc','#88bbff'],
                speed: 3, life: 20, size: 3, spread: Math.PI*2, angle: 0
              });
              ball.x = owner.lastPos.x;
              ball.y = owner.lastPos.y;
              ball.vx = 0; ball.vy = 0;
              if (evt === 'croc' || evt === 'monster') owner.strokes++;
            }
          } else if (ball === this.getPlayerBall()) {
            Particles.emit(ball.x, ball.y, 15, {
              colors: evt === 'monster' ? ['#88ff44','#ff4444','#000'] : evt === 'croc' ? ['#33aa33','#ff4444','#2244aa'] : ['#2244aa','#4488cc','#88bbff'],
              speed: 3, life: 20, size: 3, spread: Math.PI*2, angle: 0
            });
            if (evt === 'croc' || evt === 'monster') this.strokes++;
            this.resetBall();
          }
        }
        if (evt === 'wall') {
          Particles.emit(ball.x, ball.y, 5, {
            colors: ['#fff','#aaa'], speed: 2, life: 10, size: 2, spread: Math.PI*2, angle: 0
          });
        }
        if (evt === 'break') {
          // Breakable wall shattered ‚Äî screen shake + extra particles
          Game._screenShake = { intensity: 5, duration: 10 };
        }
      }

      // Gilmore: black hole and fire trail effects
      if (isGilmore) {
        Gilmore.checkBlackHoles(ball, bi, this.balls);
        Gilmore.checkFireTrails(ball, bi);
      }

      // Trail particles for player ball
      if (Physics.isMoving(ball)) {
        if (ball === this.balls[0]) {
          Particles.trailEffect(ball.x, ball.y, this.playerData.equippedEffect, this.playerData.equippedBall);
        } else if (isGilmore) {
          const owner = Gilmore.players.find(p => p.ballIndex === bi);
          if (owner) {
            Particles.trailEffect(ball.x, ball.y, null, owner.skin);
          }
        }
      }
    }

    // Restore hole radius
    if (isGilmore && Gilmore.holeGrowTurns > 0) {
      level.hole.r = origHoleR;
    }

    // Remove temp walls
    if (isGilmore) {
      for (const tw of Gilmore.tempWalls) {
        const idx = level.walls.indexOf(tw);
        if (idx >= 0) level.walls.splice(idx, 1);
      }
    }

    // Ball-ball collisions
    for (let i = 0; i < this.balls.length; i++) {
      for (let j = i + 1; j < this.balls.length; j++) {
        Physics.collideBalls(this.balls[i], this.balls[j]);
      }
    }

    // Max strokes auto-complete (non-Gilmore mode)
    if (this._maxStrokesPending && !isGilmore) {
      const pb = this.getPlayerBall();
      if (pb && !Physics.isMoving(pb) && !pb.sunk) {
        pb.sunk = true;
        pb.vx = 0; pb.vy = 0;
        this._maxStrokesPending = false;
        this.onHoleComplete();
      }
    }

    // Gilmore timing (still works for Gilmore if needed)
    Input.updateGilmore();
    Input.updateClickAim();
    Particles.update();
  },

  _render() {
    if (this.state !== 'playing') return;
    const level = this.levels[this.currentHoleIndex];
    const ctx = Renderer.ctx;

    // Apply screen shake
    ctx.save();
    if (this._screenShake && this._screenShake.duration > 0) {
      const s = this._screenShake;
      const shakeX = (Math.random() - 0.5) * s.intensity;
      const shakeY = (Math.random() - 0.5) * s.intensity;
      ctx.translate(shakeX, shakeY);
      s.intensity *= 0.88;
      s.duration--;
      if (s.duration <= 0) this._screenShake = null;
    }

    Renderer.clear(level.theme);
    Renderer.drawLevel(level);

    // Draw Gilmore hazards (black holes, fire trails, etc.) BEFORE balls
    const isGilmore = this.hasBots() && Gilmore.active;
    if (isGilmore) {
      Gilmore.draw(ctx, Renderer.W, Renderer.H, level);
    }

    // Draw hole grow effect
    if (isGilmore && Gilmore.holeGrowTurns > 0) {
      const hx = level.hole.x * Renderer.W, hy = level.hole.y * Renderer.H;
      const hr = level.hole.r * Renderer.W;
      const growR = hr * 1.5;
      ctx.save();
      // Extra big hole ring
      ctx.globalAlpha = 0.5;
      const hg = ctx.createRadialGradient(hx, hy, hr, hx, hy, growR);
      hg.addColorStop(0, '#222');
      hg.addColorStop(1, 'rgba(100,100,100,0.3)');
      ctx.fillStyle = hg;
      ctx.beginPath();
      ctx.arc(hx, hy, growR, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // Draw all balls
    for (let bi = 0; bi < this.balls.length; bi++) {
      const ball = this.balls[bi];
      if (ball.sunk || ball.hidden) continue;

      // Check stealth
      if (isGilmore) {
        const owner = Gilmore.players.find(p => p.ballIndex === bi);
        if (owner && owner.stealthTurns > 0 && owner.isBot) {
          // Stealth bots are nearly invisible
          ctx.save();
          ctx.globalAlpha = 0.15;
          Renderer.drawBall(ball, owner.skin);
          ctx.restore();
          continue;
        }
        if (owner && owner.stealthTurns > 0 && !owner.isBot) {
          ctx.save();
          ctx.globalAlpha = 0.35;
          Renderer.drawBallMotionEffects(ball, owner.skin);
          Renderer.drawBall(ball, owner.skin);
          ctx.restore();
          continue;
        }
      }

      if (bi === 0) {
        // Player ball
        Renderer.drawBallMotionEffects(ball, this.playerData.equippedBall);
        Renderer.drawBall(ball, this.playerData.equippedBall);
      } else if (isGilmore) {
        // Bot balls with their own skins
        const owner = Gilmore.players.find(p => p.ballIndex === bi);
        const skinId = owner ? owner.skin : 'ball_flame';
        Renderer.drawBallMotionEffects(ball, skinId);
        Renderer.drawBall(ball, skinId);
        // Name label above bot ball
        if (owner) {
          ctx.save();
          ctx.font = '9px "Space Mono"';
          ctx.textAlign = 'center';
          ctx.fillStyle = 'rgba(255,255,255,0.6)';
          ctx.fillText(owner.name.split(' ').pop(), ball.x, ball.y - 16);
          ctx.restore();
        }
      } else {
        Renderer.drawBall(ball, ball.color ? 'ball_flame' : 'ball_neon');
      }
    }

    // Swap ability targeting ‚Äî highlight enemy balls with pulsing rings
    if (isGilmore && Gilmore.turnPhase === 'ability_targeting' && Gilmore.targetingType === 'swap') {
      const t = performance.now() / 1000;
      const curP = Gilmore.getCurrentPlayer();
      ctx.save();
      for (const p of Gilmore.players) {
        if (p === curP) continue;
        const b = this.balls[p.ballIndex];
        if (!b || b.sunk || b.hidden) continue;
        const pulse = 0.5 + 0.3 * Math.sin(t * 5);
        ctx.globalAlpha = pulse;
        ctx.strokeStyle = '#33ff44';
        ctx.lineWidth = 2.5;
        ctx.setLineDash([4, 3]);
        ctx.beginPath();
        ctx.arc(b.x, b.y, 18 + Math.sin(t * 3) * 3, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
        // "SWAP" label
        ctx.globalAlpha = 0.7;
        ctx.font = 'bold 8px "Space Mono"';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#33ff44';
        ctx.fillText('SWAP', b.x, b.y - 24);
      }
      // Instruction text
      ctx.globalAlpha = 0.8;
      ctx.font = 'bold 12px "Space Mono"';
      ctx.textAlign = 'center';
      ctx.fillStyle = '#33ff44';
      ctx.fillText('üëΩ Click an enemy ball to swap!', Renderer.W / 2, 30);
      ctx.restore();
    }

    // Aim line + club when aiming (drag or click mode)
    const playerBall = this.getPlayerBall();
    const isAiming = (Input.dragging || Input.clickAiming) && this.canShoot();
    if (isAiming && playerBall) {
      Renderer.drawAimLine(playerBall, Input.aimAngle, Input.aimPower);
      Renderer.drawClub(playerBall, Input.aimAngle, this.playerData.equippedClub);

      // Click-to-aim: draw target reticle + power ring
      if (Input.clickAiming) {
        const ctx = Renderer.ctx;
        ctx.save();
        // Target crosshair at click position
        ctx.strokeStyle = 'rgba(57,255,20,0.6)';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([4,3]);
        ctx.beginPath();
        ctx.moveTo(Input.clickTargetX - 12, Input.clickTargetY);
        ctx.lineTo(Input.clickTargetX + 12, Input.clickTargetY);
        ctx.moveTo(Input.clickTargetX, Input.clickTargetY - 12);
        ctx.lineTo(Input.clickTargetX, Input.clickTargetY + 12);
        ctx.stroke();
        ctx.setLineDash([]);
        // Power ring around ball
        const ringR = 20 + Input.clickChargePower * 25;
        ctx.beginPath();
        ctx.arc(playerBall.x, playerBall.y, ringR, 0, Math.PI * 2 * Input.clickChargePower);
        const ringColor = Input.clickChargePower > 0.8 ? '#ff3333' : Input.clickChargePower > 0.5 ? '#ffaa00' : '#39ff14';
        ctx.strokeStyle = ringColor;
        ctx.lineWidth = 3;
        ctx.stroke();
        // Power % text
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 11px "Space Mono"';
        ctx.textAlign = 'center';
        ctx.fillText(Math.round(Input.clickChargePower * 100) + '%', playerBall.x, playerBall.y - ringR - 8);
        ctx.restore();
      }

      // Update power meter with danger zone coloring
      document.getElementById('powerMeter').style.display = 'block';
      const powerFill = document.getElementById('powerFill');
      const pct = Input.aimPower * 100;
      powerFill.style.height = pct + '%';
      if (Input.aimPower > 0.8) {
        powerFill.style.background = 'linear-gradient(to top, var(--neon-green), var(--neon-yellow), #ff3333, #ff0000)';
      } else if (Input.aimPower > 0.5) {
        powerFill.style.background = 'linear-gradient(to top, var(--neon-green), var(--neon-yellow), var(--danger))';
      } else {
        powerFill.style.background = 'linear-gradient(to top, var(--neon-green), var(--neon-yellow), var(--danger))';
      }
    } else {
      document.getElementById('powerMeter').style.display = 'none';
    }

    // Gilmore timing bar overlay
    if (Input.gilmoreActive) {
      const ctx = Renderer.ctx;
      const W = Renderer.W;
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(W/2 - 120, 60, 240, 30);
      ctx.fillStyle = '#ff3333';
      const barW = 236 * Input.gilmorePower;
      ctx.fillRect(W/2 - 118, 62, barW, 26);
      // Sweet spot indicator
      ctx.fillStyle = '#39ff14';
      ctx.fillRect(W/2 + 50, 62, 10, 26);
      ctx.fillStyle = '#fff';
      ctx.font = '12px "Space Mono"';
      ctx.textAlign = 'center';
      ctx.fillText('TAP / SPACE to swing!', W/2, 55);
    }

    // Particles on top
    Particles.draw(Renderer.ctx);

    // End screen shake
    ctx.restore();
  }
};

// ‚îÄ‚îÄ‚îÄ UI MANAGER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Controls all screen transitions, HUD updates, store rendering, achievements.
const UI = {
  init() {
    this.buildClubSelector();
    this.buildStore();
    this.buildAchievements();

    document.getElementById('hudBack').addEventListener('click', () => {
      Game.state = 'menu';
      Game.useBots = false;
      Gilmore.reset();
      this.showScreen('mainMenu');
    });
  },

  showScreen(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    const el = document.getElementById(id);
    if (el) el.classList.add('active');

    // Hide gameplay elements
    document.getElementById('hud').classList.remove('active');
    document.getElementById('powerMeter').style.display = 'none';
    document.getElementById('clubSelector').style.display = 'none';
    // Hide Gilmore UI
    document.getElementById('gilmoreTurnBar').style.display = 'none';
    document.getElementById('gilmoreAbilityBtn').style.display = 'none';
    document.getElementById('gilmoreScoreboard').style.display = 'none';
    document.getElementById('abilityTooltip').style.display = 'none';
    document.getElementById('maxStrokesBar').style.display = 'none';

    Game.state = 'menu';
    Game.updateCreditsDisplay();

    if (id === 'storeScreen') this.buildStore();
    if (id === 'achievementsScreen') this.buildAchievements();
    if (id === 'gilmoreBotSelect') this.buildGilmoreBotSelect();
    if (id === 'gilmoreDiffSelect') this.buildGilmoreDiffSelect();
    if (id === 'botCountSelect') this.buildBotCountSelect();
    if (id === 'gilmoreAbilityInfo') this.buildAbilityInfoScreen();
  },

  showGameplay() {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById('hud').classList.add('active');
    document.getElementById('clubSelector').style.display = 'block';
    // Show turn UI if bots are active
    if (Game.hasBots()) {
      document.getElementById('gilmoreTurnBar').style.display = 'block';
      document.getElementById('gilmoreScoreboard').style.display = 'block';
    }
  },

  updateHUD(hole, par, strokes) {
    const total = Game.levels ? Game.levels.length : '?';
    document.getElementById('hudHole').textContent = `${hole}/${total}`;
    document.getElementById('hudPar').textContent = par;
    document.getElementById('hudStrokes').textContent = strokes;
    document.getElementById('hudCredits').textContent = Game.playerData.credits;
  },

  // ‚îÄ‚îÄ CLUB SELECTOR ‚îÄ‚îÄ
  buildClubSelector() {
    const container = document.getElementById('clubSelector');
    container.innerHTML = '<div style="font-size:0.65rem;color:#666;padding:4px 8px;text-transform:uppercase;letter-spacing:1px;">Club</div>';
    for (const club of CosmeticsCatalog.clubs) {
      if (!Game.playerData.ownedClubs.includes(club.id)) continue;
      const btn = document.createElement('button');
      btn.className = 'club-btn' + (Game.playerData.equippedClub === club.id ? ' active' : '');
      const dot = `<span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:${club.headColor};margin-right:4px;vertical-align:middle;${club.glow ? 'box-shadow:0 0 4px ' + club.glow : ''}"></span>`;
      btn.innerHTML = dot + club.name;
      btn.onclick = () => {
        Store.equip(club.id, Game.playerData);
        this.buildClubSelector();
      };
      container.appendChild(btn);
    }
  },

  // ‚îÄ‚îÄ GILMORE BOT SELECTOR ‚îÄ‚îÄ
  buildGilmoreBotSelect() {
    const container = document.getElementById('gilmoreBotBtns');
    container.innerHTML = '';

    const title = document.getElementById('gilmoreBotTitle');
    const info = document.getElementById('gilmoreBotInfo');

    if (Game.mode === 'gilmore_bots') {
      title.textContent = 'How Many Bots?';
      info.textContent = 'Bots use abilities and have unique skins!';
    } else {
      title.textContent = 'How Many Players?';
      info.textContent = 'Pass the device between turns!';
    }

    const maxCount = 9;
    for (let i = 1; i <= maxCount; i++) {
      const btn = document.createElement('button');
      btn.className = 'bot-count-btn' + (Game.gilmoreBotCount === i ? ' active' : '');
      btn.textContent = i;
      btn.onclick = () => {
        Game.gilmoreBotCount = i;
        this.buildGilmoreBotSelect();
      };
      container.appendChild(btn);
    }
  },

  buildGilmoreDiffSelect() {
    const grid = document.getElementById('gilmoreTierGrid');
    grid.innerHTML = '';
    const tiers = [
      { id: 'rookie', icon: '‚õ≥', name: 'Rookie',  info: '9 holes ‚Ä¢ Easy bots ‚Ä¢ Calm courses',       color: '#44cc44' },
      { id: 'pro',    icon: 'üèåÔ∏è', name: 'Pro',     info: '12 holes ‚Ä¢ Smart bots ‚Ä¢ Tricky terrain',    color: '#4488ff' },
      { id: 'legend', icon: 'üèÜ', name: 'Legend',   info: '15 holes ‚Ä¢ Tough bots ‚Ä¢ Wild hazards',      color: '#ff8800' },
      { id: 'chaos',  icon: 'üî•', name: 'Chaos',    info: '20 holes ‚Ä¢ Expert bots ‚Ä¢ Total mayhem!',    color: '#ff2244' },
    ];
    for (const t of tiers) {
      const btn = document.createElement('button');
      btn.className = 'gilmore-tier-btn' + (Game.gilmoreDifficulty === t.id ? ' active' : '');
      btn.innerHTML = `<span class="tier-icon">${t.icon}</span><span class="tier-name" style="color:${t.color}">${t.name}</span><span class="tier-info">${t.info}</span>`;
      btn.onclick = () => {
        Game.gilmoreDifficulty = t.id;
        this.buildGilmoreDiffSelect();
      };
      grid.appendChild(btn);
    }
  },

  buildBotCountSelect() {
    const container = document.getElementById('botCountBtns');
    container.innerHTML = '';
    for (let i = 1; i <= 5; i++) {
      const btn = document.createElement('button');
      btn.className = 'bot-count-btn' + (Game.botCountForMode === i ? ' active' : '');
      btn.textContent = i;
      btn.onclick = () => {
        Game.botCountForMode = i;
        this.buildBotCountSelect();
      };
      container.appendChild(btn);
    }
  },

  // ‚îÄ‚îÄ GILMORE ABILITY INFO SCREEN ‚îÄ‚îÄ
  buildAbilityInfoScreen() {
    const grid = document.getElementById('abilityGrid');
    grid.innerHTML = '';
    const balls = CosmeticsCatalog.balls;
    for (const ball of balls) {
      const ability = GilmoreAbilities[ball.id];
      if (!ability) continue;
      const card = document.createElement('div');
      card.className = 'ability-card';
      card.innerHTML = `
        <span class="ab-icon">${ability.icon}</span>
        <span class="ab-name">${ability.name}</span>
        <div class="ab-desc">${ability.desc}</div>
        <div class="ab-skin">üé± ${ball.name}</div>
      `;
      card.style.borderLeft = `3px solid ${ability.color}`;
      grid.appendChild(card);
    }
  },

  // ‚îÄ‚îÄ ABILITY TOOLTIP (hover on ability button) ‚îÄ‚îÄ
  showAbilityTooltip() {
    if (!Gilmore.active || !Gilmore.isPlayerTurn()) return;
    const player = Gilmore.getCurrentPlayer();
    if (!player) return;
    const ability = GilmoreAbilities[player.skin];
    if (!ability) return;
    const tt = document.getElementById('abilityTooltip');
    document.getElementById('ttName').textContent = `${ability.icon} ${ability.name}`;
    document.getElementById('ttDesc').textContent = ability.desc;
    if (player.abilityUsed) {
      document.getElementById('ttDesc').textContent = 'Already used this hole!';
    }
    tt.style.display = 'block';
  },
  hideAbilityTooltip() {
    document.getElementById('abilityTooltip').style.display = 'none';
  },

  // ‚îÄ‚îÄ SCORE SUMMARY ‚îÄ‚îÄ
  showScoreSummary(strokes, par, breakdown, newAchs, isLastHole) {
    const el = document.getElementById('scoreSummary');
    el.classList.add('active');

    // Title
    let title = 'Hole Complete!';
    if (strokes === 1) title = 'üéØ HOLE IN ONE!';
    else if (strokes <= par - 2) title = 'ü¶Ö EAGLE!';
    else if (strokes === par - 1) title = 'üê¶ BIRDIE!';
    else if (strokes === par) title = 'Par ‚Äî Nice!';
    else title = `+${strokes - par} Over Par`;

    document.getElementById('sumTitle').textContent = title;
    document.getElementById('sumStrokes').textContent = `Strokes: ${strokes}  |  Par: ${par}`;

    const diff = strokes - par;
    let parText = '';
    if (diff < 0) parText = `${Math.abs(diff)} under par!`;
    else if (diff === 0) parText = 'Even par';
    else parText = `${diff} over par`;
    document.getElementById('sumPar').textContent = parText;

    document.getElementById('sumBonuses').innerHTML = breakdown.bonuses.join('<br>');
    document.getElementById('sumCredits').textContent = `+${breakdown.total} ‚≠ê`;

    // Achievement popups
    if (newAchs.length > 0) {
      const achText = newAchs.map(a => `${a.icon} ${a.name} unlocked! (+${a.reward}‚≠ê)`).join('<br>');
      document.getElementById('sumBonuses').innerHTML += '<br>' + achText;
    }

    const nextBtn = document.getElementById('sumNext');
    if (isLastHole) {
      if (Game.mode === 'tournament' || Game.mode === 'tournament_online') {
        nextBtn.textContent = 'üèÜ See Results';
      } else if (Game.hasBots()) {
        nextBtn.textContent = 'üèÜ See Standings';
      } else {
        nextBtn.textContent = 'Finish Course';
      }
    } else {
      nextBtn.textContent = 'Next Hole ‚Üí';
    }
  },

  hideScoreSummary() {
    document.getElementById('scoreSummary').classList.remove('active');
  },

  // ‚îÄ‚îÄ POST-GAME STATS ‚îÄ‚îÄ
  showPostGameStats(scores, placement) {
    this.hideScoreSummary();
    const gs = Game.gameStats;
    const el = document.getElementById('postGameStats');
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    el.classList.add('active');
    document.getElementById('hud').classList.remove('active');
    document.getElementById('clubSelector').style.display = 'none';
    document.getElementById('gilmoreTurnBar').style.display = 'none';
    document.getElementById('gilmoreAbilityBtn').style.display = 'none';
    document.getElementById('gilmoreScoreboard').style.display = 'none';
    Game.state = 'menu';

    // Title
    const title = document.getElementById('pgsTitle');
    const elapsed = Math.round((Date.now() - gs.startTime) / 1000);
    const mins = Math.floor(elapsed / 60);
    const secs = elapsed % 60;
    title.textContent = 'üìä Game Complete!';

    // Placement banner (if tournament/bots)
    const placementEl = document.getElementById('pgsPlacement');
    if (placement >= 0 && scores) {
      placementEl.style.display = 'block';
      if (placement === 0) {
        placementEl.textContent = 'ü•á 1st Place ‚Äî You Win!';
        placementEl.style.background = 'linear-gradient(135deg, rgba(255,215,0,0.2), rgba(255,180,0,0.1))';
        placementEl.style.color = '#ffd700';
        placementEl.style.border = '1px solid rgba(255,215,0,0.3)';
      } else if (placement === 1) {
        placementEl.textContent = 'ü•à 2nd Place';
        placementEl.style.background = 'rgba(192,192,192,0.1)';
        placementEl.style.color = '#c0c0d0';
        placementEl.style.border = '1px solid rgba(192,192,192,0.2)';
      } else if (placement === 2) {
        placementEl.textContent = 'ü•â 3rd Place';
        placementEl.style.background = 'rgba(205,127,50,0.1)';
        placementEl.style.color = '#cd7f32';
        placementEl.style.border = '1px solid rgba(205,127,50,0.2)';
      } else {
        placementEl.textContent = `#${placement + 1} of ${scores.length}`;
        placementEl.style.background = 'rgba(255,255,255,0.05)';
        placementEl.style.color = 'var(--text-secondary)';
        placementEl.style.border = '1px solid #1e293b';
      }
    } else {
      placementEl.style.display = 'none';
    }

    // Stat cards
    const grid = document.getElementById('pgsGrid');
    grid.innerHTML = '';
    const vsPar = gs.totalStrokes - gs.totalPar;
    const vsParStr = vsPar === 0 ? 'Even' : (vsPar > 0 ? `+${vsPar}` : `${vsPar}`);
    const vsParColor = vsPar < 0 ? 'highlight' : (vsPar === 0 ? '' : '');

    const statCards = [
      { val: gs.totalStrokes, label: 'Total Strokes', cls: '' },
      { val: vsParStr, label: 'vs Par', cls: vsParColor },
      { val: gs.holeData.length, label: 'Holes Played', cls: '' },
      { val: `${mins}:${secs.toString().padStart(2,'0')}`, label: 'Time', cls: '' },
      { val: gs.totalCredits, label: 'Credits Earned', cls: 'gold' },
      { val: gs.holeInOnes, label: 'Hole-in-Ones', cls: gs.holeInOnes > 0 ? 'highlight' : '' },
    ];

    // Score distribution row
    const distParts = [];
    if (gs.eagles > 0) distParts.push(`ü¶Ö ${gs.eagles}`);
    if (gs.birdies > 0) distParts.push(`üê¶ ${gs.birdies}`);
    if (gs.pars > 0) distParts.push(`‚õ≥ ${gs.pars}`);
    if (gs.bogeys > 0) distParts.push(`üìå ${gs.bogeys}`);
    if (gs.doubleBogeys + gs.worse > 0) distParts.push(`üí• ${gs.doubleBogeys + gs.worse}`);

    for (const sc of statCards) {
      const card = document.createElement('div');
      card.className = 'pgs-stat ' + sc.cls;
      card.innerHTML = `<div class="pgs-val">${sc.val}</div><div class="pgs-label">${sc.label}</div>`;
      grid.appendChild(card);
    }

    // Best & worst hole (span full width)
    if (gs.bestHole) {
      const best = document.createElement('div');
      best.className = 'pgs-stat highlight';
      best.style.gridColumn = '1';
      best.innerHTML = `<div class="pgs-val">‚≠ê ${gs.bestHole.strokes} strokes</div><div class="pgs-label">Best: ${gs.bestHole.name}</div>`;
      grid.appendChild(best);
    }
    if (gs.worstHole && gs.holeData.length > 1) {
      const worst = document.createElement('div');
      worst.className = 'pgs-stat';
      worst.style.gridColumn = '2';
      worst.innerHTML = `<div class="pgs-val">üíÄ ${gs.worstHole.strokes} strokes</div><div class="pgs-label">Worst: ${gs.worstHole.name}</div>`;
      grid.appendChild(worst);
    }

    // Score distribution card (full width)
    if (distParts.length > 0) {
      const dist = document.createElement('div');
      dist.className = 'pgs-stat';
      dist.style.gridColumn = '1 / -1';
      dist.innerHTML = `<div class="pgs-val" style="font-size:1rem">${distParts.join('  ')}</div><div class="pgs-label">Score Distribution (Eagle ¬∑ Birdie ¬∑ Par ¬∑ Bogey ¬∑ Worse)</div>`;
      grid.appendChild(dist);
    }

    // Hole-by-hole table
    const table = document.getElementById('pgsTable');
    table.innerHTML = '';
    const hdr = document.createElement('div');
    hdr.className = 'pgs-row header';
    hdr.innerHTML = '<span class="pgs-hole">#</span><span class="pgs-name">Hole</span><span class="pgs-par">Par</span><span class="pgs-strk">Strk</span><span class="pgs-score">Score</span>';
    table.appendChild(hdr);

    for (const h of gs.holeData) {
      const row = document.createElement('div');
      row.className = 'pgs-row';
      let scoreClass = 'par-score';
      if (h.diff <= -2) scoreClass = 'eagle';
      else if (h.diff === -1) scoreClass = 'birdie';
      else if (h.diff === 0) scoreClass = 'par-score';
      else if (h.diff === 1) scoreClass = 'bogey';
      else scoreClass = 'bad';

      const themeEmoji = { castle:'üè∞', pirate:'üè¥‚Äç‚ò†Ô∏è', pyramid:'üè∫', monster:'üëæ', dragon:'üêâ',
        dungeon:'üïØÔ∏è', haunted:'üëª', tropical:'üå¥', volcano:'üåã', space:'üõ∏', neon:'üíú',
        grass:'üåø', desert:'üèúÔ∏è', snow:'‚ùÑÔ∏è', canyon:'üèúÔ∏è', rooftop:'üè¢' }[h.theme] || '‚õ≥';

      row.innerHTML = `<span class="pgs-hole">${h.hole}</span>`
        + `<span class="pgs-name">${themeEmoji} ${h.name}</span>`
        + `<span class="pgs-par">${h.par}</span>`
        + `<span class="pgs-strk">${h.strokes}</span>`
        + `<span class="pgs-score ${scoreClass}">${h.scoreName}</span>`;
      table.appendChild(row);
    }

    // Totals row
    const totRow = document.createElement('div');
    totRow.className = 'pgs-row';
    totRow.style.borderTop = '2px solid #334';
    totRow.style.fontWeight = '700';
    totRow.innerHTML = `<span class="pgs-hole"></span>`
      + `<span class="pgs-name">TOTAL</span>`
      + `<span class="pgs-par">${gs.totalPar}</span>`
      + `<span class="pgs-strk">${gs.totalStrokes}</span>`
      + `<span class="pgs-score ${vsPar < 0 ? 'birdie' : vsPar === 0 ? 'par-score' : 'bogey'}">${vsParStr}</span>`;
    table.appendChild(totRow);

    // Leaderboard table (if scores provided)
    const lbTitle = document.getElementById('pgsLbTitle');
    const lbTable = document.getElementById('pgsLbTable');
    if (scores && scores.length > 0) {
      lbTitle.style.display = 'block';
      lbTable.style.display = 'block';
      lbTable.innerHTML = '';
      const lbHdr = document.createElement('div');
      lbHdr.className = 'lb-row header';
      lbHdr.innerHTML = '<span class="lb-name">Rank  Player</span><span class="lb-score">Strokes</span>';
      lbTable.appendChild(lbHdr);
      scores.forEach((s, i) => {
        const row = document.createElement('div');
        row.className = 'lb-row' + (s.isPlayer ? ' player' : '');
        const icon = s.isPlayer ? 'üë§' : (s.isOnline ? 'üåê' : 'ü§ñ');
        row.innerHTML = `<span class="lb-name">${i+1}. ${icon} ${s.name}</span><span class="lb-score">${s.totalStrokes}</span>`;
        lbTable.appendChild(row);
      });
    } else {
      lbTitle.style.display = 'none';
      lbTable.style.display = 'none';
    }

    // Scroll to top
    document.querySelector('.pgs-scroll').scrollTop = 0;
  },

  // ‚îÄ‚îÄ LEADERBOARD ‚îÄ‚îÄ
  showLeaderboard(scores, playerPlacement) {
    this.hideScoreSummary();
    const el = document.getElementById('leaderboard');
    el.classList.add('active');
    document.querySelectorAll('.screen').forEach(s => { if (s.id !== 'leaderboard') s.classList.remove('active'); });

    // Update title based on mode
    const titleEl = el.querySelector('.menu-title');
    if (Game.mode === 'tournament_online') {
      titleEl.textContent = 'üåê Online Results';
    } else if (Game.hasBots()) {
      titleEl.textContent = 'üèÜ Final Standings';
    } else {
      titleEl.textContent = 'üèÜ Leaderboard';
    }

    const table = document.getElementById('lbTable');
    table.innerHTML = '';

    const header = document.createElement('div');
    header.className = 'lb-row header';
    header.innerHTML = '<span class="lb-name">Rank  Player</span><span class="lb-score">Strokes</span>';
    table.appendChild(header);

    scores.forEach((s, i) => {
      const row = document.createElement('div');
      row.className = 'lb-row' + (s.isPlayer ? ' player' : '');
      const icon = s.isPlayer ? 'üë§' : (s.isOnline ? 'üåê' : 'ü§ñ');
      row.innerHTML = `<span class="lb-name">${i+1}. ${icon} ${s.name}</span><span class="lb-score">${s.totalStrokes}</span>`;
      table.appendChild(row);
    });

    Game.state = 'menu';
    document.getElementById('hud').classList.remove('active');
    document.getElementById('clubSelector').style.display = 'none';
  },

  // ‚îÄ‚îÄ STORE ‚îÄ‚îÄ
  buildStore() {
    const pd = Game.playerData;
    document.getElementById('storeCredits').textContent = pd.credits;

    // Tabs
    const tabs = document.getElementById('storeTabs');
    tabs.innerHTML = '';
    ['balls','clubs','effects'].forEach(tab => {
      const btn = document.createElement('button');
      btn.className = 'store-tab' + (Store.currentTab === tab ? ' active' : '');
      btn.textContent = tab.charAt(0).toUpperCase() + tab.slice(1);
      btn.onclick = () => { Store.currentTab = tab; this.buildStore(); };
      tabs.appendChild(btn);
    });

    // Grid
    const grid = document.getElementById('storeGrid');
    grid.innerHTML = '';
    const items = CosmeticsCatalog[Store.currentTab];
    if (!items) return;

    for (const item of items) {
      const owned = Store._ownsItem(item.id, pd);
      const equipped = (pd.equippedBall === item.id || pd.equippedClub === item.id || pd.equippedEffect === item.id);
      const locked = item.price === null && !owned;

      const div = document.createElement('div');
      div.className = 'store-item' + (owned ? ' owned' : '') + (equipped ? ' equipped' : '') + (locked ? ' locked' : '');

      // Preview
      const preview = document.createElement('div');
      preview.className = 'item-preview';
      if (item.color) {
        preview.style.background = item.color;
      } else if (item.headColor) {
        // Club preview: shaft-to-head gradient
        preview.style.background = `linear-gradient(135deg, ${item.shaftColor || '#555'}, ${item.headColor})`;
        if (item.glow) preview.style.boxShadow = `0 0 10px ${item.glow}`;
      } else {
        preview.style.background = '#555';
      }
      if (item.glow && item.color) {
        preview.style.boxShadow = `0 0 10px ${item.glow}`;
      }
      div.appendChild(preview);

      const name = document.createElement('div');
      name.className = 'item-name';
      name.textContent = item.name;
      div.appendChild(name);

      const rarity = document.createElement('div');
      rarity.className = `item-rarity rarity-${item.rarity}`;
      rarity.textContent = item.rarity;
      div.appendChild(rarity);

      if (equipped) {
        const badge = document.createElement('div');
        badge.className = 'item-badge';
        badge.textContent = 'EQUIPPED';
        badge.style.background = 'var(--neon-yellow)'; badge.style.color = '#000';
        div.appendChild(badge);
      } else if (locked) {
        const badge = document.createElement('div');
        badge.className = 'item-badge';
        badge.textContent = 'LOCKED';
        div.appendChild(badge);

        const price = document.createElement('div');
        price.className = 'item-price';
        price.style.color = 'var(--text-secondary)';
        const ach = AchievementsDef.find(a => a.id === item.achievement);
        price.textContent = ach ? ach.name : 'Achievement';
        div.appendChild(price);
      } else if (owned) {
        const badge = document.createElement('div');
        badge.className = 'item-badge';
        badge.textContent = 'OWNED';
        badge.style.background = 'var(--success)';
        div.appendChild(badge);
      } else if (item.price > 0) {
        const price = document.createElement('div');
        price.className = 'item-price';
        price.textContent = `${item.price} ‚≠ê`;
        div.appendChild(price);
      }

      // Click handler
      div.onclick = () => {
        if (equipped) return;
        if (owned) {
          Store.equip(item.id, pd);
          this.buildStore();
          this.buildClubSelector();
        } else if (!locked && Store.canBuy(item.id, pd)) {
          Store.buy(item.id, pd);
          Store.equip(item.id, pd);
          this.buildStore();
          this.buildClubSelector();
        }
      };

      grid.appendChild(div);
    }
  },

  // ‚îÄ‚îÄ ACHIEVEMENTS ‚îÄ‚îÄ
  buildAchievements() {
    const grid = document.getElementById('achGrid');
    grid.innerHTML = '';
    const pd = Game.playerData;

    for (const ach of AchievementsDef) {
      const unlocked = pd.achievements[ach.id];
      const card = document.createElement('div');
      card.className = 'ach-card' + (unlocked ? ' unlocked' : '');

      card.innerHTML = `
        <div class="ach-icon">${unlocked ? ach.icon : 'üîí'}</div>
        <div class="ach-name">${ach.name}</div>
        <div class="ach-desc">${ach.desc}</div>
        <div class="ach-reward">${unlocked ? '‚úÖ Completed' : `Reward: ${ach.reward} ‚≠ê`}</div>
      `;
      grid.appendChild(card);
    }
  }
};

// ‚îÄ‚îÄ‚îÄ BOOT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
window.addEventListener('DOMContentLoaded', () => Game.init());
</script>
</body>
</html>
