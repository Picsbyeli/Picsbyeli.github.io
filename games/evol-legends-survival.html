<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>EVOL LEGENDS - Tower Defense</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      background: #000;
      width: 100vw;
      height: 100vh;
      font-family: 'Courier New', monospace;
      color: #fff;
      overflow: hidden;
    }
    #gameContainer {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      width: 100%;
      height: 100%;
      background: #000;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    
    /* Title Screen */
    #titleScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: linear-gradient(135deg, #0a0015 0%, #1a0030 100%);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }
    #titleScreen.hidden { display: none; }
    
    .title {
      font-size: 72px;
      font-weight: bold;
      color: #00ffff;
      text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
      margin-bottom: 20px;
      animation: glow 2s ease-in-out infinite;
    }
    @keyframes glow {
      0%, 100% { text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff; }
      50% { text-shadow: 0 0 30px #00ffff, 0 0 60px #00ffff, 0 0 80px #00ffff; }
    }
    
    .subtitle {
      font-size: 24px;
      color: #ff00ff;
      margin-bottom: 40px;
      text-shadow: 0 0 10px #ff00ff;
    }
    
    .start-btn {
      padding: 20px 60px;
      font-size: 28px;
      font-weight: bold;
      background: linear-gradient(135deg, #ff0080 0%, #ff8c00 100%);
      color: #fff;
      border: 4px solid #00ffff;
      border-radius: 15px;
      cursor: pointer;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
      transition: all 0.3s;
    }
    .start-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
    }
    
    /* Class Selection Screen */
    #classSelection {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: linear-gradient(135deg, #0a0015 0%, #1a0030 100%);
      display: none;
      flex-direction: column;
      justify-content: flex-start; /* Start at top! */
      align-items: center;
      z-index: 100;
      overflow-y: auto;
      padding: 20px;
      scroll-behavior: smooth; /* Smooth scrolling */
    }
    #classSelection.active { 
      display: flex; 
      /* Force scroll to top when opened */
    }
    
    .class-title {
      font-size: 42px;
      color: #00ffff;
      text-shadow: 0 0 20px #00ffff;
      margin-bottom: 10px;
    }
    
    .class-subtitle {
      font-size: 16px;
      color: #ffff00;
      margin-bottom: 30px;
    }
    
    .class-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      max-width: 900px;
      width: 100%;
    }
    
    .class-card {
      background: linear-gradient(135deg, #1a1a3a 0%, #2a1a3a 100%);
      border: 3px solid #00ffff;
      border-radius: 15px;
      padding: 20px;
      cursor: pointer;
      transition: all 0.3s;
      position: relative;
    }
    .class-card:hover:not(.locked) {
      transform: translateY(-10px);
      box-shadow: 0 10px 30px rgba(0, 255, 255, 0.5);
      border-color: #ffff00;
    }
    .class-card.locked {
      opacity: 0.5;
      cursor: not-allowed;
      border-color: #666;
    }
    .class-card.locked::after {
      content: "üîí";
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 32px;
    }
    
    .class-icon {
      font-size: 48px;
      text-align: center;
      margin-bottom: 10px;
    }
    .class-name {
      font-size: 22px;
      font-weight: bold;
      text-align: center;
      margin-bottom: 10px;
    }
    .class-stats {
      font-size: 12px;
      color: #aaa;
      line-height: 1.6;
    }
    .class-unlock {
      font-size: 12px;
      color: #ff8800;
      text-align: center;
      margin-top: 10px;
      font-weight: bold;
    }
    
    /* Unlock Requirements Modal */
    #unlockModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      z-index: 200;
      display: none;
      align-items: center;
      justify-content: center;
    }
    
    #unlockModal.active {
      display: flex;
    }
    
    .unlock-modal-content {
      position: relative;
      background: linear-gradient(135deg, #1a1a3a 0%, #2a1a3a 100%);
      border: 3px solid #00ffff;
      border-radius: 15px;
      padding: 30px;
      min-width: 400px;
      max-width: 90%;
      box-shadow: 0 0 50px rgba(0, 255, 255, 0.5);
      animation: modalSlideIn 0.3s ease-out;
    }
    
    @keyframes modalSlideIn {
      from {
        transform: scale(0.8);
        opacity: 0;
      }
      to {
        transform: scale(1);
        opacity: 1;
      }
    }
    
    .unlock-modal-title {
      font-size: 28px;
      color: #00ffff;
      text-align: center;
      margin-bottom: 20px;
      text-shadow: 0 0 10px #00ffff;
    }
    
    .unlock-modal-icon {
      font-size: 60px;
      text-align: center;
      margin-bottom: 15px;
    }
    
    .unlock-modal-requirement {
      font-size: 18px;
      color: #ffff00;
      text-align: center;
      margin-bottom: 15px;
      line-height: 1.6;
    }
    
    .unlock-modal-desc {
      font-size: 14px;
      color: #aaaaaa;
      text-align: center;
      margin-bottom: 25px;
    }
    
    .unlock-modal-close {
      background: #ff4444;
      color: white;
      border: none;
      padding: 12px 40px;
      font-size: 18px;
      border-radius: 8px;
      cursor: pointer;
      display: block;
      margin: 0 auto;
      font-family: 'Courier New', monospace;
      font-weight: bold;
    }
    
    .unlock-modal-close:hover {
      background: #ff6666;
      box-shadow: 0 0 15px #ff4444;
    }
    
    /* Shop Screen */
    #shopScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      flex-direction: column;
      align-items: center;
      z-index: 90;
      overflow-y: auto;
      padding: 20px;
    }
    #shopScreen.active { display: flex; }
    
    .shop-header {
      width: 100%;
      max-width: 900px;
      background: linear-gradient(135deg, #1a1a3a 0%, #2a1a3a 100%);
      border: 3px solid #00ffff;
      border-radius: 15px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .shop-title {
      font-size: 36px;
      color: #ffff00;
      text-shadow: 0 0 20px #ffff00;
      text-align: center;
      margin-bottom: 10px;
    }
    .shop-currency {
      display: flex;
      justify-content: center;
      gap: 40px;
      font-size: 20px;
      color: #00ffff;
    }
    
    .shop-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
      max-width: 900px;
      width: 100%;
      margin-bottom: 20px;
    }
    
    .shop-item {
      background: linear-gradient(135deg, #2a1a3a 0%, #3a2a4a 100%);
      border: 2px solid #00ffff;
      border-radius: 10px;
      padding: 15px;
      cursor: pointer;
      transition: all 0.3s;
    }
    .shop-item:hover:not(.maxed) {
      transform: scale(1.05);
      box-shadow: 0 5px 20px rgba(0, 255, 255, 0.5);
    }
    .shop-item.maxed {
      opacity: 0.6;
      cursor: not-allowed;
      border-color: #666;
    }
    
    .shop-item-name {
      font-size: 18px;
      font-weight: bold;
      color: #ffff00;
      margin-bottom: 5px;
    }
    .shop-item-desc {
      font-size: 12px;
      color: #aaa;
      margin-bottom: 10px;
    }
    .shop-item-level {
      font-size: 14px;
      color: #00ff00;
      margin-bottom: 5px;
    }
    .shop-item-cost {
      font-size: 16px;
      color: #ff8800;
      font-weight: bold;
    }
    
    .shop-close-btn {
      padding: 15px 40px;
      font-size: 20px;
      background: #ff0000;
      color: #fff;
      border: 2px solid #fff;
      border-radius: 10px;
      cursor: pointer;
      font-weight: bold;
    }
    .shop-close-btn:hover {
      background: #cc0000;
      transform: scale(1.05);
    }
    
    /* Upgrade Screen */
    #upgradeScreen {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #1a0030 0%, #2a0050 100%);
      border: 4px solid #00ffff;
      border-radius: 20px;
      padding: 30px;
      display: none;
      flex-direction: column;
      align-items: center;
      z-index: 90;
      box-shadow: 0 0 50px rgba(0, 255, 255, 0.5);
    }
    #upgradeScreen.active { display: flex; }
    
    /* BTD-Style Upgrade Tree */
    #upgradeTreeScreen {
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: linear-gradient(135deg, #0a0015 0%, #1a0030 100%);
      display: none;
      flex-direction: column;
      z-index: 95;
      overflow-y: auto;
    }
    #upgradeTreeScreen.active { display: flex; }
    
    .upgrade-tree-header {
      padding: 20px;
      background: linear-gradient(135deg, #2a0050 0%, #3a1060 100%);
      border-bottom: 3px solid #00ffff;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .upgrade-tree-title {
      font-size: 36px;
      color: #ffff00;
      text-shadow: 0 0 20px #ffff00;
    }
    
    .upgrade-tree-info {
      display: flex;
      gap: 30px;
      font-size: 20px;
      color: #00ffff;
    }
    
    .upgrade-tree-container {
      flex: 1;
      display: flex;
      gap: 20px;
      padding: 30px;
      justify-content: center;
      align-items: flex-start;
    }
    
    .upgrade-path {
      flex: 1;
      max-width: 350px;
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .path-header {
      font-size: 24px;
      font-weight: bold;
      color: #00ffff;
      text-align: center;
      padding: 15px;
      background: linear-gradient(135deg, #2a1a3a 0%, #3a2a4a 100%);
      border: 2px solid #00ffff;
      border-radius: 10px;
      text-shadow: 0 0 10px #00ffff;
    }
    
    .path-upgrades {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .upgrade-node {
      background: linear-gradient(135deg, #2a1a3a 0%, #3a2a4a 100%);
      border: 3px solid #666;
      border-radius: 12px;
      padding: 15px;
      cursor: pointer;
      transition: all 0.3s;
      position: relative;
    }
    
    .upgrade-node.available {
      border-color: #00ff00;
      box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
    }
    
    .upgrade-node.available:hover {
      transform: translateY(-5px);
      border-color: #00ffff;
      box-shadow: 0 5px 20px rgba(0, 255, 255, 0.5);
    }
    
    .upgrade-node.purchased {
      border-color: #ffff00;
      background: linear-gradient(135deg, #3a2a1a 0%, #4a3a2a 100%);
      box-shadow: 0 0 15px rgba(255, 255, 0, 0.3);
    }
    
    .upgrade-node.locked {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .upgrade-node.master {
      border: 4px solid #ff00ff;
      background: linear-gradient(135deg, #3a1a4a 0%, #4a2a5a 100%);
      box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
    }
    
    .upgrade-node-tier {
      position: absolute;
      top: 5px;
      right: 10px;
      font-size: 12px;
      color: #888;
      font-weight: bold;
    }
    
    .upgrade-node-name {
      font-size: 18px;
      font-weight: bold;
      color: #fff;
      margin-bottom: 8px;
    }
    
    .upgrade-node.master .upgrade-node-name {
      color: #ff00ff;
      text-shadow: 0 0 10px #ff00ff;
    }
    
    .upgrade-node-desc {
      font-size: 13px;
      color: #aaa;
      margin-bottom: 10px;
      line-height: 1.4;
    }
    
    .upgrade-node-cost {
      font-size: 14px;
      color: #00ffff;
      font-weight: bold;
    }
    
    .upgrade-node.purchased .upgrade-node-cost {
      color: #ffff00;
    }
    
    .upgrade-tree-close {
      margin: 20px auto;
      padding: 15px 50px;
      font-size: 24px;
      font-weight: bold;
      background: linear-gradient(135deg, #ff0080 0%, #ff8c00 100%);
      color: #fff;
      border: 4px solid #00ffff;
      border-radius: 15px;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
    }
    
    .upgrade-tree-close:hover {
      transform: scale(1.05);
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
    }
    
    .upgrade-title {
      font-size: 32px;
      color: #ffff00;
      text-shadow: 0 0 20px #ffff00;
      margin-bottom: 10px;
    }
    .upgrade-subtitle {
      font-size: 16px;
      color: #00ffff;
      margin-bottom: 20px;
    }
    
    #upgradeOptions {
      display: flex;
      gap: 20px;
      flex-wrap: nowrap; /* Single row - all horizontal */
      justify-content: center;
      overflow-x: auto; /* Allow scroll if needed */
    }
    
    .upgrade-card {
      background: linear-gradient(135deg, #2a1a3a 0%, #3a2a4a 100%);
      border: 3px solid #00ffff;
      border-radius: 15px;
      padding: 20px;
      width: 180px; /* Slightly smaller for horizontal fit */
      min-width: 180px; /* Prevent shrinking */
      cursor: pointer;
      transition: all 0.3s;
    }
    .upgrade-card:hover {
      transform: translateY(-10px);
      box-shadow: 0 10px 30px rgba(0, 255, 255, 0.5);
      border-color: #ffff00;
    }
    
    .upgrade-card-icon {
      font-size: 48px;
      text-align: center;
      margin-bottom: 10px;
    }
    .upgrade-card-title {
      font-size: 18px;
      font-weight: bold;
      color: #ffff00;
      text-align: center;
      margin-bottom: 8px;
    }
    .upgrade-card-desc {
      font-size: 13px;
      color: #aaa;
      text-align: center;
    }
    
    .upgrade-card-skip {
      background: linear-gradient(135deg, #3a2a2a 0%, #4a3a3a 100%);
      border-color: #ff4444;
    }
    
    .upgrade-card-skip:hover {
      border-color: #ff8888;
      box-shadow: 0 10px 30px rgba(255, 68, 68, 0.5);
    }
    
    /* Pause Menu */
    #pauseMenu {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 200;
    }
    
    #pauseMenu.active {
      display: flex;
    }
    
    .pause-content {
      background: linear-gradient(135deg, #1a1a3a 0%, #2a1a3a 100%);
      border: 4px solid #00ffff;
      border-radius: 20px;
      padding: 40px;
      min-width: 600px;
      max-height: 90vh;
      overflow-y: auto;
    }
    
    .pause-title {
      font-size: 48px;
      color: #ffff00;
      text-align: center;
      margin-bottom: 30px;
      text-shadow: 0 0 20px #ffff00;
    }
    
    .pause-section {
      margin-bottom: 30px;
      padding: 20px;
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid #00ffff;
      border-radius: 15px;
    }
    
    .pause-section-title {
      font-size: 24px;
      color: #00ffff;
      margin-bottom: 15px;
      text-shadow: 0 0 10px #00ffff;
    }
    
    .pause-stat {
      font-size: 16px;
      color: #ffffff;
      margin: 8px 0;
      display: flex;
      justify-content: space-between;
    }
    
    .pause-stat-label {
      color: #aaaaaa;
    }
    
    .pause-stat-value {
      color: #ffff00;
      font-weight: bold;
    }
    
    .pause-slider {
      width: 100%;
      margin: 10px 0;
    }
    
    .pause-button {
      width: 100%;
      padding: 15px;
      margin: 10px 0;
      font-size: 18px;
      font-weight: bold;
      color: white;
      background: linear-gradient(135deg, #ff0080 0%, #ff8c00 100%);
      border: 3px solid #00ffff;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .pause-button:hover {
      transform: scale(1.05);
      box-shadow: 0 0 20px #00ffff;
    }
    
    .pause-button.danger {
      background: linear-gradient(135deg, #8B0000, #FF0000);
      border-color: #ff0000;
    }
    
    .pause-button.danger:hover {
      box-shadow: 0 0 20px #ff0000;
    }
    
    /* Round Break Screen */
    #roundBreakScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 80;
    }
    #roundBreakScreen.active { display: flex; }
    
    .break-title {
      font-size: 48px;
      color: #00ffff;
      text-shadow: 0 0 20px #00ffff;
      margin-bottom: 20px;
    }
    .break-info {
      font-size: 20px;
      color: #ffff00;
      text-align: center;
      line-height: 1.8;
    }
    .break-timer {
      font-size: 72px;
      color: #ff00ff;
      text-shadow: 0 0 30px #ff00ff;
      margin: 20px 0;
    }
    
    #gameOverScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      color: white;
    }
    #gameOverScreen.active { display: flex; }
    
    .gameover-title {
      font-size: 64px;
      color: #ff0000;
      text-shadow: 0 0 30px #ff0000;
      margin-bottom: 20px;
      animation: pulse 2s infinite;
    }
    
    .gameover-countdown {
      font-size: 18px;
      color: #ffff00;
      margin-bottom: 20px;
      padding: 10px 20px;
      background: rgba(255, 255, 0, 0.1);
      border: 2px solid #ffff00;
      border-radius: 20px;
      text-shadow: 0 0 10px #ffff00;
    }
    
    #countdownTimer {
      font-size: 24px;
      font-weight: bold;
      color: #ff0000;
    }
    
    .gameover-stats {
      background: rgba(20, 20, 20, 0.8);
      border: 3px solid #00ffff;
      border-radius: 15px;
      padding: 30px 50px;
      margin: 20px 0;
      min-width: 500px;
    }
    
    .gameover-stat-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 0;
      border-bottom: 1px solid rgba(0, 255, 255, 0.2);
      font-size: 20px;
    }
    
    .gameover-stat-row:last-child {
      border-bottom: none;
    }
    
    .gameover-stat-label {
      color: #00ffff;
      font-weight: bold;
    }
    
    .gameover-stat-value {
      color: #ffff00;
      font-size: 24px;
      font-weight: bold;
    }
    
    .gameover-earnings {
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(0, 255, 255, 0.2));
      border: 3px solid #ffff00;
      border-radius: 15px;
      padding: 25px 50px;
      margin: 20px 0;
      min-width: 500px;
    }
    
    .gameover-earnings-title {
      font-size: 28px;
      color: #ffff00;
      text-align: center;
      margin-bottom: 20px;
      text-shadow: 0 0 10px #ffff00;
    }
    
    .gameover-continue {
      margin-top: 30px;
      padding: 15px 40px;
      font-size: 20px;
      background: linear-gradient(135deg, #ff0000, #ff8800);
      color: white;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-weight: bold;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
      box-shadow: 0 4px 15px rgba(255, 0, 0, 0.5);
      transition: all 0.3s;
    }
    
    .gameover-continue:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 20px rgba(255, 0, 0, 0.7);
    }
    
    #statusText {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 24px;
      font-weight: bold;
      color: #ff0000;
      text-shadow: 0 0 10px #ff0000;
      text-align: center;
      z-index: 70;
      display: none;
      background: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border: 2px solid #ff0000;
      border-radius: 10px;
    }
    
    #potionBar {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: none; /* HIDDEN - Using canvas version instead */
      gap: 10px;
      z-index: 60;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px 20px;
      border-radius: 15px;
      border: 3px solid #00ffff;
    }
    
    .potion-slot {
      width: 60px;
      height: 70px;
      background: rgba(40, 40, 40, 0.9);
      border: 2px solid #666;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    
    .potion-slot:hover:not(.cooldown) {
      transform: scale(1.1);
      border-color: #00ffff;
      box-shadow: 0 0 15px #00ffff;
    }
    
    .potion-slot.cooldown {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .potion-icon {
      font-size: 32px;
      margin-bottom: 5px;
    }
    
    .potion-count {
      font-size: 14px;
      font-weight: bold;
      color: #ffff00;
      text-shadow: 0 0 5px #000;
    }
    
    .potion-key {
      position: absolute;
      top: 2px;
      left: 4px;
      font-size: 10px;
      color: #aaa;
      font-weight: bold;
    }
    
    .potion-cooldown-overlay {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.7);
      height: 100%;
      transition: height 0.1s;
    }
    
    .potion-effect-indicator {
      position: absolute;
      top: 70px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 255, 0, 0.8);
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 12px;
      color: white;
      white-space: nowrap;
      animation: pulse 1s infinite;
    }
    
    .back-arrow-btn {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #00ffff;
      color: #00ffff;
      font-size: 28px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s;
      z-index: 100;
    }
    
    .back-arrow-btn:hover {
      background: #00ffff;
      color: #000;
      transform: scale(1.1);
      box-shadow: 0 0 20px #00ffff;
    }
    
    .ability-btn {
      position: fixed;
      bottom: 150px;
      background: rgba(0, 0, 0, 0.8);
      border: 3px solid #ff00ff;
      color: #ffff00;
      padding: 15px 20px;
      border-radius: 10px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-weight: bold;
      font-size: 14px;
      transition: all 0.2s;
      min-width: 150px;
      text-align: center;
    }
    
    .ability-btn:hover:not(.cooldown) {
      transform: scale(1.05);
      box-shadow: 0 0 20px #ff00ff;
    }
    
    .ability-btn.cooldown {
      opacity: 0.5;
      cursor: not-allowed;
      border-color: #666;
    }
    
    .ability-btn.ready {
      border-color: #00ff00;
      animation: pulse 1s infinite;
    }
    
    #ability1Btn {
      right: 20px;
    }
    
    #ability2Btn {
      right: 190px;
    }
    
    /* Currency Conversion Button Hover Effects */
    button.shop-btn:hover {
      transform: scale(1.05) !important;
      box-shadow: 0 0 25px rgba(0,255,255,0.6) !important;
    }
    
    button.shop-btn:active {
      transform: scale(0.95) !important;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="1000" height="550"></canvas>
    
    <!-- Give Up Button (visible during gameplay) -->
    <button id="giveUpBtn" style="display: none; position: absolute; top: 10px; right: 180px; padding: 10px 20px; background: linear-gradient(135deg, #8B0000, #FF0000); color: white; font-family: 'Courier New', monospace; font-size: 14px; font-weight: bold; border: 2px solid #ff0000; border-radius: 8px; cursor: pointer; z-index: 100; box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);">
      ‚ùå GIVE UP
    </button>
    
    <!-- Title Screen -->
    <div id="titleScreen">
      <div class="title">EVOL LEGENDS</div>
      <div class="subtitle">‚öîÔ∏è TOWER DEFENSE ‚öîÔ∏è</div>
      <button class="start-btn" id="startBtn">START GAME</button>
      <button class="start-btn" id="waveSelectBtn" style="margin-top: 15px; font-size: 18px; padding: 12px 35px; background: linear-gradient(135deg, #00aaaa, #0066ff);">
        üéØ START FROM WAVE
      </button>
      <div style="margin-top: 30px; font-size: 14px; color: #888;">
        <div>üèÜ Highest Wave: <span id="highestWaveTitleDisplay">1</span></div>
        <div style="margin-top: 10px;">üí∞ <span id="totalCoinsDisplay">0</span> Coins | üíé <span id="totalGemsDisplay">0</span> Gems</div>
      </div>
      <button class="start-btn" id="shopBtn" style="margin-top: 20px; font-size: 20px; padding: 15px 40px;">üõí SHOP</button>
      <button class="start-btn" id="evolAuraBtn" style="margin-top: 10px; font-size: 20px; padding: 15px 40px; background: linear-gradient(135deg, #8B0000, #FF0000);">üåü EVOL AURA</button>
      <button class="start-btn" id="tutorialBtn" style="margin-top: 10px; font-size: 20px; padding: 15px 40px; background: linear-gradient(135deg, #00aa00, #00ff00);">üìñ HOW TO PLAY</button>
    </div>
    
    <!-- Tutorial/How to Play Screen -->
    <div id="tutorialScreen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); display: none; flex-direction: column; align-items: center; justify-content: flex-start; z-index: 100; overflow-y: auto; padding: 40px 20px;">
      <button style="position: absolute; top: 20px; left: 20px; padding: 15px 30px; font-size: 24px; background: linear-gradient(135deg, #ff0080 0%, #ff8c00 100%); color: #fff; border: 3px solid #00ffff; border-radius: 10px; cursor: pointer; font-weight: bold;" id="tutorialBackBtn">‚Üê BACK</button>
      
      <div style="max-width: 1000px; width: 100%;">
        <h1 style="font-size: 48px; color: #00ffff; text-align: center; margin-bottom: 30px; text-shadow: 0 0 20px #00ffff;">üìñ HOW TO PLAY</h1>
        
        <!-- CONTROLS -->
        <div style="background: linear-gradient(135deg, #1a1a3a 0%, #2a1a3a 100%); border: 3px solid #00ffff; border-radius: 15px; padding: 25px; margin-bottom: 20px;">
          <h2 style="font-size: 32px; color: #ffff00; margin-bottom: 20px;">üéÆ CONTROLS</h2>
          <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; font-size: 16px; color: #fff;">
            <div><span style="color: #00ff00; font-weight: bold;">[1-6]</span> - Use Potions (Heal, Shield, Crit, Damage, Speed, Dragon)</div>
            <div><span style="color: #00ff00; font-weight: bold;">[Q]</span> - Ultimate Ability 1</div>
            <div><span style="color: #00ff00; font-weight: bold;">[E]</span> - Ultimate Ability 2</div>
            <div><span style="color: #00ff00; font-weight: bold;">[T]</span> - Toggle Auto-Shoot (ON/OFF)</div>
            <div><span style="color: #00ff00; font-weight: bold;">[Y]</span> - Toggle Auto-Aim (ON/OFF)</div>
            <div><span style="color: #00ff00; font-weight: bold;">[R]</span> - Toggle Auto-Start Waves</div>
            <div><span style="color: #00ff00; font-weight: bold;">[F]</span> - Fast-Forward Mode (1x/2x Speed)</div>
            <div><span style="color: #00ff00; font-weight: bold;">[SPACE]</span> - Start Next Wave Manually</div>
          </div>
        </div>
        
        <!-- GAMEPLAY -->
        <div style="background: linear-gradient(135deg, #1a1a3a 0%, #2a1a3a 100%); border: 3px solid #ff00ff; border-radius: 15px; padding: 25px; margin-bottom: 20px;">
          <h2 style="font-size: 32px; color: #ff00ff; margin-bottom: 20px;">‚öîÔ∏è GAMEPLAY</h2>
          <div style="font-size: 16px; color: #fff; line-height: 1.8;">
            <p style="margin-bottom: 15px;">üéØ <strong>OBJECTIVE:</strong> Defend your tower from endless waves of enemies! Survive as long as possible and reach the highest wave.</p>
            <p style="margin-bottom: 15px;">üí∞ <strong>CURRENCY:</strong> Collect coins and gems from defeated enemies. Use them in the shop to unlock new classes and permanent upgrades.</p>
            <p style="margin-bottom: 15px;">‚≠ê <strong>LEVEL UP:</strong> Gain XP from kills to level up and choose powerful upgrades during battle.</p>
            <p style="margin-bottom: 15px;">üß™ <strong>POTIONS:</strong> Use potions (bottom bar) to heal, gain shields, or boost your abilities. They refill each wave!</p>
            <p style="margin-bottom: 15px;">üåü <strong>SKILL TREE:</strong> Unlock 2 ultimate abilities per class by reaching Level 10. Each class has 20 powerful options!</p>
          </div>
        </div>
        
        <!-- ENEMIES -->
        <div style="background: linear-gradient(135deg, #1a1a3a 0%, #2a1a3a 100%); border: 3px solid #ff0000; border-radius: 15px; padding: 25px; margin-bottom: 20px;">
          <h2 style="font-size: 32px; color: #ff0000; margin-bottom: 20px;">üëæ ENEMY TYPES</h2>
          <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; font-size: 16px; color: #fff;">
            <div><span style="color: #ffff00;">üî∫ SPEEDY</span> - Fast moving triangles</div>
            <div><span style="color: #00ff00;">üîµ HEALER</span> - Circles that heal nearby enemies</div>
            <div><span style="color: #ff8800;">üî∂ JUMPER</span> - Teleports toward you</div>
            <div><span style="color: #ff0000;">üí£ KAMIKAZE</span> - Explodes on contact!</div>
            <div><span style="color: #8800ff;">üéØ SHOOTER</span> - Fires projectiles from range</div>
            <div><span style="color: #ff00ff;">üëë MINI-BOSS</span> - Every 5 waves (larger, tougher)</div>
            <div><span style="color: #ff0000;">üíÄ BOSS</span> - Every 10 waves (huge health pool, special attacks)</div>
          </div>
        </div>
        
        <!-- TIPS -->
        <div style="background: linear-gradient(135deg, #1a1a3a 0%, #2a1a3a 100%); border: 3px solid #00ff00; border-radius: 15px; padding: 25px;">
          <h2 style="font-size: 32px; color: #00ff00; margin-bottom: 20px;">üí° PRO TIPS</h2>
          <div style="font-size: 16px; color: #fff; line-height: 1.8;">
            <p style="margin-bottom: 10px;">‚úÖ Use <strong>Auto-Start Waves</strong> [R] + <strong>Fast-Forward</strong> [F] to farm early waves quickly!</p>
            <p style="margin-bottom: 10px;">‚úÖ <strong>Prioritize</strong> kamikazes and healers first - they're the most dangerous!</p>
            <p style="margin-bottom: 10px;">‚úÖ Save your <strong>Dragon Beam</strong> potion [6] for tough bosses</p>
            <p style="margin-bottom: 10px;">‚úÖ Unlock the <strong>Evol Aura</strong> system for powerful permanent bonuses</p>
            <p style="margin-bottom: 10px;">‚úÖ Try different classes! Each has unique abilities and playstyles</p>
            <p style="margin-bottom: 10px;">‚úÖ The <strong>Vecna</strong> class is ultra-rare - unlock it from the shop for a challenge!</p>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Class Selection Screen -->
    <div id="classSelection">
      <div class="class-title">SELECT YOUR LEGEND</div>
      <div class="class-subtitle">Choose your class to defend the tower!</div>
      <div class="class-grid" id="classGrid"></div>
    </div>
    
    <!-- Wave Selection Screen -->
    <div id="waveSelectionScreen" style="display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2a 100%); z-index: 100; overflow-y: auto; padding: 50px 20px;">
      <button class="back-arrow-btn" id="waveSelectBackBtn" onclick="closeWaveSelect()">‚Üê</button>
      
      <div style="text-align: center; margin-bottom: 30px;">
        <div style="font-size: 48px; font-weight: bold; color: #00ffff; text-shadow: 0 0 20px #00ffff; margin-bottom: 10px;">
          üéØ SELECT STARTING WAVE
        </div>
        <div style="font-size: 20px; color: #ffff00;">
          Highest Wave Reached: <span id="highestWaveDisplay" style="font-weight: bold;">1</span>
        </div>
        <div style="font-size: 16px; color: #aaa; margin-top: 10px;">
          Start from any wave you've reached before
        </div>
      </div>
      
      <div id="waveGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; max-width: 1200px; margin: 0 auto; padding: 20px;">
        <!-- Wave buttons will be populated by JavaScript -->
      </div>
      
      <div style="text-align: center; margin-top: 40px;">
        <button onclick="closeWaveSelect()" style="padding: 15px 40px; font-size: 18px; font-weight: bold; background: linear-gradient(135deg, #ff0000, #aa0000); border: none; border-radius: 10px; color: white; cursor: pointer; box-shadow: 0 4px 15px rgba(255,0,0,0.4);">
          ‚ùå CANCEL
        </button>
      </div>
    </div>
    
    <!-- Unlock Requirements Modal -->
    <div id="unlockModal">
      <div class="unlock-modal-content">
        <div class="unlock-modal-icon" id="unlockModalIcon">üîí</div>
        <div class="unlock-modal-title" id="unlockModalTitle">Class Locked</div>
        <div class="unlock-modal-requirement" id="unlockModalRequirement">Complete the challenge to unlock!</div>
        <div class="unlock-modal-desc" id="unlockModalDesc">More details here...</div>
        <button class="unlock-modal-close" id="unlockModalClose">‚úñ CLOSE</button>
      </div>
    </div>
    
    <!-- Shop Screen -->
    <div id="shopScreen">
      <button class="back-arrow-btn" id="shopBackBtn">‚Üê</button>
      <div class="shop-header">
        <div class="shop-title">üõí PERMANENT UPGRADES</div>
        <div class="shop-currency">
          <div>üí∞ Coins: <span id="shopCoins">0</span></div>
          <div>üíé Gems: <span id="shopGems">0</span></div>
        </div>
      </div>
      <div class="shop-grid" id="shopGrid"></div>
      
      <!-- Currency Exchange Section -->
      <div style="margin: 30px auto; padding: 25px; background: linear-gradient(135deg, rgba(0,100,200,0.2), rgba(100,0,200,0.2)); border: 3px solid #00ffff; border-radius: 15px; max-width: 600px; box-shadow: 0 0 30px rgba(0,255,255,0.3);">
        <div style="text-align: center; margin-bottom: 20px;">
          <div style="font-size: 28px; font-weight: bold; color: #00ffff; text-shadow: 0 0 10px #00ffff;">üí± CURRENCY EXCHANGE</div>
          <div style="font-size: 14px; color: #aaa; margin-top: 5px;">Convert between Coins and Gems</div>
        </div>
        
        <div style="display: flex; gap: 20px; justify-content: center; flex-wrap: wrap;">
          <button class="shop-btn" onclick="convertGemsToCoins()" 
                  style="flex: 1; min-width: 200px; padding: 20px; background: linear-gradient(135deg, #00ffff, #0088ff); border: none; border-radius: 10px; cursor: pointer; font-size: 16px; font-weight: bold; color: white; transition: transform 0.2s, box-shadow 0.2s;">
            <div style="font-size: 32px; margin-bottom: 8px;">üíé ‚Üí üí∞</div>
            <div>Gems to Coins</div>
            <div style="font-size: 13px; opacity: 0.9; margin-top: 5px;">1 Gem = 100 Coins</div>
          </button>
          
          <button class="shop-btn" onclick="convertCoinsToGems()" 
                  style="flex: 1; min-width: 200px; padding: 20px; background: linear-gradient(135deg, #ffd700, #ff8800); border: none; border-radius: 10px; cursor: pointer; font-size: 16px; font-weight: bold; color: white; transition: transform 0.2s, box-shadow 0.2s;">
            <div style="font-size: 32px; margin-bottom: 8px;">üí∞ ‚Üí üíé</div>
            <div>Coins to Gems</div>
            <div style="font-size: 13px; opacity: 0.9; margin-top: 5px;">100 Coins = 1 Gem</div>
          </button>
        </div>
        
        <div style="margin-top: 20px; text-align: center; font-size: 16px; color: #ffff00;">
          Your Currency: 
          <span style="color: #ffd700; font-weight: bold;">üí∞ <span id="shopCoinsDisplay2">0</span></span> | 
          <span style="color: #00ffff; font-weight: bold;">üíé <span id="shopGemsDisplay2">0</span></span>
        </div>
      </div>
    </div>
    
    <!-- Evol Aura Screen -->
    <div id="evolAuraScreen" style="display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.95); z-index: 50; overflow-y: auto;">
      <button class="back-arrow-btn" id="auraBackBtn">‚Üê</button>
      <div class="shop-header">
        <div class="shop-title">üåü EVOL AURA - SKILL TREES</div>
        <div class="shop-currency">
          <div>üí∞ Coins: <span id="auraCoins">0</span></div>
          <div>üíé Gems: <span id="auraGems">0</span></div>
        </div>
      </div>
      <div id="classTabsContainer" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin: 20px auto; max-width: 900px;">
      </div>
      <div class="shop-grid" id="auraSkillGrid" style="padding-bottom: 50px;"></div>
    </div>
    
    <!-- Upgrade Screen -->
    <!-- BTD-Style Upgrade Tree Screen -->
    <div id="upgradeTreeScreen">
      <div class="upgrade-tree-header">
        <div class="upgrade-tree-title">‚ö° UPGRADE TREE ‚ö°</div>
        <div class="upgrade-tree-info">
          <span>Level: <span id="treePlayerLevel">1</span></span>
          <span>Upgrade Points: <span id="upgradePoints">0</span></span>
        </div>
      </div>
      
      <div class="upgrade-tree-container">
        <!-- Left Path -->
        <div class="upgrade-path">
          <div class="path-header">PATH A</div>
          <div id="pathA" class="path-upgrades"></div>
        </div>
        
        <!-- Middle Path -->
        <div class="upgrade-path">
          <div class="path-header">PATH B</div>
          <div id="pathB" class="path-upgrades"></div>
        </div>
        
        <!-- Right Path -->
        <div class="upgrade-path">
          <div class="path-header">PATH C</div>
          <div id="pathC" class="path-upgrades"></div>
        </div>
      </div>
      
      <button class="upgrade-tree-close" id="closeUpgradeTree">‚úì CONTINUE</button>
    </div>
    
    <!-- Pause Menu -->
    <div id="pauseMenu">
      <div class="pause-content">
        <div class="pause-title">‚è∏Ô∏è PAUSED</div>
        
        <!-- Character Stats -->
        <div class="pause-section">
          <div class="pause-section-title">üìä Character Stats</div>
          <div id="pauseStats"></div>
        </div>
        
        <!-- Settings -->
        <div class="pause-section">
          <div class="pause-section-title">‚öôÔ∏è Settings</div>
          
          <div class="pause-stat">
            <span>üîÜ Brightness</span>
            <span id="brightnessValue">100%</span>
          </div>
          <input type="range" class="pause-slider" id="brightnessSlider" 
                 min="50" max="150" value="100">
          
          <div class="pause-stat">
            <span>üîä Volume</span>
            <span id="volumeValue">100%</span>
          </div>
          <input type="range" class="pause-slider" id="volumeSlider" 
                 min="0" max="100" value="100">
        </div>
        
        <!-- Buttons -->
        <button class="pause-button" id="resumeBtn">‚ñ∂Ô∏è RESUME</button>
        <button class="pause-button danger" id="returnLobbyBtn">üè† RETURN HOME</button>
      </div>
    </div>
    
    <!-- Round Break Screen -->
    <div id="roundBreakScreen">
      <div class="break-title" id="breakTitle">WAVE COMPLETE!</div>
      <div class="break-timer" id="breakTimer">20</div>
      <div class="break-info" id="breakInfo">
        Prepare for the next wave!<br>
        <br>Press SPACE to start immediately
      </div>
    </div>
    
    <!-- Game Over Screen -->
    <div id="gameOverScreen">
      <button class="back-arrow-btn" id="gameOverBackBtn">‚Üê</button>
      <div class="gameover-title">üíÄ GAME OVER üíÄ</div>
      
      <div class="gameover-countdown" id="gameOverCountdown">Returning to home in <span id="countdownTimer">10</span>s...</div>
      
      <div class="gameover-stats">
        <div class="gameover-stat-row">
          <span class="gameover-stat-label">üåä Wave Reached:</span>
          <span class="gameover-stat-value" id="finalWave">1</span>
        </div>
        <div class="gameover-stat-row">
          <span class="gameover-stat-label">‚≠ê Level Reached:</span>
          <span class="gameover-stat-value" id="finalLevel">1</span>
        </div>
        <div class="gameover-stat-row">
          <span class="gameover-stat-label">üíÄ Enemies Killed:</span>
          <span class="gameover-stat-value" id="finalKills">0</span>
        </div>
        <div class="gameover-stat-row">
          <span class="gameover-stat-label">üî• Max Combo:</span>
          <span class="gameover-stat-value" id="finalCombo">0</span>
        </div>
      </div>
      
      <div class="gameover-earnings">
        <div class="gameover-earnings-title">üí∞ RUN EARNINGS üí∞</div>
        <div class="gameover-stat-row">
          <span class="gameover-stat-label">üí∞ Coins Earned:</span>
          <span class="gameover-stat-value" style="color: #ffff00;" id="earnedCoins">0</span>
        </div>
        <div class="gameover-stat-row">
          <span class="gameover-stat-label">üíé Gems Earned:</span>
          <span class="gameover-stat-value" style="color: #00ffff;" id="earnedGems">0</span>
        </div>
        <div class="gameover-stat-row" style="border-top: 2px solid rgba(255, 255, 255, 0.3); margin-top: 10px; padding-top: 15px;">
          <span class="gameover-stat-label">üí∞ Total Coins:</span>
          <span class="gameover-stat-value" style="color: #ffff00;" id="totalCoinsNow">0</span>
        </div>
        <div class="gameover-stat-row">
          <span class="gameover-stat-label">üíé Total Gems:</span>
          <span class="gameover-stat-value" style="color: #00ffff;" id="totalGemsNow">0</span>
        </div>
      </div>
      
      <div style="display: flex; gap: 15px; width: 100%; max-width: 400px;">
        <button class="gameover-continue" id="retryBtn" style="flex: 1;">üîÑ RETRY</button>
        <button class="gameover-continue" id="continueBtn" style="flex: 1;">üè† RETURN HOME</button>
      </div>
    </div>
    
    <!-- Potion Bar -->
    <div id="potionBar">
      <div class="potion-slot" id="potionHeal" data-key="1">
        <div class="potion-key">1</div>
        <div class="potion-icon">‚ù§Ô∏è</div>
        <div class="potion-count" id="countHeal">3</div>
        <div class="potion-cooldown-overlay" id="cdHeal" style="height: 0%"></div>
      </div>
      <div class="potion-slot" id="potionShield" data-key="2">
        <div class="potion-key">2</div>
        <div class="potion-icon">üõ°Ô∏è</div>
        <div class="potion-count" id="countShield">2</div>
        <div class="potion-cooldown-overlay" id="cdShield" style="height: 0%"></div>
      </div>
      <div class="potion-slot" id="potionCrit" data-key="3">
        <div class="potion-key">3</div>
        <div class="potion-icon">üí•</div>
        <div class="potion-count" id="countCrit">1</div>
        <div class="potion-cooldown-overlay" id="cdCrit" style="height: 0%"></div>
      </div>
      <div class="potion-slot" id="potionDamage" data-key="4">
        <div class="potion-key">4</div>
        <div class="potion-icon">‚öîÔ∏è</div>
        <div class="potion-count" id="countDamage">1</div>
        <div class="potion-cooldown-overlay" id="cdDamage" style="height: 0%"></div>
      </div>
      <div class="potion-slot" id="potionSpeed" data-key="5">
        <div class="potion-key">5</div>
        <div class="potion-icon">‚ö°</div>
        <div class="potion-count" id="countSpeed">1</div>
        <div class="potion-cooldown-overlay" id="cdSpeed" style="height: 0%"></div>
      </div>
      <div class="potion-slot" id="potionDragon" data-key="6">
        <div class="potion-key">6</div>
        <div class="potion-icon">üêâ</div>
        <div class="potion-count" id="countDragon">1</div>
        <div class="potion-cooldown-overlay" id="cdDragon" style="height: 0%"></div>
      </div>
    </div>
    
    <!-- Ultimate Ability Buttons -->
    <div id="ability1Btn" class="ability-btn" style="display: none;">
      <div style="font-size: 24px; margin-bottom: 5px;" id="ability1Icon">üéØ</div>
      <div id="ability1Name">Ability 1</div>
      <div style="font-size: 12px; margin-top: 3px;" id="ability1Key">[Q]</div>
      <div style="font-size: 16px; margin-top: 5px; color: #00ff00;" id="ability1CD"></div>
    </div>
    
    <div id="ability2Btn" class="ability-btn" style="display: none;">
      <div style="font-size: 24px; margin-bottom: 5px;" id="ability2Icon">üì¶</div>
      <div id="ability2Name">Ability 2</div>
      <div style="font-size: 12px; margin-top: 3px;" id="ability2Key">[E]</div>
      <div style="font-size: 16px; margin-top: 5px; color: #00ff00;" id="ability2CD"></div>
    </div>
    
    <div id="statusText"></div>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    
    const titleScreen = document.getElementById("titleScreen");
    const startBtn = document.getElementById("startBtn");
    const shopBtn = document.getElementById("shopBtn");
    const tutorialBtn = document.getElementById("tutorialBtn");
    const tutorialScreen = document.getElementById("tutorialScreen");
    const tutorialBackBtn = document.getElementById("tutorialBackBtn");
    const classSelection = document.getElementById("classSelection");
    const classGrid = document.getElementById("classGrid");
    const unlockModal = document.getElementById("unlockModal");
    const unlockModalIcon = document.getElementById("unlockModalIcon");
    const unlockModalTitle = document.getElementById("unlockModalTitle");
    const unlockModalRequirement = document.getElementById("unlockModalRequirement");
    const unlockModalDesc = document.getElementById("unlockModalDesc");
    const unlockModalClose = document.getElementById("unlockModalClose");
    const shopScreen = document.getElementById("shopScreen");
    const shopGrid = document.getElementById("shopGrid");
    const shopCloseBtn = document.getElementById("shopCloseBtn");
    const upgradeScreen = document.getElementById("upgradeScreen");
    const upgradeSubtitle = document.getElementById("upgradeSubtitle");
    const upgradeOptions = document.getElementById("upgradeOptions");
    const shuffleBtn = document.getElementById("shuffleBtn");
    const shuffleCount = document.getElementById("shuffleCount");
    const skipUpgradeBtn = document.getElementById("skipUpgradeBtn");
    const roundBreakScreen = document.getElementById("roundBreakScreen");
    const breakTitle = document.getElementById("breakTitle");
    const breakTimer = document.getElementById("breakTimer");
    const breakInfo = document.getElementById("breakInfo");
    const gameOverScreen = document.getElementById("gameOverScreen");
    const finalWave = document.getElementById("finalWave");
    const finalLevel = document.getElementById("finalLevel");
    const finalKills = document.getElementById("finalKills");
    const finalCombo = document.getElementById("finalCombo");
    const earnedCoins = document.getElementById("earnedCoins");
    const earnedGems = document.getElementById("earnedGems");
    const totalCoinsNow = document.getElementById("totalCoinsNow");
    const totalGemsNow = document.getElementById("totalGemsNow");
    const continueBtn = document.getElementById("continueBtn");
    const retryBtn = document.getElementById("retryBtn");
    const gameOverBackBtn = document.getElementById("gameOverBackBtn");
    const countdownTimer = document.getElementById("countdownTimer");
    const giveUpBtn = document.getElementById("giveUpBtn");
    const statusText = document.getElementById("statusText");
    const highestWaveDisplay = document.getElementById("highestWaveDisplay");
    const totalCoinsDisplay = document.getElementById("totalCoinsDisplay");
    const totalGemsDisplay = document.getElementById("totalGemsDisplay");
    const shopCoins = document.getElementById("shopCoins");
    const shopGems = document.getElementById("shopGems");

    // GAME CONSTANTS
    const GROUND_Y = 470;
    const ROUND_BREAK_TIME = 20;
    const PLAYER_X = 100; // Fixed position

    // PERSISTENT DATA (localStorage)
    let gameData = {
      highestWave: 1,
      totalCoins: 0,
      totalGems: 0,
      unlockedWaves: [1], // Waves player can start from
      shieldUpgradesChosen: 0, // Track for Guardian Tank unlock
      permanentUpgrades: {
        damage: 0,
        health: 0,
        fireRate: 0,
        critChance: 0,
        startLevel: 0
      },
      potionUpgrades: {
        healStrength: 0,
        shieldStrength: 0,
        effectStrength: 0,
        dragonStrength: 0,
        startingHeals: 0,
        startingShields: 0,
        startingOthers: 0,
        potionGen: 0,
        potionDamage: 0,
        potionExplosion: 0
      },
      unlockedClasses: ["Hunter", "Rookie"], // Rookie available from start
      purchasedClasses: [], // Track purchased classes separately
      skillTrees: {} // Track unlocked abilities for each class
    };

    // Load saved data
    function loadGameData() {
      const saved = localStorage.getItem("evolLegendsData");
      if (saved) {
        gameData = JSON.parse(saved);
        
        // Ensure potionUpgrades exists (for backward compatibility)
        if (!gameData.potionUpgrades) {
          gameData.potionUpgrades = {
            healStrength: 0,
            shieldStrength: 0,
            effectStrength: 0,
            dragonStrength: 0,
            startingHeals: 0,
            startingShields: 0,
            startingOthers: 0,
            potionGen: 0,
            potionDamage: 0,
            potionExplosion: 0
          };
        }
        
        // Ensure skillTrees exists (for future compatibility)
        if (!gameData.skillTrees) {
          gameData.skillTrees = {};
        }
        
        // Ensure unlockedWaves exists
        if (!gameData.unlockedWaves) {
          gameData.unlockedWaves = [1];
          // Unlock all waves up to highest wave
          for (let w = 1; w <= gameData.highestWave; w++) {
            if (!gameData.unlockedWaves.includes(w)) {
              gameData.unlockedWaves.push(w);
            }
          }
        }
        
        // Ensure shieldUpgradesChosen exists
        if (gameData.shieldUpgradesChosen === undefined) {
          gameData.shieldUpgradesChosen = 0;
        }
        
        // Ensure Rookie is unlocked
        if (!gameData.unlockedClasses.includes("Rookie")) {
          gameData.unlockedClasses.push("Rookie");
        }
      }
      updateTitleScreenDisplay();
    }

    function saveGameData() {
      localStorage.setItem("evolLegendsData", JSON.stringify(gameData));
      updateTitleScreenDisplay();
    }

    function updateTitleScreenDisplay() {
      highestWaveDisplay.textContent = gameData.highestWave;
      const highestWaveTitleDisplay = document.getElementById('highestWaveTitleDisplay');
      if (highestWaveTitleDisplay) {
        highestWaveTitleDisplay.textContent = gameData.highestWave;
      }
      totalCoinsDisplay.textContent = gameData.totalCoins;
      totalGemsDisplay.textContent = gameData.totalGems;
      shopCoins.textContent = gameData.totalCoins;
      shopGems.textContent = gameData.totalGems;
      
      // IMPORTANT: Check if any classes should be unlocked based on highestWave
      // This ensures classes unlock even if the player already reached the wave
      let classesUnlocked = false;
      Object.entries(CLASSES).forEach(([name, data]) => {
        if (!data.purchasable && !data.challengeUnlock && !data.achievementUnlock && 
            data.unlockWave && gameData.highestWave >= data.unlockWave && 
            !gameData.unlockedClasses.includes(name)) {
          gameData.unlockedClasses.push(name);
          classesUnlocked = true;
          console.log(`üîì AUTO-UNLOCKED: ${name} (Wave ${data.unlockWave}) - You've reached wave ${gameData.highestWave}!`);
        }
      });
      
      if (classesUnlocked) {
        saveGameData(); // Save the newly unlocked classes
      }
    }

    // POTION SYSTEM
    function resetPotions() {
      // Base amounts + upgrades
      potions.heal = 3 + gameData.potionUpgrades.startingHeals;
      potions.shield = 2 + gameData.potionUpgrades.startingShields;
      potions.crit = 1 + gameData.potionUpgrades.startingOthers;
      potions.damage = 1 + gameData.potionUpgrades.startingOthers;
      potions.speed = 1 + gameData.potionUpgrades.startingOthers;
      potions.dragon = 1 + gameData.potionUpgrades.startingOthers;
      
      // Potion generation chance (10% per level)
      const genChance = gameData.potionUpgrades.potionGen * 0.1;
      if (Math.random() < genChance) {
        const types = ['heal', 'shield', 'crit', 'damage', 'speed', 'dragon'];
        const randomType = types[Math.floor(Math.random() * types.length)];
        potions[randomType]++;
        addFloatingText(player.x + player.w / 2, player.y - 50, "Bonus Potion!", "#ff00ff");
      }
      
      updatePotionDisplay();
    }
    
    function updatePotionDisplay() {
      document.getElementById('countHeal').textContent = potions.heal;
      document.getElementById('countShield').textContent = potions.shield;
      document.getElementById('countCrit').textContent = potions.crit;
      document.getElementById('countDamage').textContent = potions.damage;
      document.getElementById('countSpeed').textContent = potions.speed;
      document.getElementById('countDragon').textContent = potions.dragon;
    }
    
    function usePotion(type) {
      if (!player || !player.alive) return;
      if (potions[type] <= 0) return;
      if (potionCooldowns[type] > 0) return;
      
      potions[type]--;
      potionCooldowns[type] = 1.0; // 1 second cooldown
      
      // Apply effects based on type
      switch(type) {
        case 'heal':
          const healAmount = 50 + (gameData.potionUpgrades.healStrength * 20);
          player.hp = Math.min(player.hp + healAmount, player.maxHP);
          addFloatingText(player.x + player.w / 2, player.y - 30, "+" + healAmount + " HP", "#00ff00");
          spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#00ff00", 10);
          break;
          
        case 'shield':
          const shieldAmount = 50 + (gameData.potionUpgrades.shieldStrength * 25);
          if (player.maxShield === 0) player.maxShield = shieldAmount;
          player.shield = Math.min(player.shield + shieldAmount, player.maxShield);
          addFloatingText(player.x + player.w / 2, player.y - 30, "+" + shieldAmount + " Shield", "#00aaff");
          spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#00aaff", 10);
          break;
          
        case 'crit':
          const critBonus = 0.25 + (gameData.potionUpgrades.effectStrength * 0.1);
          potionEffects.critActive = true;
          potionEffects.critTimer = 10; // 10 seconds
          player.critChance += critBonus;
          addFloatingText(player.x + player.w / 2, player.y - 30, "Crit Boost!", "#ff0000");
          spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#ff0000", 10);
          break;
          
        case 'damage':
          const damageBonus = 10 + (gameData.potionUpgrades.effectStrength * 5);
          potionEffects.damageActive = true;
          potionEffects.damageTimer = 10; // 10 seconds
          player.damage += damageBonus;
          addFloatingText(player.x + player.w / 2, player.y - 30, "Damage Boost!", "#ff8800");
          spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#ff8800", 10);
          break;
          
        case 'speed':
          const speedBonus = 0.15 + (gameData.potionUpgrades.effectStrength * 0.05);
          potionEffects.speedActive = true;
          potionEffects.speedTimer = 10; // 10 seconds
          player.fireRate *= (1 - speedBonus);
          addFloatingText(player.x + player.w / 2, player.y - 30, "Speed Boost!", "#ffff00");
          spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#ffff00", 10);
          break;
          
        case 'dragon':
          useDragonBeam();
          break;
      }
      
      // Potion explosion damage upgrade
      if (gameData.potionUpgrades.potionExplosion > 0 && enemies.length > 0) {
        const randomEnemy = enemies[Math.floor(Math.random() * enemies.length)];
        const explosionDamage = 30 * gameData.potionUpgrades.potionExplosion;
        randomEnemy.hp -= explosionDamage;
        spawnExplosion(randomEnemy.x + randomEnemy.w / 2, randomEnemy.y + randomEnemy.h / 2, "#ff00ff", 15);
        addFloatingText(randomEnemy.x + randomEnemy.w / 2, randomEnemy.y - 20, "-" + explosionDamage, "#ff00ff");
      }
      
      updatePotionDisplay();
      screenShake += 3;
    }
    
    function useDragonBeam() {
      const dragonDamage = (player.damage * 3) + (gameData.potionUpgrades.dragonStrength * 20);
      
      addFloatingText(canvas.width / 2, 200, "üêâ DRAGON BEAM! üêâ", "#ff00ff");
      screenShake += 25;
      
      // Create single massive laser beam that goes across the entire screen
      projectiles.push({
        x: player.x + player.w / 2,
        y: player.y + player.h / 2,
        vx: 30, // Very fast to cross screen
        vy: 0,
        radius: 30, // Wide beam
        damage: dragonDamage,
        color: "#ff4400",
        glowColor: "#ff8800",
        life: 3,
        trail: [],
        pierce: true,
        pierceCount: 0,
        explosive: false,
        isCrit: true,
        critMultiplier: 2.0,
        isDragonBeam: true,
        isEnemyProjectile: false
      });
      
      // Create fire zones along the ground that last 5 seconds with DOT
      const startX = player.x + player.w / 2;
      const y = GROUND_Y - 20; // On the ground
      const numZones = 25; // Create zones across screen
      
      for (let i = 0; i < numZones; i++) {
        const x = startX + (i * 40); // Space them out
        
        // Create fire zone that damages enemies
        fireZones.push({
          x: x,
          y: y,
          radius: 50,
          damage: dragonDamage * 0.2, // 20% of beam damage per second
          life: 5, // Lasts 5 seconds
          color: "#ff4400"
        });
      }
      
      // Visual particles for laser effect
      for (let i = 0; i < 80; i++) {
        particles.push({
          x: player.x + player.w / 2,
          y: player.y + player.h / 2,
          vx: Math.random() * 20 + 10,
          vy: Math.random() * 10 - 5,
          radius: Math.random() * 8 + 3,
          color: i % 2 === 0 ? "#ff4400" : "#ff8800",
          life: 2
        });
      }
    }
    
    function updateFireZones(dt) {
      for (let i = fireZones.length - 1; i >= 0; i--) {
        const zone = fireZones[i];
        zone.life -= dt;
        
        if (zone.life <= 0) {
          fireZones.splice(i, 1);
          continue;
        }
        
        // Damage enemies in fire zone
        enemies.forEach(e => {
          const dx = (e.x + e.w / 2) - zone.x;
          const dy = (e.y + e.h / 2) - zone.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < zone.radius) {
            e.hp -= zone.damage * dt;
            
            // Visual fire damage
            if (Math.random() < 0.1) {
              particles.push({
                x: e.x + e.w / 2,
                y: e.y + e.h / 2,
                vx: Math.random() * 4 - 2,
                vy: Math.random() * 4 - 2,
                radius: 3,
                color: "#ff4400",
                life: 0.5
              });
            }
          }
        });
      }
    }
    
    function updatePoisonClouds(dt) {
      const classStats = CLASSES[player.class]?.stats || {};
      
      for (let i = poisonClouds.length - 1; i >= 0; i--) {
        const cloud = poisonClouds[i];
        cloud.life -= dt;
        
        if (cloud.life <= 0) {
          poisonClouds.splice(i, 1);
          continue;
        }
        
        // Affect enemies in cloud
        enemies.forEach(e => {
          const dx = (e.x + e.w / 2) - cloud.x;
          const dy = (e.y + e.h / 2) - cloud.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < cloud.radius) {
            // Poison damage
            e.hp -= cloud.poisonDPS * dt;
            
            // Slow
            if (cloud.slowAmount) {
              e.slowAmount = (e.slowAmount || 0) + cloud.slowAmount;
              e.slowDuration = 1.0;
            }
            
            // Confusion (random direction changes)
            if (Math.random() < cloud.confusionChance * dt) {
              e.vx = (Math.random() - 0.5) * 2;
              e.vy = (Math.random() - 0.5) * 2;
            }
            
            // Stun
            if (Math.random() < cloud.stunChance * dt) {
              e.stunned = true;
              e.stunDuration = 1.0;
            }
          }
        });
      }
    }
    
    function updateIceShards(dt) {
      for (let i = iceShards.length - 1; i >= 0; i--) {
        const shard = iceShards[i];
        shard.life -= dt;
        
        if (shard.life <= 0) {
          iceShards.splice(i, 1);
          continue;
        }
        
        // Check collision with enemies
        enemies.forEach(e => {
          const dx = (e.x + e.w / 2) - shard.x;
          const dy = (e.y + e.h / 2) - shard.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < 20 && !shard.hit) {
            e.hp -= shard.damage;
            e.slowAmount = (e.slowAmount || 0) + shard.slowAmount;
            e.slowDuration = 2.0;
            shard.hit = true;
            iceShards.splice(i, 1);
            
            // Ice particles
            for (let j = 0; j < 10; j++) {
              particles.push({
                x: shard.x,
                y: shard.y,
                vx: Math.random() * 4 - 2,
                vy: Math.random() * 4 - 2,
                radius: 2,
                color: "#00bfff",
                life: 0.5
              });
            }
          }
        });
      }
    }
    
    function updateTurrets(dt) {
      for (let i = turrets.length - 1; i >= 0; i--) {
        const turret = turrets[i];
        
        if (turret.hp <= 0) {
          turrets.splice(i, 1);
          continue;
        }
        
        // Turret shooting logic
        turret.shootTimer -= dt;
        if (turret.shootTimer <= 0) {
          turret.shootTimer = turret.fireRate;
          
          // Find nearest enemy in range
          let nearest = null;
          let minDist = Infinity;
          enemies.forEach(e => {
            const dx = (e.x + e.w / 2) - turret.x;
            const dy = (e.y + e.h / 2) - turret.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < turret.range && dist < minDist) {
              minDist = dist;
              nearest = e;
            }
          });
          
          if (nearest) {
            const dx = (nearest.x + nearest.w / 2) - turret.x;
            const dy = (nearest.y + nearest.h / 2) - turret.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            projectiles.push({
              x: turret.x,
              y: turret.y,
              vx: (dx / dist) * 8,
              vy: (dy / dist) * 8,
              damage: turret.damage,
              color: "#FF8C00",
              radius: 3,
              pierce: false
            });
          }
        }
      }
    }
    
    function updateRootBarriers(dt) {
      for (let i = rootBarriers.length - 1; i >= 0; i--) {
        const barrier = rootBarriers[i];
        
        if (barrier.hp <= 0) {
          rootBarriers.splice(i, 1);
          continue;
        }
        
        // Check collision with enemies
        enemies.forEach(e => {
          const dx = (e.x + e.w / 2) - barrier.x;
          const dy = (e.y + e.h / 2) - barrier.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < 40) {
            // Deal thorn damage
            e.hp -= barrier.thornDamage * dt;
            barrier.hp -= 5 * dt;
            
            // Heal player
            player.hp = Math.min(player.hp + barrier.healAmount * dt, player.maxHP);
            
            // Knock back enemy
            const angle = Math.atan2(dy, dx);
            e.x += Math.cos(angle) * 2;
            e.y += Math.sin(angle) * 2;
          }
        });
      }
    }
    
    function updateHelperStars(dt) {
      helperStars.forEach(star => {
        star.shootTimer -= dt;
        
        if (star.shootTimer <= 0) {
          star.shootTimer = star.fireRate;
          
          // Find nearest enemy in range
          let nearest = null;
          let minDist = Infinity;
          enemies.forEach(e => {
            const dx = (e.x + e.w / 2) - star.x;
            const dy = (e.y + e.h / 2) - star.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < star.range && dist < minDist) {
              minDist = dist;
              nearest = e;
            }
          });
          
          if (nearest) {
            const dx = (nearest.x + nearest.w / 2) - star.x;
            const dy = (nearest.y + nearest.h / 2) - star.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            projectiles.push({
              x: star.x,
              y: star.y,
              vx: (dx / dist) * 8,
              vy: (dy / dist) * 8,
              damage: star.damage,
              color: "#9400d3",
              radius: 3,
              pierce: false
            });
          }
        }
        
        // Helper star orbits around player
        star.angle += dt * 2;
        star.x = player.x + Math.cos(star.angle) * 80;
        star.y = player.y + Math.sin(star.angle) * 80;
      });
    }
    
    function updatePotionEffects(dt) {
      // Update crit effect
      if (potionEffects.critActive) {
        potionEffects.critTimer -= dt;
        if (potionEffects.critTimer <= 0) {
          potionEffects.critActive = false;
          const critBonus = 0.25 + (gameData.potionUpgrades.effectStrength * 0.1);
          player.critChance -= critBonus;
        }
      }
      
      // Update damage effect
      if (potionEffects.damageActive) {
        potionEffects.damageTimer -= dt;
        if (potionEffects.damageTimer <= 0) {
          potionEffects.damageActive = false;
          const damageBonus = 10 + (gameData.potionUpgrades.effectStrength * 5);
          player.damage -= damageBonus;
        }
      }
      
      // Update speed effect
      if (potionEffects.speedActive) {
        potionEffects.speedTimer -= dt;
        if (potionEffects.speedTimer <= 0) {
          potionEffects.speedActive = false;
          const speedBonus = 0.15 + (gameData.potionUpgrades.effectStrength * 0.05);
          player.fireRate /= (1 - speedBonus);
        }
      }
      
      // Update cooldowns
      for (let type in potionCooldowns) {
        if (potionCooldowns[type] > 0) {
          potionCooldowns[type] -= dt;
          if (potionCooldowns[type] < 0) potionCooldowns[type] = 0;
        }
      }
    }
    
    function updatePotionCooldownDisplay() {
      const types = ['heal', 'shield', 'crit', 'damage', 'speed', 'dragon'];
      types.forEach((type) => {
        const cooldownPercent = (potionCooldowns[type] / 1.0) * 100;
        document.getElementById('cd' + type.charAt(0).toUpperCase() + type.slice(1)).style.height = cooldownPercent + '%';
        
        const slot = document.getElementById('potion' + type.charAt(0).toUpperCase() + type.slice(1));
        if (potionCooldowns[type] > 0 || potions[type] <= 0) {
          slot.classList.add('cooldown');
        } else {
          slot.classList.remove('cooldown');
        }
      });
    }

    // SKILL TREE SYSTEM
    let currentSelectedClass = "Hunter";
    let selectedClassName = null;
    
    function showEvolAura() {
      document.getElementById('evolAuraScreen').style.display = 'block';
      updateAuraDisplay();
      renderClassTabs();
      displaySkillTree(currentSelectedClass);
    }
    
    function updateAuraDisplay() {
      document.getElementById('auraCoins').textContent = gameData.totalCoins;
      document.getElementById('auraGems').textContent = gameData.totalGems;
    }
    
    function renderClassTabs() {
      const container = document.getElementById('classTabsContainer');
      container.innerHTML = '';
      
      Object.entries(CLASSES).forEach(([className, classData]) => {
        const isUnlocked = gameData.unlockedClasses.includes(className) || 
                          gameData.purchasedClasses.includes(className);
        
        const tab = document.createElement('button');
        tab.style.cssText = `
          padding: 12px 20px;
          font-size: 16px;
          font-weight: bold;
          border: 2px solid ${currentSelectedClass === className ? '#00ff00' : '#00ffff'};
          background: ${currentSelectedClass === className ? 'rgba(0, 255, 0, 0.2)' : 'rgba(0, 0, 0, 0.8)'};
          color: ${isUnlocked ? '#ffff00' : '#666'};
          border-radius: 8px;
          cursor: ${isUnlocked ? 'pointer' : 'not-allowed'};
          transition: all 0.2s;
          font-family: 'Courier New', monospace;
        `;
        
        tab.innerHTML = `${classData.icon} ${className}`;
        
        if (isUnlocked) {
          tab.addEventListener('click', () => {
            currentSelectedClass = className;
            renderClassTabs();
            displaySkillTree(className);
          });
          
          tab.addEventListener('mouseenter', () => {
            if (currentSelectedClass !== className) {
              tab.style.background = 'rgba(0, 255, 255, 0.2)';
            }
          });
          
          tab.addEventListener('mouseleave', () => {
            if (currentSelectedClass !== className) {
              tab.style.background = 'rgba(0, 0, 0, 0.8)';
            }
          });
        }
        
        container.appendChild(tab);
      });
    }
    
    function displaySkillTree(className) {
      const skillGrid = document.getElementById('auraSkillGrid');
      skillGrid.innerHTML = '';
      
      if (!SKILL_TREES[className]) {
        skillGrid.innerHTML = '<div style="text-align: center; color: #ff0000; font-size: 20px; padding: 50px;">Skill tree coming soon for this class!</div>';
        return;
      }
      
      // Initialize class skill data if not exists
      if (!gameData.skillTrees[className]) {
        gameData.skillTrees[className] = {
          ultimate1: false,
          ultimate2: false
        };
      }
      
      const abilities = SKILL_TREES[className];
      
      // Ultimate 1
      const ability1 = abilities.ultimate1;
      const isUnlocked1 = gameData.skillTrees[className].ultimate1;
      
      const card1 = document.createElement('div');
      card1.className = 'shop-item';
      if (isUnlocked1) card1.classList.add('maxed');
      
      card1.innerHTML = `
        <div class="shop-item-name">${ability1.icon} ${ability1.name}</div>
        <div class="shop-item-desc">${ability1.desc}</div>
        <div class="shop-item-level">Activation: ${getActivationText(ability1)}</div>
        ${ability1.cooldown ? `<div class="shop-item-level">Cooldown: ${ability1.cooldown}s</div>` : ''}
        ${!isUnlocked1 ? `
          <div class="shop-item-cost">
            üí∞ ${ability1.cost.coins} | üíé ${ability1.cost.gems}
          </div>
        ` : '<div class="shop-item-cost" style="color: #00ff00;">‚úÖ UNLOCKED</div>'}
      `;
      
      if (!isUnlocked1) {
        card1.onclick = () => purchaseAbility(className, 'ultimate1');
      }
      
      skillGrid.appendChild(card1);
      
      // Ultimate 2
      const ability2 = abilities.ultimate2;
      const isUnlocked2 = gameData.skillTrees[className].ultimate2;
      
      const card2 = document.createElement('div');
      card2.className = 'shop-item';
      if (isUnlocked2) card2.classList.add('maxed');
      
      card2.innerHTML = `
        <div class="shop-item-name">${ability2.icon} ${ability2.name}</div>
        <div class="shop-item-desc">${ability2.desc}</div>
        <div class="shop-item-level">Activation: ${getActivationText(ability2)}</div>
        ${ability2.cooldown ? `<div class="shop-item-level">Cooldown: ${ability2.cooldown}s</div>` : ''}
        ${!isUnlocked2 ? `
          <div class="shop-item-cost">
            üí∞ ${ability2.cost.coins} | üíé ${ability2.cost.gems}
          </div>
        ` : '<div class="shop-item-cost" style="color: #00ff00;">‚úÖ UNLOCKED</div>'}
      `;
      
      if (!isUnlocked2) {
        card2.onclick = () => purchaseAbility(className, 'ultimate2');
      }
      
      skillGrid.appendChild(card2);
    }
    
    function getActivationText(ability) {
      if (ability.activation === 'kills') {
        return `After ${ability.killRequirement} kills`;
      } else if (ability.activation === 'manual') {
        return `Press ${ability.hotkey.toUpperCase()} key`;
      } else if (ability.activation === 'auto') {
        return 'Automatic when conditions met';
      }
      return 'Special';
    }
    
    function purchaseAbility(className, abilityKey) {
      const ability = SKILL_TREES[className][abilityKey];
      const cost = ability.cost;
      
      // Can purchase with EITHER enough coins OR enough gems (not both required)
      const canAffordCoins = gameData.totalCoins >= cost.coins;
      const canAffordGems = gameData.totalGems >= cost.gems;
      
      if (canAffordCoins || canAffordGems) {
        // Deduct ONLY ONE currency - prioritize coins if player has enough of both
        if (canAffordCoins) {
          gameData.totalCoins -= cost.coins;
        } else if (canAffordGems) {
          gameData.totalGems -= cost.gems;
        }
        
        gameData.skillTrees[className][abilityKey] = true;
        
        saveGameData();
        updateAuraDisplay();
        displaySkillTree(className);
        
        alert(`‚úÖ Unlocked ${ability.name}! You can now use this ability in battle!`);
      } else {
        alert(`‚ùå Not enough currency! Need either ${cost.coins} coins OR ${cost.gems} gems.`);
      }
    }

    // ABILITY ACTIVATION SYSTEM
    function initializeAbilities() {
      ability1Cooldown = 0;
      ability2Cooldown = 0;
      ability1KillCounter = 0;
      ability2KillCounter = 0;
      lastStandUsed = false;
      chainReactionShots = 0;
      headhunterShots = 0;
      overwatchActive = false;
      bladeStormActive = false;
      soulHarvestActive = false;
      timeFreezeActive = false;
      hiveMindActive = false;
      upsideDownActive = false;
      vecnaKillCounter = 0;
      
      const className = selectedClassName;
      if (!className || !gameData.skillTrees[className]) return;
      
      const ability1Unlocked = gameData.skillTrees[className].ultimate1;
      const ability2Unlocked = gameData.skillTrees[className].ultimate2;
      
      const ability1Btn = document.getElementById('ability1Btn');
      const ability2Btn = document.getElementById('ability2Btn');
      
      if (ability1Unlocked && SKILL_TREES[className]) {
        const ability = SKILL_TREES[className].ultimate1;
        document.getElementById('ability1Icon').textContent = ability.icon;
        document.getElementById('ability1Name').textContent = ability.name;
        document.getElementById('ability1Key').textContent = `[${ability.hotkey ? ability.hotkey.toUpperCase() : 'AUTO'}]`;
        ability1Btn.style.display = 'block';
      } else {
        ability1Btn.style.display = 'none';
      }
      
      if (ability2Unlocked && SKILL_TREES[className]) {
        const ability = SKILL_TREES[className].ultimate2;
        document.getElementById('ability2Icon').textContent = ability.icon;
        document.getElementById('ability2Name').textContent = ability.name;
        document.getElementById('ability2Key').textContent = `[${ability.hotkey ? ability.hotkey.toUpperCase() : 'AUTO'}]`;
        ability2Btn.style.display = 'block';
      } else {
        ability2Btn.style.display = 'none';
      }
    }
    
    function updateAbilities(dt) {
      // Update cooldowns
      if (ability1Cooldown > 0) ability1Cooldown -= dt;
      if (ability2Cooldown > 0) ability2Cooldown -= dt;
      
      // Update special timers
      if (overwatchTimer > 0) {
        overwatchTimer -= dt;
        if (overwatchTimer <= 0) overwatchActive = false;
      }
      if (bladeStormTimer > 0) {
        bladeStormTimer -= dt;
        if (bladeStormTimer <= 0) bladeStormActive = false;
      }
      if (soulHarvestTimer > 0) {
        soulHarvestTimer -= dt;
        if (soulHarvestTimer <= 0) soulHarvestActive = false;
      }
      if (timeFreezeTimer > 0) {
        timeFreezeTimer -= dt;
        if (timeFreezeTimer <= 0) {
          timeFreezeActive = false;
          enemies.forEach(e => e.frozen = false);
        }
      }
      if (hiveMindTimer > 0) {
        hiveMindTimer -= dt;
        if (hiveMindTimer <= 0) hiveMindActive = false;
      }
      if (upsideDownTimer > 0) {
        upsideDownTimer -= dt;
        if (upsideDownTimer <= 0) upsideDownActive = false;
      }
      
      // Blade storm damage
      if (bladeStormActive) {
        enemies.forEach(enemy => {
          const dx = enemy.x - player.x;
          const dy = enemy.y - player.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 150) {
            enemy.hp -= 50 * dt;
            if (enemy.hp <= 0 && !enemy.dead) {
              enemy.dead = true;
              onEnemyKilled(enemy);
            }
          }
        });
      }
      
      // Check auto-trigger abilities
      checkAutoAbilities();
      
      // Update display
      updateAbilityDisplay();
      
      // Update Vecna monsters
      if (selectedClassName === 'Vecna' && player.alive) {
        updateVecnaMonsters(dt);
      }
    }
    
    function checkAutoAbilities() {
      if (!selectedClassName || !gameData.skillTrees[selectedClassName]) return;
      
      const abilities = SKILL_TREES[selectedClassName];
      
      // Check ability 1 kill requirement
      if (abilities.ultimate1 && gameData.skillTrees[selectedClassName].ultimate1) {
        if (abilities.ultimate1.activation === 'kills' && 
            ability1KillCounter >= abilities.ultimate1.killRequirement &&
            ability1Cooldown <= 0) {
          activateAbility1();
        }
      }
      
      // Check ability 2 kill requirement
      if (abilities.ultimate2 && gameData.skillTrees[selectedClassName].ultimate2) {
        if (abilities.ultimate2.activation === 'kills' && 
            ability2KillCounter >= abilities.ultimate2.killRequirement &&
            ability2Cooldown <= 0) {
          activateAbility2();
        }
      }
      
      // Check Knight Last Stand
      if (selectedClassName === 'Knight' && 
          gameData.skillTrees.Knight?.ultimate2 &&
          player.hp < player.maxHP * 0.2 && 
          !lastStandUsed && 
          player.alive) {
        activateLastStand();
      }
    }
    
    function updateAbilityDisplay() {
      const ability1Btn = document.getElementById('ability1Btn');
      const ability2Btn = document.getElementById('ability2Btn');
      
      if (ability1Btn.style.display !== 'none') {
        const cd1 = document.getElementById('ability1CD');
        if (ability1Cooldown > 0) {
          cd1.textContent = Math.ceil(ability1Cooldown) + 's';
          ability1Btn.classList.add('cooldown');
          ability1Btn.classList.remove('ready');
        } else {
          cd1.textContent = 'READY';
          ability1Btn.classList.remove('cooldown');
          ability1Btn.classList.add('ready');
        }
      }
      
      if (ability2Btn.style.display !== 'none') {
        const cd2 = document.getElementById('ability2CD');
        if (ability2Cooldown > 0) {
          cd2.textContent = Math.ceil(ability2Cooldown) + 's';
          ability2Btn.classList.add('cooldown');
          ability2Btn.classList.remove('ready');
        } else {
          cd2.textContent = 'READY';
          ability2Btn.classList.remove('cooldown');
          ability2Btn.classList.add('ready');
        }
      }
    }
    
    function activateAbility1() {
      if (ability1Cooldown > 0 || !player.alive) return;
      
      const className = selectedClassName;
      if (!className || !gameData.skillTrees[className]?.ultimate1) return;
      
      const ability = SKILL_TREES[className].ultimate1;
      ability1Cooldown = ability.cooldown || 30;
      ability1KillCounter = 0;
      
      // Activate specific ability
      switch(className) {
        case 'Hunter': activateSniperShot(); break;
        case 'Knight': activateShieldBash(); break;
        case 'Assassin': activateShadowStrike(); break;
        case 'Wizard': activateMeteorStorm(); break;
        case 'Archer': activateArrowBarrage(); break;
        case 'Summoner': activateArmyOfDead(); break;
        case 'Bomber': activateNuke(); break;
        case 'Sniper': activateHeadhunter(); break;
        case 'Necromancer': activatePlague(); break;
        case 'Vecna': activateHiveMind(); break;
      }
    }
    
    function activateAbility2() {
      if (ability2Cooldown > 0 || !player.alive) return;
      
      const className = selectedClassName;
      if (!className || !gameData.skillTrees[className]?.ultimate2) return;
      
      const ability = SKILL_TREES[className].ultimate2;
      ability2Cooldown = ability.cooldown || 30;
      ability2KillCounter = 0;
      
      // Activate specific ability
      switch(className) {
        case 'Hunter': activateCarePackage(); break;
        case 'Knight': activateLastStand(); break;
        case 'Assassin': activateBladeStorm(); break;
        case 'Wizard': activateTimeFreeze(); break;
        case 'Archer': activateExplosiveArrow(); break;
        case 'Summoner': activateSacrifice(); break;
        case 'Bomber': activateChainReaction(); break;
        case 'Sniper': activateOverwatch(); break;
        case 'Necromancer': activateSoulHarvest(); break;
        case 'Vecna': activateVecnasCurse(); break;
      }
    }

    // ========== ABILITY IMPLEMENTATIONS ==========
    
    // HUNTER ABILITIES
    function activateSniperShot() {
      createFloatingText("üéØ SNIPER SHOT!", player.x, player.y - 30, "#00ffff");
      screenShake = 15;
      
      // Create massive cross-screen beam
      const damage = 500;
      projectiles.push({
        x: player.x,
        y: player.y,
        vx: 25,
        vy: 0,
        radius: 20,
        color: "#ff0000",
        damage: damage,
        pierce: true,
        isCrit: true,
        critMultiplier: 3,
        life: 3,
        isSniperShot: true
      });
    }
    
    function activateCarePackage() {
      createFloatingText("üì¶ CARE PACKAGE!", player.x, player.y - 30, "#00ff00");
      screenShake = 10;
      
      // Drop potions from sky
      potions.heal += 2;
      potions.shield += 1;
      potions.damage += 1;
      updatePotionDisplay();
      
      createExplosion(player.x, player.y, "#00ff00");
    }
    
    // KNIGHT ABILITIES
    function activateShieldBash() {
      createFloatingText("üõ°Ô∏è SHIELD BASH!", player.x, player.y - 30, "#0088ff");
      screenShake = 12;
      
      // Charge forward
      const chargeSpeed = 300;
      const chargeDist = 300;
      let chargeRemaining = chargeDist;
      
      const chargeInterval = setInterval(() => {
        if (chargeRemaining > 0 && player.alive) {
          player.x += 15;
          chargeRemaining -= 15;
          
          // Damage and stun enemies
          enemies.forEach(enemy => {
            const dx = enemy.x - player.x;
            const dy = enemy.y - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 80) {
              enemy.hp -= 100;
              enemy.stunned = true;
              enemy.stunnedTimer = 2;
              if (enemy.hp <= 0 && !enemy.dead) {
                enemy.dead = true;
                onEnemyKilled(enemy);
              }
            }
          });
        } else {
          clearInterval(chargeInterval);
        }
      }, 50);
    }
    
    function activateLastStand() {
      createFloatingText("‚ö° LAST STAND!", player.x, player.y - 30, "#ffff00");
      screenShake = 20;
      lastStandUsed = true;
      
      // Invincible for 5 seconds
      player.invincible = true;
      setTimeout(() => {
        player.invincible = false;
      }, 5000);
    }
    
    // ASSASSIN ABILITIES
    function activateShadowStrike() {
      if (enemies.length === 0) return;
      
      const target = enemies[Math.floor(Math.random() * enemies.length)];
      createFloatingText("üëª SHADOW STRIKE!", player.x, player.y - 30, "#9933ff");
      
      // Teleport behind enemy
      player.x = target.x - 50;
      player.y = target.y;
      
      // Deal massive damage
      target.hp -= 300;
      createExplosion(target.x, target.y, "#9933ff");
      screenShake = 15;
      
      if (target.hp <= 0 && !target.dead) {
        target.dead = true;
        onEnemyKilled(target);
      }
    }
    
    function activateBladeStorm() {
      createFloatingText("üåÄ BLADE STORM!", player.x, player.y - 30, "#ff00ff");
      screenShake = 10;
      bladeStormActive = true;
      bladeStormTimer = 5;
    }
    
    // WIZARD ABILITIES
    function activateMeteorStorm() {
      createFloatingText("‚òÑÔ∏è METEOR STORM!", player.x, player.y - 30, "#ff8800");
      screenShake = 15;
      
      // Drop 10 meteors
      for (let i = 0; i < 10; i++) {
        setTimeout(() => {
          const x = Math.random() * canvas.width;
          const y = 0;
          
          projectiles.push({
            x: x,
            y: y,
            vx: 0,
            vy: 15,
            radius: 15,
            color: "#ff8800",
            damage: 150,
            explosive: true,
            explosionRadius: 100,
            isCrit: true,
            life: 5
          });
        }, i * 200);
      }
    }
    
    function activateTimeFreeze() {
      createFloatingText("‚ùÑÔ∏è TIME FREEZE!", player.x, player.y - 30, "#00ffff");
      screenShake = 12;
      timeFreezeActive = true;
      timeFreezeTimer = 5;
      
      enemies.forEach(enemy => {
        enemy.frozen = true;
      });
    }

    // ARCHER ABILITIES
    function activateArrowBarrage() {
      createFloatingText("üèπ ARROW BARRAGE!", player.x, player.y - 30, "#00ff00");
      screenShake = 12;
      
      // Fire 50 arrows in all directions
      for (let i = 0; i < 50; i++) {
        const angle = (i / 50) * Math.PI * 2;
        projectiles.push({
          x: player.x,
          y: player.y,
          vx: Math.cos(angle) * 10,
          vy: Math.sin(angle) * 10,
          radius: 8,
          color: "#00ff00",
          damage: 30,
          pierce: true,
          life: 2
        });
      }
    }
    
    function activateExplosiveArrow() {
      createFloatingText("üí• EXPLOSIVE ARROW!", player.x, player.y - 30, "#ff0000");
      screenShake = 20;
      
      // Find nearest enemy
      let nearest = null;
      let minDist = Infinity;
      enemies.forEach(enemy => {
        const dx = enemy.x - player.x;
        const dy = enemy.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < minDist) {
          minDist = dist;
          nearest = enemy;
        }
      });
      
      if (nearest) {
        const angle = Math.atan2(nearest.y - player.y, nearest.x - player.x);
        projectiles.push({
          x: player.x,
          y: player.y,
          vx: Math.cos(angle) * 15,
          vy: Math.sin(angle) * 15,
          radius: 25,
          color: "#ff6600",
          damage: 800,
          explosive: true,
          explosionRadius: 300,
          isCrit: true,
          critMultiplier: 3,
          life: 5
        });
      }
    }
    
    // SUMMONER ABILITIES
    function activateArmyOfDead() {
      createFloatingText("üíÄ ARMY OF THE DEAD!", player.x, player.y - 30, "#9933ff");
      screenShake = 15;
      
      // Spawn 10 skeletons
      for (let i = 0; i < 10; i++) {
        const angle = (i / 10) * Math.PI * 2;
        const dist = 80;
        minions.push({
          x: player.x + Math.cos(angle) * dist,
          y: player.y + Math.sin(angle) * dist,
          hp: 40,
          maxHP: 40,
          damage: 8,
          speed: 2,
          radius: 8,
          color: "#9933ff"
        });
      }
    }
    
    function activateSacrifice() {
      createFloatingText("üîÆ SACRIFICE!", player.x, player.y - 30, "#ff00ff");
      screenShake = 10;
      
      const minionCount = minions.length;
      const shieldGain = minionCount * 30;
      
      player.shield += shieldGain;
      minions = [];
      
      createFloatingText("+" + shieldGain + " Shield", player.x, player.y, "#00ffff");
    }
    
    // BOMBER ABILITIES
    function activateNuke() {
      createFloatingText("‚ò¢Ô∏è NUKE!", player.x, player.y - 30, "#ff0000");
      screenShake = 30;
      
      // Damage all enemies
      enemies.forEach(enemy => {
        enemy.hp -= 1000;
        if (enemy.hp <= 0 && !enemy.dead) {
          enemy.dead = true;
          onEnemyKilled(enemy);
        }
      });
      
      // Massive explosion
      createExplosion(canvas.width / 2, canvas.height / 2, "#ff0000", 400);
    }
    
    function activateChainReaction() {
      createFloatingText("‚õìÔ∏è CHAIN REACTION!", player.x, player.y - 30, "#ff8800");
      screenShake = 10;
      chainReactionShots = 10;
    }
    
    // SNIPER ABILITIES
    function activateHeadhunter() {
      createFloatingText("üíÄ HEADHUNTER!", player.x, player.y - 30, "#ff0000");
      screenShake = 10;
      headhunterShots = 5;
    }
    
    function activateOverwatch() {
      createFloatingText("üî≠ OVERWATCH!", player.x, player.y - 30, "#00ffff");
      screenShake = 8;
      overwatchActive = true;
      overwatchTimer = 15;
    }
    
    // NECROMANCER ABILITIES
    function activatePlague() {
      createFloatingText("ü¶† PLAGUE!", player.x, player.y - 30, "#00ff00");
      screenShake = 12;
      
      enemies.forEach(enemy => {
        enemy.poisoned = true;
        enemy.poisonDamage = 20;
        enemy.poisonDuration = 10;
        enemy.poisonTimer = 10;
      });
    }
    
    function activateSoulHarvest() {
      createFloatingText("üëª SOUL HARVEST!", player.x, player.y - 30, "#9933ff");
      screenShake = 10;
      soulHarvestActive = true;
      soulHarvestTimer = 10;
    }
    
    // VECNA ABILITIES
    function activateHiveMind() {
      createFloatingText("üëÅÔ∏è HIVE MIND!", player.x, player.y - 30, "#8B0000");
      screenShake = 20;
      hiveMindActive = true;
      hiveMindTimer = 15;
    }
    
    function activateVecnasCurse() {
      createFloatingText("üåÄ VECNA'S CURSE!", player.x, player.y - 30, "#FF0000");
      screenShake = 25;
      upsideDownActive = true;
      upsideDownTimer = 20;
    }
    
    // VECNA SPECIAL MECHANICS
    function spawnVecnaMonster() {
      vecnaMonsters.push({
        x: player.x + (Math.random() - 0.5) * 100,
        y: player.y + (Math.random() - 0.5) * 100,
        hp: 50,
        maxHP: 50,
        damage: 10,
        speed: 2.5,
        radius: 12,
        color: "#8B0000",
        target: null
      });
    }
    
    function updateVecnaMonsters(dt) {
      const classStats = CLASSES[player.class]?.stats || {};
      const attackSpeedMultiplier = classStats.monsterAttackSpeed || 1;
      const slowEffect = classStats.monsterSlowEffect || 0;
      const slowDuration = classStats.monsterSlowDuration || 0;
      
      vecnaMonsters.forEach((monster, idx) => {
        if (monster.hp <= 0) {
          vecnaMonsters.splice(idx, 1);
          return;
        }
        
        // Find nearest enemy
        let nearest = null;
        let minDist = Infinity;
        enemies.forEach(enemy => {
          const dx = enemy.x - monster.x;
          const dy = enemy.y - monster.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < minDist) {
            minDist = dist;
            nearest = enemy;
          }
        });
        
        if (nearest) {
          const dx = nearest.x - monster.x;
          const dy = nearest.y - monster.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist > 30) {
            monster.x += (dx / dist) * monster.speed;
            monster.y += (dy / dist) * monster.speed;
            
            // Apply slow on touch (within 30 units)
            if (dist <= 30 && slowEffect > 0) {
              nearest.slowAmount = (nearest.slowAmount || 0) + slowEffect;
              nearest.slowDuration = slowDuration;
            }
          } else {
            // Attack with 10x speed multiplier
            nearest.hp -= monster.damage * dt * attackSpeedMultiplier;
            
            // Apply slow effect on attack
            if (slowEffect > 0) {
              nearest.slowAmount = (nearest.slowAmount || 0) + slowEffect;
              nearest.slowDuration = slowDuration;
            }
            
            if (nearest.hp <= 0 && !nearest.dead) {
              nearest.dead = true;
              onEnemyKilled(nearest);
            }
          }
        }
      });
    }

    // CLASS DEFINITIONS
    const CLASSES = {
      Hunter: {
        icon: "üèπ",
        color: "#00ff88",
        accent: "#88ffaa",
        bulletColor: "#00ff88",
        glowColor: "#00ff88",
        unlockWave: 0,
        purchasable: false,
        stats: {
          maxHP: 100,
          damage: 10,
          fireRate: 0.8, // 1.25/sec
          range: 650,
          projectileSpeed: 8
        },
        description: "Balanced starter class"
      },
      Knight: {
        icon: "‚öîÔ∏è",
        color: "#4488ff",
        accent: "#88aaff",
        bulletColor: "#4488ff",
        glowColor: "#4488ff",
        unlockWave: 20,
        purchasable: false,
        stats: {
          maxHP: 140,
          damage: 14,
          fireRate: 1.111, // 0.9/sec
          range: 400,
          projectileSpeed: 6.5
        },
        description: "Durable frontline fighter with slower heavy shots"
      },
      Archer: {
        icon: "üèπ",
        color: "#228b22",
        accent: "#32cd32",
        bulletColor: "#228b22",
        glowColor: "#32cd32",
        unlockWave: 20, // Unlocks at wave 20
        purchasable: false,
        stats: {
          maxHP: 90,
          damage: 12,
          fireRate: 0.556, // 1.8/sec
          range: 700,
          projectileSpeed: 10,
          alwaysPierce: true // Rapid-firing ranged attacker
        },
        description: "Rapid-firing ranged attacker"
      },
      Thief: {
        icon: "ü•∑",
        color: "#4a0080",
        accent: "#8800ff",
        bulletColor: "#4a0080",
        glowColor: "#8800ff",
        unlockWave: 15, // Unlocks at wave 15 - 5x money class!
        purchasable: false,
        stats: {
          maxHP: 85,
          damage: 8,
          fireRate: 0.455, // 2.2/sec - Fast dagger-throwing
          range: 350,
          projectileSpeed: 8,
          coinMultiplier: 5, // Earns 5x coins!
          gemMultiplier: 5 // Earns 5x gems!
        },
        description: "Fast dagger-throwing crit-based DPS"
      },
      Assassin: {
        icon: "üó°Ô∏è",
        color: "#ff00ff",
        accent: "#ff88ff",
        bulletColor: "#ff00ff",
        glowColor: "#ff00ff",
        unlockWave: 35,
        purchasable: false,
        stats: {
          maxHP: 95,
          damage: 9,
          fireRate: 0.357, // 2.8/sec - Ultra-fast
          range: 400,
          projectileSpeed: 9.5
        },
        description: "Ultra-fast glass cannon"
      },
      Summoner: {
        icon: "‚ú®",
        color: "#88ff88",
        accent: "#aaffaa",
        bulletColor: "#88ff88",
        glowColor: "#88ff88",
        unlockWave: 65,
        purchasable: false,
        stats: {
          maxHP: 110,
          damage: 12,
          fireRate: 1.0, // 1.0/sec
          range: 500,
          projectileSpeed: 7
        },
        description: "Summons spirit helpers to assist with damage"
      },
      DarkMagician: {
        icon: "üîÆ",
        color: "#8800ff",
        accent: "#aa88ff",
        bulletColor: "#8800ff",
        glowColor: "#8800ff",
        unlockWave: 95,
        purchasable: false,
        stats: {
          maxHP: 85,
          damage: 35,
          fireRate: 1.818, // 0.55/sec - Slow but powerful
          range: 550,
          projectileSpeed: 5.5
        },
        description: "Slow but extremely powerful caster"
      },
      // PURCHASABLE CLASSES
      Bomber: {
        icon: "üí£",
        color: "#ff8800",
        accent: "#ffaa44",
        bulletColor: "#ff8800",
        glowColor: "#ff8800",
        unlockWave: 0,
        purchasable: true,
        cost: { coins: 500, gems: 2 }, // MUCH cheaper early unlock!
        stats: {
          maxHP: 130,
          damage: 30, // 3x Hunter's damage (Hunter = 10)
          fireRate: 1.2, // 0.83/sec - Slightly faster
          range: 500,
          projectileSpeed: 6,
          alwaysExplosive: true, // Every shot explodes!
          explosionRadius: 120, // HUGE explosion radius
          explosionDamage: 90 // AOE explosion does 3x the projectile damage!
        },
        description: "Massive AOE explosions ‚Äî 3x direct hit, 3x AOE blast damage!"
      },
      Sniper: {
        icon: "üéØ",
        color: "#00ffff",
        accent: "#88ffff",
        bulletColor: "#00ffff",
        glowColor: "#00ffff",
        unlockWave: 0,
        purchasable: true,
        cost: { coins: 15000, gems: 150 },
        stats: {
          maxHP: 100,
          damage: 45,
          fireRate: 2.222, // 0.45/sec - Very slow
          range: 900,
          projectileSpeed: 12,
          alwaysCrit: true // Highest single-hit damage
        },
        description: "Highest single-hit damage. Very slow fire rate"
      },
      Necromancer: {
        icon: "üíÄ",
        color: "#9933ff",
        accent: "#bb66ff",
        bulletColor: "#9933ff",
        glowColor: "#9933ff",
        unlockWave: 0,
        purchasable: true,
        cost: { coins: 25000, gems: 250 },
        stats: {
          maxHP: 105,
          damage: 15,
          fireRate: 1.111, // 0.9/sec
          range: 550,
          projectileSpeed: 7,
          alwaysPoison: true, // Poisons enemies
          spawnSkeletonsOnKill: true // Raises skeletons
        },
        description: "Poisons enemies and raises skeletons"
      },
      Vecna: {
        icon: "üëÅÔ∏è",
        color: "#8B0000",
        accent: "#FF0000",
        bulletColor: "#8B0000",
        glowColor: "#FF0000",
        unlockWave: 0,
        purchasable: true,
        cost: { coins: 10000000, gems: 10000 },
        stats: {
          maxHP: 110,
          damage: 18,
          fireRate: 1.333, // 0.75/sec
          range: 600,
          projectileSpeed: 7.5,
          summonMonsters: true,
          monsterAttackSpeed: 10, // Monsters attack 10x faster
          monsterSlowEffect: 0.8, // 80% slow on touch
          monsterSlowDuration: 2.0, // 2 seconds
          shieldOnKills: 10,
          enemyConversionChance: 0.2
        },
        description: "Summons ultra-fast monsters that slow enemies by 80% on touch"
      },
      // NEW CLASSES
      Pyromancer: {
        icon: "üî•",
        color: "#ff4500",
        accent: "#ff6347",
        bulletColor: "#ff4500",
        glowColor: "#ff6347",
        unlockWave: 45,
        purchasable: false,
        stats: {
          maxHP: 90,
          damage: 22,
          fireRate: 0.909, // 1.1/sec
          range: 550,
          projectileSpeed: 7,
          burnDamageOverTime: true, // Burns enemies
          fireZones: true, // Sets floor on fire
          fireZoneDuration: 5.0, // Fire zones last 5 seconds
          fireZoneDamage: 10, // Damage per second in fire zones
          burnDuration: 4.0, // Burn lasts 4 seconds
          burnDamagePerSec: 8 // Burn damage per second
        },
        description: "Sets floor and enemies on fire, dealing massive burn damage over time"
      },
      CryoSentinel: {
        icon: "‚ùÑÔ∏è",
        color: "#00bfff",
        accent: "#87ceeb",
        bulletColor: "#00bfff",
        glowColor: "#87ceeb",
        unlockWave: 0,
        purchasable: false,
        achievementUnlock: "freeze100", // Freeze 100 enemies
        stats: {
          maxHP: 120,
          damage: 14,
          fireRate: 1.053, // 0.95/sec
          range: 500,
          projectileSpeed: 6.5,
          slowOnHit: 0.5, // 50% slow
          freezeChance: 0.1, // 10% chance to freeze
          iceShards: true, // Ice shards stick in ground
          maxIceShards: 8, // Maximum 8 shards on field
          iceShardDamage: 20, // Damage when enemy touches shard
          iceShardDuration: 15.0, // Shards last 15 seconds
          iceShardSlowAmount: 0.3 // 30% additional slow
        },
        description: "Ice shards stick in ground and damage enemies that touch them"
      },
      PlagueDoctor: {
        icon: "ü¶†",
        color: "#32cd32",
        accent: "#90ee90",
        bulletColor: "#32cd32",
        glowColor: "#90ee90",
        unlockWave: 0,
        purchasable: true,
        cost: { coins: 20000, gems: 200 },
        stats: {
          maxHP: 100,
          damage: 16,
          fireRate: 0.833, // 1.2/sec
          range: 500,
          projectileSpeed: 7,
          stackingPoison: true, // Stacking poison
          poisonSpread: true, // Spreads between enemies
          placeableClouds: true, // Can place poison clouds with mouse click
          maxClouds: 3, // Maximum 3 clouds at once
          cloudRadius: 150, // Cloud effect radius
          cloudDuration: 10.0, // Clouds last 10 seconds
          cloudPoisonDPS: 5, // Poison damage per second
          cloudSlowAmount: 0.4, // 40% slow
          cloudConfusionChance: 0.2, // 20% chance to confuse
          cloudStunChance: 0.1 // 10% chance to stun
        },
        description: "Place poison clouds that confuse, slow, stun, and poison enemies"
      },
      LightningRanger: {
        icon: "‚ö°",
        color: "#ffd700",
        accent: "#ffff00",
        bulletColor: "#ffd700",
        glowColor: "#ffff00",
        unlockWave: 75,
        purchasable: false,
        stats: {
          maxHP: 105,
          damage: 28,
          fireRate: 1.176, // 0.85/sec
          range: 600,
          projectileSpeed: 9,
          chainLightning: 3 // Chains to 3 enemies
        },
        description: "Electric shots chain between enemies"
      },
      BloodReaver: {
        icon: "ü©∏",
        color: "#8b0000",
        accent: "#dc143c",
        bulletColor: "#8b0000",
        glowColor: "#dc143c",
        unlockWave: 0,
        purchasable: false,
        achievementUnlock: "defeat3Elites", // Defeat 3 elite enemies
        stats: {
          maxHP: 140,
          damage: 18,
          fireRate: 1.0, // 1.0/sec
          range: 450,
          projectileSpeed: 7,
          lifestealPercent: 0.15, // 15% lifesteal to start
          bleedDamage: true, // Applies bleed
          bleedDuration: 5.0, // Bleed lasts 5 seconds
          bleedDamagePerSec: 6 // Bleed damage per second
        },
        description: "Starts with 15% lifesteal and applies bleeding to enemies"
      },
      CrystalGuardian: {
        icon: "üíé",
        color: "#9370db",
        accent: "#ba55d3",
        bulletColor: "#9370db",
        glowColor: "#ba55d3",
        unlockWave: 0,
        purchasable: true,
        cost: { coins: 40000, gems: 350 },
        stats: {
          maxHP: 160,
          damage: 12,
          fireRate: 1.25, // 0.8/sec
          range: 500,
          projectileSpeed: 6,
          startingShield: 200, // Starts with 200 shield
          reflectProjectiles: true, // Reflects enemy projectiles
          reflectDamageMultiplier: 2.0, // Reflects at 2x damage
          reflectDamage: 0.15 // 15% passive reflect
        },
        description: "Starts with 200 shield, reflects enemy projectiles at 2x damage"
      },
      ShadowMonk: {
        icon: "ü•ã",
        color: "#2f4f4f",
        accent: "#696969",
        bulletColor: "#2f4f4f",
        glowColor: "#696969",
        unlockWave: 85,
        purchasable: false,
        stats: {
          maxHP: 110,
          damage: 20,
          fireRate: 0.714, // 1.4/sec
          range: 300, // Low range for close combat
          projectileSpeed: 8,
          knockback: 60, // Medium knockback
          critBonus: 0.5 // +50% crit damage
        },
        description: "Low-range martial artist with medium knockback and crit damage"
      },
      ArcWarden: {
        icon: "‚ö°",
        color: "#4169e1",
        accent: "#6495ed",
        bulletColor: "#4169e1",
        glowColor: "#6495ed",
        unlockWave: 0,
        purchasable: false,
        achievementUnlock: "collect5ArcCores", // Collect 5 Arc Cores
        stats: {
          maxHP: 95,
          damage: 30,
          fireRate: 1.429, // 0.7/sec
          range: 550,
          projectileSpeed: 7.5,
          stunChance: 0.15 // 15% stun chance
        },
        description: "Electric cannon with stun potential"
      },
      HolyCleric: {
        icon: "‚úùÔ∏è",
        color: "#ffd700",
        accent: "#ffffe0",
        bulletColor: "#ffd700",
        glowColor: "#ffffe0",
        unlockWave: 0,
        purchasable: false,
        achievementUnlock: "heal1000HP", // Heal 1000 total HP
        stats: {
          maxHP: 150,
          damage: 10,
          fireRate: 0.909, // 1.1/sec
          range: 500,
          projectileSpeed: 6.5,
          healOnHit: 2, // Heals 2 HP per hit
          autoHealSpell: true, // 30s auto-healing spell
          autoHealInterval: 30.0, // Triggers every 30 seconds
          autoHealAmount: 40, // Heals 40 HP
          autoHealRadius: 200, // 200 radius
          autoHealKnockback: 50 // Knockback enemies in radius
        },
        description: "Auto-heals 40 HP every 30s with knockback in 200 radius"
      },
      TrickshotRogue: {
        icon: "üé≤",
        color: "#ff1493",
        accent: "#ff69b4",
        bulletColor: "#ff1493",
        glowColor: "#ff69b4",
        unlockWave: 100,
        purchasable: false,
        stats: {
          maxHP: 80,
          damage: 35,
          fireRate: 1.0, // 1.0/sec
          range: 600,
          projectileSpeed: 9,
          ricochetShots: 5, // Bounces 5 times between enemies
          ricochetDamageIncrease: 0.25 // +25% damage per bounce
        },
        description: "Shots bounce 5x between enemies, increasing damage each bounce"
      },
      Starcaller: {
        icon: "üåü",
        color: "#9400d3",
        accent: "#ba55d3",
        bulletColor: "#9400d3",
        glowColor: "#ba55d3",
        unlockWave: 0,
        purchasable: false,
        achievementUnlock: "fallingStarDrop", // Rare drop
        stats: {
          maxHP: 115,
          damage: 18,
          fireRate: 1.0, // 1.0/sec
          range: 550,
          projectileSpeed: 7,
          gravityPull: true, // Pulls enemies
          helperStar: true, // Mini helper star
          helperStarDamage: 12, // Helper star damage
          helperStarFireRate: 0.6, // Helper shoots at 1.67/sec
          helperStarRange: 400 // Helper star range
        },
        description: "Mini helper star shoots alongside player with gravity effects"
      },
      VoidAssassin: {
        icon: "üåë",
        color: "#191970",
        accent: "#483d8b",
        bulletColor: "#191970",
        glowColor: "#483d8b",
        unlockWave: 0,
        purchasable: false,
        achievementUnlock: "kill100In10Sec", // Challenge completion
        stats: {
          maxHP: 90,
          damage: 40,
          fireRate: 1.111, // 0.9/sec
          range: 450,
          projectileSpeed: 8.5,
          voidStrike: true, // Void damage
          invulnFrames: 0.5 // 0.5s invuln on hit
        },
        description: "High crit void strikes with brief invuln"
      },
      Shadowblade: {
        icon: "‚öîÔ∏è",
        color: "#000000",
        accent: "#696969",
        bulletColor: "#000000",
        glowColor: "#696969",
        unlockWave: 0,
        purchasable: true,
        cost: { coins: 5000, gems: 0 }, // OR shadow scroll drop
        stats: {
          maxHP: 100,
          damage: 12,
          fireRate: 0.526, // 1.9/sec
          range: 400,
          projectileSpeed: 8,
          curseOnHit: true, // Curses enemies
          bonusCritDamage: 0.75 // +75% crit damage
        },
        description: "Curses enemies and deals bonus crit"
      },
      AstralGolem: {
        icon: "üóø",
        color: "#708090",
        accent: "#a9a9a9",
        bulletColor: "#708090",
        glowColor: "#a9a9a9",
        unlockWave: 120,
        purchasable: false,
        stats: {
          maxHP: 400, // Massive HP pool
          damage: 22,
          fireRate: 1.818, // 0.55/sec - Very slow
          range: 500,
          projectileSpeed: 5,
          damageReduction: 0.30, // 30% damage reduction
          heavyProjectiles: true // Heavy star projectiles
        },
        description: "400 HP tank with 30% damage reduction and heavy projectiles"
      },
      Engineer: {
        icon: "üîß",
        color: "#FF8C00",
        accent: "#FFA500",
        bulletColor: "#FF8C00",
        glowColor: "#FFA500",
        unlockWave: 25,
        purchasable: false,
        stats: {
          maxHP: 95,
          damage: 7, // Lower personal damage
          fireRate: 1.0, // 1.0/sec
          range: 450,
          projectileSpeed: 7,
          turretClass: true, // Special flag for turret mechanics
          maxTurrets: 2, // Can place 2 turrets at round start
          turretDamage: 8, // Base turret damage
          turretRange: 350, // Turret attack range
          turretFireRate: 0.5, // 2.0/sec
          turretHP: 150, // Base turret health
          placeAtRoundStart: true // Place turrets at round start
        },
        description: "Place 2 defensive turrets at round start with specialized abilities"
      },
      TheForsakenOne: {
        icon: "üíÄ",
        color: "#4B0082",
        accent: "#8B00FF",
        bulletColor: "#4B0082",
        glowColor: "#8B00FF",
        unlockWave: 0,
        purchasable: false,
        challengeUnlock: "rejectAllPowerups", // Reject all level-ups & potions, survive to wave 11
        stats: {
          maxHP: 115,
          damage: 17,
          fireRate: 0.741, // 1.35/sec - Balanced hybrid
          range: 500,
          projectileSpeed: 7.5,
          knockback: 1.5, // Strong knockback on all shots
          cursedFlux: true, // Random buffs every 15 seconds
          cursedFluxTimer: 0,
          cursedFluxDuration: 6,
          currentBuff: null
        },
        description: "A cursed survivor who chose nothing and overcame everything. Chaos fuels their power."
      },
      Rookie: {
        icon: "üéØ",
        color: "#cccccc",
        accent: "#ffffff",
        bulletColor: "#999999",
        glowColor: "#cccccc",
        unlockWave: 0,  // Available from start
        purchasable: false,
        stats: {
          maxHP: 80,        // Weakest HP
          damage: 6,        // Weakest damage
          fireRate: 1.25,   // Slowest fire rate (0.8/sec)
          range: 350,       // Shortest range
          projectileSpeed: 6, // Slowest projectile
          xpMultiplier: 1.5,  // 50% more XP gained
          powerUpMultiplier: 1.2 // 20% bonus to all upgrades
        },
        description: "Beginner class that levels up faster and gets 20% better upgrades"
      },
      GuardianTank: {
        icon: "üõ°Ô∏è",
        color: "#4169e1",
        accent: "#6495ed",
        bulletColor: "#4169e1",
        glowColor: "#87ceeb",
        unlockWave: 0,
        purchasable: false,
        unlockedByCondition: true,  // Special unlock condition
        stats: {
          maxHP: 180,
          damage: 35,       // High damage
          fireRate: 2.0,    // Slow (0.5/sec)
          range: 500,       // Decent range
          projectileSpeed: 4.5, // Slow but strong
          knockback: 80,    // Pushes enemies back
          autoKnockback: 0.20, // 20% automatic knockback
          projectileSize: 24 // Giant shield visual
        },
        description: "Massive shields with 20% automatic knockback. Unlock: 5 shield upgrades + HP > 200"
      },
      Berserk: {
        icon: "ü™ì",
        color: "#8B0000",
        accent: "#DC143C",
        bulletColor: "#8B0000",
        glowColor: "#DC143C",
        unlockWave: 50,
        purchasable: false,
        stats: {
          maxHP: 150,
          damage: 15, // Base damage
          fireRate: 0.625, // 1.6/sec
          range: 350,
          projectileSpeed: 9,
          berserkMode: true, // Damage scales with low HP
          maxDamageMultiplier: 3.0, // 3x damage at low HP
          lowHPThreshold: 0.25 // Starts scaling below 25% HP
        },
        description: "Damage scales up to 3x when at low HP - high risk, high reward"
      },
      Samurai: {
        icon: "‚öîÔ∏è",
        color: "#C41E3A",
        accent: "#FF4500",
        bulletColor: "#C41E3A",
        glowColor: "#FF4500",
        unlockWave: 70,
        purchasable: false,
        stats: {
          maxHP: 120,
          damage: 25,
          fireRate: 1.2, // 0.83/sec
          range: 999999, // Screen-wide slashes
          projectileSpeed: 15,
          screenWideSlash: true, // Screen-wide attack
          slashKnockback: 0.02, // 2% knockback
          chainReaction: true, // Chain reaction on kills
          chainDamageBonus: 0.5 // +50% damage per chain
        },
        description: "Screen-wide slashes with 2% knockback, chain reactions on kills"
      },
      Warlock: {
        icon: "üîÆ",
        color: "#4B0082",
        accent: "#9370DB",
        bulletColor: "#4B0082",
        glowColor: "#9370DB",
        unlockWave: 60,
        purchasable: false,
        stats: {
          maxHP: 95,
          damage: 30,
          fireRate: 1.5, // 0.67/sec
          range: 600,
          projectileSpeed: 6,
          ignoreShields: true, // Ignores enemy shields
          weakenEnemies: true, // Weakens enemies
          weakenAmount: 0.25, // 25% weaken
          weakenDuration: 5.0 // 5 second weaken
        },
        description: "Dark magic ignores shields and weakens enemies by 25%"
      },
      Druid: {
        icon: "üåø",
        color: "#228B22",
        accent: "#32CD32",
        bulletColor: "#228B22",
        glowColor: "#32CD32",
        unlockWave: 55,
        purchasable: false,
        stats: {
          maxHP: 130,
          damage: 18,
          fireRate: 1.0, // 1.0/sec
          range: 500,
          projectileSpeed: 7,
          rootBarriers: true, // Can place root barriers
          maxBarriers: 4, // Maximum 4 barriers
          barrierHP: 200, // Barrier health
          barrierThornDamage: 15, // Damage to enemies touching barrier
          barrierHealAmount: 3 // Heals player per thorn hit
        },
        description: "Place root barriers that block enemies, deal thorn damage, and heal you"
      },
      Gunslinger: {
        icon: "üî´",
        color: "#FFD700",
        accent: "#FFA500",
        bulletColor: "#FFD700",
        glowColor: "#FFA500",
        unlockWave: 40,
        purchasable: false,
        stats: {
          maxHP: 100,
          damage: 12,
          fireRate: 0.4, // 2.5/sec - Fast dual guns
          range: 550,
          projectileSpeed: 10,
          dualGuns: true, // Fires from both guns
          ricochetOffWalls: true, // Ricochets off walls/floor
          maxRicochets: 2, // Bounces 2 times
          ricochetDamageMultiplier: 1.0 // Same damage on ricochet
        },
        description: "Dual guns fire rapidly, shots ricochet 2x off floor and walls"
      }
    };

    // BOSSES - Named bosses with unique mechanics
    const BOSSES = {
      BoneKnight: {
        name: "The Bone Knight",
        wave: 10,
        hp: 4000,
        damage: 20,
        attackRate: 2.2,
        speed: 0.8,
        size: 60,
        color: "#d3d3d3",
        icon: "üíÄ",
        reward: { type: "permanentHP", bonus: 0.05 }
      },
      HollowArcher: {
        name: "The Hollow Archer",
        wave: 20,
        hp: 5000,
        damage: 15,
        attackRate: 0.8,
        speed: 1.2,
        size: 55,
        color: "#8b4513",
        icon: "üèπ",
        reward: { type: "classUnlock", className: "Thief" }
      },
      FireBroodmother: {
        name: "The Fire Broodmother",
        wave: 30,
        hp: 6200,
        damage: 18,
        attackRate: 1.5,
        speed: 0.6,
        size: 70,
        color: "#ff4500",
        icon: "üï∑Ô∏è",
        reward: { type: "abilityPoint", amount: 1 }
      },
      FrostColossus: {
        name: "Frost Colossus",
        wave: 45,
        hp: 12000,
        damage: 25,
        attackRate: 2.0,
        speed: 0.5,
        size: 80,
        color: "#00bfff",
        icon: "‚ùÑÔ∏è",
        reward: { type: "classUnlock", className: "CryoSentinel" }
      },
      ChainReaper: {
        name: "The Chain Reaper",
        wave: 55,
        hp: 14000,
        damage: 35,
        attackRate: 1.8,
        speed: 1.0,
        size: 65,
        color: "#696969",
        icon: "‚õìÔ∏è",
        reward: { type: "currency", coins: 5000, gems: 200 }
      },
      ThunderHydra: {
        name: "Thunder Hydra",
        wave: 75,
        hp: 18000,
        damage: 15,
        attackRate: 1.5,
        speed: 0.7,
        size: 90,
        color: "#ffd700",
        icon: "üêâ",
        reward: { type: "classUnlock", className: "LightningRanger" }
      },
      CrystalTitan: {
        name: "Crystal Titan",
        wave: 85,
        hp: 20000,
        damage: 40,
        attackRate: 1.4,
        speed: 0.4,
        size: 85,
        color: "#9370db",
        icon: "üíé",
        reward: { type: "classUnlock", className: "CrystalGuardian" }
      },
      SpiritEmperor: {
        name: "The Spirit Emperor",
        wave: 100,
        hp: 30000,
        damage: 28,
        attackRate: 1.1,
        speed: 0.9,
        size: 75,
        color: "#00ffff",
        icon: "üëª",
        reward: { type: "currency", coins: 10000, gems: 500 }
      },
      VoidTyrant: {
        name: "The Void Tyrant",
        wave: 120,
        hp: 35000,
        damage: 55,
        attackRate: 2.2,
        speed: 0.6,
        size: 95,
        color: "#191970",
        icon: "üåë",
        reward: { type: "classUnlock", className: "VoidAssassin" }
      },
      BloodKing: {
        name: "The Blood King",
        wave: 135,
        hp: 38500,
        damage: 30,
        attackRate: 1.3,
        speed: 0.8,
        size: 70,
        color: "#8b0000",
        icon: "üëë",
        reward: { type: "permanentLifesteal", bonus: 0.05 }
      },
      ArcCelestial: {
        name: "The Arc Celestial",
        wave: 150,
        hp: 50000,
        damage: 42,
        attackRate: 1.0,
        speed: 1.0,
        size: 85,
        color: "#ff1493",
        icon: "‚≠ê",
        reward: { type: "classUnlock", className: "AstralGolem" }
      },
      ShadowMonarch: {
        name: "The Shadow Monarch",
        wave: 170,
        hp: 55000,
        damage: 48,
        attackRate: 0.9,
        speed: 1.1,
        size: 75,
        color: "#000000",
        icon: "üë§",
        reward: { type: "classUnlock", className: "ShadowMonk" }
      },
      EtheriumWarden: {
        name: "Etherium Warden",
        wave: 185,
        hp: 70000,
        damage: 60,
        attackRate: 1.7,
        speed: 0.5,
        size: 100,
        color: "#4169e1",
        icon: "‚ö°",
        reward: { type: "classUnlock", className: "ArcWarden" }
      },
      ChronoSeraph: {
        name: "The Chrono Seraph",
        wave: 200,
        hp: 100000,
        damage: 65,
        attackRate: 1.0,
        speed: 1.2,
        size: 90,
        color: "#ffd700",
        icon: "‚è∞",
        reward: { type: "permanentFireRate", bonus: 0.1 }
      },
      HeadThrower: {
        name: "The Head Thrower",
        wave: 15,
        hp: 8000,
        damage: 25,
        attackRate: 3.0,
        speed: 0.7,
        size: 65,
        color: "#ff6347",
        icon: "üéÉ",
        reward: { type: "currency", coins: 2000, gems: 50 }
      }
    };

    // SKILL TREES - Ultimate Abilities for Each Class
    const SKILL_TREES = {
      Hunter: {
        ultimate1: {
          name: "Sniper Shot",
          icon: "üéØ",
          desc: "Fire devastating cross-screen shot after 15 kills",
          cost: { coins: 5000, gems: 50 },
          activation: "kills",
          killRequirement: 15,
          cooldown: 30,
          damage: 500
        },
        ultimate2: {
          name: "Care Package",
          icon: "üì¶",
          desc: "Supply drop with potions (Q key)",
          cost: { coins: 10000, gems: 100 },
          activation: "manual",
          hotkey: "q",
          cooldown: 60
        }
      },
      Knight: {
        ultimate1: {
          name: "Shield Bash",
          icon: "üõ°Ô∏è",
          desc: "Charge forward, stunning enemies (Q key)",
          cost: { coins: 5000, gems: 50 },
          activation: "manual",
          hotkey: "q",
          cooldown: 20,
          damage: 100,
          stunDuration: 2
        },
        ultimate2: {
          name: "Last Stand",
          icon: "‚ö°",
          desc: "Invincible for 5s when HP < 20%",
          cost: { coins: 10000, gems: 100 },
          activation: "auto",
          duration: 5
        }
      },
      Archer: {
        ultimate1: {
          name: "Cupid's Bow",
          icon: "üíò",
          desc: "Next 5 shots convert enemies to allies (Q key)",
          cost: { coins: 5000, gems: 50 },
          activation: "manual",
          hotkey: "q",
          cooldown: 45,
          shotsRemaining: 5
        },
        ultimate2: {
          name: "Hook Shot",
          icon: "ü™ù",
          desc: "50% chance to root enemies in place (E key to toggle)",
          cost: { coins: 10000, gems: 100 },
          activation: "toggle",
          hotkey: "e",
          rootChance: 0.5,
          rootDuration: 3
        }
      },
      Thief: {
        ultimate1: {
          name: "Thief's Hand",
          icon: "ü§ö",
          desc: "Stuns all enemies, steals half their HP (Q key)",
          cost: { coins: 5000, gems: 50 },
          activation: "manual",
          hotkey: "q",
          cooldown: 60,
          stunDuration: 2
        },
        ultimate2: {
          name: "Phantom Clone",
          icon: "üë§",
          desc: "Create shadow clone that mirrors actions (E key)",
          cost: { coins: 10000, gems: 100 },
          activation: "manual",
          hotkey: "e",
          cooldown: 90,
          duration: 30,
          speedBoostOnDeath: 2.0,
          speedBoostDuration: 15
        }
      },
      Assassin: {
        ultimate1: {
          name: "Shadow Strike",
          icon: "üëª",
          desc: "Teleport behind enemy after 10 kills",
          cost: { coins: 5000, gems: 50 },
          activation: "kills",
          killRequirement: 10,
          cooldown: 25,
          damage: 300
        },
        ultimate2: {
          name: "Blade Storm",
          icon: "üåÄ",
          desc: "Spinning blades around player (Q key)",
          cost: { coins: 10000, gems: 100 },
          activation: "manual",
          hotkey: "q",
          cooldown: 45,
          duration: 5,
          damagePerSec: 50
        }
      },
      Wizard: {
        ultimate1: {
          name: "Meteor Storm",
          icon: "‚òÑÔ∏è",
          desc: "Rain 10 meteors from sky (Q key)",
          cost: { coins: 5000, gems: 50 },
          activation: "manual",
          hotkey: "q",
          cooldown: 40,
          count: 10,
          damage: 150
        },
        ultimate2: {
          name: "Time Freeze",
          icon: "‚ùÑÔ∏è",
          desc: "Freeze all enemies for 5s (E key)",
          cost: { coins: 10000, gems: 100 },
          activation: "manual",
          hotkey: "e",
          cooldown: 60,
          duration: 5
        }
      },
      Archer: {
        ultimate1: {
          name: "Arrow Barrage",
          icon: "üèπ",
          desc: "Fire 50 arrows in all directions after 20 kills",
          cost: { coins: 5000, gems: 50 },
          activation: "kills",
          killRequirement: 20,
          cooldown: 35,
          count: 50,
          damage: 30
        },
        ultimate2: {
          name: "Explosive Arrow",
          icon: "üí•",
          desc: "One massive explosive arrow (Q key)",
          cost: { coins: 10000, gems: 100 },
          activation: "manual",
          hotkey: "q",
          cooldown: 50,
          damage: 800,
          explosionRadius: 300
        }
      },
      Summoner: {
        ultimate1: {
          name: "Army of the Dead",
          icon: "üíÄ",
          desc: "Summon 10 skeletons instantly (Q key)",
          cost: { coins: 5000, gems: 50 },
          activation: "manual",
          hotkey: "q",
          cooldown: 70,
          count: 10
        },
        ultimate2: {
          name: "Sacrifice",
          icon: "üîÆ",
          desc: "Convert minions to shields (E key)",
          cost: { coins: 10000, gems: 100 },
          activation: "manual",
          hotkey: "e",
          cooldown: 40,
          shieldPerMinion: 30
        }
      },
      Bomber: {
        ultimate1: {
          name: "Nuke",
          icon: "‚ò¢Ô∏è",
          desc: "Massive screen explosion after 25 kills",
          cost: { coins: 5000, gems: 50 },
          activation: "kills",
          killRequirement: 25,
          cooldown: 80,
          damage: 1000
        },
        ultimate2: {
          name: "Chain Reaction",
          icon: "‚õìÔ∏è",
          desc: "Next 10 shots have 2x explosion radius (Q key)",
          cost: { coins: 10000, gems: 100 },
          activation: "manual",
          hotkey: "q",
          cooldown: 55,
          shotCount: 10
        }
      },
      Sniper: {
        ultimate1: {
          name: "Headhunter",
          icon: "üíÄ",
          desc: "Next 5 shots guaranteed 5x crits (Q key)",
          cost: { coins: 5000, gems: 50 },
          activation: "manual",
          hotkey: "q",
          cooldown: 35,
          shotCount: 5,
          critMultiplier: 5
        },
        ultimate2: {
          name: "Overwatch",
          icon: "üî≠",
          desc: "Auto-target highest HP enemy for 15s (E key)",
          cost: { coins: 10000, gems: 100 },
          activation: "manual",
          hotkey: "e",
          cooldown: 50,
          duration: 15
        }
      },
      Necromancer: {
        ultimate1: {
          name: "Plague",
          icon: "ü¶†",
          desc: "Poison all on-screen enemies (Q key)",
          cost: { coins: 5000, gems: 50 },
          activation: "manual",
          hotkey: "q",
          cooldown: 60,
          damagePerSec: 20,
          duration: 10
        },
        ultimate2: {
          name: "Soul Harvest",
          icon: "üëª",
          desc: "Heal from poison damage for 10s (E key)",
          cost: { coins: 10000, gems: 100 },
          activation: "manual",
          hotkey: "e",
          cooldown: 45,
          duration: 10
        }
      },
      Vecna: {
        ultimate1: {
          name: "Hive Mind",
          icon: "üëÅÔ∏è",
          desc: "Link all enemy HP - kill one, kill all (Q key)",
          cost: { coins: 50000, gems: 500 },
          activation: "manual",
          hotkey: "q",
          cooldown: 120,
          duration: 15
        },
        ultimate2: {
          name: "Vecna's Curse",
          icon: "üåÄ",
          desc: "Enter Upside Down: +50% dmg, 50% lifesteal (E key)",
          cost: { coins: 75000, gems: 750 },
          activation: "manual",
          hotkey: "e",
          cooldown: 90,
          duration: 20,
          damageBonus: 0.5,
          lifesteal: 0.5
        }
      },
      Engineer: {
        ultimate1: {
          name: "The Sentry",
          icon: "üî´",
          desc: "Deploy massive turret that shoots laser (50% of your HP damage) for 5s. Cooldown: 120 kills",
          cost: { coins: 15000, gems: 150 },
          activation: "kills",
          killRequirement: 120,
          cooldown: 0, // Reset by kills
          duration: 5,
          laserDamagePercent: 0.5 // 50% of player HP
        },
        ultimate2: {
          name: "The Protector",
          icon: "üõ°Ô∏è",
          desc: "Deploy shield turret that creates protective wall. Your shots slow enemies through it (E key)",
          cost: { coins: 20000, gems: 200 },
          activation: "manual",
          hotkey: "e",
          cooldown: 60,
          duration: 20,
          shieldRadius: 200,
          wallHP: 500,
          slowEffect: 0.5 // 50% slow
        }
      },
      TheForsakenOne: {
        ultimate1: {
          name: "Void Within",
          icon: "üåÄ",
          desc: "All random buffs activate at once for 5 seconds (Q key)",
          cost: { coins: 30000, gems: 300 },
          activation: "manual",
          hotkey: "q",
          cooldown: 30,
          duration: 5
        },
        ultimate2: {
          name: "Fractured Fate",
          icon: "üí•",
          desc: "Massive projectile that splits into 4 knockback fragments (E key)",
          cost: { coins: 40000, gems: 400 },
          activation: "manual",
          hotkey: "e",
          cooldown: 14,
          mainDamage: 100,
          fragmentDamage: 30,
          fragmentCount: 4,
          knockbackMultiplier: 2.0
        }
      }
    };

    // PERMANENT UPGRADES (Shop)
    const SHOP_UPGRADES = {
      damage: {
        name: "üí• Base Damage",
        desc: "Increase starting damage",
        maxLevel: 10,
        getBonus: (level) => level * 3,
        getCost: (level) => ({ coins: 50 + level * 30, gems: 0 })
      },
      health: {
        name: "‚ù§Ô∏è Base Health",
        desc: "Increase starting HP",
        maxLevel: 10,
        getBonus: (level) => level * 15,
        getCost: (level) => ({ coins: 40 + level * 25, gems: 0 })
      },
      fireRate: {
        name: "‚ö° Fire Rate",
        desc: "Shoot faster (reduces fire delay)",
        maxLevel: 5,
        getBonus: (level) => level * 0.05,
        getCost: (level) => ({ coins: 100 + level * 50, gems: level * 2 })
      },
      critChance: {
        name: "üí¢ Crit Chance",
        desc: "Start with critical hit chance",
        maxLevel: 5,
        getBonus: (level) => level * 0.05,
        getCost: (level) => ({ coins: 150 + level * 75, gems: level * 3 })
      },
      startLevel: {
        name: "‚≠ê Starting Level",
        desc: "Begin at higher level",
        maxLevel: 3,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 300 + level * 200, gems: level * 10 })
      },
      healStrength: {
        name: "‚ù§Ô∏è Heal Potion Strength",
        desc: "+20 HP restored per level",
        maxLevel: 5,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 100 + level * 50, gems: level * 2 })
      },
      shieldStrength: {
        name: "üõ°Ô∏è Shield Potion Strength",
        desc: "+25 shield per level",
        maxLevel: 5,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 100 + level * 50, gems: level * 2 })
      },
      effectStrength: {
        name: "üí• Effect Potion Strength",
        desc: "Boost crit/damage/speed potions",
        maxLevel: 5,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 150 + level * 75, gems: level * 3 })
      },
      dragonStrength: {
        name: "üêâ Dragon Beam Power",
        desc: "+20 damage per level",
        maxLevel: 5,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 200 + level * 100, gems: level * 5 })
      },
      startingHeals: {
        name: "‚ù§Ô∏è Starting Heal Potions",
        desc: "+1 heal potion at wave start",
        maxLevel: 3,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 150 + level * 75, gems: level * 3 })
      },
      startingShields: {
        name: "üõ°Ô∏è Starting Shield Potions",
        desc: "+1 shield potion at wave start",
        maxLevel: 3,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 150 + level * 75, gems: level * 3 })
      },
      startingOthers: {
        name: "‚ö° Starting Effect Potions",
        desc: "+1 to all effect potions",
        maxLevel: 3,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 200 + level * 100, gems: level * 5 })
      },
      potionGen: {
        name: "üçÄ Potion Generation",
        desc: "Boosts potion drops (scales with wave #)",
        maxLevel: 5,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 250 + level * 125, gems: level * 6 })
      },
      potionDamage: {
        name: "‚öîÔ∏è Potion Damage Bonus",
        desc: "+2 damage per potion held",
        maxLevel: 5,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 200 + level * 100, gems: level * 4 })
      },
      potionExplosion: {
        name: "üí£ Potion Explosion",
        desc: "30 damage to random enemy when using potion",
        maxLevel: 5,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 300 + level * 150, gems: level * 7 })
      }
    };

    // TEMPORARY UPGRADES (Level-up)
    const UPGRADE_TYPES = {
      damage: {
        icon: "‚öîÔ∏è",
        name: "Power Strike",
        desc: "Increase damage by 25%",
        apply: (player) => { player.damage *= 1.25; }
      },
      fireRate: {
        icon: "‚ö°",
        name: "Rapid Fire",
        desc: "Attack 20% faster",
        apply: (player) => { player.fireRate *= 0.8; }
      },
      hp: {
        icon: "‚ù§Ô∏è",
        name: "Vitality Boost",
        desc: "Gain +30 Max HP and heal fully",
        apply: (player) => { 
          player.maxHP += 30; 
          player.hp = player.maxHP; 
        }
      },
      range: {
        icon: "üéØ",
        name: "Extended Range",
        desc: "Increase attack range by 30%",
        apply: (player) => { player.range *= 1.3; }
      },
      projectileSpeed: {
        icon: "üöÄ",
        name: "Bullet Velocity",
        desc: "Projectiles fly 30% faster",
        apply: (player) => { player.projectileSpeed *= 1.3; }
      },
      multiShot: {
        icon: "üåü",
        name: "Multi-Shot",
        desc: "Fire +1 additional shot",
        apply: (player) => { 
          player.multiShot++; // Increment by 1 each time
        }
      },
      pierce: {
        icon: "üî±",
        name: "Piercing Shots",
        desc: "Projectiles pierce through enemies",
        apply: (player) => { player.pierce = true; }
      },
      lifesteal: {
        icon: "ü©∏",
        name: "Life Drain",
        desc: "Heal 15% of damage dealt",
        apply: (player) => { player.lifesteal = (player.lifesteal || 0) + 0.15; }
      },
      explosive: {
        icon: "üí•",
        name: "Explosive Rounds",
        desc: "Shots explode, damaging nearby enemies",
        apply: (player) => { player.explosive = true; }
      },
      criticalHit: {
        icon: "üí¢",
        name: "Critical Strike",
        desc: "20% chance to deal 2x damage",
        apply: (player) => { 
          player.critChance = (player.critChance || 0) + 0.2;
          player.critMultiplier = 2.0;
        }
      },
      shield: {
        icon: "üõ°Ô∏è",
        name: "Energy Shield",
        desc: "Gain a shield that absorbs 50 damage",
        apply: (player) => { 
          player.shield = (player.shield || 0) + 50;
          player.maxShield = (player.maxShield || 0) + 50;
        }
      },
      regeneration: {
        icon: "üíö",
        name: "Regeneration",
        desc: "Heal 2 HP per second",
        apply: (player) => { player.regen = (player.regen || 0) + 2; }
      },
      chainLightning: {
        icon: "‚ö°",
        name: "Chain Lightning",
        desc: "Damage chains to 2 nearby enemies",
        apply: (player) => { player.chainLightning = 2; }
      },
      damageAura: {
        icon: "üî•",
        name: "Flame Aura",
        desc: "Damage nearby enemies constantly",
        apply: (player) => { 
          player.aura = { damage: 3, radius: 80 };
        }
      },
      potionDamageBonus: {
        icon: "‚öîÔ∏è",
        name: "Potion Damage Bonus",
        desc: "+2 damage per potion held",
        apply: (player) => {
          gameData.potionUpgrades.potionDamage = (gameData.potionUpgrades.potionDamage || 0) + 1;
          saveGameData();
        }
      },
      potionExplosion: {
        icon: "üí£",
        name: "Potion Explosion",
        desc: "30 damage to random enemy when using potion",
        apply: (player) => {
          gameData.potionUpgrades.potionExplosion = (gameData.potionUpgrades.potionExplosion || 0) + 1;
          saveGameData();
        }
      },
      potionGeneration: {
        icon: "üçÄ",
        name: "Potion Generation",
        desc: "Boost potion drops (scales with wave)",
        apply: (player) => {
          gameData.potionUpgrades.potionGen = (gameData.potionUpgrades.potionGen || 0) + 1;
          saveGameData();
        }
      }
    };

    // ACHIEVEMENT UNLOCK REQUIREMENTS
    const ACHIEVEMENT_UNLOCKS = {
      freeze100: {
        title: "Freeze 100 Enemies",
        requirement: "üßä Freeze 100 enemies total",
        description: "Use ice-based abilities or upgrades to freeze enemies. Progress is saved across all runs.",
        icon: "‚ùÑÔ∏è"
      },
      defeat3Elites: {
        title: "Defeat 3 Elite Enemies",
        requirement: "üíÄ Defeat 3 elite enemies (mini-bosses or bosses)",
        description: "Elite enemies appear every 5 waves (mini-bosses) and every 10 waves (bosses). Kill 3 total.",
        icon: "ü©∏"
      },
      collect5ArcCores: {
        title: "Collect 5 Arc Cores",
        requirement: "‚ö° Collect 5 Arc Cores from enemies",
        description: "Arc Cores are rare drops from electric-type enemies. Look for glowing blue orbs.",
        icon: "‚ö°"
      },
      heal1000HP: {
        title: "Heal 1000 Total HP",
        requirement: "üíö Heal 1000 HP across all runs",
        description: "Use heal potions, lifesteal, regeneration upgrades. All healing counts toward this total.",
        icon: "‚úùÔ∏è"
      },
      fallingStarDrop: {
        title: "Find a Falling Star",
        requirement: "üåü Obtain a rare Falling Star drop",
        description: "Extremely rare random drop from any enemy. Higher waves = slightly better chance.",
        icon: "üåü"
      },
      kill100In10Sec: {
        title: "Kill 100 in 10 Seconds",
        requirement: "‚öîÔ∏è Kill 100 enemies within 10 seconds",
        description: "Use AoE classes (Bomber, Necromancer) on high-wave swarms. Requires explosive damage!",
        icon: "üåë"
      },
      rejectAllPowerups: {
        title: "The Forsaken Challenge",
        requirement: "üíÄ Reject ALL powerups and reach Wave 11",
        description: "Don't choose ANY level-up upgrades. Don't use ANY potions. Survive to Wave 11 without help!",
        icon: "üíÄ"
      }
    };

    // BOSS PATTERNS
    const BOSS_PATTERNS = [
      {
        name: "The Charger",
        color: "#ff00ff",
        pattern: "charge", // Speeds up periodically
        speed: 0.8,
        attackInterval: 2,
        specialAbility: "Speed Burst"
      },
      {
        name: "The Sniper",
        color: "#ff4444",
        pattern: "ranged", // Shoots multiple projectiles
        speed: 0.5,
        attackInterval: 3,
        specialAbility: "Triple Shot"
      },
      {
        name: "The Tank",
        color: "#4444ff",
        pattern: "tank", // Extra HP and shield
        speed: 0.6,
        attackInterval: 2.5,
        specialAbility: "Shield Regen"
      },
      {
        name: "The Summoner",
        color: "#88ff88",
        pattern: "summon", // Spawns extra enemies
        speed: 0.7,
        attackInterval: 4,
        specialAbility: "Spawn Minions"
      },
      {
        name: "The Berserker",
        color: "#ff8800",
        pattern: "berserk", // Gets faster as HP lowers
        speed: 0.9,
        attackInterval: 1.5,
        specialAbility: "Rage Mode"
      },
      {
        name: "The Headless",
        color: "#8B0000",
        pattern: "headthrow", // Throws its head as projectile
        speed: 0.7,
        attackInterval: 3,
        specialAbility: "Head Throw"
      }
    ];

    // GAME STATE
    let keys = {};
    window.keys = keys; // Make accessible for sprite animation
    let lastTime = 0;
    let gameRunning = false;
    let screenShake = 0;
    let gameState = "playing";
    let gamePaused = false;
    let brightnessLevel = 1.0;
    let volumeLevel = 1.0;
    let roundBreakTimer = 0;

    // SPRITE SYSTEM
    const characterSprites = {};
    let spritesLoaded = false;
    const SPRITE_MAP = {
      'Hunter': 'hunter',
      'Knight': 'knight',
      'Archer': 'archer',
      'Thief': 'thief',
      'Mage': null, // Need sprite
      'Pyromancer': 'pyromancer',
      'Frostmage': 'frostmage',
      'Tank': 'tank',
      'Berserk': null, // Need sprite
      'Paladin': 'healer',
      'Ninja': 'ninja',
      'Bomber': 'bomber',
      'Sniper': 'sniper',
      'Samurai': null, // Need sprite
      'Monk': 'monk',
      'Warlock': null, // Need sprite
      'Druid': null, // Need sprite
      'Assassin': 'assassin',
      'Summoner': 'summoner',
      'Gunslinger': null, // Need sprite
      'DarkMagician': 'dark_magician',
      'Ranger': null, // Need sprite
      'Necromancer': 'necromancer',
      'Vecna': 'vecna',
      'Engineer': 'engineer',
      'TheForsakenOne': null // Need sprite
    };

    let player = null;
    let enemies = [];
    let projectiles = [];
    let minions = [];
    let particles = [];
    let floatingTexts = [];
    let currencyDrops = [];

    let shootTimer = 0;
    let wave = 1;
    let enemiesToSpawn = 0;
    let spawnTimer = 0;
    let autoShoot = true;
    let autoAim = true;
    let autoStartWave = false; // Auto-start next wave when ready
    let gameSpeed = 1; // Game speed multiplier (1 = normal, 2 = 2x, 3 = 3x)
    let combo = 0;
    let comboTimer = 0;
    let maxCombo = 0;
    
    let sessionCoins = 0;
    let sessionGems = 0;
    
    // Game over countdown
    let gameOverCountdownInterval = null;
    
    // New features
    let shufflesRemaining = 4; // Shuffle counter for upgrades
    let currentMap = 1; // Map tracking
    let mapsCompleted = 0;
    let enemiesKilled = 0; // Track kills for stats
    let waveTimer = 0; // Timer for next wave (30s after last spawn)
    let waveTimerActive = false; // Is wave timer counting down?
    let shieldUpgradesChosen = 0; // Track shield upgrades for Guardian Tank unlock
    
    // Dragon beam fire zones
    let fireZones = [];
    
    // New BTD-style mechanic zones
    let poisonClouds = [];
    let iceShards = [];
    let turrets = [];
    let rootBarriers = [];
    let helperStars = [];
    
    // BTD-Style Upgrade Tree System
    let upgradePoints = 0;
    let purchasedUpgrades = {
      pathA: [],
      pathB: [],
      pathC: []
    };
    
    // Universal Upgrade Tree (works for all classes)
    const UPGRADE_TREE = {
      pathA: [ // Attack/Damage Path
        {
          id: 'damage1',
          tier: 1,
          name: 'Enhanced Damage',
          desc: '+15% damage',
          cost: 1,
          effect: (player) => { player.damage *= 1.15; }
        },
        {
          id: 'damage2',
          tier: 2,
          name: 'Superior Firepower',
          desc: '+25% damage, +10% fire rate',
          cost: 1,
          requires: ['damage1'],
          effect: (player) => { player.damage *= 1.25; player.fireRate *= 0.90; }
        },
        {
          id: 'damage3',
          tier: 3,
          name: 'Devastating Force',
          desc: '+40% damage, all shots pierce once',
          cost: 1,
          requires: ['damage2'],
          effect: (player) => { player.damage *= 1.40; player.pierce = true; }
        },
        {
          id: 'masterA',
          tier: 4,
          name: '‚≠ê ASSASSIN MASTER',
          desc: '+100% crit damage, 25% crit chance, every 5th shot guaranteed crit',
          cost: 2,
          requires: ['damage3'],
          master: true,
          effect: (player) => { 
            player.critMultiplier = 2.0;
            player.critChance = Math.max(player.critChance, 0.25);
            player.masterClass = 'Assassin';
          }
        }
      ],
      pathB: [ // Defense/Survival Path
        {
          id: 'health1',
          tier: 1,
          name: 'Fortified Health',
          desc: '+40 max HP',
          cost: 1,
          effect: (player) => { player.maxHP += 40; player.hp += 40; }
        },
        {
          id: 'health2',
          tier: 2,
          name: 'Shield Generator',
          desc: '+50 max HP, +75 max shield, gain 50 shield',
          cost: 1,
          requires: ['health1'],
          effect: (player) => { 
            player.maxHP += 50;
            player.hp += 50;
            player.maxShield += 75;
            player.shield += 75;
          }
        },
        {
          id: 'health3',
          tier: 3,
          name: 'Regeneration Field',
          desc: '+60 max HP, regenerate 5 HP/sec',
          cost: 1,
          requires: ['health2'],
          effect: (player) => { 
            player.maxHP += 60;
            player.hp += 60;
            player.regen = (player.regen || 0) + 5;
          }
        },
        {
          id: 'masterB',
          tier: 4,
          name: '‚≠ê GUARDIAN MASTER',
          desc: '+100 max HP, +150 max shield, 50% lifesteal, immune to first fatal hit per wave',
          cost: 2,
          requires: ['health3'],
          master: true,
          effect: (player) => { 
            player.maxHP += 100;
            player.hp += 100;
            player.maxShield += 150;
            player.shield += 150;
            player.lifesteal = Math.max(player.lifesteal, 0.50);
            player.lastStandActive = true;
            player.masterClass = 'Guardian';
          }
        }
      ],
      pathC: [ // Utility/Special Path
        {
          id: 'utility1',
          tier: 1,
          name: 'Rapid Fire',
          desc: '+25% fire rate',
          cost: 1,
          effect: (player) => { player.fireRate *= 0.75; }
        },
        {
          id: 'utility2',
          tier: 2,
          name: 'Multishot',
          desc: '+30% fire rate, shoot 1 additional projectile',
          cost: 1,
          requires: ['utility1'],
          effect: (player) => { 
            player.fireRate *= 0.70;
            player.multiShot = (player.multiShot || 0) + 1;
          }
        },
        {
          id: 'utility3',
          tier: 3,
          name: 'Chain Lightning',
          desc: 'Shots chain to 3 nearby enemies at 60% damage',
          cost: 1,
          requires: ['utility2'],
          effect: (player) => { 
            player.chainLightning = 3;
          }
        },
        {
          id: 'masterC',
          tier: 4,
          name: '‚≠ê ARCHMAGE MASTER',
          desc: 'All projectiles explode in 150 radius, chains to 5 enemies, +50% range',
          cost: 2,
          requires: ['utility3'],
          master: true,
          effect: (player) => { 
            player.explosive = true;
            player.explosionRadius = 150;
            player.chainLightning = 5;
            player.range *= 1.5;
            player.masterClass = 'Archmage';
          }
        }
      ]
    };
    
    // Potion system
    let potions = {
      heal: 3,
      shield: 2,
      crit: 1,
      damage: 1,
      speed: 1,
      dragon: 1
    };
    
    let potionCooldowns = {
      heal: 0,
      shield: 0,
      crit: 0,
      damage: 0,
      speed: 0,
      dragon: 0
    };
    
    let potionEffects = {
      critActive: false,
      critTimer: 0,
      damageActive: false,
      damageTimer: 0,
      speedActive: false,
      speedTimer: 0
    };

    // ABILITY SYSTEM
    let ability1Cooldown = 0;
    let ability2Cooldown = 0;
    let ability1KillCounter = 0;
    let ability2KillCounter = 0;
    let ability1Active = false;
    let ability2Active = false;
    
    // Special ability states
    let lastStandUsed = false;
    let chainReactionShots = 0;
    let headhunterShots = 0;
    let overwatchActive = false;
    let overwatchTimer = 0;
    let bladeStormActive = false;
    let bladeStormTimer = 0;
    let soulHarvestActive = false;
    let soulHarvestTimer = 0;
    let timeFreezeActive = false;
    let timeFreezeTimer = 0;
    
    // Vecna special states
    let hiveMindActive = false;
    let hiveMindTimer = 0;
    let upsideDownActive = false;
    let upsideDownTimer = 0;
    let vecnaKillCounter = 0;
    let vecnaMonsters = [];
    let vecnaMonsterKillCounter = 0;
    let convertedEnemies = [];
    
    // Archer special states
    let cupidsBowActive = false;
    let cupidsBowShots = 0;
    let hookShotActive = false;
    
    // Thief special states
    let phantomClone = null;
    let phantomSpeedBoost = false;
    let phantomSpeedBoostTimer = 0;

    // Initialize
    loadGameData();
    updateShopDisplay();
    updateTitleScreenDisplay();
    
    // Ensure correct initial screen state
    titleScreen.classList.remove("hidden");
    classSelection.classList.remove("active");
    shopScreen.classList.remove("active");
    tutorialScreen.style.display = "none";
    roundBreakScreen.classList.remove("active");
    gameOverScreen.classList.remove("active");
    upgradeScreen.classList.remove("active");

    // EVENT LISTENERS
    startBtn.addEventListener("click", () => {
      titleScreen.classList.add("hidden");
      showClassSelection();
    });

    shopBtn.addEventListener("click", () => {
      titleScreen.classList.add("hidden");
      showShop();
    });
    
    waveSelectBtn.addEventListener("click", () => {
      titleScreen.classList.add("hidden");
      showWaveSelect();
    });
    
    evolAuraBtn.addEventListener("click", () => {
      titleScreen.classList.add("hidden");
      showEvolAura();
    });

    shopBackBtn.addEventListener("click", () => {
      shopScreen.classList.remove("active");
      titleScreen.classList.remove("hidden");
    });
    
    auraBackBtn.addEventListener("click", () => {
      document.getElementById('evolAuraScreen').style.display = 'none';
      titleScreen.classList.remove("hidden");
    });
    
    tutorialBtn.addEventListener("click", () => {
      titleScreen.classList.add("hidden");
      tutorialScreen.style.display = "flex";
    });
    
    tutorialBackBtn.addEventListener("click", () => {
      tutorialScreen.style.display = "none";
      titleScreen.classList.remove("hidden");
    });
    
    // Unlock modal close button
    unlockModalClose.addEventListener("click", () => {
      closeUnlockModal();
    });
    
    // Close modal when clicking the backdrop (not the content)
    unlockModal.addEventListener("click", (e) => {
      // If click is directly on the modal backdrop (not bubbled from content), close it
      if (e.target === unlockModal) {
        closeUnlockModal();
      }
    });
    
    // Potion click handlers
    document.getElementById('potionHeal').addEventListener('click', () => usePotion('heal'));
    document.getElementById('potionShield').addEventListener('click', () => usePotion('shield'));
    document.getElementById('potionCrit').addEventListener('click', () => usePotion('crit'));
    document.getElementById('potionDamage').addEventListener('click', () => usePotion('damage'));
    document.getElementById('potionSpeed').addEventListener('click', () => usePotion('speed'));
    document.getElementById('potionDragon').addEventListener('click', () => usePotion('dragon'));
    
    // Ability button click handlers
    document.getElementById('ability1Btn').addEventListener('click', () => activateAbility1());
    document.getElementById('ability2Btn').addEventListener('click', () => activateAbility2());
    
    // Canvas click handler for placeable abilities
    canvas.addEventListener('click', (e) => {
      if (!player || !player.alive || gameState !== "playing") return;
      
      const rect = canvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      
      const classStats = CLASSES[player.class]?.stats || {};
      
      // Plague Doctor - Place poison cloud
      if (classStats.placeableClouds && poisonClouds.length < classStats.maxClouds) {
        poisonClouds.push({
          x: clickX,
          y: clickY,
          radius: classStats.cloudRadius,
          life: classStats.cloudDuration,
          poisonDPS: classStats.cloudPoisonDPS,
          slowAmount: classStats.cloudSlowAmount,
          confusionChance: classStats.cloudConfusionChance,
          stunChance: classStats.cloudStunChance
        });
        addFloatingText(clickX, clickY, "‚ò†Ô∏è POISON CLOUD", "#32cd32");
      }
      
      // Engineer - Place turret
      if (classStats.turretClass && turrets.length < classStats.maxTurrets) {
        turrets.push({
          x: clickX,
          y: clickY,
          hp: classStats.turretHP,
          damage: classStats.turretDamage,
          range: classStats.turretRange,
          fireRate: classStats.turretFireRate,
          shootTimer: 0
        });
        addFloatingText(clickX, clickY, "üîß TURRET", "#FF8C00");
      }
      
      // Druid - Place root barrier
      if (classStats.rootBarriers && rootBarriers.length < classStats.maxBarriers) {
        rootBarriers.push({
          x: clickX,
          y: clickY,
          hp: classStats.barrierHP,
          thornDamage: classStats.barrierThornDamage,
          healAmount: classStats.barrierHealAmount
        });
        addFloatingText(clickX, clickY, "üåø ROOT BARRIER", "#228B22");
      }
    });
    
    // Pause menu button listeners
    document.getElementById('resumeBtn').addEventListener('click', () => {
      togglePause();
    });
    
    document.getElementById('returnLobbyBtn').addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      console.log('üè† Return Home button clicked - returning immediately');
      
      // IMMEDIATELY stop everything
      gameRunning = false;
      gamePaused = false;
      gameState = "title";
      
      // Get pause menu element
      const pauseMenu = document.getElementById('pauseMenu');
      
      // COMPLETELY HIDE pause menu
      pauseMenu.classList.remove('active');
      pauseMenu.style.display = 'none';
      pauseMenu.style.visibility = 'hidden';
      pauseMenu.style.opacity = '0';
      pauseMenu.style.zIndex = '-100';
      pauseMenu.style.pointerEvents = 'none';
      
      // COMPLETELY HIDE canvas
      canvas.style.display = 'none';
      canvas.style.visibility = 'hidden';
      canvas.style.opacity = '0';
      canvas.style.zIndex = '-100';
      canvas.style.pointerEvents = 'none';
      
      // Hide ALL other screens
      document.getElementById('classSelection').classList.remove('active');
      document.getElementById('shopScreen').classList.remove('active');
      document.getElementById('gameOverScreen').classList.remove('active');
      document.getElementById('upgradeScreen').classList.remove('active');
      document.getElementById('roundBreakScreen').classList.remove('active');
      document.getElementById('tutorialScreen').style.display = 'none';
      document.getElementById('evolAuraScreen').style.display = 'none';
      
      // SHOW title screen - remove hidden class, clear ALL inline styles
      titleScreen.classList.remove('hidden');
      titleScreen.removeAttribute('style'); // Remove ALL inline styles completely!
      
      // Force reflow to ensure browser processes changes
      void titleScreen.offsetHeight;
      
      // Use setTimeout to ensure browser has processed everything
      setTimeout(() => {
        // Double-check title screen is visible
        if (titleScreen.classList.contains('hidden')) {
          titleScreen.classList.remove('hidden');
        }
        
        // Ensure canvas is still hidden
        canvas.style.display = 'none';
        
        console.log('‚úÖ Title screen forced visible after delay');
      }, 50);
      
      // Then do cleanup
      returnToHome();
      
      console.log('‚úÖ Returned to home screen - fully visible!');
      console.log('   Canvas display:', canvas.style.display);
      console.log('   Title screen classes:', titleScreen.className);
    });
    
    document.getElementById('brightnessSlider').addEventListener('input', (e) => {
      setBrightness(e.target.value);
    });
    
    document.getElementById('volumeSlider').addEventListener('input', (e) => {
      setVolume(e.target.value);
    });

    window.addEventListener("keydown", (e) => {
      keys[e.key] = true;
      
      // ESC to pause/unpause - ALWAYS works when playing
      if (e.key === "Escape" && gameState === "playing") {
        e.preventDefault();
        console.log('üéÆ ESC pressed - toggling pause');
        console.log('   Current gamePaused:', gamePaused);
        togglePause();
        console.log('   New gamePaused:', gamePaused);
        return;
      }
      
      if (e.key === " " || e.code === "Space") {
        e.preventDefault();
        if (gameState === "roundBreak") {
          endRoundBreak();
        } else if (waveTimerActive && waveTimer <= 0 && !autoStartWave) {
          // Manually start next wave
          wave++;
          waveTimerActive = false;
          
          // Check for map progression (every 20 waves)
          if (wave % 20 === 1 && wave > 1) {
            currentMap++;
            mapsCompleted++;
            shufflesRemaining = 4;
            addFloatingText(canvas.width / 2, 200, `üó∫Ô∏è MAP ${currentMap} üó∫Ô∏è`, "#ff00ff");
            addFloatingText(canvas.width / 2, 230, "SHUFFLES RESET!", "#00ffff");
            screenShake += 15;
          }
          
          // Give wave bonus XP
          const waveBonus = 50 + wave * 10;
          giveXP(waveBonus);
          addFloatingText(canvas.width / 2, 150, "WAVE " + wave + " START!", "#00ffff");
          
          // Potions DO NOT reset - Summoner ability only!
          
          // Reset Last Stand for new wave
          lastStandUsed = false;
          
          // Start next wave
          enemiesToSpawn = calcEnemiesForWave(wave);
          spawnTimer = 0;
          
          // Spawn boss/mini-boss immediately if applicable
          if (wave % 10 === 0) {
            spawnEnemy(true, false);
            enemiesToSpawn--;
          } else if (wave % 5 === 0) {
            spawnEnemy(false, true);
            enemiesToSpawn--;
          }
        }
      }
      if (e.key === "t" || e.key === "T") {
        autoShoot = !autoShoot;
      }
      if (e.key === "y" || e.key === "Y") {
        autoAim = !autoAim;
      }
      if (e.key === "r" || e.key === "R") {
        autoStartWave = !autoStartWave;
        addFloatingText(canvas.width / 2, 150, autoStartWave ? "Auto-Start: ON" : "Auto-Start: OFF", autoStartWave ? "#00ff00" : "#ff0000");
      }
      if (e.key === "f" || e.key === "F") {
        gameSpeed = gameSpeed === 1 ? 2 : 1; // Toggle between 1x and 2x
        addFloatingText(canvas.width / 2, 180, "Game Speed: " + gameSpeed + "x", gameSpeed === 2 ? "#ff8800" : "#ffffff");
      }
      
      // Potion hotkeys
      if (e.key === "1") usePotion('heal');
      if (e.key === "2") usePotion('shield');
      if (e.key === "3") usePotion('crit');
      if (e.key === "4") usePotion('damage');
      if (e.key === "5") usePotion('speed');
      if (e.key === "6") usePotion('dragon');
      
      // Ability hotkeys
      if ((e.key === "q" || e.key === "Q") && gameState === "playing") {
        activateAbility1();
      }
      if ((e.key === "e" || e.key === "E") && gameState === "playing") {
        activateAbility2();
      }
    });
    
    window.addEventListener("keyup", (e) => {
      keys[e.key] = false;
    });

    // CLASS SELECTION
    function showClassSelection() {
      classSelection.classList.add("active");
      classSelection.scrollTop = 0; // Scroll to top!
      classGrid.innerHTML = "";
      
      // Debug logging
      console.log(`üéÆ Class Selection Screen`);
      console.log(`  Highest Wave: ${gameData.highestWave}`);
      console.log(`  Unlocked Classes:`, gameData.unlockedClasses);
      console.log(`  Purchased Classes:`, gameData.purchasedClasses);
      
      Object.entries(CLASSES).forEach(([className, classData]) => {
        const card = document.createElement("div");
        card.className = "class-card";
        
        let isUnlocked = false;
        let lockReason = "";
        let hasAchievementUnlock = false;
        let achievementKey = "";
        
        // Check if it's a challenge unlock (The Forsaken One)
        if (classData.challengeUnlock) {
          achievementKey = classData.challengeUnlock;
          hasAchievementUnlock = true;
          isUnlocked = gameData.unlockedClasses.includes(className);
          if (!isUnlocked) {
            lockReason = `üîí Complete Challenge`;
          }
        }
        // Check if it's an achievement unlock
        else if (classData.achievementUnlock) {
          achievementKey = classData.achievementUnlock;
          hasAchievementUnlock = true;
          isUnlocked = gameData.unlockedClasses.includes(className);
          if (!isUnlocked) {
            lockReason = `üèÜ Complete Achievement`;
          }
        }
        // Purchasable class
        else if (classData.purchasable) {
          isUnlocked = gameData.purchasedClasses.includes(className);
          if (!isUnlocked) {
            lockReason = `üí∞ ${classData.cost.coins} coins, üíé ${classData.cost.gems} gems`;
          }
        }
        // Wave-unlock class
        else {
          isUnlocked = gameData.unlockedClasses.includes(className);
          if (!isUnlocked && gameData.highestWave < classData.unlockWave) {
            lockReason = `Unlock at Wave ${classData.unlockWave}`;
          }
          
          // Debug Thief specifically
          if (className === "Thief") {
            console.log(`ü•∑ THIEF STATUS:`);
            console.log(`  - Unlock Wave Required: ${classData.unlockWave}`);
            console.log(`  - Your Highest Wave: ${gameData.highestWave}`);
            console.log(`  - In unlockedClasses array: ${gameData.unlockedClasses.includes(className)}`);
            console.log(`  - isUnlocked: ${isUnlocked}`);
            console.log(`  - lockReason: ${lockReason}`);
          }
        }
        
        const isLocked = !isUnlocked;
        
        if (isLocked) {
          card.classList.add("locked");
        }
        
        card.innerHTML = `
          <div class="class-icon">${classData.icon}</div>
          <div class="class-name" style="color: ${classData.color}">${className}</div>
          <div class="class-stats">
            HP: ${classData.stats.maxHP}<br>
            DMG: ${classData.stats.damage}<br>
            ${classData.description}
          </div>
          ${isLocked ? `<div class="class-unlock">${lockReason}</div>` : ""}
          ${classData.purchasable && isLocked ? '<div class="class-unlock" style="color: #00ff00; margin-top: 5px;">Available in Shop!</div>' : ""}
          ${isLocked ? '<div class="class-unlock" style="color: #ffff00; margin-top: 5px; cursor: pointer;">üìã Click for details</div>' : ""}
        `;
        
        if (!isLocked) {
          card.onclick = () => selectClass(className);
        } else {
          // ALL locked classes show unlock requirements when clicked or hovered
          card.style.cursor = "pointer";
          card.onclick = () => showUnlockRequirements(className, classData, achievementKey, lockReason);
          card.title = "Click to see unlock requirements";
        }
        
        classGrid.appendChild(card);
      });
    }

    // WAVE SELECTION FUNCTIONS
    let selectedStartingWave = 1; // Track which wave player wants to start from
    
    function showWaveSelect() {
      const waveScreen = document.getElementById('waveSelectionScreen');
      const highestDisplay = document.getElementById('highestWaveDisplay');
      const waveGrid = document.getElementById('waveGrid');
      
      // Update highest wave display
      highestDisplay.textContent = gameData.highestWave;
      
      // Clear and populate wave grid
      waveGrid.innerHTML = '';
      
      // Create buttons for each unlocked wave
      gameData.unlockedWaves.sort((a, b) => a - b); // Sort waves in order
      
      for (let w of gameData.unlockedWaves) {
        const btn = document.createElement('button');
        btn.className = 'wave-select-btn';
        btn.innerHTML = `
          <div style="font-size: 32px; font-weight: bold; color: #00ffff; margin-bottom: 5px;">
            Wave ${w}
          </div>
          <div style="font-size: 12px; color: #aaa;">
            ${w === 1 ? 'Start' : 'Skip to'}
          </div>
        `;
        btn.style.cssText = `
          padding: 20px;
          background: linear-gradient(135deg, #1a3a5a, #2a1a5a);
          border: 2px solid #00ffff;
          border-radius: 10px;
          color: white;
          cursor: pointer;
          transition: all 0.3s;
          font-family: 'Orbitron', monospace;
        `;
        
        // Hover effects
        btn.onmouseenter = () => {
          btn.style.transform = 'scale(1.1)';
          btn.style.boxShadow = '0 0 25px rgba(0,255,255,0.6)';
          btn.style.borderColor = '#ffff00';
        };
        btn.onmouseleave = () => {
          btn.style.transform = 'scale(1)';
          btn.style.boxShadow = 'none';
          btn.style.borderColor = '#00ffff';
        };
        
        btn.onclick = () => startFromWave(w);
        
        waveGrid.appendChild(btn);
      }
      
      // Show the screen
      waveScreen.style.display = 'block';
    }
    
    function closeWaveSelect() {
      const waveScreen = document.getElementById('waveSelectionScreen');
      waveScreen.style.display = 'none';
    }
    
    function startFromWave(startWave) {
      selectedStartingWave = startWave;
      closeWaveSelect();
      showClassSelection(); // Go to class selection with selected wave
    }

    function selectClass(className) {
      classSelection.classList.remove("active");
      startGame(className, selectedStartingWave); // Pass starting wave
      selectedStartingWave = 1; // Reset for next time
    }

    function showUnlockRequirements(className, classData, achievementKey, lockReason) {
      // Set icon and title
      unlockModalIcon.textContent = classData.icon;
      unlockModalTitle.textContent = className;
      
      // Check what type of unlock this class has
      if (achievementKey && ACHIEVEMENT_UNLOCKS[achievementKey]) {
        // Achievement-locked class (like The Forsaken One)
        const unlockInfo = ACHIEVEMENT_UNLOCKS[achievementKey];
        unlockModalRequirement.innerHTML = `<strong>${unlockInfo.requirement}</strong>`;
        unlockModalDesc.textContent = unlockInfo.description;
      } else if (classData.challengeUnlock) {
        // Challenge unlock without defined achievement info
        unlockModalRequirement.innerHTML = "üîí <strong>Complete Special Challenge</strong>";
        unlockModalDesc.textContent = "This class requires completing a special achievement or challenge.";
      } else if (classData.purchasable) {
        // Purchasable class
        unlockModalRequirement.innerHTML = `üí∞ <strong>${classData.cost.coins} Coins</strong><br>üíé <strong>${classData.cost.gems} Gems</strong>`;
        unlockModalDesc.textContent = `This class can be purchased in the Shop! Go to the main menu and click the Shop button to unlock ${className}.`;
      } else if (classData.unlockWave) {
        // Wave-unlock class
        const wavesNeeded = classData.unlockWave - gameData.highestWave;
        if (wavesNeeded > 0) {
          unlockModalRequirement.innerHTML = `üåä <strong>Reach Wave ${classData.unlockWave}</strong>`;
          unlockModalDesc.textContent = `You need to reach wave ${classData.unlockWave} with any class to unlock ${className}. You're currently at wave ${gameData.highestWave} (${wavesNeeded} more wave${wavesNeeded > 1 ? 's' : ''} to go!).`;
        } else {
          unlockModalRequirement.innerHTML = `üåä <strong>Wave ${classData.unlockWave} Unlocked!</strong>`;
          unlockModalDesc.textContent = `You've reached wave ${classData.unlockWave}! This class is now unlocked. Start a new game to play as ${className}!`;
        }
      } else {
        // Fallback for unknown unlock type
        unlockModalRequirement.innerHTML = lockReason || "üîí <strong>Class Locked</strong>";
        unlockModalDesc.textContent = `Keep playing to unlock ${className}!`;
      }
      
      // Show the modal
      unlockModal.classList.add("active");
    }

    function closeUnlockModal() {
      unlockModal.classList.remove("active");
    }

    // SHOP
    function showShop() {
      shopScreen.classList.add("active");
      updateShopDisplay();
    }

    function updateShopDisplay() {
      shopGrid.innerHTML = "";
      shopCoins.textContent = gameData.totalCoins;
      shopGems.textContent = gameData.totalGems;
      
      // Update currency exchange displays
      const coinsDisplay2 = document.getElementById('shopCoinsDisplay2');
      const gemsDisplay2 = document.getElementById('shopGemsDisplay2');
      if (coinsDisplay2) coinsDisplay2.textContent = gameData.totalCoins;
      if (gemsDisplay2) gemsDisplay2.textContent = gameData.totalGems;
      
      // PURCHASABLE CLASSES SECTION
      const classesHeader = document.createElement("div");
      classesHeader.style.gridColumn = "1 / -1";
      classesHeader.style.fontSize = "24px";
      classesHeader.style.color = "#ff00ff";
      classesHeader.style.fontWeight = "bold";
      classesHeader.style.marginTop = "10px";
      classesHeader.style.marginBottom = "10px";
      classesHeader.textContent = "üéØ UNLOCK CLASSES";
      shopGrid.appendChild(classesHeader);
      
      Object.entries(CLASSES).forEach(([className, classData]) => {
        if (!classData.purchasable) return;
        
        const isPurchased = gameData.purchasedClasses.includes(className);
        
        const card = document.createElement("div");
        card.className = "shop-item";
        if (isPurchased) card.classList.add("maxed");
        
        card.innerHTML = `
          <div class="shop-item-name">${classData.icon} ${className}</div>
          <div class="shop-item-desc">${classData.description}</div>
          <div class="shop-item-level">HP: ${classData.stats.maxHP} | DMG: ${classData.stats.damage}</div>
          ${!isPurchased ? `
            <div class="shop-item-cost">
              üí∞ ${classData.cost.coins} | üíé ${classData.cost.gems}
            </div>
          ` : '<div class="shop-item-cost" style="color: #00ff00;">‚úÖ OWNED</div>'}
        `;
        
        if (!isPurchased) {
          card.onclick = () => purchaseClass(className);
        }
        
        shopGrid.appendChild(card);
      });
      
      // PERMANENT UPGRADES SECTION
      const upgradesHeader = document.createElement("div");
      upgradesHeader.style.gridColumn = "1 / -1";
      upgradesHeader.style.fontSize = "24px";
      upgradesHeader.style.color = "#ffff00";
      upgradesHeader.style.fontWeight = "bold";
      upgradesHeader.style.marginTop = "20px";
      upgradesHeader.style.marginBottom = "10px";
      upgradesHeader.textContent = "‚¨ÜÔ∏è PERMANENT UPGRADES";
      shopGrid.appendChild(upgradesHeader);
      
      const permanentUpgradeKeys = ['damage', 'health', 'fireRate', 'critChance', 'startLevel'];
      permanentUpgradeKeys.forEach((key) => {
        const upgrade = SHOP_UPGRADES[key];
        const currentLevel = gameData.permanentUpgrades[key];
        const isMaxed = currentLevel >= upgrade.maxLevel;
        const cost = isMaxed ? null : upgrade.getCost(currentLevel);
        const bonus = upgrade.getBonus(currentLevel);
        const nextBonus = isMaxed ? 0 : upgrade.getBonus(currentLevel + 1);
        
        const card = document.createElement("div");
        card.className = "shop-item";
        if (isMaxed) card.classList.add("maxed");
        
        card.innerHTML = `
          <div class="shop-item-name">${upgrade.name}</div>
          <div class="shop-item-desc">${upgrade.desc}</div>
          <div class="shop-item-level">Level: ${currentLevel}/${upgrade.maxLevel}</div>
          <div class="shop-item-level">Current: +${bonus}${key === 'fireRate' ? 's faster' : ''}</div>
          ${!isMaxed ? `
            <div class="shop-item-level" style="color: #00ff00;">Next: +${nextBonus}</div>
            <div class="shop-item-cost">
              ${cost.coins > 0 ? `üí∞ ${cost.coins}` : ''}
              ${cost.gems > 0 ? ` üíé ${cost.gems}` : ''}
            </div>
          ` : '<div class="shop-item-cost" style="color: #00ff00;">MAX LEVEL</div>'}
        `;
        
        if (!isMaxed) {
          card.onclick = () => purchaseUpgrade(key);
        }
        
        shopGrid.appendChild(card);
      });
      
      // POTION UPGRADES SECTION
      const potionHeader = document.createElement("div");
      potionHeader.style.gridColumn = "1 / -1";
      potionHeader.style.fontSize = "24px";
      potionHeader.style.color = "#ff00ff";
      potionHeader.style.fontWeight = "bold";
      potionHeader.style.marginTop = "20px";
      potionHeader.style.marginBottom = "10px";
      potionHeader.textContent = "üß™ POTION UPGRADES";
      shopGrid.appendChild(potionHeader);
      
      const potionUpgradeKeys = ['healStrength', 'shieldStrength', 'effectStrength', 'dragonStrength', 
                                  'startingHeals', 'startingShields', 'startingOthers', 
                                  'potionGen', 'potionDamage', 'potionExplosion'];
      potionUpgradeKeys.forEach((key) => {
        const upgrade = SHOP_UPGRADES[key];
        const currentLevel = gameData.potionUpgrades[key];
        const isMaxed = currentLevel >= upgrade.maxLevel;
        const cost = isMaxed ? null : upgrade.getCost(currentLevel);
        const bonus = upgrade.getBonus(currentLevel);
        const nextBonus = isMaxed ? 0 : upgrade.getBonus(currentLevel + 1);
        
        const card = document.createElement("div");
        card.className = "shop-item";
        if (isMaxed) card.classList.add("maxed");
        
        card.innerHTML = `
          <div class="shop-item-name">${upgrade.name}</div>
          <div class="shop-item-desc">${upgrade.desc}</div>
          <div class="shop-item-level">Level: ${currentLevel}/${upgrade.maxLevel}</div>
          <div class="shop-item-level">Current: Level ${currentLevel}</div>
          ${!isMaxed ? `
            <div class="shop-item-level" style="color: #00ff00;">Next: Level ${currentLevel + 1}</div>
            <div class="shop-item-cost">
              ${cost.coins > 0 ? `üí∞ ${cost.coins}` : ''}
              ${cost.gems > 0 ? ` üíé ${cost.gems}` : ''}
            </div>
          ` : '<div class="shop-item-cost" style="color: #00ff00;">MAX LEVEL</div>'}
        `;
        
        if (!isMaxed) {
          card.onclick = () => purchaseUpgrade(key);
        }
        
        shopGrid.appendChild(card);
      });
    }

    function purchaseClass(className) {
      const classData = CLASSES[className];
      const cost = classData.cost;
      
      // Can purchase with EITHER enough coins OR enough gems (not both required)
      const canAffordCoins = gameData.totalCoins >= cost.coins;
      const canAffordGems = gameData.totalGems >= cost.gems;
      
      if (canAffordCoins || canAffordGems) {
        // Deduct ONLY ONE currency - prioritize coins if player has enough of both
        if (canAffordCoins) {
          gameData.totalCoins -= cost.coins;
        } else if (canAffordGems) {
          gameData.totalGems -= cost.gems;
        }
        
        gameData.purchasedClasses.push(className);
        gameData.unlockedClasses.push(className); // Also add to unlocked
        
        saveGameData();
        updateShopDisplay();
        
        alert(`‚úÖ Unlocked ${className}! You can now play as this class!`);
      } else {
        alert(`‚ùå Not enough currency! Need either ${cost.coins} coins OR ${cost.gems} gems.`);
      }
    }

    function purchaseUpgrade(upgradeKey) {
      const upgrade = SHOP_UPGRADES[upgradeKey];
      
      // Determine which upgrade category this belongs to
      const isPotionUpgrade = upgradeKey in gameData.potionUpgrades;
      const currentLevel = isPotionUpgrade ? 
        gameData.potionUpgrades[upgradeKey] : 
        gameData.permanentUpgrades[upgradeKey];
      
      if (currentLevel >= upgrade.maxLevel) return;
      
      const cost = upgrade.getCost(currentLevel);
      
      // Can purchase with EITHER enough coins OR enough gems (not both required)
      const canAffordCoins = gameData.totalCoins >= cost.coins;
      const canAffordGems = gameData.totalGems >= cost.gems;
      
      if (canAffordCoins || canAffordGems) {
        // Deduct ONLY ONE currency - prioritize coins if player has enough of both
        if (canAffordCoins) {
          gameData.totalCoins -= cost.coins;
        } else if (canAffordGems) {
          gameData.totalGems -= cost.gems;
        }
        
        if (isPotionUpgrade) {
          gameData.potionUpgrades[upgradeKey]++;
        } else {
          gameData.permanentUpgrades[upgradeKey]++;
        }
        
        saveGameData();
        updateShopDisplay();
        
        // Visual feedback
        const newLevel = isPotionUpgrade ? 
          gameData.potionUpgrades[upgradeKey] : 
          gameData.permanentUpgrades[upgradeKey];
        alert(`‚úÖ Upgraded ${upgrade.name} to level ${newLevel}!`);
      } else {
        alert(`‚ùå Not enough currency! Need either ${cost.coins} coins OR ${cost.gems} gems.`);
      }
    }

    // CURRENCY CONVERSION FUNCTIONS
    function convertGemsToCoins() {
      const gemsToConvert = prompt("How many gems would you like to convert?\n\nüíé ‚Üí üí∞ (1 Gem = 100 Coins)\n\nYou have " + gameData.totalGems + " gems.");
      const amount = parseInt(gemsToConvert);
      
      if (isNaN(amount) || amount <= 0) {
        if (gemsToConvert !== null) { // User didn't cancel
          alert("‚ùå Invalid amount! Please enter a positive number.");
        }
        return;
      }
      
      if (gameData.totalGems < amount) {
        alert(`‚ùå Not enough gems! You only have ${gameData.totalGems} gems.`);
        return;
      }
      
      // Convert gems to coins
      gameData.totalGems -= amount;
      gameData.totalCoins += amount * 100;
      saveGameData();
      updateShopDisplay();
      
      alert(`‚úÖ Converted ${amount} gems ‚Üí ${amount * 100} coins!\n\nüíé ${gameData.totalGems} gems remaining\nüí∞ ${gameData.totalCoins} coins total`);
    }

    function convertCoinsToGems() {
      const coinsToConvert = prompt("How many coins would you like to convert?\n\nüí∞ ‚Üí üíé (100 Coins = 1 Gem)\n\nYou have " + gameData.totalCoins + " coins.\n\nMust be a multiple of 100!");
      const amount = parseInt(coinsToConvert);
      
      if (isNaN(amount) || amount <= 0) {
        if (coinsToConvert !== null) { // User didn't cancel
          alert("‚ùå Invalid amount! Please enter a positive number.");
        }
        return;
      }
      
      if (amount % 100 !== 0) {
        alert("‚ùå Invalid amount! Must be a multiple of 100.\n\nExample: 100, 200, 500, 1000");
        return;
      }
      
      if (gameData.totalCoins < amount) {
        alert(`‚ùå Not enough coins! You only have ${gameData.totalCoins} coins.`);
        return;
      }
      
      // Convert coins to gems
      gameData.totalCoins -= amount;
      gameData.totalGems += amount / 100;
      saveGameData();
      updateShopDisplay();
      
      alert(`‚úÖ Converted ${amount} coins ‚Üí ${amount / 100} gems!\n\nüí∞ ${gameData.totalCoins} coins remaining\nüíé ${gameData.totalGems} gems total`);
    }

    // ABILITY ACTIVATION SYSTEM
    function initializeAbilities(className) {
      selectedClassName = className;
      ability1Cooldown = 0;
      ability2Cooldown = 0;
      ability1KillCounter = 0;
      ability2KillCounter = 0;
      lastStandUsed = false;
      chainReactionShots = 0;
      headhunterShots = 0;
      overwatchActive = false;
      bladeStormActive = false;
      soulHarvestActive = false;
      timeFreezeActive = false;
      hiveMindActive = false;
      upsideDownActive = false;
      vecnaKillCounter = 0;
      vecnaMonsters = [];
      vecnaMonsterKillCounter = 0;
      convertedEnemies = [];
      cupidsBowActive = false;
      cupidsBowShots = 0;
      hookShotActive = false;
      
      updateAbilityDisplay();
    }
    
    function updateAbilities(dt) {
      if (!selectedClassName) return;
      
      // Update cooldowns
      if (ability1Cooldown > 0) ability1Cooldown -= dt;
      if (ability2Cooldown > 0) ability2Cooldown -= dt;
      
      // Update special ability timers
      if (overwatchTimer > 0) {
        overwatchTimer -= dt;
        if (overwatchTimer <= 0) overwatchActive = false;
      }
      
      if (bladeStormTimer > 0) {
        bladeStormTimer -= dt;
        if (bladeStormTimer <= 0) bladeStormActive = false;
      }
      
      if (soulHarvestTimer > 0) {
        soulHarvestTimer -= dt;
        if (soulHarvestTimer <= 0) soulHarvestActive = false;
      }
      
      if (timeFreezeTimer > 0) {
        timeFreezeTimer -= dt;
        if (timeFreezeTimer <= 0) timeFreezeActive = false;
      }
      
      if (hiveMindTimer > 0) {
        hiveMindTimer -= dt;
        if (hiveMindTimer <= 0) hiveMindActive = false;
      }
      
      if (upsideDownTimer > 0) {
        upsideDownTimer -= dt;
        if (upsideDownTimer <= 0) {
          upsideDownActive = false;
          // Reset damage and remove lifesteal
          if (player.damage > player.baseDamage) {
            player.damage = player.baseDamage;
          }
        }
      }
      
      // Update Vecna monsters
      vecnaMonsters = vecnaMonsters.filter(monster => {
        if (monster.hp <= 0) return false;
        
        // Find nearest enemy
        let nearest = null;
        let minDist = Infinity;
        enemies.forEach(e => {
          const dist = Math.hypot(e.x - monster.x, e.y - monster.y);
          if (dist < minDist) {
            minDist = dist;
            nearest = e;
          }
        });
        
        if (nearest) {
          const dx = nearest.x - monster.x;
          const dy = nearest.y - monster.y;
          const dist = Math.hypot(dx, dy);
          
          if (dist > 30) {
            monster.x += (dx / dist) * 2;
            monster.y += (dy / dist) * 2;
          } else {
            // Attack
            monster.attackTimer -= dt;
            if (monster.attackTimer <= 0) {
              nearest.hp -= 10;
              if (nearest.hp <= 0) {
                onEnemyKilled(nearest);
              }
              monster.attackTimer = 1;
            }
          }
        }
        
        return true;
      });
      
      // Update converted enemies
      convertedEnemies = convertedEnemies.filter(e => {
        e.convertTimer -= dt;
        if (e.convertTimer <= 0) {
          e.isConverted = false;
          e.color = e.originalColor;
          return false;
        }
        
        // Attack other enemies
        let nearest = null;
        let minDist = Infinity;
        enemies.forEach(enemy => {
          if (enemy === e || enemy.isConverted) return;
          const dist = Math.hypot(enemy.x - e.x, enemy.y - e.y);
          if (dist < minDist) {
            minDist = dist;
            nearest = enemy;
          }
        });
        
        if (nearest && minDist < 100) {
          e.attackTimer = (e.attackTimer || 0) - dt;
          if (e.attackTimer <= 0) {
            nearest.hp -= e.damage;
            if (nearest.hp <= 0) {
              onEnemyKilled(nearest);
            }
            e.attackTimer = 1;
          }
        }
        
        return true;
      });
      
      // Blade storm damage
      if (bladeStormActive) {
        enemies.forEach(e => {
          const dist = Math.hypot(e.x - player.x, e.y - player.y);
          if (dist < 150) {
            e.hp -= 50 * dt;
            if (e.hp <= 0) {
              onEnemyKilled(e);
            }
          }
        });
      }
      
      // Check auto-activation abilities
      checkAutoAbilities();
      
      // Check for Last Stand
      if (selectedClassName === "Knight" && gameData.skillTrees.Knight?.ultimate2 && !lastStandUsed) {
        if (player.hp < player.maxHP * 0.2) {
          activateLastStand();
        }
      }
      
      // Vecna shield on kills
      if (selectedClassName === "Vecna") {
        if (vecnaKillCounter >= 10) {
          player.shield = Math.min(player.shield + 50, 200);
          vecnaKillCounter = 0;
          floatingText("üí† SHIELD +50", player.x, player.y - 30, "#00ffff", 1.5);
        }
      }
      
      updateAbilityDisplay();
    }
    
    function checkAutoAbilities() {
      if (!selectedClassName || !SKILL_TREES[selectedClassName]) return;
      
      const abilities = SKILL_TREES[selectedClassName];
      const classSkills = gameData.skillTrees[selectedClassName];
      if (!classSkills) return;
      
      // Check ability 1 (kills-based)
      if (classSkills.ultimate1 && abilities.ultimate1.activation === 'kills') {
        if (ability1KillCounter >= abilities.ultimate1.killRequirement && ability1Cooldown <= 0) {
          activateAbility(1);
        }
      }
      
      // Check ability 2 (kills-based)
      if (classSkills.ultimate2 && abilities.ultimate2.activation === 'kills') {
        if (ability2KillCounter >= abilities.ultimate2.killRequirement && ability2Cooldown <= 0) {
          activateAbility(2);
        }
      }
    }
    
    function updateAbilityDisplay() {
      if (!selectedClassName || !SKILL_TREES[selectedClassName]) {
        document.getElementById('ability1Btn').style.display = 'none';
        document.getElementById('ability2Btn').style.display = 'none';
        return;
      }
      
      const abilities = SKILL_TREES[selectedClassName];
      const classSkills = gameData.skillTrees[selectedClassName];
      
      // Ability 1
      if (classSkills?.ultimate1) {
        const btn = document.getElementById('ability1Btn');
        btn.style.display = 'block';
        document.getElementById('ability1Icon').textContent = abilities.ultimate1.icon;
        document.getElementById('ability1Name').textContent = abilities.ultimate1.name;
        document.getElementById('ability1Key').textContent = `[${abilities.ultimate1.hotkey?.toUpperCase() || 'Q'}]`;
        
        if (ability1Cooldown > 0) {
          document.getElementById('ability1CD').textContent = `${Math.ceil(ability1Cooldown)}s`;
          btn.classList.add('cooldown');
          btn.classList.remove('ready');
        } else if (abilities.ultimate1.activation === 'kills') {
          const progress = `${ability1KillCounter}/${abilities.ultimate1.killRequirement}`;
          document.getElementById('ability1CD').textContent = progress;
          if (ability1KillCounter >= abilities.ultimate1.killRequirement) {
            btn.classList.add('ready');
            btn.classList.remove('cooldown');
          } else {
            btn.classList.remove('ready', 'cooldown');
          }
        } else {
          document.getElementById('ability1CD').textContent = 'READY';
          btn.classList.add('ready');
          btn.classList.remove('cooldown');
        }
      } else {
        document.getElementById('ability1Btn').style.display = 'none';
      }
      
      // Ability 2
      if (classSkills?.ultimate2) {
        const btn = document.getElementById('ability2Btn');
        btn.style.display = 'block';
        document.getElementById('ability2Icon').textContent = abilities.ultimate2.icon;
        document.getElementById('ability2Name').textContent = abilities.ultimate2.name;
        document.getElementById('ability2Key').textContent = `[${abilities.ultimate2.hotkey?.toUpperCase() || 'E'}]`;
        
        if (ability2Cooldown > 0) {
          document.getElementById('ability2CD').textContent = `${Math.ceil(ability2Cooldown)}s`;
          btn.classList.add('cooldown');
          btn.classList.remove('ready');
        } else if (abilities.ultimate2.activation === 'kills') {
          const progress = `${ability2KillCounter}/${abilities.ultimate2.killRequirement}`;
          document.getElementById('ability2CD').textContent = progress;
          if (ability2KillCounter >= abilities.ultimate2.killRequirement) {
            btn.classList.add('ready');
            btn.classList.remove('cooldown');
          } else {
            btn.classList.remove('ready', 'cooldown');
          }
        } else {
          document.getElementById('ability2CD').textContent = 'READY';
          btn.classList.add('ready');
          btn.classList.remove('cooldown');
        }
      } else {
        document.getElementById('ability2Btn').style.display = 'none';
      }
    }
    
    function onEnemyKilled(enemy) {
      ability1KillCounter++;
      ability2KillCounter++;
      vecnaKillCounter++;
      
      // Enemy conversion chance for Vecna
      if (selectedClassName === "Vecna" && Math.random() < 0.2 && !enemy.isConverted) {
        enemy.isConverted = true;
        enemy.originalColor = enemy.color;
        enemy.color = "#9933ff";
        enemy.convertTimer = 15;
        convertedEnemies.push(enemy);
        floatingText("üëÅÔ∏è CONVERTED!", enemy.x, enemy.y, "#9933ff", 1);
      }
      
      // Vecna monster spawning (every 5 kills)
      if (selectedClassName === "Vecna") {
        vecnaMonsterKillCounter++;
        if (vecnaMonsterKillCounter >= 5 && vecnaMonsters.length < 3) {
          spawnVecnaMonster();
          vecnaMonsterKillCounter = 0;
        }
      }
    }
    
    function activateAbility1() {
      activateAbility(1);
    }
    
    function activateAbility2() {
      activateAbility(2);
    }

    // ABILITY IMPLEMENTATIONS
    function activateAbility(abilityNum) {
      if (!selectedClassName || !SKILL_TREES[selectedClassName]) return;
      
      const abilities = SKILL_TREES[selectedClassName];
      const ability = abilityNum === 1 ? abilities.ultimate1 : abilities.ultimate2;
      
      // Check if ability is purchased
      if (!gameData.skillTrees[selectedClassName]) {
        gameData.skillTrees[selectedClassName] = {};
      }
      const abilityKey = abilityNum === 1 ? 'ultimate1' : 'ultimate2';
      if (!gameData.skillTrees[selectedClassName][abilityKey]) {
        addFloatingText(canvas.width / 2, canvas.height / 2, "‚ùå ABILITY NOT PURCHASED!", "#ff0000", 2);
        return; // Ability not purchased yet!
      }
      
      if (abilityNum === 1 && ability1Cooldown > 0) return;
      if (abilityNum === 2 && ability2Cooldown > 0) return;
      
      // Set cooldown
      if (abilityNum === 1) {
        ability1Cooldown = ability.cooldown;
        ability1KillCounter = 0;
      } else {
        ability2Cooldown = ability.cooldown;
        ability2KillCounter = 0;
      }
      
      // Execute ability based on class and ability
      const abilityName = ability.name;
      
      // Hunter abilities
      if (abilityName === "Sniper Shot") {
        activateSniperShot();
      } else if (abilityName === "Care Package") {
        activateCarePackage();
      }
      // Knight abilities
      else if (abilityName === "Shield Bash") {
        activateShieldBash();
      } else if (abilityName === "Last Stand") {
        activateLastStand();
      }
      // Assassin abilities
      else if (abilityName === "Shadow Strike") {
        activateShadowStrike();
      } else if (abilityName === "Blade Storm") {
        activateBladeStorm();
      }
      // Archer abilities (NEW Archer class)
      else if (abilityName === "Cupid's Bow") {
        activateCupidsBow();
      } else if (abilityName === "Hook Shot") {
        activateHookShot();
      }
      // Thief abilities (NEW Thief class)
      else if (abilityName === "Thief's Hand") {
        activateThiefsHand();
      } else if (abilityName === "Phantom Clone") {
        activatePhantomClone();
      }
      // Wizard abilities
      else if (abilityName === "Meteor Storm") {
        activateMeteorStorm();
      } else if (abilityName === "Time Freeze") {
        activateTimeFreeze();
      }
      // Archer abilities
      else if (abilityName === "Arrow Barrage") {
        activateArrowBarrage();
      } else if (abilityName === "Explosive Arrow") {
        activateExplosiveArrow();
      }
      // Summoner abilities
      else if (abilityName === "Army of the Dead") {
        activateArmyOfDead();
      } else if (abilityName === "Sacrifice") {
        activateSacrifice();
      }
      // Bomber abilities
      else if (abilityName === "Nuke") {
        activateNuke();
      } else if (abilityName === "Chain Reaction") {
        activateChainReaction();
      }
      // Sniper abilities
      else if (abilityName === "Headhunter") {
        activateHeadhunter();
      } else if (abilityName === "Overwatch") {
        activateOverwatch();
      }
      // Necromancer abilities
      else if (abilityName === "Plague") {
        activatePlague();
      } else if (abilityName === "Soul Harvest") {
        activateSoulHarvest();
      }
      // Vecna abilities
      else if (abilityName === "Hive Mind") {
        activateHiveMind();
      } else if (abilityName === "Vecna's Curse") {
        activateVecnasCurse();
      }
      
      updateAbilityDisplay();
    }
    
    // HUNTER ABILITIES
    function activateSniperShot() {
      screenShake = 15;
      floatingText("üéØ SNIPER SHOT!", canvas.width / 2, 100, "#00ffff", 2);
      
      // Create massive laser beam across screen
      const beam = {
        x: player.x,
        y: player.y,
        vx: 20,
        vy: 0,
        radius: 15,
        damage: 500,
        color: "#ff0000",
        pierce: true,
        life: 2,
        isSniperShot: true
      };
      projectiles.push(beam);
      
      // Add visual effect
      for (let i = 0; i < 30; i++) {
        particles.push({
          x: player.x,
          y: player.y,
          vx: Math.random() * 10 - 5,
          vy: Math.random() * 10 - 5,
          radius: Math.random() * 3 + 2,
          color: "#ff0000",
          life: 1
        });
      }
    }
    
    function activateCarePackage() {
      floatingText("üì¶ CARE PACKAGE!", player.x, player.y - 50, "#ffff00", 2);
      
      // Add potions
      potions.heal += 2;
      potions.shield += 1;
      potions.damage += 1;
      updatePotionDisplay();
      
      // Visual effect - parachute drop
      for (let i = 0; i < 20; i++) {
        particles.push({
          x: player.x,
          y: player.y - 100,
          vx: Math.random() * 4 - 2,
          vy: Math.random() * 2 + 2,
          radius: Math.random() * 4 + 2,
          color: "#00ff00",
          life: 1.5
        });
      }
      
      screenShake = 8;
    }
    
    // KNIGHT ABILITIES
    function activateShieldBash() {
      floatingText("üõ°Ô∏è SHIELD BASH!", player.x, player.y - 50, "#0088ff", 2);
      
      // Dash forward
      const dashDistance = 300;
      const dashSpeed = 15;
      let dashedDistance = 0;
      
      const dashInterval = setInterval(() => {
        if (dashedDistance >= dashDistance || !gameActive) {
          clearInterval(dashInterval);
          return;
        }
        
        player.x += dashSpeed;
        dashedDistance += dashSpeed;
        
        // Damage enemies in path
        enemies.forEach(e => {
          const dist = Math.hypot(e.x - player.x, e.y - player.y);
          if (dist < 80) {
            e.hp -= 100;
            e.stunned = true;
            e.stunnedTimer = 2;
            if (e.hp <= 0) {
              onEnemyKilled(e);
            }
          }
        });
        
        // Particles
        particles.push({
          x: player.x,
          y: player.y,
          vx: Math.random() * 4 - 2,
          vy: Math.random() * 4 - 2,
          radius: 5,
          color: "#0088ff",
          life: 0.5
        });
      }, 50);
      
      screenShake = 10;
    }
    
    function activateLastStand() {
      floatingText("‚ö° LAST STAND!", player.x, player.y - 50, "#ffff00", 2);
      player.invincible = true;
      lastStandUsed = true;
      
      setTimeout(() => {
        player.invincible = false;
      }, 5000);
      
      // Golden aura particles
      const particleInterval = setInterval(() => {
        if (!player.invincible) {
          clearInterval(particleInterval);
          return;
        }
        for (let i = 0; i < 5; i++) {
          particles.push({
            x: player.x,
            y: player.y,
            vx: Math.random() * 6 - 3,
            vy: Math.random() * 6 - 3,
            radius: 4,
            color: "#ffff00",
            life: 0.5
          });
        }
      }, 100);
      
      screenShake = 12;
    }
    
    // ARCHER ABILITIES
    function activateCupidsBow() {
      floatingText("üíò CUPID'S BOW!", player.x, player.y - 50, "#ff1493", 2);
      
      cupidsBowActive = true;
      cupidsBowShots = 5;
      
      // Pink heart particles
      for (let i = 0; i < 30; i++) {
        particles.push({
          x: player.x,
          y: player.y,
          vx: Math.random() * 8 - 4,
          vy: Math.random() * 8 - 4,
          radius: Math.random() * 4 + 2,
          color: "#ff1493",
          life: 1
        });
      }
      
      screenShake = 8;
    }
    
    function activateHookShot() {
      hookShotActive = !hookShotActive;
      
      if (hookShotActive) {
        floatingText("ü™ù HOOK SHOT ON!", player.x, player.y - 50, "#00ff00", 2);
      } else {
        floatingText("ü™ù HOOK SHOT OFF!", player.x, player.y - 50, "#ff0000", 2);
      }
      
      // Chain particles when toggling on
      if (hookShotActive) {
        for (let i = 0; i < 20; i++) {
          particles.push({
            x: player.x,
            y: player.y,
            vx: Math.random() * 6 - 3,
            vy: Math.random() * 6 - 3,
            radius: Math.random() * 3 + 1,
            color: "#888888",
            life: 0.8
          });
        }
      }
      
      screenShake = 5;
    }
    
    // ASSASSIN ABILITIES
    function activateShadowStrike() {
      if (enemies.length === 0) return;
      
      // Find random enemy
      const target = enemies[Math.floor(Math.random() * enemies.length)];
      
      floatingText("üëª SHADOW STRIKE!", player.x, player.y - 50, "#9933ff", 2);
      
      // Teleport behind enemy
      player.x = target.x - 50;
      player.y = target.y;
      
      // Deal backstab damage
      target.hp -= 300;
      if (target.hp <= 0) {
        onEnemyKilled(target);
      }
      
      // Smoke effect
      for (let i = 0; i < 40; i++) {
        particles.push({
          x: player.x,
          y: player.y,
          vx: Math.random() * 8 - 4,
          vy: Math.random() * 8 - 4,
          radius: Math.random() * 6 + 2,
          color: "#000000",
          life: 1
        });
      }
      
      screenShake = 10;
    }
    
    function activateBladeStorm() {
      floatingText("üåÄ BLADE STORM!", player.x, player.y - 50, "#9933ff", 2);
      bladeStormActive = true;
      bladeStormTimer = 5;
      screenShake = 8;
    }
    
    // WIZARD ABILITIES
    function activateMeteorStorm() {
      floatingText("‚òÑÔ∏è METEOR STORM!", canvas.width / 2, 100, "#ff8800", 2);
      
      for (let i = 0; i < 10; i++) {
        setTimeout(() => {
          const x = Math.random() * canvas.width;
          const y = 0;
          
          projectiles.push({
            x: x,
            y: y,
            vx: 0,
            vy: 8,
            radius: 20,
            damage: 150,
            color: "#ff8800",
            explosive: true,
            life: 3,
            isMeteor: true
          });
          
          screenShake = 5;
        }, i * 200);
      }
    }
    
    function activateTimeFreeze() {
      floatingText("‚ùÑÔ∏è TIME FREEZE!", canvas.width / 2, 100, "#00ffff", 2);
      timeFreezeActive = true;
      timeFreezeTimer = 5;
      
      // Freeze all enemies
      enemies.forEach(e => {
        e.frozen = true;
      });
      
      setTimeout(() => {
        enemies.forEach(e => {
          e.frozen = false;
        });
      }, 5000);
      
      screenShake = 10;
    }

    // ARCHER ABILITIES
    function activateArrowBarrage() {
      floatingText("üèπ ARROW BARRAGE!", player.x, player.y - 50, "#00ff88", 2);
      
      for (let i = 0; i < 50; i++) {
        const angle = (Math.PI * 2 / 50) * i;
        projectiles.push({
          x: player.x,
          y: player.y,
          vx: Math.cos(angle) * 10,
          vy: Math.sin(angle) * 10,
          radius: 8,
          damage: 30,
          color: "#00ff88",
          pierce: true,
          life: 2
        });
      }
      
      screenShake = 12;
    }
    
    function activateExplosiveArrow() {
      floatingText("üí• EXPLOSIVE ARROW!", player.x, player.y - 50, "#ff0000", 2);
      
      projectiles.push({
        x: player.x,
        y: player.y,
        vx: 15,
        vy: 0,
        radius: 25,
        damage: 800,
        color: "#ff4400",
        explosive: true,
        explosionRadius: 300,
        life: 3,
        isExplosiveArrow: true
      });
      
      screenShake = 15;
    }
    
    // THIEF ABILITIES
    function activateThiefsHand() {
      floatingText("ü§ö THIEF'S HAND!", player.x, player.y - 50, "#8800ff", 2);
      
      let totalHealthStolen = 0;
      
      // Stun and steal health from ALL enemies on screen
      enemies.forEach(e => {
        // Stun enemy
        e.stunned = true;
        e.stunnedTimer = 2;
        e.vx = 0;
        
        // Steal half their HP
        const stolenHP = e.hp * 0.5;
        totalHealthStolen += stolenHP;
        e.hp -= stolenHP;
        
        // Visual effect on enemy
        addFloatingText(e.x + e.w / 2, e.y - 20, "-" + Math.floor(stolenHP), "#8800ff");
        
        // Purple particles
        for (let i = 0; i < 5; i++) {
          particles.push({
            x: e.x + e.w / 2,
            y: e.y + e.h / 2,
            vx: Math.random() * 8 - 4,
            vy: Math.random() * 8 - 4,
            radius: Math.random() * 4 + 2,
            color: "#8800ff",
            life: 0.8
          });
        }
        
        // Check if enemy died from health steal
        if (e.hp <= 0) {
          onEnemyKilled(e);
        }
      });
      
      // Heal player by total stolen amount
      player.hp = Math.min(player.hp + totalHealthStolen, player.maxHP);
      addFloatingText(player.x + player.w / 2, player.y - 30, "+" + Math.floor(totalHealthStolen) + " HP!", "#00ff00");
      
      // Player aura effect
      for (let i = 0; i < 30; i++) {
        particles.push({
          x: player.x + player.w / 2,
          y: player.y + player.h / 2,
          vx: Math.random() * 10 - 5,
          vy: Math.random() * 10 - 5,
          radius: Math.random() * 4 + 2,
          color: "#8800ff",
          life: 1
        });
      }
      
      screenShake = 12;
    }
    
    function activatePhantomClone() {
      floatingText("üë§ PHANTOM CLONE!", player.x, player.y - 50, "#000000", 2);
      
      // Increase player's health by half of max HP
      const hpBoost = player.maxHP * 0.5;
      player.maxHP += hpBoost;
      player.hp += hpBoost;
      addFloatingText(player.x + player.w / 2, player.y - 40, "+" + Math.floor(hpBoost) + " MAX HP!", "#00ff00");
      
      // Create phantom clone
      phantomClone = {
        active: true,
        x: player.x - 50,
        y: player.y,
        w: player.w,
        h: player.h,
        hp: player.maxHP,
        duration: 30,
        timer: 30,
        color: "#000000",
        alpha: 0.6
      };
      
      // Shadow particles
      for (let i = 0; i < 40; i++) {
        particles.push({
          x: phantomClone.x + phantomClone.w / 2,
          y: phantomClone.y + phantomClone.h / 2,
          vx: Math.random() * 8 - 4,
          vy: Math.random() * 8 - 4,
          radius: Math.random() * 5 + 2,
          color: "#000000",
          life: 1.2
        });
      }
      
      screenShake = 10;
    }
    
    // SUMMONER ABILITIES
    function activateArmyOfDead() {
      floatingText("üíÄ ARMY OF THE DEAD!", player.x, player.y - 50, "#9933ff", 2);
      
      for (let i = 0; i < 10; i++) {
        const angle = (Math.PI * 2 / 10) * i;
        const distance = 80;
        
        minions.push({
          x: player.x + Math.cos(angle) * distance,
          y: player.y + Math.sin(angle) * distance,
          hp: 50,
          maxHP: 50,
          damage: 15,
          speed: 2,
          radius: 15,
          color: "#9933ff",
          attackTimer: 0,
          isArmy: true
        });
      }
      
      // Ground eruption effect
      for (let i = 0; i < 50; i++) {
        particles.push({
          x: player.x,
          y: player.y,
          vx: Math.random() * 12 - 6,
          vy: Math.random() * 12 - 6,
          radius: Math.random() * 5 + 2,
          color: "#9933ff",
          life: 1.5
        });
      }
      
      screenShake = 10;
    }
    
    function activateSacrifice() {
      if (minions.length === 0) {
        floatingText("‚ùå No minions to sacrifice!", player.x, player.y - 50, "#ff0000", 1.5);
        return;
      }
      
      const minionCount = minions.length;
      floatingText(`üîÆ SACRIFICE ${minionCount} MINIONS!`, player.x, player.y - 50, "#9933ff", 2);
      
      // Convert minions to shields
      player.shield += minionCount * 30;
      
      // Remove minions with soul effect
      minions.forEach(m => {
        for (let i = 0; i < 10; i++) {
          particles.push({
            x: m.x,
            y: m.y,
            vx: (player.x - m.x) / 20 + Math.random() * 2 - 1,
            vy: (player.y - m.y) / 20 + Math.random() * 2 - 1,
            radius: 4,
            color: "#9933ff",
            life: 1
          });
        }
      });
      
      minions.length = 0;
      screenShake = 8;
    }
    
    // BOMBER ABILITIES
    function activateNuke() {
      floatingText("‚ò¢Ô∏è NUCLEAR STRIKE!", canvas.width / 2, canvas.height / 2, "#ff0000", 3);
      
      // Damage all enemies
      enemies.forEach(e => {
        e.hp -= 1000;
        if (e.hp <= 0) {
          onEnemyKilled(e);
        }
      });
      
      // Massive explosion effect
      for (let i = 0; i < 100; i++) {
        particles.push({
          x: canvas.width / 2,
          y: canvas.height / 2,
          vx: Math.random() * 20 - 10,
          vy: Math.random() * 20 - 10,
          radius: Math.random() * 10 + 5,
          color: i % 2 === 0 ? "#ff8800" : "#ffff00",
          life: 2
        });
      }
      
      screenShake = 25;
    }
    
    function activateChainReaction() {
      floatingText("‚õìÔ∏è CHAIN REACTION!", player.x, player.y - 50, "#ff8800", 2);
      chainReactionShots = 10;
      screenShake = 8;
    }
    
    // SNIPER ABILITIES
    function activateHeadhunter() {
      floatingText("üíÄ HEADHUNTER MODE!", player.x, player.y - 50, "#00ffff", 2);
      headhunterShots = 5;
      screenShake = 8;
    }
    
    function activateOverwatch() {
      floatingText("üî≠ OVERWATCH ACTIVE!", player.x, player.y - 50, "#00ffff", 2);
      overwatchActive = true;
      overwatchTimer = 15;
      screenShake = 8;
    }
    
    // NECROMANCER ABILITIES
    function activatePlague() {
      floatingText("ü¶† PLAGUE UNLEASHED!", canvas.width / 2, 100, "#00ff00", 2);
      
      enemies.forEach(e => {
        if (!e.poisoned) {
          e.poisoned = true;
          e.poisonDamage = 20;
          e.poisonTimer = 10;
        }
      });
      
      // Green gas effect
      for (let i = 0; i < 80; i++) {
        particles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          vx: Math.random() * 4 - 2,
          vy: Math.random() * 4 - 2,
          radius: Math.random() * 8 + 3,
          color: "#00ff00",
          life: 3
        });
      }
      
      screenShake = 10;
    }
    
    function activateSoulHarvest() {
      floatingText("üëª SOUL HARVEST!", player.x, player.y - 50, "#9933ff", 2);
      soulHarvestActive = true;
      soulHarvestTimer = 10;
      screenShake = 8;
    }
    
    // VECNA ABILITIES
    function activateHiveMind() {
      if (enemies.length === 0) {
        floatingText("‚ùå No enemies to link!", player.x, player.y - 50, "#ff0000", 1.5);
        return;
      }
      
      floatingText("üëÅÔ∏è HIVE MIND ACTIVATED!", canvas.width / 2, 100, "#ff0000", 3);
      hiveMindActive = true;
      hiveMindTimer = 15;
      
      // Mark all enemies as linked
      enemies.forEach(e => {
        e.hiveMindLinked = true;
      });
      
      screenShake = 15;
    }
    
    function activateVecnasCurse() {
      floatingText("üåÄ ENTERING THE UPSIDE DOWN!", canvas.width / 2, canvas.height / 2, "#8B0000", 3);
      upsideDownActive = true;
      upsideDownTimer = 20;
      
      // Store base damage
      player.baseDamage = player.damage;
      
      // Apply damage boost
      player.damage = player.baseDamage * 1.5;
      
      screenShake = 20;
    }
    
    function spawnVecnaMonster() {
      vecnaMonsters.push({
        x: player.x + Math.random() * 100 - 50,
        y: player.y + Math.random() * 100 - 50,
        hp: 50,
        maxHP: 50,
        damage: 10,
        radius: 12,
        color: "#8B0000",
        attackTimer: 1
      });
      
      floatingText("üëÅÔ∏è Monster Spawned!", player.x, player.y - 50, "#8B0000", 1);
    }

    // SPRITE SYSTEM FUNCTIONS
    function loadCharacterSprites() {
      console.log('üé® Loading character sprites...');
      let loadedCount = 0;
      let failedCount = 0;
      let totalSprites = 0;
      
      // Count total sprites to load
      Object.values(SPRITE_MAP).forEach(spriteFile => {
        if (spriteFile) totalSprites++;
      });
      
      Object.entries(SPRITE_MAP).forEach(([className, spriteFile]) => {
        if (spriteFile) {
          const img = new Image();
          
          img.onload = () => {
            characterSprites[className] = img;
            loadedCount++;
            console.log(`‚úÖ Loaded sprite: ${className} (${loadedCount}/${totalSprites})`);
            
            if (loadedCount + failedCount === totalSprites) {
              if (loadedCount > 0) {
                spritesLoaded = true;
                console.log(`üéâ ${loadedCount}/${totalSprites} sprites loaded successfully!`);
              } else {
                console.log(`‚ö†Ô∏è No sprites loaded. Using fallback graphics.`);
              }
            }
          };
          
          img.onerror = () => {
            failedCount++;
            console.log(`‚ùå Failed to load sprite: ${className} (${spriteFile})`);
            
            if (loadedCount + failedCount === totalSprites) {
              if (loadedCount > 0) {
                spritesLoaded = true;
                console.log(`üéâ ${loadedCount}/${totalSprites} sprites loaded successfully!`);
              } else {
                console.log(`‚ö†Ô∏è No sprites loaded. Using fallback graphics.`);
                console.log(`‚ÑπÔ∏è  To use sprites, create a 'sprites/' folder and add PNG files.`);
              }
            }
          };
          
          // Try to load from sprites folder
          // Works when you have: your-website/sprites/hunter.png, etc.
          img.src = `sprites/${spriteFile}.png`;
        }
      });
      
      if (totalSprites === 0) {
        console.log('‚ÑπÔ∏è  No sprite files configured.');
      }
    }
    
    function getSpriteFrame(animFrame, frameCount = 4) {
      return Math.floor(animFrame * frameCount) % frameCount;
    }
    
    function drawPhantomClone(playerX, playerY, playerW, playerH) {
      // Phantom clone: darker, transparent copy of player
      // Position slightly behind and to the side
      const cloneX = playerX - 20;
      const cloneY = playerY;
      
      // Get player sprite
      const sprite = characterSprites[player.className];
      
      // Set transparency and darker filter
      ctx.globalAlpha = 0.3; // Very transparent
      
      if (sprite && spritesLoaded) {
        // DRAW SPRITE CLONE (darker)
        const frame = getSpriteFrame(player.animFrame || 0);
        const spriteWidth = sprite.width;
        const spriteHeight = sprite.height;
        const frameWidth = spriteWidth / 4;
        
        ctx.save();
        ctx.filter = 'brightness(0.4)'; // Much darker
        
        // Flip sprite if facing left
        if (player.facingLeft) {
          ctx.scale(-1, 1);
          ctx.drawImage(
            sprite,
            frame * frameWidth, 0,
            frameWidth, spriteHeight,
            -(cloneX + playerW), cloneY,
            playerW, playerH
          );
        } else {
          ctx.drawImage(
            sprite,
            frame * frameWidth, 0,
            frameWidth, spriteHeight,
            cloneX, cloneY,
            playerW, playerH
          );
        }
        
        ctx.restore();
      } else {
        // FALLBACK: Draw colored square clone (darker)
        // Darken the colors
        const darkerColor = darkenColor(player.color);
        const darkerAccent = darkenColor(player.accent);
        const darkerGlow = darkenColor(player.glowColor);
        
        ctx.shadowColor = darkerGlow;
        ctx.shadowBlur = 10;
        ctx.fillStyle = darkerColor;
        ctx.fillRect(cloneX, cloneY, playerW, playerH);

        ctx.shadowBlur = 0;
        ctx.fillStyle = darkerAccent;
        ctx.fillRect(cloneX + 4, cloneY + 4, playerW - 8, playerH - 8);

        // Darker face
        ctx.fillStyle = "#8b7355"; // Darker skin tone
        ctx.fillRect(cloneX + playerW * 0.25, cloneY - playerH * 0.3, playerW * 0.5, playerH * 0.3);

        // Darker eyes
        ctx.fillStyle = "#555555";
        ctx.fillRect(cloneX + playerW * 0.35, cloneY - playerH * 0.18, 4, 4);
        ctx.fillRect(cloneX + playerW * 0.55, cloneY - playerH * 0.18, 4, 4);
      }
      
      // Reset transparency
      ctx.globalAlpha = 1.0;
      ctx.filter = 'none';
    }
    
    function darkenColor(color) {
      // Convert hex color to RGB, darken it, return hex
      if (!color || color === 'transparent') return '#333333';
      
      // Remove # if present
      color = color.replace('#', '');
      
      // Parse RGB
      const r = parseInt(color.substr(0, 2), 16);
      const g = parseInt(color.substr(2, 2), 16);
      const b = parseInt(color.substr(4, 2), 16);
      
      // Darken by 60%
      const darkR = Math.floor(r * 0.4);
      const darkG = Math.floor(g * 0.4);
      const darkB = Math.floor(b * 0.4);
      
      // Convert back to hex
      return `#${darkR.toString(16).padStart(2, '0')}${darkG.toString(16).padStart(2, '0')}${darkB.toString(16).padStart(2, '0')}`;
    }

    // GAME INITIALIZATION
    function startGame(className, startingWave = 1) {
      const cls = CLASSES[className];
      
      // Apply permanent upgrades
      const baseDamage = cls.stats.damage + SHOP_UPGRADES.damage.getBonus(gameData.permanentUpgrades.damage);
      const baseHP = cls.stats.maxHP + SHOP_UPGRADES.health.getBonus(gameData.permanentUpgrades.health);
      const fireRateBonus = SHOP_UPGRADES.fireRate.getBonus(gameData.permanentUpgrades.fireRate);
      const startCrit = SHOP_UPGRADES.critChance.getBonus(gameData.permanentUpgrades.critChance);
      const startLevel = 1 + SHOP_UPGRADES.startLevel.getBonus(gameData.permanentUpgrades.startLevel);
      
      player = {
        className: className,
        x: PLAYER_X,
        y: GROUND_Y - 44,
        w: 36,
        h: 44,
        maxHP: baseHP,
        hp: baseHP,
        fireRate: cls.stats.fireRate * (1 - fireRateBonus),
        damage: baseDamage,
        range: cls.stats.range,
        projectileSpeed: cls.stats.projectileSpeed,
        color: cls.color,
        accent: cls.accent,
        bulletColor: cls.bulletColor,
        glowColor: cls.glowColor,
        xp: 0,
        level: startLevel,
        xpToNext: xpForLevel(startLevel),
        alive: true,
        // Upgrades
        multiShot: 0,
        pierce: cls.stats.alwaysPierce || false, // Archer gets piercing by default
        lifesteal: 0,
        explosive: cls.stats.alwaysExplosive || false, // Bomber gets this
        explosionRadius: cls.stats.explosionRadius || 60, // Bomber has 120, others default 60
        explosionDamage: cls.stats.explosionDamage || null, // Bomber has 90, others use formula
        critChance: cls.stats.alwaysCrit ? 0.5 : startCrit, // Sniper gets 50% base crit
        critMultiplier: 1.0,
        shield: 0,
        maxShield: 0,
        regen: 0,
        chainLightning: 0,
        aura: null,
        // Necromancer traits
        poison: cls.stats.alwaysPoison ? { damage: 5, duration: 3 } : null,
        spawnSkeletonsOnKill: cls.stats.spawnSkeletonsOnKill || false,
        // Sprite animation
        animFrame: 0,
        facingLeft: false,
        // Special class properties
        xpMultiplier: cls.stats.xpMultiplier || 1.0,
        powerUpMultiplier: cls.stats.powerUpMultiplier || 1.0
      };

      enemies = [];
      projectiles = [];
      minions = [];
      particles = [];
      floatingTexts = [];
      currencyDrops = [];
      shootTimer = 0;
      wave = startingWave; // Use selected starting wave
      enemiesToSpawn = calcEnemiesForWave(wave);
      spawnTimer = 0;
      combo = 0;
      comboTimer = 0;
      maxCombo = 0;
      screenShake = 0;
      gameState = "playing";
      roundBreakTimer = 0;
      sessionCoins = 0;
      sessionGems = 0;
      shufflesRemaining = 4; // Reset shuffle counter
      currentMap = 1;
      mapsCompleted = 0;
      enemiesKilled = 0; // Reset kill counter
      waveTimer = 0; // Reset wave timer
      waveTimerActive = false; // Wave timer not active yet
      shieldUpgradesChosen = 0; // Reset shield upgrade counter for Guardian Tank unlock
      
      // Reset BTD upgrade tree
      upgradePoints = 0;
      purchasedUpgrades = {
        pathA: [],
        pathB: [],
        pathC: []
      };

      if (className === "Summoner") {
        spawnMinion();
        spawnMinion();
      }
      
      // Initialize class-specific mechanics
      const classStats = cls.stats;
      
      // CrystalGuardian - Start with shield
      if (classStats.startingShield) {
        player.shield = classStats.startingShield;
        player.maxShield = classStats.startingShield;
      }
      
      // Starcaller - Create helper star
      if (classStats.helperStar) {
        helperStars.push({
          x: player.x,
          y: player.y,
          angle: 0,
          damage: classStats.helperStarDamage,
          fireRate: classStats.helperStarFireRate,
          range: classStats.helperStarRange,
          shootTimer: 0
        });
      }
      
      // BloodReaver - Set starting lifesteal
      if (classStats.lifestealPercent) {
        player.lifesteal = classStats.lifestealPercent;
      }
      
      // Initialize potions for first wave
      resetPotions();
      
      // Initialize abilities
      initializeAbilities(className);

      // Give up button removed - player must finish the run!
      giveUpBtn.style.display = "none";
      
      // RESTORE canvas to full visibility - clear hidden styles
      canvas.style.display = 'block';
      canvas.style.visibility = 'visible';
      canvas.style.opacity = '1';
      canvas.style.zIndex = '0';
      canvas.style.pointerEvents = 'auto';
      
      // RESET pause menu so ESC key always works
      const pauseMenu = document.getElementById('pauseMenu');
      pauseMenu.classList.remove('active');
      pauseMenu.style.display = '';  // Clear inline styles
      pauseMenu.style.visibility = '';
      pauseMenu.style.opacity = '';
      pauseMenu.style.zIndex = '';
      pauseMenu.style.pointerEvents = '';
      gamePaused = false;  // Ensure not paused when starting
      
      // Hide title screen completely
      titleScreen.classList.add('hidden');
      
      gameRunning = true;
      statusText.style.display = "none";
      lastTime = performance.now();
      requestAnimationFrame(gameLoop);
    }

    function xpForLevel(level) {
      // Much steeper XP curve - exponential growth
      // Level 1: 60 XP
      // Level 5: 670 XP
      // Level 10: 3,100 XP
      // Level 15: 8,800 XP
      // Level 20: 18,700 XP
      return Math.floor(60 * Math.pow(level, 2.1));
    }

    function calcEnemiesForWave(w) {
      if (w === 1) return 5;
      if (w === 2) return 7;
      if (w === 3) return 9;
      if (w === 4) return 11;
      if (w === 5) return 15;
      
      // After wave 5, MUCH more aggressive scaling
      // Wave 6: 20, Wave 10: 35, Wave 15: 55, Wave 20: 80
      const base = 15;
      const increment = (w - 5) * 3; // 3 enemies per wave
      const waveBonus = Math.floor(w / 5) * 5; // Bonus every 5 waves
      return base + increment + waveBonus;
    }

    function getShieldHP(wave, isBoss = false, isMiniBoss = false) {
      // Shield HP scaling - EXPONENTIAL at wave 25+
      let shieldHP;
      
      if (wave < 25) {
        // Wave 1-24: Linear scaling
        if (isBoss) {
          shieldHP = 200 + wave * 20;
        } else if (isMiniBoss) {
          shieldHP = 80 + wave * 4;
        } else {
          shieldHP = 40 + wave * 2;
        }
      } else {
        // Wave 25+: EXPONENTIAL scaling  - Much stronger shields!
        const baseShield = isBoss ? 700 : isMiniBoss ? 200 : 100;
        const exponentialGrowth = Math.pow(wave - 24, 1.8) * (isBoss ? 50 : isMiniBoss ? 15 : 8);
        shieldHP = baseShield + exponentialGrowth;
      }
      
      return Math.floor(shieldHP);
    }

    function getEnemyHP(wave, isBoss = false, isMiniBoss = false) {
      // WAVES 1-9: Fixed HP - difficulty increases by enemy COUNT only
      // WAVE 10+: HP starts scaling
      // WAVE 25+: EXPONENTIAL SCALING - Much harder!
      
      // Wave 1-9: 20 HP (2-shot from Hunter's 10 damage)
      // Wave 10: 140 HP
      // Wave 20: 500 HP
      // Wave 25: 800 HP
      // Wave 30: 1,500 HP (with exponential boost)
      // Wave 40: 4,000 HP (with exponential boost)
      // Wave 50: 10,000 HP (with exponential boost)
      
      let hp;
      
      if (wave < 10) {
        // Waves 1-9: FIXED HP, no scaling
        hp = 20; // Always 2-shot for Hunter
      } else if (wave < 25) {
        // Wave 10-24: Normal scaling
        const adjustedWave = wave;
        const baseHP = 20;
        const linearGrowth = adjustedWave * 8;
        const exponentialGrowth = Math.pow(adjustedWave, 1.8) * 1.0;
        hp = baseHP + linearGrowth + exponentialGrowth;
      } else {
        // Wave 25+: EXPONENTIAL SCALING - Much harder!
        const baseHP = 800; // Start at 800 HP
        const exponentialGrowth = Math.pow(wave - 24, 2.2) * 15; // Aggressive exponential
        hp = baseHP + exponentialGrowth;
      }
      
      if (isBoss) hp *= 12; // Bosses very tanky
      else if (isMiniBoss) hp *= 5; // Mini-bosses tanky
      
      return Math.floor(hp);
    }

    // SPAWNING
    function handleSpawning(dt) {
      if (enemiesToSpawn <= 0) return;
      
      spawnTimer += dt;
      
      // Spawn rate increases dramatically with waves
      // Wave 1: 2.0s, Wave 10: 1.2s, Wave 20: 0.6s, Wave 30: 0.3s
      let spawnInterval = 2.0 - (wave * 0.05);
      spawnInterval = Math.max(spawnInterval, 0.2); // Minimum 0.2s between spawns

      if (spawnTimer >= spawnInterval) {
        spawnTimer = 0;
        enemiesToSpawn--;
        
        // DIFFICULTY SCALING: Spawn multiple enemies at once on higher waves
        let spawnCount = 1; // Default: 1 enemy
        if (wave >= 35) {
          spawnCount = 3; // Wave 35+: 3 enemies at once
        } else if (wave >= 25) {
          spawnCount = 2; // Wave 25-34: 2 enemies at once
        }
        
        // Spawn multiple enemies
        for (let i = 0; i < spawnCount; i++) {
          spawnEnemy();
        }
        
        // Start wave timer when last enemy spawns (30s until next wave)
        if (enemiesToSpawn === 0) {
          waveTimer = 30;
          waveTimerActive = true;
          addFloatingText(canvas.width / 2, 100, "30s until next wave!", "#ffff00");
        }
      }
    }

    function spawnEnemy(isBoss = false, isMiniBoss = false) {
      let size, hp, speed, color, glowColor, type, damage, hasShield, isRanged, pattern;

      if (isBoss) {
        // Get boss pattern based on wave
        const patternIndex = Math.floor((wave - 1) / 10) % BOSS_PATTERNS.length;
        const bossPattern = BOSS_PATTERNS[patternIndex];
        
        size = 80;
        hp = getEnemyHP(wave, true, false);
        speed = bossPattern.speed;
        color = bossPattern.color;
        glowColor = bossPattern.color;
        type = "boss";
        
        // Boss damage - first boss deals 50, scales up
        // Wave 10: 50, Wave 20: 70, Wave 30: 90, Wave 40: 110
        damage = 30 + (wave * 2);
        hasShield = bossPattern.pattern === "tank";
        isRanged = bossPattern.pattern === "ranged";
        pattern = bossPattern;
        
      } else if (isMiniBoss) {
        size = 55;
        hp = getEnemyHP(wave, false, true);
        speed = 1.2 + (wave * 0.02); // Mini-bosses get faster
        color = "#ff8800";
        glowColor = "#ff8800";
        type = "miniboss";
        
        // Mini-boss damage - more reasonable scaling
        // Wave 5: 35, Wave 10: 40, Wave 20: 50, Wave 30: 60
        damage = 30 + Math.floor(wave / 5) * 5;
        hasShield = Math.random() < 0.4; // More likely to have shields
        isRanged = Math.random() < 0.3; // More likely to be ranged
        pattern = null;
      } else {
        size = 32 + Math.random() * 16;
        hp = getEnemyHP(wave);
        
        // Speed scales with waves
        const baseSpeed = 1.2 + (wave * 0.03);
        speed = baseSpeed + Math.random() * 0.4;
        
        const rand = Math.random();
        if (rand < 0.12) {
          // TRIANGLE - Extremely fast
          color = "#ffff00";
          glowColor = "#ffaa00";
          type = "triangle";
          hasShield = false;
          isRanged = false;
          speed *= 2.5; // Extremely fast!
          hp *= 0.5; // Low HP
          size = 28;
        } else if (rand < 0.24) {
          // CIRCLE - Heals over time
          color = "#00ff88";
          glowColor = "#00ffaa";
          type = "circle";
          hasShield = false;
          isRanged = false;
          speed *= 0.6; // Slow
          hp *= 1.5; // More HP
          size = 36;
        } else if (rand < 0.36) {
          // JUMPER - Jumps ahead periodically
          color = "#ff00ff";
          glowColor = "#ff88ff";
          type = "jumper";
          hasShield = false;
          isRanged = false;
          speed *= 0.8;
          size = 32;
        } else if (rand < 0.45) {
          // KAMIKAZE - Fastest, explodes on contact
          color = "#ff8800";
          glowColor = "#ffaa00";
          type = "kamikaze";
          hasShield = false;
          isRanged = false;
          speed *= 3.0; // Fastest!
          hp *= 0.3; // Very low HP
          size = 24;
        } else if (rand < 0.60 && wave >= 15) {
          // SHIELDED - Blue with shield (Wave 15+ only)
          color = "#4444ff";
          glowColor = "#4444ff";
          type = "shielded";
          hasShield = true;
          isRanged = false;
          
          // Shield HP scales with wave
          hp = 50 + (wave * 10) + Math.pow(wave, 1.6) * 1.2;
        } else if (rand < 0.75) {
          // SHOOTER - Ranged attacker
          color = "#ff4444";
          glowColor = "#ffaa00";
          type = "shooter";
          hasShield = false;
          isRanged = true;
          speed *= 0.7;
        }
        // NEW ENEMY TYPES - Unlock at higher waves
        else if (rand < 0.78 && wave >= 15) {
          // ARMORED - High HP, slow, always shielded (Wave 15+)
          color = "#888888";
          glowColor = "#aaaaaa";
          type = "armored";
          hasShield = true;
          isRanged = false;
          speed *= 0.5; // Very slow
          hp *= 2.0; // Double HP!
          size = 44; // Larger
        } else if (rand < 0.81 && wave >= 20) {
          // SPLITTER - Splits into 2 on death (Wave 20+)
          color = "#ff00ff";
          glowColor = "#ff88ff";
          type = "splitter";
          hasShield = false;
          isRanged = false;
          speed *= 0.9;
          hp *= 1.2;
          size = 36;
        } else if (rand < 0.84 && wave >= 25) {
          // TELEPORTER - Randomly teleports (Wave 25+)
          color = "#00ffff";
          glowColor = "#88ffff";
          type = "teleporter";
          hasShield = false;
          isRanged = false;
          speed *= 0.7;
          size = 32;
        } else if (rand < 0.87 && wave >= 30) {
          // BERSERKER - Gets faster when low HP (Wave 30+)
          color = "#ff0000";
          glowColor = "#ff4400";
          type = "berserker";
          hasShield = false;
          isRanged = false;
          speed *= 1.0;
          hp *= 1.3;
          size = 38;
        } else if (rand < 0.90 && wave >= 35) {
          // DRAINER - Steals HP on hit (Wave 35+)
          color = "#8800ff";
          glowColor = "#aa44ff";
          type = "drainer";
          hasShield = false;
          isRanged = false;
          speed *= 0.8;
          hp *= 1.4;
          size = 34;
        } else if (rand < 0.93 && wave >= 40) {
          // SUMMONER - Spawns minion enemies (Wave 40+)
          color = "#ffaa00";
          glowColor = "#ffcc44";
          type = "summoner";
          hasShield = false;
          isRanged = false;
          speed *= 0.6; // Slow
          hp *= 1.6;
          size = 40;
        } else {
          // GRUNT - Basic enemy
          color = "#ff4444";
          glowColor = "#ff0000";
          type = "grunt";
          hasShield = false;
          isRanged = false;
        }
        
        // Damage scales - EXPONENTIAL at wave 25+
        if (wave < 25) {
          damage = 20 + Math.floor(wave / 5) * 4;
        } else {
          // Wave 25+: Much higher damage!
          const baseDamage = 40;
          const scalingDamage = (wave - 24) * 8; // +8 per wave
          damage = baseDamage + scalingDamage;
        }
        
        // Kamikaze does massive explosion damage
        if (type === "kamikaze") {
          damage = 50 + wave * 5; // Much higher damage
        }
        
        pattern = null;
      }
      
      const enemy = {
        x: canvas.width + 30,
        y: GROUND_Y - size,
        vx: -speed,
        w: size,
        h: size,
        maxHP: hp,
        hp: hp,
        color: color,
        glowColor: glowColor,
        type: type,
        isBoss: isBoss,
        isMiniBoss: isMiniBoss,
        baseSpeed: speed,
        damage: damage,
        hasShield: hasShield,
        shieldHP: hasShield ? getShieldHP(wave, isBoss, isMiniBoss) : 0,
        maxShieldHP: hasShield ? getShieldHP(wave, isBoss, isMiniBoss) : 0,
        isRanged: isRanged,
        shootTimer: 0,
        shootCooldown: 2.5 + Math.random(),
        attackTimer: 0,
        attackCooldown: 1.5,
        // New AI state machine for attack behavior
        attackState: "approaching", // States: "approaching", "attacking", "returning", "waiting"
        savedAttackX: null, // Position where enemy stopped to attack
        pattern: pattern,
        patternTimer: 0,
        animFrame: 0,
        // Special properties for new enemy types
        healTimer: 0,
        healCooldown: 2, // Circle heals every 2 seconds
        jumpTimer: 0,
        jumpCooldown: 3 + Math.random() * 2, // Jumper jumps every 3-5 seconds
        // New enemy type properties
        teleportTimer: 0,
        teleportCooldown: 5, // Teleporter teleports every 5 seconds
        berserkerEnraged: false, // Berserker speed boost when low HP
        drainAmount: 5 + Math.floor(wave / 5), // Drainer HP steal amount
        summonTimer: 0,
        summonCooldown: 8, // Summoner spawns minion every 8 seconds
        summonCount: 0, // Track how many minions spawned
        isSplitterChild: false, // Track if this is a split offspring
        shape: type === "triangle" ? "triangle" : type === "circle" ? "circle" : "square"
      };
      
      enemies.push(enemy);
    }

    // CURRENCY SYSTEM
    function dropCurrency(x, y, coins, gems) {
      if (coins > 0) {
        currencyDrops.push({
          x: x,
          y: y,
          type: "coin",
          amount: coins,
          vy: -3,
          life: 5
        });
      }
      if (gems > 0) {
        currencyDrops.push({
          x: x,
          y: y + 20,
          type: "gem",
          amount: gems,
          vy: -2.5,
          life: 5
        });
      }
    }

    function updateCurrencyDrops(dt) {
      for (let i = currencyDrops.length - 1; i >= 0; i--) {
        const drop = currencyDrops[i];
        
        drop.vy += 0.3; // Gravity
        drop.y += drop.vy;
        drop.x += (PLAYER_X + player.w / 2 - drop.x) * 0.05; // Move toward player
        
        drop.life -= dt;
        
        // Collect if close to player
        const dx = drop.x - (player.x + player.w / 2);
        const dy = drop.y - (player.y + player.h / 2);
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < 50) {
          // Apply Thief coin/gem multiplier (5x)
          const coinMult = CLASSES[player.className]?.stats?.coinMultiplier || 1;
          const gemMult = CLASSES[player.className]?.stats?.gemMultiplier || 1;
          
          if (drop.type === "coin") {
            const amount = drop.amount * coinMult;
            sessionCoins += amount;
            gameData.totalCoins += amount;
            addFloatingText(drop.x, drop.y, `+${Math.floor(amount)} üí∞`, coinMult > 1 ? "#ffff00" : "#ffff00");
          } else {
            const amount = drop.amount * gemMult;
            sessionGems += amount;
            gameData.totalGems += amount;
            addFloatingText(drop.x, drop.y, `+${Math.floor(amount)} üíé`, gemMult > 1 ? "#00ff00" : "#00ffff");
          }
          currencyDrops.splice(i, 1);
          continue;
        }
        
        if (drop.life <= 0 || drop.y > canvas.height) {
          currencyDrops.splice(i, 1);
        }
      }
    }

    // ENEMY UPDATES
    function updateEnemies(dt) {
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        
        // BOSS SPECIAL ABILITIES
        if (e.pattern) {
          e.patternTimer += dt;
          
          if (e.pattern.pattern === "charge" && e.patternTimer > 5) {
            // Speed burst every 5 seconds
            e.vx = -e.baseSpeed * 3;
            setTimeout(() => { e.vx = -e.baseSpeed; }, 1000);
            e.patternTimer = 0;
          } else if (e.pattern.pattern === "summon" && e.patternTimer > 6) {
            // Spawn 2 extra enemies
            for (let j = 0; j < 2; j++) {
              setTimeout(() => spawnEnemy(false, false), j * 500);
            }
            addFloatingText(canvas.width / 2, 200, "Boss summons minions!", "#ff00ff");
            e.patternTimer = 0;
          } else if (e.pattern.pattern === "tank" && e.shieldHP <= 0 && e.hp < e.maxHP * 0.5 && e.patternTimer > 8) {
            // Regenerate shield at 50% HP
            e.shieldHP = e.maxShieldHP;
            addFloatingText(e.x + e.w / 2, e.y - 30, "SHIELD REGEN!", "#00aaff");
            e.patternTimer = 0;
          } else if (e.pattern.pattern === "berserk") {
            // Speed increases as HP lowers
            const hpPercent = e.hp / e.maxHP;
            e.vx = -e.baseSpeed * (2 - hpPercent);
          } else if (e.pattern.pattern === "headthrow" && e.patternTimer > 3) {
            // Throws head as projectile every 3 seconds
            const ex = e.x + e.w / 2;
            const ey = e.y + e.h / 4; // Head position (top quarter)
            const px = player.x + player.w / 2;
            const py = player.y + player.h / 2;
            
            let dx = px - ex;
            let dy = py - ey;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            dx /= dist;
            dy /= dist;
            
            // Throw spinning head
            projectiles.push({
              x: ex, y: ey,
              vx: dx * 10, vy: dy * 10,
              radius: 20, // Large head projectile
              damage: e.damage * 1.5, // Massive damage
              color: "#8B0000",
              glowColor: "#ff0000",
              life: 5,
              trail: [],
              isEnemyProjectile: true,
              isHeadProjectile: true, // Special flag for visual
              rotation: 0
            });
            
            addFloatingText(e.x + e.w / 2, e.y - 40, "üíÄ HEAD THROW!", "#ff0000");
            spawnExplosion(ex, ey, "#8B0000", 12);
            screenShake += 10;
            e.patternTimer = 0;
          }
        }
        
        // SPECIAL ENEMY TYPE BEHAVIORS
        if (e.type === "circle") {
          // Circle heals over time
          e.healTimer += dt;
          if (e.healTimer >= e.healCooldown) {
            e.hp = Math.min(e.hp + e.maxHP * 0.05, e.maxHP); // Heal 5% max HP
            addFloatingText(e.x + e.w / 2, e.y - 20, "+HP", "#00ff00", 0.5);
            e.healTimer = 0;
          }
        } else if (e.type === "jumper") {
          // Jumper teleports forward periodically
          e.jumpTimer += dt;
          if (e.jumpTimer >= e.jumpCooldown) {
            e.x -= 200; // Jump forward 200 pixels
            addFloatingText(e.x + e.w / 2, e.y - 20, "JUMP!", "#ff00ff", 0.5);
            // Visual effect
            spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, "#ff00ff", 8);
            e.jumpTimer = 0;
          }
        } else if (e.type === "kamikaze" && e.x + e.w < player.x + player.w) {
          // Kamikaze explodes when it reaches player
          screenShake += 15;
          spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, "#ff8800", 20);
          addFloatingText(e.x + e.w / 2, e.y - 30, "üí• BOOM! üí•", "#ff8800");
          
          // Damage player
          const damageDealt = damagePlayer(e.damage);
          if (damageDealt > 0) {
            addFloatingText(player.x + player.w / 2, player.y - 30, `-${damageDealt} HP`, "#ff0000");
          }
          
          // Remove kamikaze (it died)
          enemies.splice(i, 1);
          continue;
        }
        
        // NEW ENEMY TYPE BEHAVIORS
        
        // TELEPORTER: Randomly teleports around the screen
        if (e.type === "teleporter") {
          e.teleportTimer += dt;
          if (e.teleportTimer >= e.teleportCooldown) {
            // Teleport to random position
            const oldX = e.x;
            const oldY = e.y;
            e.x = Math.random() * (canvas.width - 200) + 100;
            e.y = Math.random() * (GROUND_Y - 250) + 100;
            
            // Visual effects at old and new positions
            spawnExplosion(oldX + e.w/2, oldY + e.h/2, "#00ffff", 15);
            spawnExplosion(e.x + e.w/2, e.y + e.h/2, "#00ffff", 15);
            addFloatingText(e.x + e.w / 2, e.y - 20, "TELEPORT!", "#00ffff", 0.7);
            
            e.teleportTimer = 0;
            e.teleportCooldown = 4 + Math.random() * 2; // Random cooldown
          }
        }
        
        // BERSERKER: Gets faster when low HP
        else if (e.type === "berserker") {
          const hpPercent = e.hp / e.maxHP;
          if (hpPercent < 0.3 && !e.berserkerEnraged) {
            // Enrage at 30% HP!
            e.berserkerEnraged = true;
            e.vx = e.baseSpeed * -2; // Double speed!
            e.color = "#ff4400"; // Brighter red
            addFloatingText(e.x + e.w / 2, e.y - 30, "ENRAGED!", "#ff0000");
            screenShake += 8;
            spawnExplosion(e.x + e.w/2, e.y + e.h/2, "#ff0000", 20);
          }
        }
        
        // DRAINER: Heals itself when hitting player
        // (Handled in player damage function)
        
        // SUMMONER: Spawns minion enemies periodically
        else if (e.type === "summoner") {
          e.summonTimer += dt;
          if (e.summonTimer >= e.summonCooldown && enemies.length < 50 && e.summonCount < 3) {
            // Spawn a smaller minion enemy
            const minion = {
              x: e.x,
              y: e.y,
              vx: -e.baseSpeed * 1.2,
              w: 20,
              h: 20,
              maxHP: e.maxHP * 0.3,
              hp: e.maxHP * 0.3,
              color: "#ffcc00",
              glowColor: "#ffee88",
              type: "grunt",
              isBoss: false,
              isMiniBoss: false,
              baseSpeed: e.baseSpeed * 1.2,
              damage: e.damage * 0.5,
              hasShield: false,
              shieldHP: 0,
              maxShieldHP: 0,
              isRanged: false,
              shootTimer: 0,
              shootCooldown: 2.5,
              attackTimer: 0,
              attackCooldown: 1.5,
              attackState: "approaching",
              savedAttackX: null,
              pattern: null,
              patternTimer: 0,
              animFrame: 0,
              healTimer: 0,
              healCooldown: 2,
              jumpTimer: 0,
              jumpCooldown: 5,
              teleportTimer: 0,
              teleportCooldown: 5,
              berserkerEnraged: false,
              drainAmount: 0,
              summonTimer: 0,
              summonCooldown: 8,
              summonCount: 0,
              isSplitterChild: false,
              shape: "square"
            };
            
            enemies.push(minion);
            e.summonCount++;
            e.summonTimer = 0;
            addFloatingText(e.x + e.w / 2, e.y - 30, "SUMMON!", "#ffaa00");
            spawnExplosion(e.x + e.w/2, e.y + e.h/2, "#ffaa00", 12);
          }
        }
        
        // Ranged enemies shoot
        if (e.isRanged && player.alive) {
          e.shootTimer += dt;
          const distToPlayer = Math.abs(e.x - player.x);
          
          // Shooters need to get within 300 pixels to shoot
          if (distToPlayer <= 300) {
            // In range - stop and shoot
            e.vx = 0;
            
            if (e.shootTimer >= e.shootCooldown) {
              e.shootTimer = 0;
              e.shootCooldown = 2 + Math.random() * 1.5;
              
              // Boss triple shot
              const shots = (e.pattern && e.pattern.pattern === "ranged") ? 3 : 1;
              
              for (let s = 0; s < shots; s++) {
                setTimeout(() => {
                  const ex = e.x + e.w / 2;
                  const ey = e.y + e.h / 2;
                  const px = player.x + player.w / 2;
                  const py = player.y + player.h / 2;
                  
                  let dx = px - ex;
                  let dy = py - ey;
                  const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                  dx /= dist;
                  dy /= dist;
                  
                  // Add spread for triple shot
                  if (shots > 1) {
                    const angle = Math.atan2(dy, dx) + (s - 1) * 0.3;
                    dx = Math.cos(angle);
                    dy = Math.sin(angle);
                  }
                  
                  projectiles.push({
                    x: ex, y: ey,
                    vx: dx * 7, vy: dy * 7, // Faster projectiles
                    radius: 8,
                    damage: e.damage * 0.6,
                    color: "#ff4444",
                    glowColor: "#ff0000",
                    life: 3,
                    trail: [],
                    isEnemyProjectile: true
                  });
                }, s * 200);
              }
              
              spawnHitParticles(e.x + e.w / 2, e.y + e.h / 2, "#ff8800", 6);
            }
          } else {
            // Not in range - move closer actively
            e.vx = -e.baseSpeed * 0.9; // Move toward player at 90% speed
          }
        }
        
        // Attack cooldown timer
        if (e.attackTimer > 0) {
          e.attackTimer -= dt;
        }
        
        // NEW AI STATE MACHINE
        // State: "approaching" - enemy moves toward player
        if (e.attackState === "approaching") {
          // Normal movement toward player
          if (!e.frozen) {
            e.x += e.vx;
          }
          
          // Check if close enough to attack (collision range)
          if (
            player.alive &&
            e.x < player.x + player.w + 5 && // Slightly ahead for better positioning
            e.x + e.w > player.x &&
            e.y < player.y + player.h &&
            e.y + e.h > player.y
          ) {
            // STOP! Save this position and prepare to attack
            e.attackState = "attacking";
            e.savedAttackX = e.x; // Save position to return to later
            e.vx = 0; // Stop moving
            e.attackTimer = 0; // Ready to attack immediately
          }
        }
        
        // State: "attacking" - enemy is stopped and attacking player
        else if (e.attackState === "attacking") {
          e.vx = 0; // Stay still
          
          // Attack when timer is ready
          if (e.attackTimer <= 0 && player.alive) {
            // Check if still in range
            if (
              e.x < player.x + player.w &&
              e.x + e.w > player.x &&
              e.y < player.y + player.h &&
              e.y + e.h > player.y
            ) {
              // ATTACK!
              let damage = e.damage || 20;
              
              if (player.shield > 0) {
                if (player.shield >= damage) {
                  player.shield -= damage;
                  damage = 0;
                } else {
                  damage -= player.shield;
                  player.shield = 0;
                }
              }
              
              player.hp -= damage;
              screenShake += 2;
              
              // DRAINER: Steals HP from player
              if (e.type === "drainer" && damage > 0) {
                const healAmount = Math.min(e.drainAmount, e.maxHP - e.hp);
                e.hp = Math.min(e.hp + healAmount, e.maxHP);
                addFloatingText(e.x + e.w / 2, e.y - 30, `+${healAmount} HP`, "#8800ff", 0.8);
                spawnHitParticles(e.x + e.w / 2, e.y + e.h / 2, "#8800ff", 6);
              }
              
              addFloatingText(player.x + player.w / 2, player.y - 10, "-" + Math.floor(damage), "#ff0000");
              spawnHitParticles(player.x + player.w / 2, player.y + player.h / 2, "#ff0000", 8);
              
              // After attacking, return to saved position
              e.attackState = "returning";
              e.attackTimer = 0; // Reset timer for return movement
              
              if (player.hp <= 0) {
                player.hp = 0;
                player.alive = false;
                endGame();
              }
            } else {
              // Player moved away - return to approaching
              e.attackState = "approaching";
              e.vx = -e.baseSpeed;
            }
          }
        }
        
        // State: "returning" - enemy moves back to saved position
        else if (e.attackState === "returning") {
          if (e.savedAttackX !== null) {
            const distanceToReturn = Math.abs(e.x - e.savedAttackX);
            
            if (distanceToReturn > 2) {
              // Move back toward saved position
              if (e.x < e.savedAttackX) {
                e.vx = e.baseSpeed; // Move right
              } else {
                e.vx = -e.baseSpeed * 0.5; // Move left slower
              }
              
              if (!e.frozen) {
                e.x += e.vx;
              }
            } else {
              // Reached saved position - now wait
              e.x = e.savedAttackX; // Snap to exact position
              e.vx = 0;
              e.attackState = "waiting";
              e.attackTimer = 1.5; // Wait 1.5 seconds before next attack
            }
          } else {
            // No saved position - go back to approaching
            e.attackState = "approaching";
            e.vx = -e.baseSpeed;
          }
        }
        
        // State: "waiting" - enemy waits at position before attacking again
        else if (e.attackState === "waiting") {
          e.vx = 0; // Stay still
          
          if (e.attackTimer <= 0) {
            // Wait time is up - advance toward player again!
            e.attackState = "approaching";
            e.vx = -e.baseSpeed; // Move toward player
          }
        }
        
        // Apply movement with debuffs
        if (!e.frozen && !e.stunned) {
          // Apply slow effect
          let moveSpeed = e.vx;
          if (e.slowAmount > 0) {
            moveSpeed *= (1 - e.slowAmount);
          }
          e.x += moveSpeed;
        }
        e.animFrame = ((e.animFrame || 0) + dt * 10) % 1;
        
        // Aura damage
        if (player.aura && player.alive) {
          const dx = (e.x + e.w / 2) - (player.x + player.w / 2);
          const dy = (e.y + e.h / 2) - (player.y + player.h / 2);
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < player.aura.radius) {
            if (e.hasShield && e.shieldHP > 0) {
              e.shieldHP -= player.aura.damage * dt;
            } else {
              e.hp -= player.aura.damage * dt;
            }
          }
        }

        // Check death
        if (e.hp <= 0) {
          // Hive Mind: Kill all linked enemies
          if (hiveMindActive && e.hiveMindLinked) {
            enemies.forEach(enemy => {
              if (enemy.hiveMindLinked && enemy !== e) {
                enemy.hp = 0;
              }
            });
            floatingText("üëÅÔ∏è HIVE MIND TRIGGERED!", canvas.width / 2, 150, "#ff0000", 2);
            screenShake += 15;
          }
          
          // Track kill for abilities
          onEnemyKilled(e);
          
          // Increment kill counter
          enemiesKilled++;
          
          let xpGain = 18 + 7 * wave;
          let coinReward = 1; // 1 coin per regular enemy
          let gemReward = 0; // Only bosses and mini-bosses drop gems
          
          // Regular enemies: 1 coin each (all sizes)
          if (!e.isMiniBoss && !e.isBoss) {
            coinReward = 1; // Flat 1 coin for all regular enemies
          }
          
          // Mini-bosses: 5 coins + 1 gem
          if (e.isMiniBoss) {
            xpGain *= 3;
            coinReward = 5; // Fixed 5 coins
            gemReward = 1; // Fixed 1 gem
          }
          
          // Bosses: 7 coins + 3 gems
          if (e.isBoss) {
            xpGain *= 8;
            coinReward = 7; // Fixed 7 coins
            gemReward = 3; // Fixed 3 gems
          }
          
          // IMMEDIATE REWARDS (no drops to collect!)
          const coinMult = CLASSES[player.className]?.stats?.coinMultiplier || 1;
          const gemMult = CLASSES[player.className]?.stats?.gemMultiplier || 1;
          
          const finalCoins = Math.floor(coinReward * coinMult);
          const finalGems = Math.floor(gemReward * gemMult);
          
          sessionCoins += finalCoins;
          gameData.totalCoins += finalCoins;
          
          if (finalGems > 0) {
            sessionGems += finalGems;
            gameData.totalGems += finalGems;
          }
          
          // Console log for debugging
          console.log(`üíÄ Enemy killed! Wave ${wave} | Coins: +${finalCoins} (Total: ${gameData.totalCoins}) | Gems: +${finalGems} | Boss: ${e.isBoss} | MiniBoss: ${e.isMiniBoss}`);
          
          // Give XP
          giveXP(xpGain);
          
          // Show rewards as floating text
          if (finalCoins > 0) {
            // Bigger text for bosses/mini-bosses
            const textSize = (e.isBoss || e.isMiniBoss) ? 2.5 : 1.5;
            addFloatingText(e.x + e.w / 2, e.y - 20, `+${finalCoins} üí∞`, "#ffff00", textSize);
          }
          if (finalGems > 0) {
            const textSize = (e.isBoss || e.isMiniBoss) ? 2.5 : 1.5;
            addFloatingText(e.x + e.w / 2, e.y - 40, `+${finalGems} üíé`, "#00ffff", textSize);
          }
          
          // Extra large text for boss kills
          if (e.isBoss) {
            addFloatingText(e.x + e.w / 2, e.y - 80, `üí∞ BOSS BONUS! üí∞`, "#ffff00", 2);
          }
          if (e.isMiniBoss) {
            addFloatingText(e.x + e.w / 2, e.y - 80, `‚≠ê MINI-BOSS BONUS! ‚≠ê`, "#00ffff", 2);
          }
          
          spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, e.color, 15);
          
          // THEN handle boss wave completion
          if (e.isBoss) {
            // BOSS DEATH = START WAVE TIMER!
            enemiesToSpawn = 0;
            // Clear all remaining enemies
            for (let j = enemies.length - 1; j >= 0; j--) {
              if (enemies[j] !== e) {
                spawnExplosion(enemies[j].x + enemies[j].w / 2, enemies[j].y + enemies[j].h / 2, enemies[j].color, 10);
              }
            }
            enemies.length = 0; // Clear all
            
            addFloatingText(canvas.width / 2, 250, "üéâ BOSS DEFEATED! üéâ", "#ff00ff");
            addFloatingText(canvas.width / 2, 280, "Next wave in 30s!", "#ffff00");
            screenShake += 25;
            
            // Start 30-second timer for next wave
            waveTimer = 30;
            waveTimerActive = true;
          }
          
          // Necromancer: Spawn skeleton minion
          if (player.spawnSkeletonsOnKill && Math.random() < 0.3) {
            spawnMinion();
            addFloatingText(player.x + player.w / 2, player.y - 40, "Skeleton Raised!", "#9933ff");
          }
          
          combo++;
          comboTimer = 2.0;
          if (combo > maxCombo) maxCombo = combo;
          
          enemiesKilled++; // Track kills for stats
          
          // SPLITTER: Splits into 2 smaller enemies on death
          if (e.type === "splitter" && !e.isSplitterChild) {
            // Spawn 2 smaller split offspring
            for (let split = 0; split < 2; split++) {
              const splitEnemy = {
                x: e.x + (split * 20),
                y: e.y,
                vx: -e.baseSpeed * 1.3,
                w: e.w * 0.7, // Smaller
                h: e.h * 0.7,
                maxHP: e.maxHP * 0.4, // 40% HP
                hp: e.maxHP * 0.4,
                color: "#cc00cc",
                glowColor: "#ff44ff",
                type: "splitter",
                isBoss: false,
                isMiniBoss: false,
                baseSpeed: e.baseSpeed * 1.3,
                damage: e.damage * 0.6,
                hasShield: false,
                shieldHP: 0,
                maxShieldHP: 0,
                isRanged: false,
                shootTimer: 0,
                shootCooldown: 2.5,
                attackTimer: 0,
                attackCooldown: 1.5,
                attackState: "approaching",
                savedAttackX: null,
                pattern: null,
                patternTimer: 0,
                animFrame: 0,
                healTimer: 0,
                healCooldown: 2,
                jumpTimer: 0,
                jumpCooldown: 5,
                teleportTimer: 0,
                teleportCooldown: 5,
                berserkerEnraged: false,
                drainAmount: 0,
                summonTimer: 0,
                summonCooldown: 8,
                summonCount: 0,
                isSplitterChild: true, // Mark as child so it doesn't split again
                shape: "square"
              };
              
              enemies.push(splitEnemy);
            }
            
            addFloatingText(e.x + e.w / 2, e.y - 40, "SPLIT!", "#ff00ff", 1.5);
            spawnExplosion(e.x + e.w/2, e.y + e.h/2, "#ff00ff", 20);
            screenShake += 6;
          }
          
          if (!e.isBoss) { // Boss already cleared enemies array above
            enemies.splice(i, 1);
          }
          continue;
        }

        if (e.x + e.w < -50) {
          enemies.splice(i, 1);
        }
      }
    }

    // SHOOTING
    function handleShooting(dt) {
      shootTimer += dt;
      const target = getTargetEnemy();
      
      if (!autoShoot || !target) return;

      if (shootTimer >= player.fireRate) {
        shootTimer = 0;
        shootProjectile(target);
        
        // Multishot: Fire additional shots based on multiShot level
        // multiShot = 1: 2 total shots, multiShot = 2: 3 total shots, etc.
        if (player.multiShot > 0) {
          for (let i = 0; i < player.multiShot; i++) {
            setTimeout(() => {
              const currentTarget = getTargetEnemy();
              if (currentTarget) {
                shootProjectile(currentTarget, 0);
              }
            }, 100 * (i + 1)); // Stagger shots by 100ms each
          }
        }
      }
    }

    function getTargetEnemy() {
      if (enemies.length === 0) return null;
      
      // Overwatch: Target highest HP enemy
      if (overwatchActive) {
        let highestHP = null;
        let maxHP = 0;
        
        for (const e of enemies) {
          const dx = (e.x + e.w / 2) - (player.x + player.w / 2);
          const dy = (e.y + e.h / 2) - (player.y + player.h / 2);
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < player.range && e.hp > maxHP) {
            maxHP = e.hp;
            highestHP = e;
          }
        }
        
        return highestHP;
      }
      
      if (!autoAim) {
        return enemies.find(e => 
          Math.abs((e.x + e.w / 2) - (player.x + player.w / 2)) < player.range
        ) || null;
      }
      
      let closestInRange = null;
      let closestDist = player.range;
      
      for (const e of enemies) {
        const dx = (e.x + e.w / 2) - (player.x + player.w / 2);
        const dy = (e.y + e.h / 2) - (player.y + player.h / 2);
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < closestDist) {
          closestDist = dist;
          closestInRange = e;
        }
      }
      
      return closestInRange;
    }

    function shootProjectile(target, angleOffset = 0) {
      const px = player.x + player.w / 2;
      const py = player.y + player.h / 2;
      const tx = target.x + target.w / 2;
      const ty = target.y + target.h / 2;

      let dx = tx - px;
      let dy = ty - py;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      dx /= dist;
      dy /= dist;

      if (angleOffset !== 0) {
        const angle = Math.atan2(dy, dx) + (angleOffset * Math.PI / 180);
        dx = Math.cos(angle);
        dy = Math.sin(angle);
      }

      let isCrit = false;
      if (player.critChance && Math.random() < player.critChance) {
        isCrit = true;
      }
      
      // Headhunter: Guaranteed 5x crits
      if (headhunterShots > 0) {
        isCrit = true;
        headhunterShots--;
      }
      
      // Chain Reaction: Double explosion radius
      let explosiveRadius = player.explosive ? player.explosionRadius : 0;
      if (chainReactionShots > 0) {
        explosiveRadius = player.explosionRadius * 2; // Double the player's base explosion radius
        chainReactionShots--;
      }
      
      // Calculate potion damage bonus
      const totalPotions = potions.heal + potions.shield + potions.crit + potions.damage + potions.speed + potions.dragon;
      const potionDamageBonus = totalPotions * gameData.potionUpgrades.potionDamage * 2;
      const finalDamage = player.damage + potionDamageBonus;
      
      let critMultiplier = player.critMultiplier || 1.0;
      if (headhunterShots >= 0 && isCrit) {
        critMultiplier = 5.0; // Headhunter 5x crits
      }

      const classStats = CLASSES[player.className]?.stats || {};
      
      // Berserk: Scale damage based on HP
      let berserkMultiplier = 1.0;
      if (classStats.berserkMode) {
        const hpPercent = player.hp / player.maxHP;
        if (hpPercent <= classStats.lowHPThreshold) {
          berserkMultiplier = 1 + (classStats.maxDamageMultiplier - 1) * (1 - (hpPercent / classStats.lowHPThreshold));
        }
      }
      
      const berserkDamage = finalDamage * berserkMultiplier;
      
      // Samurai: Screen-wide slash
      if (player.className === "Samurai") {
        projectiles.push({
          x: px, y: py,
          vx: dx * player.projectileSpeed,
          vy: dy * player.projectileSpeed,
          radius: 8,
          damage: berserkDamage,
          color: isCrit ? "#ff0000" : player.bulletColor,
          glowColor: isCrit ? "#ff0000" : player.glowColor,
          life: 3.5,
          trail: [],
          pierce: true,
          pierceCount: 0,
          explosive: false,
          isCrit: isCrit,
          critMultiplier: critMultiplier,
          chainLightning: 0,
          isEnemyProjectile: false,
          isSamuraiSlash: true,
          slashKnockback: classStats.slashKnockback,
          chainReaction: classStats.chainReaction,
          chainDamageBonus: classStats.chainDamageBonus
        });
      }
      // Guardian Tank: Create rotating shield projectile
      else if (player.className === "GuardianTank") {
        projectiles.push({
          x: px, y: py,
          vx: dx * player.projectileSpeed,
          vy: dy * player.projectileSpeed,
          radius: 12,
          damage: berserkDamage,
          color: isCrit ? "#ff0000" : player.bulletColor,
          glowColor: isCrit ? "#ff0000" : player.glowColor,
          life: 3.5,
          trail: [],
          pierce: false,
          pierceCount: 0,
          explosive: false,
          isCrit: isCrit,
          critMultiplier: critMultiplier,
          chainLightning: 0,
          isEnemyProjectile: false,
          isShield: true,
          rotation: 0,
          knockback: player.knockback || 80
        });
      }
      // Gunslinger: Dual guns with ricochet
      else if (player.className === "Gunslinger") {
        // Fire from both guns
        projectiles.push({
          x: px - 5, y: py,
          vx: dx * player.projectileSpeed,
          vy: dy * player.projectileSpeed,
          radius: 4,
          damage: berserkDamage,
          color: isCrit ? "#ff0000" : player.bulletColor,
          glowColor: isCrit ? "#ff0000" : player.glowColor,
          life: 3.5,
          trail: [],
          pierce: false,
          pierceCount: 0,
          explosive: false,
          isCrit: isCrit,
          critMultiplier: critMultiplier,
          chainLightning: 0,
          isEnemyProjectile: false,
          ricochetOffWalls: classStats.ricochetOffWalls,
          maxRicochets: classStats.maxRicochets,
          ricochetCount: 0
        });
        projectiles.push({
          x: px + 5, y: py,
          vx: dx * player.projectileSpeed,
          vy: dy * player.projectileSpeed,
          radius: 4,
          damage: berserkDamage,
          color: isCrit ? "#ff0000" : player.bulletColor,
          glowColor: isCrit ? "#ff0000" : player.glowColor,
          life: 3.5,
          trail: [],
          pierce: false,
          pierceCount: 0,
          explosive: false,
          isCrit: isCrit,
          critMultiplier: critMultiplier,
          chainLightning: 0,
          isEnemyProjectile: false,
          ricochetOffWalls: classStats.ricochetOffWalls,
          maxRicochets: classStats.maxRicochets,
          ricochetCount: 0
        });
      }
      // TrickshotRogue: Bouncing shots
      else if (player.className === "TrickshotRogue") {
        projectiles.push({
          x: px, y: py,
          vx: dx * player.projectileSpeed,
          vy: dy * player.projectileSpeed,
          radius: 5,
          damage: berserkDamage,
          color: isCrit ? "#ff0000" : player.bulletColor,
          glowColor: isCrit ? "#ff0000" : player.glowColor,
          life: 3.5,
          trail: [],
          pierce: false,
          pierceCount: 0,
          explosive: false,
          isCrit: isCrit,
          critMultiplier: critMultiplier,
          chainLightning: 0,
          isEnemyProjectile: false,
          ricochetShots: classStats.ricochetShots,
          ricochetCount: 0,
          ricochetDamageIncrease: classStats.ricochetDamageIncrease,
          hitEnemies: []
        });
      }
      // Warlock: Shield-piercing projectiles
      else if (player.className === "Warlock") {
        projectiles.push({
          x: px, y: py,
          vx: dx * player.projectileSpeed,
          vy: dy * player.projectileSpeed,
          radius: 6,
          damage: berserkDamage,
          color: isCrit ? "#ff0000" : player.bulletColor,
          glowColor: isCrit ? "#ff0000" : player.glowColor,
          life: 3.5,
          trail: [],
          pierce: false,
          pierceCount: 0,
          explosive: false,
          isCrit: isCrit,
          critMultiplier: critMultiplier,
          chainLightning: 0,
          isEnemyProjectile: false,
          ignoreShields: classStats.ignoreShields,
          weakenEnemies: classStats.weakenEnemies,
          weakenAmount: classStats.weakenAmount,
          weakenDuration: classStats.weakenDuration
        });
      }
      // Normal projectile for other classes
      else {
        const proj = {
          x: px, y: py,
          vx: dx * player.projectileSpeed,
          vy: dy * player.projectileSpeed,
          radius: 5,
          damage: berserkDamage,
          color: isCrit ? "#ff0000" : player.bulletColor,
          glowColor: isCrit ? "#ff0000" : player.glowColor,
          life: 3.5,
          trail: [],
          pierce: player.pierce,
          pierceCount: 0,
          explosive: player.explosive || explosiveRadius > 0,
          explosionRadius: explosiveRadius,
          explosionDamage: player.explosionDamage,
          isCrit: isCrit,
          critMultiplier: critMultiplier,
          chainLightning: player.chainLightning || 0,
          poison: player.poison,
          isEnemyProjectile: false
        };
        
        // Pyromancer: Create fire zones
        if (classStats.fireZones) {
          proj.createFireZone = true;
          proj.fireZoneDuration = classStats.fireZoneDuration;
          proj.fireZoneDamage = classStats.fireZoneDamage;
        }
        
        // CryoSentinel: Create ice shards
        if (classStats.iceShards) {
          proj.createIceShard = true;
          proj.iceShardDamage = classStats.iceShardDamage;
          proj.iceShardDuration = classStats.iceShardDuration;
          proj.iceShardSlowAmount = classStats.iceShardSlowAmount;
        }
        
        projectiles.push(proj);
      }
    }

    // PROJECTILE UPDATES
    function updateProjectiles(dt) {
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        
        if (p.trail.length > 8) p.trail.shift();
        p.trail.push({ x: p.x, y: p.y });
        
        p.x += p.vx;
        p.y += p.vy;
        p.life -= dt;
        
        // Rotate shield projectile
        if (p.isShield) {
          p.rotation = (p.rotation || 0) + 0.15; // Rotate continuously
        }
        
        // Gunslinger: Wall ricochet
        if (p.ricochetOffWalls && p.ricochetCount < p.maxRicochets) {
          const groundY = GROUND_Y || canvas.height - 50;
          
          // Hit floor
          if (p.y >= groundY - 5) {
            p.vy = -Math.abs(p.vy);
            p.ricochetCount++;
            spawnHitParticles(p.x, p.y, "#FFD700", 6);
          }
          // Hit ceiling
          if (p.y <= 5) {
            p.vy = Math.abs(p.vy);
            p.ricochetCount++;
            spawnHitParticles(p.x, p.y, "#FFD700", 6);
          }
          // Hit left wall
          if (p.x <= 5) {
            p.vx = Math.abs(p.vx);
            p.ricochetCount++;
            spawnHitParticles(p.x, p.y, "#FFD700", 6);
          }
          // Hit right wall
          if (p.x >= canvas.width - 5) {
            p.vx = -Math.abs(p.vx);
            p.ricochetCount++;
            spawnHitParticles(p.x, p.y, "#FFD700", 6);
          }
        }

        if (p.life <= 0 || p.x < -50 || p.x > canvas.width + 50 || p.y < -50 || p.y > canvas.height + 50) {
          projectiles.splice(i, 1);
          continue;
        }

        // Enemy projectile hitting player
        if (p.isEnemyProjectile && player.alive) {
          if (p.x > player.x && p.x < player.x + player.w && p.y > player.y && p.y < player.y + player.h) {
            let damage = p.damage;
            
            if (player.shield > 0) {
              if (player.shield >= damage) {
                player.shield -= damage;
                damage = 0;
              } else {
                damage -= player.shield;
                player.shield = 0;
              }
            }
            
            player.hp -= damage;
            addFloatingText(p.x, p.y - 20, "-" + Math.floor(damage), "#ff0000"); // Show damage taken!
            spawnHitParticles(p.x, p.y, "#ff0000", 8);
            screenShake += 2;
            projectiles.splice(i, 1);
            
            if (player.hp <= 0) {
              player.hp = 0;
              player.alive = false;
              endGame();
            }
            continue;
          }
        }

        // Player projectile hitting enemies
        if (!p.isEnemyProjectile) {
          for (let j = enemies.length - 1; j >= 0; j--) {
            const e = enemies[j];
            if (p.x > e.x && p.x < e.x + e.w && p.y > e.y && p.y < e.y + e.h) {
              let actualDamage = p.damage;
              if (p.isCrit) {
                actualDamage *= p.critMultiplier;
                addFloatingText(e.x + e.w / 2, e.y - 30, "CRIT!", "#ff0000");
              }
              
              // Warlock: Ignore shields
              if (p.ignoreShields) {
                addFloatingText(e.x + e.w / 2, e.y - 10, "PIERCE!", "#4B0082");
                // Apply weaken effect
                if (p.weakenEnemies) {
                  e.weakened = true;
                  e.weakenAmount = p.weakenAmount;
                  e.weakenDuration = p.weakenDuration;
                }
              } else {
                // Damage shield first
                if (e.hasShield && e.shieldHP > 0) {
                  if (e.shieldHP >= actualDamage) {
                    e.shieldHP -= actualDamage;
                    actualDamage = 0;
                    addFloatingText(e.x + e.w / 2, e.y - 10, "SHIELD", "#00aaff");
                  } else {
                    actualDamage -= e.shieldHP;
                    e.shieldHP = 0;
                    addFloatingText(e.x + e.w / 2, e.y - 10, "SHIELD BROKEN!", "#ffaa00");
                  }
                }
              }
              
              // Apply weaken debuff if enemy is weakened
              if (e.weakened) {
                actualDamage *= (1 + e.weakenAmount);
              }
              
              e.hp -= actualDamage;
              
              // Pyromancer: Create fire zone on hit
              if (p.createFireZone) {
                fireZones.push({
                  x: e.x + e.w / 2,
                  y: e.y + e.h / 2,
                  radius: 80,
                  damage: p.fireZoneDamage,
                  life: p.fireZoneDuration
                });
                // Apply burn to enemy
                e.burning = true;
                e.burnDuration = p.fireZoneDuration;
                e.burnDPS = p.fireZoneDamage;
              }
              
              // CryoSentinel: Create ice shard on hit
              if (p.createIceShard && iceShards.length < 8) {
                iceShards.push({
                  x: e.x + e.w / 2,
                  y: e.y + e.h / 2,
                  angle: Math.random() * Math.PI * 2,
                  damage: p.iceShardDamage,
                  slowAmount: p.iceShardSlowAmount,
                  life: p.iceShardDuration,
                  hit: false
                });
              }
              
              // TrickshotRogue: Ricochet between enemies
              if (p.ricochetShots && p.ricochetCount < p.ricochetShots && !p.hitEnemies.includes(e)) {
                p.hitEnemies.push(e);
                p.ricochetCount++;
                p.damage *= (1 + p.ricochetDamageIncrease); // Increase damage
                
                // Find nearest enemy not yet hit
                let nearestEnemy = null;
                let minDist = Infinity;
                for (const otherE of enemies) {
                  if (otherE === e || p.hitEnemies.includes(otherE)) continue;
                  const dx = (otherE.x + otherE.w / 2) - p.x;
                  const dy = (otherE.y + otherE.h / 2) - p.y;
                  const dist = Math.sqrt(dx * dx + dy * dy);
                  if (dist < minDist && dist < 300) {
                    minDist = dist;
                    nearestEnemy = otherE;
                  }
                }
                
                if (nearestEnemy) {
                  const dx = (nearestEnemy.x + nearestEnemy.w / 2) - p.x;
                  const dy = (nearestEnemy.y + nearestEnemy.h / 2) - p.y;
                  const dist = Math.sqrt(dx * dx + dy * dy);
                  p.vx = (dx / dist) * player.projectileSpeed;
                  p.vy = (dy / dist) * player.projectileSpeed;
                  addFloatingText(p.x, p.y, "BOUNCE!", "#ff1493");
                  spawnHitParticles(p.x, p.y, "#ff1493", 8);
                  continue; // Don't remove projectile
                }
              }
              
              // Samurai: Chain reaction on kill
              if (p.isSamuraiSlash && e.hp <= 0 && p.chainReaction) {
                const chainDamage = p.damage * (1 + p.chainDamageBonus);
                for (const otherE of enemies) {
                  if (otherE === e) continue;
                  const dx = (otherE.x + otherE.w / 2) - (e.x + e.w / 2);
                  const dy = (otherE.y + otherE.h / 2) - (e.y + e.h / 2);
                  const dist = Math.sqrt(dx * dx + dy * dy);
                  if (dist < 200) {
                    otherE.hp -= chainDamage;
                    addFloatingText(otherE.x + otherE.w / 2, otherE.y - 30, "CHAIN!", "#C41E3A");
                    spawnExplosion(otherE.x + otherE.w / 2, otherE.y + otherE.h / 2, "#FF4500", 12);
                  }
                }
              }
              spawnHitParticles(p.x, p.y, p.color, p.isCrit ? 12 : 6);
              screenShake += p.isCrit ? 4 : 2;
              
              // Knockback (Guardian Tank or other knockback sources)
              if (p.knockback && p.knockback > 0) {
                const knockbackForce = p.knockback;
                const dx = e.x + e.w/2 - (player.x + player.w/2);
                const dy = e.y + e.h/2 - (player.y + player.h/2);
                const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                
                // Push enemy away
                e.x += (dx / dist) * knockbackForce * 0.8;
                e.y += (dy / dist) * knockbackForce * 0.8;
                
                // Visual feedback for knockback
                addFloatingText(e.x + e.w / 2, e.y - 40, "KNOCKBACK!", "#87ceeb");
                spawnExplosion(p.x, p.y, "#87ceeb", 15);
              }
              
              // Lifesteal
              if (player.lifesteal > 0) {
                const heal = actualDamage * player.lifesteal;
                if (player.shield < player.maxShield) {
                  player.shield = Math.min(player.shield + heal, player.maxShield);
                } else {
                  player.hp = Math.min(player.hp + heal, player.maxHP);
                }
              }
              
              // Upside Down lifesteal (50%)
              if (upsideDownActive) {
                const heal = actualDamage * 0.5;
                player.hp = Math.min(player.hp + heal, player.maxHP);
              }
              
              // Soul Harvest healing from poison
              if (soulHarvestActive && e.poisoned) {
                const heal = (e.poisonDamage || 5) * dt * 10;
                player.hp = Math.min(player.hp + heal, player.maxHP);
              }
              
              // Explosion
              if (p.explosive) {
                const explosionRadius = p.explosionRadius || 60;
                // Use custom explosion damage if specified (e.g., Bomber's 90 damage)
                // Otherwise use 50% of projectile damage
                const explosionDmg = p.explosionDamage || (actualDamage * 0.5);
                
                for (const otherEnemy of enemies) {
                  if (otherEnemy === e) continue;
                  const dx = (otherEnemy.x + otherEnemy.w / 2) - p.x;
                  const dy = (otherEnemy.y + otherEnemy.h / 2) - p.y;
                  const dist = Math.sqrt(dx * dx + dy * dy);
                  if (dist < explosionRadius) {
                    otherEnemy.hp -= explosionDmg;
                    addFloatingText(otherEnemy.x + otherEnemy.w / 2, otherEnemy.y - 20, "-" + Math.floor(explosionDmg), "#ff8800", 0.6);
                  }
                }
                spawnExplosion(p.x, p.y, "#ff8800", Math.min(15 + explosionRadius / 10, 30));
                screenShake += 6;
              }
              
              // Apply poison (Necromancer)
              if (p.poison && !e.poisonStacks) {
                e.poisonStacks = [];
              }
              if (p.poison) {
                e.poisonStacks.push({
                  damage: p.poison.damage,
                  duration: p.poison.duration
                });
              }
              
              // Chain lightning
              if (p.chainLightning > 0 && !p.hasChained) {
                p.hasChained = true;
                let chainsLeft = p.chainLightning;
                let lastTarget = e;
                
                while (chainsLeft > 0) {
                  let nearestDist = 150;
                  let nearestEnemy = null;
                  
                  for (const otherEnemy of enemies) {
                    if (otherEnemy === lastTarget) continue;
                    const dx = (otherEnemy.x + otherEnemy.w / 2) - (lastTarget.x + lastTarget.w / 2);
                    const dy = (otherEnemy.y + otherEnemy.h / 2) - (lastTarget.y + lastTarget.h / 2);
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < nearestDist) {
                      nearestDist = dist;
                      nearestEnemy = otherEnemy;
                    }
                  }
                  
                  if (nearestEnemy) {
                    nearestEnemy.hp -= actualDamage * 0.6;
                    spawnHitParticles(nearestEnemy.x + nearestEnemy.w / 2, nearestEnemy.y + nearestEnemy.h / 2, "#00ffff", 6);
                    lastTarget = nearestEnemy;
                    chainsLeft--;
                  } else {
                    break;
                  }
                }
              }
              
              if (p.pierce && p.pierceCount < 3) {
                p.pierceCount++;
              } else {
                projectiles.splice(i, 1);
              }
              
              if (!p.pierce) break;
            }
          }
        }
      }
    }

    // MINIONS (Summoner class)
    function spawnMinion() {
      minions.push({
        angle: Math.random() * Math.PI * 2,
        distance: 50 + Math.random() * 20,
        spinSpeed: 2 + Math.random(),
        tickTimer: 0
      });
    }

    function updateMinions(dt) {
      if (!player || player.className !== "Summoner") return;

      const px = player.x + player.w / 2;
      const py = player.y + player.h / 2 - 15;

      for (const m of minions) {
        m.angle += dt * m.spinSpeed;
        m.tickTimer += dt;

        if (m.tickTimer >= 0.3) {
          m.tickTimer = 0;
          const target = getTargetEnemy();
          if (target) {
            const mx = px + Math.cos(m.angle) * m.distance;
            const my = py + Math.sin(m.angle) * m.distance;

            let dx = target.x + target.w / 2 - mx;
            let dy = target.y + target.h / 2 - my;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            dx /= dist;
            dy /= dist;

            projectiles.push({
              x: mx, y: my,
              vx: dx * 6, vy: dy * 6,
              radius: 4,
              damage: player.damage * 0.5,
              color: "#88ff88",
              glowColor: "#88ff88",
              life: 2.5,
              trail: []
            });
          }
        }

        m.drawX = px + Math.cos(m.angle) * m.distance;
        m.drawY = py + Math.sin(m.angle) * m.distance;
      }
    }

    // XP & LEVELING
    function giveXP(amount) {
      if (!player || !player.alive) return;
      
      // Apply XP multiplier (Rookie gets 1.5x)
      const xpGained = amount * (player.xpMultiplier || 1.0);
      player.xp += xpGained;
      
      // Check for level up
      if (player.xp >= player.xpToNext) {
        player.level++;
        player.xp -= player.xpToNext;
        
        // Rookie special: At level 10+, XP requirement stays at level 10
        if (player.className === "Rookie" && player.level >= 10) {
          player.xpToNext = xpForLevel(10); // Always use level 10 requirement
        } else {
          player.xpToNext = xpForLevel(player.level);
        }
        
        showUpgradeScreen();
      }
    }

    let currentUpgradeOptions = []; // Store current options for shuffling

    function showUpgradeScreen() {
      gameState = "upgrading";
      
      // Award upgrade point
      upgradePoints++;
      
      // Show BTD-style upgrade tree
      showUpgradeTree();
    }
    
    function showUpgradeTree() {
      const upgradeTreeScreen = document.getElementById('upgradeTreeScreen');
      upgradeTreeScreen.classList.add('active');
      
      // Update header info
      document.getElementById('treePlayerLevel').textContent = player.level;
      document.getElementById('upgradePoints').textContent = upgradePoints;
      
      // Render all three paths
      renderUpgradePath('pathA', UPGRADE_TREE.pathA);
      renderUpgradePath('pathB', UPGRADE_TREE.pathB);
      renderUpgradePath('pathC', UPGRADE_TREE.pathC);
    }
    
    function renderUpgradePath(pathId, upgrades) {
      const pathContainer = document.getElementById(pathId);
      pathContainer.innerHTML = '';
      
      upgrades.forEach(upgrade => {
        const node = document.createElement('div');
        node.className = 'upgrade-node';
        
        // Check if purchased
        const isPurchased = purchasedUpgrades[pathId].includes(upgrade.id);
        
        // Check if available (requirements met)
        const isAvailable = !isPurchased && upgradePoints >= upgrade.cost && 
                           (!upgrade.requires || upgrade.requires.every(req => 
                             purchasedUpgrades[pathId].includes(req)
                           ));
        
        // Check if locked
        const isLocked = !isPurchased && !isAvailable;
        
        if (isPurchased) node.classList.add('purchased');
        else if (isAvailable) node.classList.add('available');
        else node.classList.add('locked');
        
        if (upgrade.master) node.classList.add('master');
        
        node.innerHTML = `
          <div class="upgrade-node-tier">Tier ${upgrade.tier}</div>
          <div class="upgrade-node-name">${upgrade.name}</div>
          <div class="upgrade-node-desc">${upgrade.desc}</div>
          <div class="upgrade-node-cost">${isPurchased ? '‚úì PURCHASED' : `Cost: ${upgrade.cost} ${upgrade.cost === 1 ? 'point' : 'points'}`}</div>
        `;
        
        if (isAvailable) {
          node.onclick = () => purchaseUpgrade(pathId, upgrade);
        }
        
        pathContainer.appendChild(node);
      });
    }
    
    function purchaseUpgrade(pathId, upgrade) {
      if (upgradePoints < upgrade.cost) return;
      
      // Deduct points
      upgradePoints -= upgrade.cost;
      
      // Mark as purchased
      purchasedUpgrades[pathId].push(upgrade.id);
      
      // Apply upgrade effect
      upgrade.effect(player);
      
      // Visual feedback
      addFloatingText(canvas.width / 2, 200, `${upgrade.name}!`, "#00ffff", 1.5);
      spawnExplosion(canvas.width / 2, 200, "#00ffff", 30);
      screenShake += 8;
      
      // Master class announcement
      if (upgrade.master) {
        addFloatingText(canvas.width / 2, 150, `‚≠ê ${player.masterClass.toUpperCase()} MASTER! ‚≠ê`, "#ff00ff", 2.0);
        screenShake += 15;
      }
      
      // Refresh the tree display
      showUpgradeTree();
    }

    function generateUpgradeOptions() {
      const availableUpgrades = Object.keys(UPGRADE_TYPES);
      const shuffled = availableUpgrades.sort(() => Math.random() - 0.5);
      currentUpgradeOptions = shuffled.slice(0, 3);
      
      upgradeOptions.innerHTML = "";
      
      // Add 3 upgrade cards
      currentUpgradeOptions.forEach(key => {
        const upgrade = UPGRADE_TYPES[key];
        const card = document.createElement("div");
        card.className = "upgrade-card";
        card.innerHTML = `
          <div class="upgrade-card-icon">${upgrade.icon}</div>
          <div class="upgrade-card-title">${upgrade.name}</div>
          <div class="upgrade-card-desc">${upgrade.desc}</div>
        `;
        card.onclick = () => selectUpgrade(key);
        upgradeOptions.appendChild(card);
      });
      
      // Add 4th card: "No Power-Up" option
      const skipCard = document.createElement("div");
      skipCard.className = "upgrade-card upgrade-card-skip";
      skipCard.innerHTML = `
        <div class="upgrade-card-icon">‚ùå</div>
        <div class="upgrade-card-title">No Power-Up</div>
        <div class="upgrade-card-desc">Skip and continue playing</div>
      `;
      skipCard.onclick = () => {
        upgradeScreen.classList.remove("active");
        gameState = "playing";
      };
      upgradeOptions.appendChild(skipCard);
    }

    function selectUpgrade(upgradeKey) {
      const upgrade = UPGRADE_TYPES[upgradeKey];
      
      // Store pre-upgrade values for Rookie multiplier calculation
      const preUpgrade = {};
      if (player.powerUpMultiplier > 1.0) {
        preUpgrade.damage = player.damage;
        preUpgrade.maxHP = player.maxHP;
        preUpgrade.shield = player.shield || 0;
        preUpgrade.maxShield = player.maxShield || 0;
      }
      
      // Apply the base upgrade
      upgrade.apply(player);
      
      // Apply Rookie power-up multiplier (20% bonus)
      if (player.powerUpMultiplier > 1.0) {
        const multiplier = player.powerUpMultiplier;
        
        // Apply multiplier to numeric increases
        if (upgradeKey === 'damage') {
          const increase = player.damage - preUpgrade.damage;
          player.damage = preUpgrade.damage + (increase * multiplier);
        } else if (upgradeKey === 'hp') {
          const increase = player.maxHP - preUpgrade.maxHP;
          player.maxHP = preUpgrade.maxHP + Math.floor(increase * multiplier);
          player.hp = player.maxHP; // Heal to new max
        } else if (upgradeKey === 'shield') {
          const shieldIncrease = (player.shield || 0) - preUpgrade.shield;
          const maxShieldIncrease = (player.maxShield || 0) - preUpgrade.maxShield;
          player.shield = preUpgrade.shield + Math.floor(shieldIncrease * multiplier);
          player.maxShield = preUpgrade.maxShield + Math.floor(maxShieldIncrease * multiplier);
        }
        // Percentage-based upgrades (fireRate, range, etc.) benefit from being applied multiple times
        // which happens naturally with the multiplier on the percentage
      }
      
      // Track shield upgrades for Guardian Tank unlock
      if (upgradeKey === 'shield') {
        shieldUpgradesChosen++;
        
        // Check if Guardian Tank should unlock
        if (shieldUpgradesChosen >= 5 && player.maxHP >= 200) {
          if (!gameData.unlockedClasses.includes("GuardianTank")) {
            gameData.unlockedClasses.push("GuardianTank");
            saveGameData();
            addFloatingText(canvas.width / 2, 150, "üõ°Ô∏è GUARDIAN TANK UNLOCKED! üõ°Ô∏è", "#4169e1");
            screenShake += 20;
            
            // Extra visual feedback
            for (let i = 0; i < 50; i++) {
              particles.push({
                x: canvas.width / 2,
                y: 200,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                radius: 5,
                color: "#4169e1",
                life: 2
              });
            }
          }
        }
      }
      
      upgradeScreen.classList.remove("active");
      gameState = "playing";
      
      addFloatingText(player.x + player.w / 2, player.y - 30, upgrade.name + "!", "#ffff00");
      spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, player.glowColor, 20);
    }

    // Shuffle button listener
    shuffleBtn.addEventListener("click", () => {
      if (shufflesRemaining > 0) {
        shufflesRemaining--;
        generateUpgradeOptions();
        shuffleCount.textContent = shufflesRemaining;
        
        if (shufflesRemaining === 0) {
          shuffleBtn.style.opacity = "0.5";
          shuffleBtn.style.cursor = "not-allowed";
          shuffleBtn.disabled = true;
        }
      }
    });

    // Skip/Close upgrade button listener
    skipUpgradeBtn.addEventListener("click", () => {
      upgradeScreen.classList.remove("active");
      gameState = "playing"; // Resume game immediately
      // Continue playing without choosing an upgrade
    });
    
    // Close upgrade tree button listener
    document.getElementById('closeUpgradeTree').addEventListener('click', () => {
      document.getElementById('upgradeTreeScreen').classList.remove('active');
      gameState = "playing";
    });

    // COMBO SYSTEM
    function updateCombo(dt) {
      if (combo > 0) {
        comboTimer -= dt;
        if (comboTimer <= 0) {
          combo = 0;
        }
      }
    }

    // PARTICLES & EFFECTS
    function spawnHitParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 4,
          vy: (Math.random() - 0.5) * 4,
          life: 0.5,
          color
        });
      }
    }

    function spawnExplosion(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 8,
          vy: (Math.random() - 0.5) * 8,
          life: 0.8,
          color
        });
      }
    }

    function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= dt;
        if (p.life <= 0) {
          particles.splice(i, 1);
        }
      }
    }

    function addFloatingText(x, y, text, color) {
      floatingTexts.push({ x, y, text, color, life: 1.5, vy: -1.5 });
    }
    
    function floatingText(text, x, y, color, life = 1.5) {
      floatingTexts.push({ x, y, text, color, life, vy: -1.5 });
    }

    function updateFloatingTexts(dt) {
      for (let i = floatingTexts.length - 1; i >= 0; i--) {
        const t = floatingTexts[i];
        t.y += t.vy;
        t.life -= dt;
        if (t.life <= 0) {
          floatingTexts.splice(i, 1);
        }
      }
    }

    // ROUND BREAKS
    function startRoundBreak() {
      gameState = "roundBreak";
      roundBreakTimer = ROUND_BREAK_TIME;
      roundBreakScreen.classList.add("active");
      
      if (wave % 10 === 0) {
        breakTitle.textContent = "üî• BOSS WAVE INCOMING! üî•";
        breakInfo.innerHTML = `
          Prepare yourself!<br>
          A mighty boss approaches...<br>
          <br>Press SPACE to start immediately
        `;
      } else if (wave % 5 === 0) {
        breakTitle.textContent = "‚ö° MINI-BOSS WAVE! ‚ö°";
        breakInfo.innerHTML = `
          Get ready!<br>
          A powerful enemy is coming...<br>
          <br>Press SPACE to start immediately
        `;
      } else {
        breakTitle.textContent = `üéØ WAVE ${wave} COMPLETE! üéØ`;
        breakInfo.innerHTML = `
          Prepare for the next wave!<br>
          <br>Press SPACE to start immediately
        `;
      }
    }

    function endRoundBreak() {
      gameState = "playing";
      roundBreakScreen.classList.remove("active");
      enemiesToSpawn = calcEnemiesForWave(wave);
      spawnTimer = 0;
      
      // INCREASED BOSS FREQUENCY AT HIGH WAVES
      if (wave % 10 === 0) {
        // Boss every 10 waves
        spawnEnemy(true, false);
      } else if (wave % 5 === 0) {
        // Mini-boss every 5 waves
        spawnEnemy(false, true);
      } else if (wave >= 30 && wave % 3 === 0) {
        // Wave 30+: Additional mini-boss every 3 waves
        spawnEnemy(false, true);
      }
    }

    // GAME END
    function endGame() {
      gameRunning = false; // Stop game loop
      spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, player.color, 30);
      
      // Update highest wave
      let newClassUnlocked = false;
      if (wave > gameData.highestWave) {
        gameData.highestWave = wave;
        
        // Unlock all waves up to current wave
        for (let w = 1; w <= wave; w++) {
          if (!gameData.unlockedWaves.includes(w)) {
            gameData.unlockedWaves.push(w);
          }
        }
      }
      
      // Unlock classes based on highest wave achieved (not just current wave)
      Object.entries(CLASSES).forEach(([name, data]) => {
        if (!data.purchasable && !data.challengeUnlock && !data.achievementUnlock && 
            data.unlockWave && gameData.highestWave >= data.unlockWave && 
            !gameData.unlockedClasses.includes(name)) {
          gameData.unlockedClasses.push(name);
          newClassUnlocked = true;
          console.log(`üîì CLASS UNLOCKED: ${name} (Wave ${data.unlockWave}) | Your highest wave: ${gameData.highestWave}`);
        }
      });
      
      // Log current unlocked classes for debugging
      console.log(`üìã All unlocked classes:`, gameData.unlockedClasses);
      console.log(`üìä Highest wave reached: ${gameData.highestWave}`);
      
      // Make sure all earned money is saved (should already be in gameData from collection)
      saveGameData();
      
      // Hide give up button
      giveUpBtn.style.display = "none";
      
      // Show game over screen with stats
      finalWave.textContent = wave;
      finalLevel.textContent = player.level;
      finalKills.textContent = enemiesKilled;
      finalCombo.textContent = maxCombo + "x";
      earnedCoins.textContent = sessionCoins;
      earnedGems.textContent = sessionGems;
      totalCoinsNow.textContent = gameData.totalCoins;
      totalGemsNow.textContent = gameData.totalGems;
      
      gameOverScreen.classList.add("active");
      
      // Start 10-second countdown timer
      let countdown = 10;
      countdownTimer.textContent = countdown;
      
      // Clear any existing countdown
      if (gameOverCountdownInterval) {
        clearInterval(gameOverCountdownInterval);
      }
      
      // Start new countdown
      gameOverCountdownInterval = setInterval(() => {
        countdown--;
        countdownTimer.textContent = countdown;
        
        if (countdown <= 0) {
          clearInterval(gameOverCountdownInterval);
          // Automatically return home
          returnToHome();
        }
      }, 1000);
      
      // Show class unlock notification if any
      if (newClassUnlocked) {
        setTimeout(() => {
          alert("üîì NEW CLASS UNLOCKED! Check the class selection!");
        }, 500);
      }
    }
    
    // Return to home screen function
    // PAUSE MENU FUNCTIONS
    function togglePause() {
      gamePaused = !gamePaused;
      const pauseMenu = document.getElementById('pauseMenu');
      
      if (gamePaused) {
        // SHOW pause menu - ensure it's visible
        pauseMenu.classList.add('active');
        pauseMenu.style.display = '';  // Use CSS default
        pauseMenu.style.visibility = '';
        pauseMenu.style.opacity = '';
        pauseMenu.style.zIndex = '';
        pauseMenu.style.pointerEvents = '';
        updatePauseStats();
        console.log('‚è∏Ô∏è Game paused - menu shown');
      } else {
        // HIDE pause menu
        pauseMenu.classList.remove('active');
        console.log('‚ñ∂Ô∏è Game unpaused - menu hidden');
      }
    }
    
    function updatePauseStats() {
      if (!player) return;
      const statsDiv = document.getElementById('pauseStats');
      statsDiv.innerHTML = `
        <div class="pause-stat">
          <span class="pause-stat-label">Class:</span>
          <span class="pause-stat-value">${player.className}</span>
        </div>
        <div class="pause-stat">
          <span class="pause-stat-label">HP:</span>
          <span class="pause-stat-value">${Math.ceil(player.hp)}/${player.maxHP}</span>
        </div>
        <div class="pause-stat">
          <span class="pause-stat-label">Level:</span>
          <span class="pause-stat-value">${player.level}</span>
        </div>
        <div class="pause-stat">
          <span class="pause-stat-label">Damage:</span>
          <span class="pause-stat-value">${Math.floor(player.damage)}</span>
        </div>
        <div class="pause-stat">
          <span class="pause-stat-label">Fire Rate:</span>
          <span class="pause-stat-value">${(1/player.fireRate).toFixed(2)}/sec</span>
        </div>
        <div class="pause-stat">
          <span class="pause-stat-label">Range:</span>
          <span class="pause-stat-value">${Math.floor(player.range)}</span>
        </div>
        <div class="pause-stat">
          <span class="pause-stat-label">Multi-Shot:</span>
          <span class="pause-stat-value">+${player.multiShot}</span>
        </div>
        <div class="pause-stat">
          <span class="pause-stat-label">Crit Chance:</span>
          <span class="pause-stat-value">${((player.critChance || 0) * 100).toFixed(0)}%</span>
        </div>
      `;
    }
    
    function setBrightness(value) {
      brightnessLevel = value / 100;
      canvas.style.filter = `brightness(${value}%)`;
      document.getElementById('brightnessValue').textContent = value + '%';
    }
    
    function setVolume(value) {
      volumeLevel = value / 100;
      document.getElementById('volumeValue').textContent = value + '%';
      // Future: Apply to sound effects
    }
    
    function returnToHome() {
      console.log('üè† Returning to home screen...');
      
      // Clear countdown interval
      if (gameOverCountdownInterval) {
        clearInterval(gameOverCountdownInterval);
        gameOverCountdownInterval = null;
      }
      
      // Stop the game completely
      gameRunning = false;
      gamePaused = false;
      gameState = "title";
      
      // Clear and hide canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#000000";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Reset ALL game objects
      player = null;
      enemies = [];
      projectiles = [];
      minions = [];
      particles = [];
      floatingTexts = [];
      currencyDrops = [];
      fireZones = [];
      vecnaMonsters = [];
      
      // Reset game variables
      wave = 1;
      enemiesToSpawn = 0;
      combo = 0;
      maxCombo = 0;
      screenShake = 0;
      
      // Hide all game screens
      gameOverScreen.classList.remove("active");
      classSelection.classList.remove("active");
      shopScreen.classList.remove("active");
      upgradeScreen.classList.remove("active");
      roundBreakScreen.classList.remove("active");
      document.getElementById('pauseMenu').classList.remove("active");
      
      // Hide ALL gameplay UI elements
      document.getElementById('giveUpBtn').style.display = 'none';
      document.getElementById('ability1Btn').style.display = 'none';
      document.getElementById('ability2Btn').style.display = 'none';
      document.getElementById('potionBar').style.display = 'none';
      
      // Force hide pause menu with all methods
      const pauseMenuElement = document.getElementById('pauseMenu');
      pauseMenuElement.classList.remove("active");
      pauseMenuElement.style.display = 'none';
      pauseMenuElement.style.visibility = 'hidden';
      pauseMenuElement.style.opacity = '0';
      pauseMenuElement.style.zIndex = '-100';
      pauseMenuElement.style.pointerEvents = 'none';
      
      // COMPLETELY hide canvas
      canvas.style.display = 'none';
      canvas.style.visibility = 'hidden';
      canvas.style.opacity = '0';
      canvas.style.zIndex = '-100';
      canvas.style.pointerEvents = 'none';
      
      // Hide ALL other screens
      classSelection.classList.remove("active");
      shopScreen.classList.remove("active");
      upgradeScreen.classList.remove("active");
      roundBreakScreen.classList.remove("active");
      gameOverScreen.classList.remove("active");
      document.getElementById('tutorialScreen').style.display = 'none';
      document.getElementById('evolAuraScreen').style.display = 'none';
      
      // Show title screen - REMOVE ALL INLINE STYLES
      titleScreen.classList.remove("hidden");
      titleScreen.removeAttribute('style'); // Nuclear option - remove ALL inline styles!
      
      // Update title screen stats
      updateTitleScreenDisplay();
      
      // Save game data
      saveGameData();
      
      console.log('‚úÖ Returned to home screen successfully');
      console.log('   - gameRunning:', gameRunning);
      console.log('   - gameState:', gameState);
      console.log('   - player:', player);
      console.log('   - titleScreen visible:', !titleScreen.classList.contains('hidden'));
      console.log('   - titleScreen inline styles removed');
    }
    
    // Continue button handler
    continueBtn.addEventListener("click", () => {
      returnToHome();
    });
    
    // Back arrow button handler
    gameOverBackBtn.addEventListener("click", () => {
      returnToHome();
    });
    
    // Retry button handler - restart with same class
    retryBtn.addEventListener("click", () => {
      // Clear countdown interval
      if (gameOverCountdownInterval) {
        clearInterval(gameOverCountdownInterval);
        gameOverCountdownInterval = null;
      }
      
      gameOverScreen.classList.remove("active");
      initGame(); // Restart game with same class
    });
    
    // Give up button handler
    giveUpBtn.addEventListener("click", function(e) {
      e.preventDefault();
      e.stopPropagation();
      
      if (confirm("Are you sure you want to give up? You'll keep all coins/gems earned so far.")) {
        // Stop game immediately
        gameRunning = false;
        player.alive = false;
        player.hp = 0;
        
        // Clear all timers and intervals
        waveTimerActive = false;
        waveTimer = 0;
        
        // End the game
        endGame();
      }
    });

    // MAIN UPDATE LOOP
    function update(dt) {
      if (!player || !player.alive) return;

      // Update player sprite animation
      if (player && player.alive) {
        const keys = window.keys || {};
        if (keys['a'] || keys['d'] || keys['w'] || keys['s']) {
          // Moving - animate
          player.animFrame = ((player.animFrame || 0) + dt * 8) % 1;
        } else {
          // Standing still - reset to frame 0
          player.animFrame = 0;
        }
        
        // Track facing direction
        if (keys['a']) player.facingLeft = true;
        if (keys['d']) player.facingLeft = false;
      }

      if (gameState === "roundBreak") {
        roundBreakTimer -= dt;
        breakTimer.textContent = Math.ceil(roundBreakTimer);
        
        if (roundBreakTimer <= 0) {
          endRoundBreak();
        }
        
        updateParticles(dt);
        updateFloatingTexts(dt);
        updateCurrencyDrops(dt);
        screenShake *= 0.9;
        return;
      }

      if (gameState === "upgrading") {
        updateParticles(dt);
        updateFloatingTexts(dt);
        updateCurrencyDrops(dt);
        return;
      }

      handleShooting(dt);
      handleSpawning(dt);
      updateProjectiles(dt);
      updateEnemies(dt);
      updateMinions(dt);
      updateParticles(dt);
      updateFloatingTexts(dt);
      updateCombo(dt);
      updateCurrencyDrops(dt);
      updatePotionEffects(dt);
      updatePotionCooldownDisplay();
      updateAbilities(dt);
      updateFireZones(dt);
      updatePoisonClouds(dt);
      updateIceShards(dt);
      updateTurrets(dt);
      updateRootBarriers(dt);
      updateHelperStars(dt);
      
      // HolyCleric: Auto-heal spell
      const classStats = CLASSES[player.class]?.stats || {};
      if (classStats.autoHealSpell) {
        player.autoHealTimer = (player.autoHealTimer || 0) + dt;
        if (player.autoHealTimer >= classStats.autoHealInterval) {
          player.autoHealTimer = 0;
          player.hp = Math.min(player.hp + classStats.autoHealAmount, player.maxHP);
          addFloatingText(player.x + player.w / 2, player.y - 40, "+" + classStats.autoHealAmount + " HP", "#00ff00", 1.5);
          
          // Knockback enemies in radius
          enemies.forEach(e => {
            const dx = (e.x + e.w / 2) - (player.x + player.w / 2);
            const dy = (e.y + e.h / 2) - (player.y + player.h / 2);
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < classStats.autoHealRadius) {
              const angle = Math.atan2(dy, dx);
              e.x += Math.cos(angle) * classStats.autoHealKnockback;
              e.y += Math.sin(angle) * classStats.autoHealKnockback;
              addFloatingText(e.x + e.w / 2, e.y - 30, "REPEL!", "#ffd700");
            }
          });
          
          spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#ffd700", 20);
          screenShake += 5;
        }
      }
      
      // Update enemy debuffs
      enemies.forEach(e => {
        // Burn damage
        if (e.burning) {
          e.burnDuration -= dt;
          if (e.burnDuration <= 0) {
            e.burning = false;
          } else {
            e.hp -= e.burnDPS * dt;
            if (Math.random() < 0.1) {
              particles.push({
                x: e.x + e.w / 2,
                y: e.y + e.h / 2,
                vx: Math.random() * 4 - 2,
                vy: Math.random() * 4 - 2,
                radius: 3,
                color: "#ff4500",
                life: 0.5
              });
            }
          }
        }
        
        // Weaken debuff
        if (e.weakened) {
          e.weakenDuration -= dt;
          if (e.weakenDuration <= 0) {
            e.weakened = false;
          }
        }
        
        // Slow debuff
        if (e.slowDuration > 0) {
          e.slowDuration -= dt;
          if (e.slowDuration <= 0) {
            e.slowAmount = 0;
          }
        }
        
        // Stun debuff
        if (e.stunned && e.stunDuration > 0) {
          e.stunDuration -= dt;
          if (e.stunDuration <= 0) {
            e.stunned = false;
          }
        }
      });
      
      // Regeneration
      if (player.regen > 0) {
        player.hp = Math.min(player.hp + player.regen * dt, player.maxHP);
      }
      
      screenShake *= 0.9;
      if (screenShake < 0.1) screenShake = 0;

      // Check if wave is complete (all enemies spawned AND all enemies killed)
      // Start next wave IMMEDIATELY regardless of timer
      if (enemiesToSpawn === 0 && enemies.length === 0) {
        // Cancel wave timer if active
        if (waveTimerActive) {
          waveTimerActive = false;
          waveTimer = 0;
        }
        
        // Wave complete! Start next wave immediately
        wave++;
        
        // Check for map progression (every 20 waves)
        if (wave % 20 === 1 && wave > 1) {
          currentMap++;
          mapsCompleted++;
          shufflesRemaining = 4;
          addFloatingText(canvas.width / 2, 200, `üó∫Ô∏è MAP ${currentMap} üó∫Ô∏è`, "#ff00ff");
          addFloatingText(canvas.width / 2, 230, "SHUFFLES RESET!", "#00ffff");
          screenShake += 15;
        }
        
        // Give wave bonus XP
        const waveBonus = 50 + wave * 10;
        giveXP(waveBonus);
        addFloatingText(canvas.width / 2, 150, "WAVE " + wave + " COMPLETE!", "#00ff00");
        addFloatingText(canvas.width / 2, 180, "Starting Wave " + wave, "#00ffff");
        
        // Potion generation per wave (scales with wave number!)
        if (gameData.potionUpgrades.potionGeneration > 0) {
          // Base chance: 1% per wave (wave 1 = 1%, wave 10 = 10%, wave 50 = 50%)
          const baseChance = Math.min(wave * 0.01, 0.50); // Cap at 50%
          
          // Upgrade multiplier: Each level adds +50% to the chance
          // Level 1: 1.5x, Level 2: 2x, Level 3: 2.5x, etc.
          const upgradeMultiplier = 1 + (gameData.potionUpgrades.potionGeneration * 0.5);
          
          const totalChance = baseChance * upgradeMultiplier;
          
          if (Math.random() < totalChance) {
            // Generate a random potion
            const potionTypes = ['heal', 'shield', 'crit', 'damage', 'speed', 'dragon'];
            const randomType = potionTypes[Math.floor(Math.random() * potionTypes.length)];
            potions[randomType]++;
            
            addFloatingText(canvas.width / 2, 210, `üçÄ BONUS POTION! ${randomType.toUpperCase()}`, "#00ff00", 1.5);
            updatePotionDisplay(); // Update the display immediately
          }
        }
        
        // Potions DO NOT reset - Summoner ability only!
        
        // Reset Last Stand for new wave
        lastStandUsed = false;
        
        // Start next wave immediately
        enemiesToSpawn = calcEnemiesForWave(wave);
        spawnTimer = 0;
        
        // Spawn boss/mini-boss immediately if applicable
        // Mini-boss every 5 waves
        if (wave % 5 === 0 && wave % 10 !== 0) {
          spawnEnemy(false, true);
          enemiesToSpawn--;
        }
        // Boss every 10 waves
        if (wave % 10 === 0) {
          spawnEnemy(true, false);
          enemiesToSpawn--;
        }
      }

      // Wave timer system (30s after last enemy spawns)
      if (waveTimerActive) {
        waveTimer -= dt;
        
        // Check if wave timer expired
        if (waveTimer <= 0) {
          // Auto-start if enabled, otherwise wait for player to press Space
          if (!autoStartWave) {
            // Show message and wait - but don't return, let game continue
            // Player can press Space to start manually
          } else {
            // Auto-start enabled, start wave automatically
            wave++;
            waveTimerActive = false;
            
            // Check for map progression (every 20 waves)
            if (wave % 20 === 1 && wave > 1) {
              currentMap++;
              mapsCompleted++;
              shufflesRemaining = 4; // Reset shuffles on new map!
              
              addFloatingText(canvas.width / 2, 200, `üó∫Ô∏è MAP ${currentMap} üó∫Ô∏è`, "#ff00ff");
              addFloatingText(canvas.width / 2, 230, "SHUFFLES RESET!", "#00ffff");
              screenShake += 15;
            }
            
            // Give wave bonus XP
            const waveBonus = 50 + wave * 10;
            giveXP(waveBonus);
            addFloatingText(canvas.width / 2, 150, "WAVE " + wave + " START!", "#00ffff");
            
            // Potions DO NOT reset - Summoner ability only!
            
            // Reset Last Stand for new wave
            lastStandUsed = false;
            
            // Start next wave
            enemiesToSpawn = calcEnemiesForWave(wave);
            spawnTimer = 0;
            
            // Spawn boss/mini-boss immediately if applicable
            if (wave % 10 === 0) {
              spawnEnemy(true, false);
              enemiesToSpawn--; // Boss counts as one of the enemies
            } else if (wave % 5 === 0) {
              spawnEnemy(false, true);
              enemiesToSpawn--; // Mini-boss counts as one
            }
          }
        }
      }
    }

    // DRAWING
    function drawBackground() {
      ctx.fillStyle = "#0a0015";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Stars
      const time = Date.now() * 0.0001;
      for (let i = 0; i < 50; i++) {
        const x = (i * 123.456 % canvas.width);
        const y = ((i * 78.9 + time * 20) % canvas.height);
        const brightness = (Math.sin(i + time * 3) + 1) * 0.5;
        ctx.fillStyle = `rgba(255, 255, 255, ${brightness * 0.5})`;
        ctx.fillRect(x, y, 2, 2);
      }
    }

    function drawGround() {
      ctx.fillStyle = "#2a1a3a";
      ctx.fillRect(0, GROUND_Y, canvas.width, canvas.height - GROUND_Y);
      ctx.strokeStyle = "#00ffff";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, GROUND_Y);
      ctx.lineTo(canvas.width, GROUND_Y);
      ctx.stroke();
    }

    function drawPlayer() {
      if (!player) return;
      
      const x = player.x;
      const y = player.y;
      const w = player.w;
      const h = player.h;
      
      // PHANTOM CLONE: Appears at level 10+
      if (player.level >= 10) {
        drawPhantomClone(x, y, w, h);
      }

      // Determine animation state
      const keys = window.keys || {};
      const isMoving = keys['a'] || keys['d'] || keys['w'] || keys['s'];
      const animFrame = player.animFrame || 0;
      const bobOffset = isMoving ? Math.sin(animFrame * Math.PI * 8) * 3 : 0;
      
      // Draw character-specific sprite
      ctx.save();
      
      // Flip if facing left
      if (player.facingLeft) {
        ctx.translate(x + w, y);
        ctx.scale(-1, 1);
        drawCharacterSprite(player.className, 0, 0, w, h, animFrame, isMoving, bobOffset);
      } else {
        ctx.translate(x, y);
        drawCharacterSprite(player.className, 0, 0, w, h, animFrame, isMoving, bobOffset);
      }
      
      ctx.restore();
    }
    
    function drawCharacterSprite(className, x, y, w, h, animFrame, isMoving, bobOffset) {
      ctx.shadowBlur = 15;
      ctx.shadowColor = player.glowColor;
      
      switch(className) {
        case 'Hunter':
          drawHunterSprite(x, y, w, h, animFrame, isMoving, bobOffset);
          break;
        case 'Knight':
          drawKnightSprite(x, y, w, h, animFrame, isMoving, bobOffset);
          break;
        case 'Archer':
          drawArcherSprite(x, y, w, h, animFrame, isMoving, bobOffset);
          break;
        case 'Thief':
          drawThiefSprite(x, y, w, h, animFrame, isMoving, bobOffset);
          break;
        case 'Assassin':
          drawAssassinSprite(x, y, w, h, animFrame, isMoving, bobOffset);
          break;
        case 'Summoner':
          drawSummonerSprite(x, y, w, h, animFrame, isMoving, bobOffset);
          break;
        case 'DarkMagician':
          drawDarkMagicianSprite(x, y, w, h, animFrame, isMoving, bobOffset);
          break;
        case 'Bomber':
          drawBomberSprite(x, y, w, h, animFrame, isMoving, bobOffset);
          break;
        case 'Sniper':
          drawSniperSprite(x, y, w, h, animFrame, isMoving, bobOffset);
          break;
        case 'Necromancer':
          drawNecromancerSprite(x, y, w, h, animFrame, isMoving, bobOffset);
          break;
        case 'Vecna':
          drawVecnaSprite(x, y, w, h, animFrame, isMoving, bobOffset);
          break;
        case 'Pyromancer':
          drawPyromancerSprite(x, y, w, h, animFrame, isMoving, bobOffset);
          break;
        case 'CryoSentinel':
          drawCryoSentinelSprite(x, y, w, h, animFrame, isMoving, bobOffset);
          break;
        case 'PlagueDoctor':
          drawPlagueDoctorSprite(x, y, w, h, animFrame, isMoving, bobOffset);
          break;
        case 'LightningRanger':
          drawLightningRangerSprite(x, y, w, h, animFrame, isMoving, bobOffset);
          break;
        case 'BloodReaver':
          drawBloodReaverSprite(x, y, w, h, animFrame, isMoving, bobOffset);
          break;
        case 'CrystalGuardian':
          drawCrystalGuardianSprite(x, y, w, h, animFrame, isMoving, bobOffset);
          break;
        case 'ShadowMonk':
          drawShadowMonkSprite(x, y, w, h, animFrame, isMoving, bobOffset);
          break;
        case 'HolyCleric':
          drawHolyClericSprite(x, y, w, h, animFrame, isMoving, bobOffset);
          break;
        case 'TrickshotRogue':
          drawTrickshotRogueSprite(x, y, w, h, animFrame, isMoving, bobOffset);
          break;
        case 'Starcaller':
          drawStarcallerSprite(x, y, w, h, animFrame, isMoving, bobOffset);
          break;
        case 'AstralGolem':
          drawAstralGolemSprite(x, y, w, h, animFrame, isMoving, bobOffset);
          break;
        case 'Engineer':
          drawEngineerSprite(x, y, w, h, animFrame, isMoving, bobOffset);
          break;
        case 'GuardianTank':
          drawGuardianTankSprite(x, y, w, h, animFrame, isMoving, bobOffset);
          break;
        case 'Berserk':
          drawBerserkSprite(x, y, w, h, animFrame, isMoving, bobOffset);
          break;
        case 'Samurai':
          drawSamuraiSprite(x, y, w, h, animFrame, isMoving, bobOffset);
          break;
        case 'Warlock':
          drawWarlockSprite(x, y, w, h, animFrame, isMoving, bobOffset);
          break;
        case 'Druid':
          drawDruidSprite(x, y, w, h, animFrame, isMoving, bobOffset);
          break;
        case 'Gunslinger':
          drawGunslingerSprite(x, y, w, h, animFrame, isMoving, bobOffset);
          break;
        default:
          drawDefaultSprite(x, y, w, h, animFrame, isMoving, bobOffset);
      }
      
      ctx.shadowBlur = 0;
    }
    
    // CHARACTER SPRITE FUNCTIONS
    function drawHunterSprite(x, y, w, h, animFrame, isMoving, bobOffset) {
      // Hunter - Balanced archer with bow
      // Body
      ctx.fillStyle = player.color;
      ctx.fillRect(x + w*0.3, y + h*0.35 + bobOffset, w*0.4, h*0.5);
      
      // Head
      ctx.fillStyle = "#ffd4a3";
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.25 + bobOffset, w*0.2, 0, Math.PI * 2);
      ctx.fill();
      
      // Hood/Hat
      ctx.fillStyle = player.accent;
      ctx.beginPath();
      ctx.moveTo(x + w*0.3, y + h*0.2 + bobOffset);
      ctx.lineTo(x + w*0.5, y + h*0.05 + bobOffset);
      ctx.lineTo(x + w*0.7, y + h*0.2 + bobOffset);
      ctx.closePath();
      ctx.fill();
      
      // Bow
      ctx.strokeStyle = "#8B4513";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(x + w*0.85, y + h*0.5 + bobOffset, w*0.25, -Math.PI/4, Math.PI/4, false);
      ctx.stroke();
      
      // Quiver
      ctx.fillStyle = "#654321";
      ctx.fillRect(x + w*0.2, y + h*0.4 + bobOffset, w*0.15, h*0.3);
      
      // Arrows in quiver
      for(let i = 0; i < 3; i++) {
        ctx.strokeStyle = "#FFD700";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x + w*0.22 + i*w*0.04, y + h*0.38 + bobOffset);
        ctx.lineTo(x + w*0.22 + i*w*0.04, y + h*0.45 + bobOffset);
        ctx.stroke();
      }
      
      // Legs
      ctx.fillStyle = player.color;
      ctx.fillRect(x + w*0.35, y + h*0.75 + bobOffset, w*0.12, h*0.25);
      ctx.fillRect(x + w*0.53, y + h*0.75 + bobOffset, w*0.12, h*0.25);
    }
    
    function drawKnightSprite(x, y, w, h, animFrame, isMoving, bobOffset) {
      // Knight - Heavy armored warrior
      // Armor body
      ctx.fillStyle = player.color;
      ctx.fillRect(x + w*0.25, y + h*0.35 + bobOffset, w*0.5, h*0.5);
      
      // Shoulder pads
      ctx.fillRect(x + w*0.15, y + h*0.35 + bobOffset, w*0.2, h*0.15);
      ctx.fillRect(x + w*0.65, y + h*0.35 + bobOffset, w*0.2, h*0.15);
      
      // Helmet
      ctx.fillStyle = player.accent;
      ctx.fillRect(x + w*0.3, y + h*0.15 + bobOffset, w*0.4, h*0.25);
      ctx.fillRect(x + w*0.25, y + h*0.1 + bobOffset, w*0.5, h*0.15);
      
      // Visor slit
      ctx.fillStyle = "#000";
      ctx.fillRect(x + w*0.35, y + h*0.22 + bobOffset, w*0.3, h*0.05);
      
      // Sword
      ctx.fillStyle = "#C0C0C0";
      ctx.fillRect(x + w*0.8, y + h*0.3 + bobOffset, w*0.08, h*0.5);
      ctx.fillStyle = "#FFD700";
      ctx.fillRect(x + w*0.75, y + h*0.3 + bobOffset, w*0.18, h*0.1);
      
      // Shield
      ctx.fillStyle = player.bulletColor;
      ctx.beginPath();
      ctx.arc(x + w*0.1, y + h*0.5 + bobOffset, w*0.15, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "#FFD700";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Legs
      ctx.fillStyle = player.color;
      ctx.fillRect(x + w*0.32, y + h*0.75 + bobOffset, w*0.15, h*0.25);
      ctx.fillRect(x + w*0.53, y + h*0.75 + bobOffset, w*0.15, h*0.25);
    }
    
    function drawArcherSprite(x, y, w, h, animFrame, isMoving, bobOffset) {
      // Archer - Rapid fire specialist
      // Light armor body
      ctx.fillStyle = player.color;
      ctx.fillRect(x + w*0.32, y + h*0.4 + bobOffset, w*0.36, h*0.45);
      
      // Head
      ctx.fillStyle = "#ffd4a3";
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.28 + bobOffset, w*0.18, 0, Math.PI * 2);
      ctx.fill();
      
      // Headband
      ctx.fillStyle = player.accent;
      ctx.fillRect(x + w*0.35, y + h*0.22 + bobOffset, w*0.3, h*0.06);
      
      // Rapid-fire crossbow
      ctx.fillStyle = "#654321";
      ctx.fillRect(x + w*0.7, y + h*0.45 + bobOffset, w*0.25, h*0.08);
      ctx.fillStyle = "#8B4513";
      ctx.beginPath();
      ctx.moveTo(x + w*0.95, y + h*0.4 + bobOffset);
      ctx.lineTo(x + w*0.7, y + h*0.49 + bobOffset);
      ctx.lineTo(x + w*0.95, y + h*0.58 + bobOffset);
      ctx.fill();
      
      // Multiple arrows ready
      for(let i = 0; i < 5; i++) {
        ctx.fillStyle = "#FFD700";
        ctx.fillRect(x + w*0.15 + i*w*0.03, y + h*0.5 + bobOffset, w*0.02, h*0.15);
      }
      
      // Legs
      ctx.fillStyle = player.color;
      ctx.fillRect(x + w*0.37, y + h*0.75 + bobOffset, w*0.12, h*0.25);
      ctx.fillRect(x + w*0.51, y + h*0.75 + bobOffset, w*0.12, h*0.25);
    }
    
    function drawThiefSprite(x, y, w, h, animFrame, isMoving, bobOffset) {
      // Thief - Sneaky money collector
      // Dark cloak
      ctx.fillStyle = player.color;
      ctx.beginPath();
      ctx.moveTo(x + w*0.2, y + h*0.35 + bobOffset);
      ctx.lineTo(x + w*0.5, y + h*0.3 + bobOffset);
      ctx.lineTo(x + w*0.8, y + h*0.35 + bobOffset);
      ctx.lineTo(x + w*0.7, y + h*0.85 + bobOffset);
      ctx.lineTo(x + w*0.3, y + h*0.85 + bobOffset);
      ctx.closePath();
      ctx.fill();
      
      // Masked face
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.25 + bobOffset, w*0.15, 0, Math.PI * 2);
      ctx.fill();
      
      // Eyes (glowing)
      ctx.fillStyle = player.glowColor;
      ctx.beginPath();
      ctx.arc(x + w*0.42, y + h*0.24 + bobOffset, w*0.04, 0, Math.PI * 2);
      ctx.arc(x + w*0.58, y + h*0.24 + bobOffset, w*0.04, 0, Math.PI * 2);
      ctx.fill();
      
      // Daggers
      ctx.fillStyle = "#C0C0C0";
      ctx.fillRect(x + w*0.8, y + h*0.5 + bobOffset, w*0.05, h*0.25);
      ctx.fillRect(x + w*0.15, y + h*0.5 + bobOffset, w*0.05, h*0.25);
      
      // Money bag
      ctx.fillStyle = "#FFD700";
      ctx.beginPath();
      ctx.arc(x + w*0.25, y + h*0.7 + bobOffset, w*0.1, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#000";
      ctx.font = `${w*0.15}px Arial`;
      ctx.fillText("$", x + w*0.22, y + h*0.73 + bobOffset);
    }
    
    function drawAssassinSprite(x, y, w, h, animFrame, isMoving, bobOffset) {
      // Assassin - Ultra-fast glass cannon
      // Sleek bodysuit
      ctx.fillStyle = player.color;
      ctx.fillRect(x + w*0.33, y + h*0.35 + bobOffset, w*0.34, h*0.5);
      
      // Head with mask
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.25 + bobOffset, w*0.16, 0, Math.PI * 2);
      ctx.fill();
      
      // Glowing eyes
      ctx.fillStyle = "#FF00FF";
      ctx.beginPath();
      ctx.arc(x + w*0.43, y + h*0.23 + bobOffset, w*0.035, 0, Math.PI * 2);
      ctx.arc(x + w*0.57, y + h*0.23 + bobOffset, w*0.035, 0, Math.PI * 2);
      ctx.fill();
      
      // Twin blades (crossed)
      ctx.strokeStyle = "#FF00FF";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(x + w*0.2, y + h*0.4 + bobOffset);
      ctx.lineTo(x + w*0.5, y + h*0.7 + bobOffset);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x + w*0.8, y + h*0.4 + bobOffset);
      ctx.lineTo(x + w*0.5, y + h*0.7 + bobOffset);
      ctx.stroke();
      
      // Speed lines
      if(isMoving) {
        ctx.strokeStyle = player.glowColor;
        ctx.globalAlpha = 0.5;
        ctx.lineWidth = 2;
        for(let i = 0; i < 3; i++) {
          ctx.beginPath();
          ctx.moveTo(x - w*0.2 - i*w*0.1, y + h*0.3 + i*h*0.2 + bobOffset);
          ctx.lineTo(x, y + h*0.3 + i*h*0.2 + bobOffset);
          ctx.stroke();
        }
        ctx.globalAlpha = 1;
      }
    }
    
    function drawSummonerSprite(x, y, w, h, animFrame, isMoving, bobOffset) {
      // Summoner - Spirit magic user
      // Robed body
      ctx.fillStyle = player.color;
      ctx.beginPath();
      ctx.moveTo(x + w*0.5, y + h*0.35 + bobOffset);
      ctx.lineTo(x + w*0.25, y + h*0.45 + bobOffset);
      ctx.lineTo(x + w*0.2, y + h*0.9 + bobOffset);
      ctx.lineTo(x + w*0.8, y + h*0.9 + bobOffset);
      ctx.lineTo(x + w*0.75, y + h*0.45 + bobOffset);
      ctx.closePath();
      ctx.fill();
      
      // Head
      ctx.fillStyle = "#ffd4a3";
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.25 + bobOffset, w*0.17, 0, Math.PI * 2);
      ctx.fill();
      
      // Wizard hat
      ctx.fillStyle = player.accent;
      ctx.beginPath();
      ctx.moveTo(x + w*0.3, y + h*0.2 + bobOffset);
      ctx.lineTo(x + w*0.5, y + bobOffset);
      ctx.lineTo(x + w*0.7, y + h*0.2 + bobOffset);
      ctx.closePath();
      ctx.fill();
      
      // Star on hat
      ctx.fillStyle = "#FFD700";
      drawStar(ctx, x + w*0.5, y + h*0.1 + bobOffset, 5, w*0.08, w*0.04);
      
      // Staff with crystal
      ctx.strokeStyle = "#8B4513";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(x + w*0.85, y + h*0.3 + bobOffset);
      ctx.lineTo(x + w*0.85, y + h*0.85 + bobOffset);
      ctx.stroke();
      
      ctx.fillStyle = player.glowColor;
      ctx.beginPath();
      ctx.arc(x + w*0.85, y + h*0.25 + bobOffset, w*0.08, 0, Math.PI * 2);
      ctx.fill();
      
      // Floating spirits
      const spiritOffset = Math.sin(Date.now() / 200) * 5;
      ctx.globalAlpha = 0.6;
      ctx.fillStyle = "#88ff88";
      ctx.beginPath();
      ctx.arc(x + w*1.1, y + h*0.4 + spiritOffset, w*0.1, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
    
    function drawDarkMagicianSprite(x, y, w, h, animFrame, isMoving, bobOffset) {
      // Dark Magician - Powerful slow caster
      // Dark robes
      ctx.fillStyle = player.color;
      ctx.beginPath();
      ctx.moveTo(x + w*0.5, y + h*0.35 + bobOffset);
      ctx.lineTo(x + w*0.2, y + h*0.5 + bobOffset);
      ctx.lineTo(x + w*0.15, y + h*0.95 + bobOffset);
      ctx.lineTo(x + w*0.85, y + h*0.95 + bobOffset);
      ctx.lineTo(x + w*0.8, y + h*0.5 + bobOffset);
      ctx.closePath();
      ctx.fill();
      
      // Hooded head
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.25 + bobOffset, w*0.2, 0, Math.PI * 2);
      ctx.fill();
      
      // Glowing purple eyes
      ctx.fillStyle = "#8800ff";
      ctx.shadowBlur = 10;
      ctx.shadowColor = "#8800ff";
      ctx.beginPath();
      ctx.arc(x + w*0.42, y + h*0.24 + bobOffset, w*0.04, 0, Math.PI * 2);
      ctx.arc(x + w*0.58, y + h*0.24 + bobOffset, w*0.04, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      
      // Dark orb
      const orbPulse = Math.sin(Date.now() / 300) * 0.1 + 1;
      ctx.fillStyle = player.accent;
      ctx.globalAlpha = orbPulse * 0.8;
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.6 + bobOffset, w*0.15 * orbPulse, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
      
      // Dark energy wisps
      for(let i = 0; i < 3; i++) {
        const angle = (Date.now() / 500 + i * Math.PI * 2/3);
        const wx = x + w*0.5 + Math.cos(angle) * w*0.3;
        const wy = y + h*0.6 + Math.sin(angle) * w*0.3 + bobOffset;
        ctx.fillStyle = "#8800ff";
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.arc(wx, wy, w*0.05, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }
    
    function drawBomberSprite(x, y, w, h, animFrame, isMoving, bobOffset) {
      // Bomber - AOE explosion specialist
      // Heavy vest
      ctx.fillStyle = player.color;
      ctx.fillRect(x + w*0.25, y + h*0.4 + bobOffset, w*0.5, h*0.45);
      
      // Head with goggles
      ctx.fillStyle = "#ffd4a3";
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.28 + bobOffset, w*0.18, 0, Math.PI * 2);
      ctx.fill();
      
      // Goggles
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      ctx.fillStyle = "#87CEEB";
      ctx.beginPath();
      ctx.arc(x + w*0.4, y + h*0.26 + bobOffset, w*0.08, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(x + w*0.6, y + h*0.26 + bobOffset, w*0.08, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      
      // Bomb bandolier
      for(let i = 0; i < 3; i++) {
        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.arc(x + w*0.3 + i*w*0.2, y + h*0.55 + bobOffset, w*0.08, 0, Math.PI * 2);
        ctx.fill();
        
        // Fuse
        ctx.strokeStyle = "#FF8800";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x + w*0.3 + i*w*0.2, y + h*0.47 + bobOffset);
        ctx.lineTo(x + w*0.3 + i*w*0.2 - w*0.03, y + h*0.42 + bobOffset);
        ctx.stroke();
      }
      
      // Large bomb in hand
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.arc(x + w*0.85, y + h*0.6 + bobOffset, w*0.12, 0, Math.PI * 2);
      ctx.fill();
      
      // Lit fuse
      ctx.strokeStyle = "#FF8800";
      ctx.lineWidth = 3;
      ctx.shadowBlur = 10;
      ctx.shadowColor = "#FF8800";
      ctx.beginPath();
      ctx.moveTo(x + w*0.85, y + h*0.48 + bobOffset);
      ctx.lineTo(x + w*0.88, y + h*0.4 + bobOffset);
      ctx.stroke();
      ctx.shadowBlur = 0;
      
      // Spark
      ctx.fillStyle = "#FFFF00";
      ctx.beginPath();
      ctx.arc(x + w*0.88, y + h*0.4 + bobOffset, w*0.03, 0, Math.PI * 2);
      ctx.fill();
    }
    
    function drawSniperSprite(x, y, w, h, animFrame, isMoving, bobOffset) {
      // Sniper - Long range precision
      // Ghillie suit body
      ctx.fillStyle = player.color;
      ctx.fillRect(x + w*0.3, y + h*0.4 + bobOffset, w*0.4, h*0.45);
      
      // Camouflage pattern
      ctx.fillStyle = player.accent;
      for(let i = 0; i < 5; i++) {
        ctx.fillRect(x + w*0.3 + Math.random()*w*0.3, y + h*0.4 + Math.random()*h*0.4 + bobOffset, w*0.05, h*0.05);
      }
      
      // Head with scope
      ctx.fillStyle = "#ffd4a3";
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.28 + bobOffset, w*0.16, 0, Math.PI * 2);
      ctx.fill();
      
      // Scope goggles
      ctx.fillStyle = "#00FFFF";
      ctx.beginPath();
      ctx.arc(x + w*0.42, y + h*0.26 + bobOffset, w*0.07, 0, Math.PI * 2);
      ctx.arc(x + w*0.58, y + h*0.26 + bobOffset, w*0.07, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Long sniper rifle
      ctx.fillStyle = "#2F4F4F";
      ctx.fillRect(x + w*0.7, y + h*0.45 + bobOffset, w*0.45, h*0.08);
      
      // Scope
      ctx.fillStyle = "#000";
      ctx.fillRect(x + w*0.85, y + h*0.42 + bobOffset, w*0.15, h*0.14);
      ctx.strokeStyle = "#00FFFF";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x + w*0.92, y + h*0.49 + bobOffset, w*0.05, 0, Math.PI * 2);
      ctx.stroke();
      
      // Laser sight
      ctx.strokeStyle = "#FF0000";
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.moveTo(x + w*1.15, y + h*0.49 + bobOffset);
      ctx.lineTo(x + w*2, y + h*0.49 + bobOffset);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }
    
    function drawNecromancerSprite(x, y, w, h, animFrame, isMoving, bobOffset) {
      // Necromancer - Poison and skeleton summoner
      // Tattered robes
      ctx.fillStyle = player.color;
      ctx.beginPath();
      ctx.moveTo(x + w*0.5, y + h*0.35 + bobOffset);
      ctx.lineTo(x + w*0.25, y + h*0.5 + bobOffset);
      ctx.lineTo(x + w*0.2, y + h*0.95 + bobOffset);
      for(let i = 0; i < 5; i++) {
        ctx.lineTo(x + w*0.2 + i*w*0.15, y + h*0.95 - (i%2)*h*0.05);
      }
      ctx.lineTo(x + w*0.75, y + h*0.5 + bobOffset);
      ctx.closePath();
      ctx.fill();
      
      // Skull head
      ctx.fillStyle = "#E0E0E0";
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.25 + bobOffset, w*0.18, 0, Math.PI * 2);
      ctx.fill();
      
      // Skull eyes (empty sockets)
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.arc(x + w*0.42, y + h*0.23 + bobOffset, w*0.05, 0, Math.PI * 2);
      ctx.arc(x + w*0.58, y + h*0.23 + bobOffset, w*0.05, 0, Math.PI * 2);
      ctx.fill();
      
      // Green glow in sockets
      ctx.fillStyle = "#00FF00";
      ctx.globalAlpha = 0.8;
      ctx.shadowBlur = 10;
      ctx.shadowColor = "#00FF00";
      ctx.beginPath();
      ctx.arc(x + w*0.42, y + h*0.23 + bobOffset, w*0.03, 0, Math.PI * 2);
      ctx.arc(x + w*0.58, y + h*0.23 + bobOffset, w*0.03, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
      
      // Staff with skull
      ctx.strokeStyle = "#4B0082";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(x + w*0.15, y + h*0.3 + bobOffset);
      ctx.lineTo(x + w*0.15, y + h*0.85 + bobOffset);
      ctx.stroke();
      
      ctx.fillStyle = "#E0E0E0";
      ctx.beginPath();
      ctx.arc(x + w*0.15, y + h*0.25 + bobOffset, w*0.08, 0, Math.PI * 2);
      ctx.fill();
      
      // Floating poison cloud
      const poisonFloat = Math.sin(Date.now() / 400) * 5;
      ctx.fillStyle = "#32CD32";
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      ctx.arc(x + w*0.9, y + h*0.5 + poisonFloat, w*0.15, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
    
    function drawDefaultSprite(x, y, w, h, animFrame, isMoving, bobOffset) {
      // Default fallback sprite
      ctx.fillStyle = player.color;
      ctx.fillRect(x, y + bobOffset, w, h);
      ctx.fillStyle = player.accent;
      ctx.fillRect(x + 4, y + 4 + bobOffset, w - 8, h - 8);
      
      // Simple face
      ctx.fillStyle = "#ffd4a3";
      ctx.fillRect(x + w*0.25, y - h*0.3 + bobOffset, w*0.5, h*0.3);
      ctx.fillStyle = player.glowColor;
      ctx.fillRect(x + w*0.35, y - h*0.18 + bobOffset, 4, 4);
      ctx.fillRect(x + w*0.55, y - h*0.18 + bobOffset, 4, 4);
    }
    
    function drawVecnaSprite(x, y, w, h, animFrame, isMoving, bobOffset) {
      // Vecna - Eldritch summoner with eye and tentacles
      // Dark robed body with eldritch patterns
      ctx.fillStyle = player.color;
      ctx.beginPath();
      ctx.moveTo(x + w*0.5, y + h*0.35 + bobOffset);
      ctx.lineTo(x + w*0.2, y + h*0.5 + bobOffset);
      ctx.lineTo(x + w*0.15, y + h*1 + bobOffset);
      ctx.lineTo(x + w*0.85, y + h*1 + bobOffset);
      ctx.lineTo(x + w*0.8, y + h*0.5 + bobOffset);
      ctx.closePath();
      ctx.fill();
      
      // Giant floating eye (Vecna's eye)
      const eyePulse = Math.sin(Date.now() / 300) * 0.05 + 1;
      ctx.fillStyle = "#FFFFFF";
      ctx.shadowBlur = 15;
      ctx.shadowColor = "#FF00FF";
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.25 + bobOffset, w*0.22 * eyePulse, 0, Math.PI * 2);
      ctx.fill();
      
      // Iris
      ctx.fillStyle = "#8800FF";
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.25 + bobOffset, w*0.12 * eyePulse, 0, Math.PI * 2);
      ctx.fill();
      
      // Pupil
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.25 + bobOffset, w*0.06 * eyePulse, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      
      // Tentacles emerging from robe
      for(let i = 0; i < 4; i++) {
        const tentacleWave = Math.sin(Date.now() / 200 + i) * 0.1;
        ctx.strokeStyle = player.accent;
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(x + w*0.2 + i*w*0.2, y + h*0.7 + bobOffset);
        ctx.bezierCurveTo(
          x + w*0.2 + i*w*0.2 + tentacleWave*50, y + h*0.85 + bobOffset,
          x + w*0.15 + i*w*0.2 - tentacleWave*50, y + h*1 + bobOffset,
          x + w*0.1 + i*w*0.2, y + h*1.15 + bobOffset
        );
        ctx.stroke();
      }
      
      // Eldritch runes floating around
      ctx.fillStyle = "#FF00FF";
      ctx.globalAlpha = 0.6;
      const runeAngle = Date.now() / 500;
      for(let i = 0; i < 3; i++) {
        const angle = runeAngle + i * Math.PI * 2/3;
        const rx = x + w*0.5 + Math.cos(angle) * w*0.4;
        const ry = y + h*0.5 + Math.sin(angle) * w*0.4 + bobOffset;
        ctx.font = `${w*0.15}px Arial`;
        ctx.fillText("‚ò•", rx, ry);
      }
      ctx.globalAlpha = 1;
    }
    
    function drawPyromancerSprite(x, y, w, h, animFrame, isMoving, bobOffset) {
      // Pyromancer - Fire specialist creating burning zones
      // Fire-resistant robes
      ctx.fillStyle = player.color;
      ctx.fillRect(x + w*0.28, y + h*0.4 + bobOffset, w*0.44, h*0.5);
      
      // Head
      ctx.fillStyle = "#ffd4a3";
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.28 + bobOffset, w*0.18, 0, Math.PI * 2);
      ctx.fill();
      
      // Flaming hair
      ctx.fillStyle = "#FF4500";
      for(let i = 0; i < 5; i++) {
        const flameHeight = Math.random() * h*0.15 + h*0.1;
        const flameX = x + w*0.3 + i*w*0.1;
        ctx.beginPath();
        ctx.moveTo(flameX, y + h*0.15 + bobOffset);
        ctx.lineTo(flameX - w*0.03, y + h*0.15 - flameHeight + bobOffset);
        ctx.lineTo(flameX + w*0.03, y + h*0.15 - flameHeight + bobOffset);
        ctx.closePath();
        ctx.fill();
      }
      
      // Fire aura
      const fireGlow = Math.sin(Date.now() / 200) * 0.2 + 0.8;
      ctx.shadowBlur = 20;
      ctx.shadowColor = "#FF6600";
      ctx.globalAlpha = fireGlow;
      ctx.strokeStyle = "#FF6600";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.6 + bobOffset, w*0.4, 0, Math.PI * 2);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      
      // Fireballs in hands
      ctx.fillStyle = "#FF4500";
      ctx.shadowBlur = 15;
      ctx.shadowColor = "#FF4500";
      ctx.beginPath();
      ctx.arc(x + w*0.15, y + h*0.55 + bobOffset, w*0.12, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + w*0.85, y + h*0.55 + bobOffset, w*0.12, 0, Math.PI * 2);
      ctx.fill();
      
      // Inner flame
      ctx.fillStyle = "#FFFF00";
      ctx.beginPath();
      ctx.arc(x + w*0.15, y + h*0.55 + bobOffset, w*0.06, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + w*0.85, y + h*0.55 + bobOffset, w*0.06, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      
      // Legs
      ctx.fillStyle = player.color;
      ctx.fillRect(x + w*0.35, y + h*0.8 + bobOffset, w*0.13, h*0.2);
      ctx.fillRect(x + w*0.52, y + h*0.8 + bobOffset, w*0.13, h*0.2);
    }
    
    function drawCryoSentinelSprite(x, y, w, h, animFrame, isMoving, bobOffset) {
      // CryoSentinel - Ice warrior creating ice shards
      // Crystalline ice armor
      ctx.fillStyle = player.color;
      ctx.fillRect(x + w*0.25, y + h*0.38 + bobOffset, w*0.5, h*0.5);
      
      // Ice crystal spikes on shoulders
      ctx.fillStyle = "#00FFFF";
      ctx.beginPath();
      ctx.moveTo(x + w*0.2, y + h*0.38 + bobOffset);
      ctx.lineTo(x + w*0.15, y + h*0.25 + bobOffset);
      ctx.lineTo(x + w*0.25, y + h*0.35 + bobOffset);
      ctx.closePath();
      ctx.fill();
      
      ctx.beginPath();
      ctx.moveTo(x + w*0.8, y + h*0.38 + bobOffset);
      ctx.lineTo(x + w*0.85, y + h*0.25 + bobOffset);
      ctx.lineTo(x + w*0.75, y + h*0.35 + bobOffset);
      ctx.closePath();
      ctx.fill();
      
      // Frozen head/helmet
      ctx.fillStyle = player.accent;
      ctx.fillRect(x + w*0.32, y + h*0.18 + bobOffset, w*0.36, h*0.25);
      
      // Glowing ice eyes
      ctx.fillStyle = "#00FFFF";
      ctx.shadowBlur = 10;
      ctx.shadowColor = "#00FFFF";
      ctx.fillRect(x + w*0.38, y + h*0.26 + bobOffset, w*0.08, h*0.08);
      ctx.fillRect(x + w*0.54, y + h*0.26 + bobOffset, w*0.08, h*0.08);
      ctx.shadowBlur = 0;
      
      // Ice sword
      ctx.fillStyle = "#87CEEB";
      ctx.fillRect(x + w*0.8, y + h*0.35 + bobOffset, w*0.08, h*0.5);
      ctx.beginPath();
      ctx.moveTo(x + w*0.8, y + h*0.35 + bobOffset);
      ctx.lineTo(x + w*0.84, y + h*0.25 + bobOffset);
      ctx.lineTo(x + w*0.88, y + h*0.35 + bobOffset);
      ctx.closePath();
      ctx.fill();
      
      // Frost particles
      ctx.fillStyle = "#FFFFFF";
      ctx.globalAlpha = 0.7;
      for(let i = 0; i < 8; i++) {
        const px = x + w*0.5 + (Math.random() - 0.5) * w*0.8;
        const py = y + h*0.6 + (Math.random() - 0.5) * h*0.5 + bobOffset;
        ctx.fillRect(px, py, 3, 3);
      }
      ctx.globalAlpha = 1;
      
      // Ice shards floating
      const shardFloat = Math.sin(Date.now() / 300) * 5;
      ctx.fillStyle = "#00CED1";
      ctx.beginPath();
      ctx.moveTo(x + w*0.1, y + h*0.5 + shardFloat);
      ctx.lineTo(x + w*0.08, y + h*0.45 + shardFloat);
      ctx.lineTo(x + w*0.12, y + h*0.48 + shardFloat);
      ctx.closePath();
      ctx.fill();
    }
    
    function drawPlagueDoctorSprite(x, y, w, h, animFrame, isMoving, bobOffset) {
      // PlagueDoctor - Poison cloud placer
      // Long dark coat
      ctx.fillStyle = player.color;
      ctx.beginPath();
      ctx.moveTo(x + w*0.5, y + h*0.35 + bobOffset);
      ctx.lineTo(x + w*0.25, y + h*0.45 + bobOffset);
      ctx.lineTo(x + w*0.2, y + h*0.95 + bobOffset);
      ctx.lineTo(x + w*0.8, y + h*0.95 + bobOffset);
      ctx.lineTo(x + w*0.75, y + h*0.45 + bobOffset);
      ctx.closePath();
      ctx.fill();
      
      // Plague doctor mask (beak)
      ctx.fillStyle = "#8B4513";
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.25 + bobOffset, w*0.17, 0, Math.PI * 2);
      ctx.fill();
      
      // Beak
      ctx.beginPath();
      ctx.moveTo(x + w*0.5, y + h*0.25 + bobOffset);
      ctx.lineTo(x + w*0.7, y + h*0.22 + bobOffset);
      ctx.lineTo(x + w*0.7, y + h*0.28 + bobOffset);
      ctx.closePath();
      ctx.fill();
      
      // Goggle eyes
      ctx.fillStyle = "#32CD32";
      ctx.shadowBlur = 8;
      ctx.shadowColor = "#32CD32";
      ctx.beginPath();
      ctx.arc(x + w*0.42, y + h*0.23 + bobOffset, w*0.06, 0, Math.PI * 2);
      ctx.arc(x + w*0.52, y + h*0.23 + bobOffset, w*0.06, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      
      // Wide brim hat
      ctx.fillStyle = "#000";
      ctx.fillRect(x + w*0.25, y + h*0.12 + bobOffset, w*0.5, h*0.05);
      ctx.fillRect(x + w*0.35, y + h*0.08 + bobOffset, w*0.3, h*0.08);
      
      // Poison vials
      for(let i = 0; i < 3; i++) {
        ctx.fillStyle = "#32CD32";
        ctx.globalAlpha = 0.7;
        ctx.fillRect(x + w*0.3 + i*w*0.15, y + h*0.6 + bobOffset, w*0.06, h*0.15);
        ctx.fillStyle = "#228B22";
        ctx.fillRect(x + w*0.3 + i*w*0.15, y + h*0.58 + bobOffset, w*0.06, h*0.04);
        ctx.globalAlpha = 1;
      }
      
      // Poison cloud aura
      const poisonPulse = Math.sin(Date.now() / 400) * 10;
      ctx.fillStyle = "#32CD32";
      ctx.globalAlpha = 0.3;
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.6 + bobOffset, w*0.5 + poisonPulse, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
    
    function drawLightningRangerSprite(x, y, w, h, animFrame, isMoving, bobOffset) {
      // LightningRanger - Chain lightning specialist
      // Light armor with electric patterns
      ctx.fillStyle = player.color;
      ctx.fillRect(x + w*0.3, y + h*0.4 + bobOffset, w*0.4, h*0.45);
      
      // Electric lines on armor
      ctx.strokeStyle = "#FFFF00";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x + w*0.35, y + h*0.45 + bobOffset);
      ctx.lineTo(x + w*0.4, y + h*0.55 + bobOffset);
      ctx.lineTo(x + w*0.35, y + h*0.65 + bobOffset);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x + w*0.65, y + h*0.45 + bobOffset);
      ctx.lineTo(x + w*0.6, y + h*0.55 + bobOffset);
      ctx.lineTo(x + w*0.65, y + h*0.65 + bobOffset);
      ctx.stroke();
      
      // Head
      ctx.fillStyle = "#ffd4a3";
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.28 + bobOffset, w*0.17, 0, Math.PI * 2);
      ctx.fill();
      
      // Lightning crown
      ctx.fillStyle = "#FFFF00";
      ctx.shadowBlur = 10;
      ctx.shadowColor = "#FFFF00";
      for(let i = 0; i < 5; i++) {
        ctx.beginPath();
        ctx.moveTo(x + w*0.3 + i*w*0.1, y + h*0.15 + bobOffset);
        ctx.lineTo(x + w*0.28 + i*w*0.1, y + h*0.08 + bobOffset);
        ctx.lineTo(x + w*0.32 + i*w*0.1, y + h*0.08 + bobOffset);
        ctx.closePath();
        ctx.fill();
      }
      ctx.shadowBlur = 0;
      
      // Electrified bow
      ctx.strokeStyle = "#8B4513";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(x + w*0.85, y + h*0.5 + bobOffset, w*0.25, -Math.PI/4, Math.PI/4, false);
      ctx.stroke();
      
      // Lightning string
      ctx.strokeStyle = "#FFFF00";
      ctx.lineWidth = 2;
      ctx.shadowBlur = 8;
      ctx.shadowColor = "#FFFF00";
      ctx.beginPath();
      ctx.moveTo(x + w*0.68, y + h*0.37 + bobOffset);
      ctx.lineTo(x + w*0.72, y + h*0.5 + bobOffset);
      ctx.lineTo(x + w*0.68, y + h*0.63 + bobOffset);
      ctx.stroke();
      ctx.shadowBlur = 0;
      
      // Sparks
      const sparkTime = Date.now() / 100;
      for(let i = 0; i < 4; i++) {
        const angle = sparkTime + i * Math.PI / 2;
        const sx = x + w*0.5 + Math.cos(angle) * w*0.35;
        const sy = y + h*0.6 + Math.sin(angle) * w*0.35 + bobOffset;
        ctx.fillStyle = "#FFFF00";
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.arc(sx, sy, w*0.04, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }
    
    function drawBloodReaverSprite(x, y, w, h, animFrame, isMoving, bobOffset) {
      // BloodReaver - Life-stealing vampire
      // Dark crimson armor
      ctx.fillStyle = player.color;
      ctx.fillRect(x + w*0.27, y + h*0.38 + bobOffset, w*0.46, h*0.5);
      
      // Cape
      ctx.fillStyle = "#8B0000";
      ctx.beginPath();
      ctx.moveTo(x + w*0.3, y + h*0.38 + bobOffset);
      ctx.lineTo(x + w*0.15, y + h*0.5 + bobOffset);
      ctx.lineTo(x + w*0.2, y + h*0.9 + bobOffset);
      ctx.lineTo(x + w*0.35, y + h*0.8 + bobOffset);
      ctx.closePath();
      ctx.fill();
      
      ctx.beginPath();
      ctx.moveTo(x + w*0.7, y + h*0.38 + bobOffset);
      ctx.lineTo(x + w*0.85, y + h*0.5 + bobOffset);
      ctx.lineTo(x + w*0.8, y + h*0.9 + bobOffset);
      ctx.lineTo(x + w*0.65, y + h*0.8 + bobOffset);
      ctx.closePath();
      ctx.fill();
      
      // Pale vampire head
      ctx.fillStyle = "#E8E8E8";
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.26 + bobOffset, w*0.18, 0, Math.PI * 2);
      ctx.fill();
      
      // Blood-red eyes
      ctx.fillStyle = "#FF0000";
      ctx.shadowBlur = 10;
      ctx.shadowColor = "#FF0000";
      ctx.beginPath();
      ctx.arc(x + w*0.42, y + h*0.24 + bobOffset, w*0.04, 0, Math.PI * 2);
      ctx.arc(x + w*0.58, y + h*0.24 + bobOffset, w*0.04, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      
      // Fangs
      ctx.fillStyle = "#FFFFFF";
      ctx.beginPath();
      ctx.moveTo(x + w*0.45, y + h*0.3 + bobOffset);
      ctx.lineTo(x + w*0.47, y + h*0.34 + bobOffset);
      ctx.lineTo(x + w*0.43, y + h*0.34 + bobOffset);
      ctx.closePath();
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(x + w*0.55, y + h*0.3 + bobOffset);
      ctx.lineTo(x + w*0.57, y + h*0.34 + bobOffset);
      ctx.lineTo(x + w*0.53, y + h*0.34 + bobOffset);
      ctx.closePath();
      ctx.fill();
      
      // Blood scythe
      ctx.strokeStyle = "#C0C0C0";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(x + w*0.85, y + h*0.3 + bobOffset);
      ctx.lineTo(x + w*0.85, y + h*0.8 + bobOffset);
      ctx.stroke();
      
      ctx.fillStyle = "#8B0000";
      ctx.beginPath();
      ctx.arc(x + w*0.85, y + h*0.25 + bobOffset, w*0.15, Math.PI, Math.PI * 1.5);
      ctx.fill();
      
      // Blood droplets
      const dropTime = Date.now() / 200;
      for(let i = 0; i < 3; i++) {
        const dy = (dropTime + i*20) % 50;
        ctx.fillStyle = "#FF0000";
        ctx.globalAlpha = 1 - dy/50;
        ctx.beginPath();
        ctx.arc(x + w*0.4 + i*w*0.1, y + h*0.5 + dy + bobOffset, w*0.03, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }
    
    function drawCrystalGuardianSprite(x, y, w, h, animFrame, isMoving, bobOffset) {
      // CrystalGuardian - Defensive tank with crystal armor
      // Massive crystal body
      ctx.fillStyle = player.color;
      ctx.fillRect(x + w*0.2, y + h*0.35 + bobOffset, w*0.6, h*0.55);
      
      // Crystal facets
      ctx.strokeStyle = player.glowColor;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x + w*0.2, y + h*0.35 + bobOffset);
      ctx.lineTo(x + w*0.5, y + h*0.5 + bobOffset);
      ctx.lineTo(x + w*0.8, y + h*0.35 + bobOffset);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x + w*0.2, y + h*0.9 + bobOffset);
      ctx.lineTo(x + w*0.5, y + h*0.7 + bobOffset);
      ctx.lineTo(x + w*0.8, y + h*0.9 + bobOffset);
      ctx.stroke();
      
      // Crystal spikes on shoulders
      ctx.fillStyle = player.accent;
      for(let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.moveTo(x + w*0.15, y + h*0.4 + i*h*0.08 + bobOffset);
        ctx.lineTo(x + w*0.05, y + h*0.35 + i*h*0.08 + bobOffset);
        ctx.lineTo(x + w*0.15, y + h*0.35 + i*h*0.08 + bobOffset);
        ctx.closePath();
        ctx.fill();
        
        ctx.beginPath();
        ctx.moveTo(x + w*0.85, y + h*0.4 + i*h*0.08 + bobOffset);
        ctx.lineTo(x + w*0.95, y + h*0.35 + i*h*0.08 + bobOffset);
        ctx.lineTo(x + w*0.85, y + h*0.35 + i*h*0.08 + bobOffset);
        ctx.closePath();
        ctx.fill();
      }
      
      // Glowing crystal core
      const corePulse = Math.sin(Date.now() / 300) * 0.1 + 0.9;
      ctx.fillStyle = player.bulletColor;
      ctx.shadowBlur = 20;
      ctx.shadowColor = player.bulletColor;
      ctx.globalAlpha = corePulse;
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.55 + bobOffset, w*0.15, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      
      // Crystal head/helmet
      ctx.fillStyle = player.accent;
      ctx.beginPath();
      ctx.moveTo(x + w*0.5, y + h*0.15 + bobOffset);
      ctx.lineTo(x + w*0.35, y + h*0.35 + bobOffset);
      ctx.lineTo(x + w*0.65, y + h*0.35 + bobOffset);
      ctx.closePath();
      ctx.fill();
      
      // Glowing eyes
      ctx.fillStyle = player.glowColor;
      ctx.shadowBlur = 8;
      ctx.shadowColor = player.glowColor;
      ctx.fillRect(x + w*0.4, y + h*0.26 + bobOffset, w*0.06, h*0.04);
      ctx.fillRect(x + w*0.54, y + h*0.26 + bobOffset, w*0.06, h*0.04);
      ctx.shadowBlur = 0;
    }
    
    function drawShadowMonkSprite(x, y, w, h, animFrame, isMoving, bobOffset) {
      // ShadowMonk - Melee martial artist
      // Simple monk robes
      ctx.fillStyle = player.color;
      ctx.fillRect(x + w*0.32, y + h*0.4 + bobOffset, w*0.36, h*0.48);
      
      // Belt/sash
      ctx.fillStyle = player.accent;
      ctx.fillRect(x + w*0.28, y + h*0.65 + bobOffset, w*0.44, h*0.08);
      
      // Head
      ctx.fillStyle = "#ffd4a3";
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.28 + bobOffset, w*0.17, 0, Math.PI * 2);
      ctx.fill();
      
      // Shaved head marking
      ctx.strokeStyle = player.accent;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.2 + bobOffset, w*0.08, 0, Math.PI * 2);
      ctx.stroke();
      
      // Focused eyes
      ctx.fillStyle = "#000";
      ctx.fillRect(x + w*0.42, y + h*0.27 + bobOffset, w*0.06, h*0.02);
      ctx.fillRect(x + w*0.52, y + h*0.27 + bobOffset, w*0.06, h*0.02);
      
      // Fighting stance - fists
      ctx.fillStyle = "#ffd4a3";
      ctx.beginPath();
      ctx.arc(x + w*0.15, y + h*0.55 + bobOffset, w*0.1, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + w*0.85, y + h*0.55 + bobOffset, w*0.1, 0, Math.PI * 2);
      ctx.fill();
      
      // Shadow energy aura
      ctx.strokeStyle = "#4B0082";
      ctx.globalAlpha = 0.5;
      ctx.lineWidth = 3;
      for(let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.arc(x + w*0.5, y + h*0.6 + bobOffset, w*0.35 + i*w*0.1, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      
      // Chi symbol on chest
      ctx.fillStyle = player.glowColor;
      ctx.font = `${w*0.2}px Arial`;
      ctx.fillText("‚òØ", x + w*0.42, y + h*0.6 + bobOffset);
    }
    
    function drawHolyClericSprite(x, y, w, h, animFrame, isMoving, bobOffset) {
      // HolyCleric - Healer with auto-heal and knockback
      // White/gold robes
      ctx.fillStyle = player.color;
      ctx.beginPath();
      ctx.moveTo(x + w*0.5, y + h*0.35 + bobOffset);
      ctx.lineTo(x + w*0.25, y + h*0.48 + bobOffset);
      ctx.lineTo(x + w*0.22, y + h*0.92 + bobOffset);
      ctx.lineTo(x + w*0.78, y + h*0.92 + bobOffset);
      ctx.lineTo(x + w*0.75, y + h*0.48 + bobOffset);
      ctx.closePath();
      ctx.fill();
      
      // Gold trim
      ctx.strokeStyle = "#FFD700";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(x + w*0.25, y + h*0.48 + bobOffset);
      ctx.lineTo(x + w*0.22, y + h*0.92 + bobOffset);
      ctx.lineTo(x + w*0.78, y + h*0.92 + bobOffset);
      ctx.lineTo(x + w*0.75, y + h*0.48 + bobOffset);
      ctx.stroke();
      
      // Head
      ctx.fillStyle = "#ffd4a3";
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.26 + bobOffset, w*0.17, 0, Math.PI * 2);
      ctx.fill();
      
      // Halo
      const haloGlow = Math.sin(Date.now() / 400) * 0.2 + 0.8;
      ctx.strokeStyle = "#FFD700";
      ctx.lineWidth = 4;
      ctx.shadowBlur = 15;
      ctx.shadowColor = "#FFD700";
      ctx.globalAlpha = haloGlow;
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.12 + bobOffset, w*0.15, 0, Math.PI * 2);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      
      // Staff with cross
      ctx.strokeStyle = "#FFFFFF";
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.moveTo(x + w*0.85, y + h*0.25 + bobOffset);
      ctx.lineTo(x + w*0.85, y + h*0.85 + bobOffset);
      ctx.stroke();
      
      // Cross top
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.moveTo(x + w*0.75, y + h*0.3 + bobOffset);
      ctx.lineTo(x + w*0.95, y + h*0.3 + bobOffset);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x + w*0.85, y + h*0.2 + bobOffset);
      ctx.lineTo(x + w*0.85, y + h*0.4 + bobOffset);
      ctx.stroke();
      
      // Healing aura
      ctx.fillStyle = "#90EE90";
      ctx.globalAlpha = 0.3;
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.6 + bobOffset, w*0.55, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
      
      // Healing particles
      for(let i = 0; i < 5; i++) {
        const angle = Date.now() / 500 + i * Math.PI * 2/5;
        const px = x + w*0.5 + Math.cos(angle) * w*0.4;
        const py = y + h*0.6 + Math.sin(angle) * w*0.4 + bobOffset;
        ctx.fillStyle = "#FFD700";
        ctx.beginPath();
        ctx.arc(px, py, w*0.04, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    function drawTrickshotRogueSprite(x, y, w, h, animFrame, isMoving, bobOffset) {
      // TrickshotRogue - Ricochet specialist
      // Agile leather armor
      ctx.fillStyle = player.color;
      ctx.fillRect(x + w*0.33, y + h*0.42 + bobOffset, w*0.34, h*0.46);
      
      // Head
      ctx.fillStyle = "#ffd4a3";
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.29 + bobOffset, w*0.16, 0, Math.PI * 2);
      ctx.fill();
      
      // Bandana
      ctx.fillStyle = player.accent;
      ctx.fillRect(x + w*0.35, y + h*0.23 + bobOffset, w*0.3, h*0.06);
      
      // Confident smirk
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.32 + bobOffset, w*0.08, 0, Math.PI);
      ctx.stroke();
      
      // Trick crossbow with angles
      ctx.fillStyle = "#8B4513";
      ctx.save();
      ctx.translate(x + w*0.8, y + h*0.5 + bobOffset);
      ctx.rotate(Math.PI / 6);
      ctx.fillRect(-w*0.15, -h*0.04, w*0.3, h*0.08);
      ctx.fillStyle = "#C0C0C0";
      ctx.beginPath();
      ctx.moveTo(w*0.15, -h*0.08);
      ctx.lineTo(w*0.22, 0);
      ctx.lineTo(w*0.15, h*0.08);
      ctx.fill();
      ctx.restore();
      
      // Ricochet trajectory lines
      ctx.strokeStyle = player.bulletColor;
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.moveTo(x + w, y + h*0.5 + bobOffset);
      ctx.lineTo(x + w*1.3, y + h*0.3 + bobOffset);
      ctx.lineTo(x + w*1.5, y + h*0.6 + bobOffset);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.globalAlpha = 1;
      
      // Trick shot coins (target markers)
      for(let i = 0; i < 3; i++) {
        ctx.fillStyle = "#FFD700";
        ctx.beginPath();
        ctx.arc(x + w*0.2 + i*w*0.08, y + h*0.65 + bobOffset, w*0.04, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    function drawStarcallerSprite(x, y, w, h, animFrame, isMoving, bobOffset) {
      // Starcaller - Summons helper stars
      // Cosmic robes
      ctx.fillStyle = player.color;
      ctx.beginPath();
      ctx.moveTo(x + w*0.5, y + h*0.36 + bobOffset);
      ctx.lineTo(x + w*0.24, y + h*0.49 + bobOffset);
      ctx.lineTo(x + w*0.2, y + h*0.94 + bobOffset);
      ctx.lineTo(x + w*0.8, y + h*0.94 + bobOffset);
      ctx.lineTo(x + w*0.76, y + h*0.49 + bobOffset);
      ctx.closePath();
      ctx.fill();
      
      // Star pattern on robes
      ctx.fillStyle = "#FFD700";
      for(let i = 0; i < 6; i++) {
        drawStar(ctx, x + w*0.35 + (i%3)*w*0.15, y + h*0.65 + Math.floor(i/3)*h*0.15 + bobOffset, 5, w*0.04, w*0.02);
      }
      
      // Head
      ctx.fillStyle = "#ffd4a3";
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.27 + bobOffset, w*0.17, 0, Math.PI * 2);
      ctx.fill();
      
      // Starry wizard hat
      ctx.fillStyle = player.accent;
      ctx.beginPath();
      ctx.moveTo(x + w*0.3, y + h*0.21 + bobOffset);
      ctx.lineTo(x + w*0.5, y + h*0.02 + bobOffset);
      ctx.lineTo(x + w*0.7, y + h*0.21 + bobOffset);
      ctx.closePath();
      ctx.fill();
      
      // Glowing star on hat
      const starPulse = Math.sin(Date.now() / 300) * 0.15 + 1;
      ctx.fillStyle = "#FFD700";
      ctx.shadowBlur = 15;
      ctx.shadowColor = "#FFD700";
      ctx.globalAlpha = starPulse;
      drawStar(ctx, x + w*0.5, y + h*0.11 + bobOffset, 5, w*0.08, w*0.04);
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      
      // Cosmic staff
      ctx.strokeStyle = "#4B0082";
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.moveTo(x + w*0.12, y + h*0.28 + bobOffset);
      ctx.lineTo(x + w*0.12, y + h*0.88 + bobOffset);
      ctx.stroke();
      
      // Orbiting stars around staff
      for(let i = 0; i < 3; i++) {
        const angle = Date.now() / 600 + i * Math.PI * 2/3;
        const sx = x + w*0.12 + Math.cos(angle) * w*0.12;
        const sy = y + h*0.55 + Math.sin(angle) * w*0.12 + bobOffset;
        ctx.fillStyle = "#FFD700";
        ctx.globalAlpha = 0.8;
        drawStar(ctx, sx, sy, 5, w*0.05, w*0.025);
        ctx.globalAlpha = 1;
      }
      
      // Constellation background
      ctx.strokeStyle = "#FFFFFF";
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.4;
      ctx.beginPath();
      ctx.moveTo(x + w*0.4, y + h*0.5 + bobOffset);
      ctx.lineTo(x + w*0.55, y + h*0.45 + bobOffset);
      ctx.lineTo(x + w*0.6, y + h*0.6 + bobOffset);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }
    
    function drawAstralGolemSprite(x, y, w, h, animFrame, isMoving, bobOffset) {
      // AstralGolem - Massive slow cosmic tank
      // Large stone/crystal body
      ctx.fillStyle = player.color;
      ctx.fillRect(x + w*0.18, y + h*0.32 + bobOffset, w*0.64, h*0.6);
      
      // Stone texture cracks
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.3;
      for(let i = 0; i < 8; i++) {
        ctx.beginPath();
        ctx.moveTo(x + w*0.2 + Math.random()*w*0.6, y + h*0.35 + bobOffset);
        ctx.lineTo(x + w*0.2 + Math.random()*w*0.6, y + h*0.35 + Math.random()*h*0.5 + bobOffset);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      
      // Massive shoulders
      ctx.fillStyle = player.accent;
      ctx.fillRect(x + w*0.08, y + h*0.35 + bobOffset, w*0.25, h*0.2);
      ctx.fillRect(x + w*0.67, y + h*0.35 + bobOffset, w*0.25, h*0.2);
      
      // Cosmic core (glowing)
      const corePulse = Math.sin(Date.now() / 400) * 0.15 + 0.85;
      ctx.fillStyle = player.bulletColor;
      ctx.shadowBlur = 25;
      ctx.shadowColor = player.bulletColor;
      ctx.globalAlpha = corePulse;
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.6 + bobOffset, w*0.18, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      
      // Cosmic runes on body
      ctx.fillStyle = player.glowColor;
      ctx.globalAlpha = 0.7;
      ctx.font = `${w*0.12}px Arial`;
      ctx.fillText("‚úß", x + w*0.25, y + h*0.5 + bobOffset);
      ctx.fillText("‚ú¶", x + w*0.7, y + h*0.5 + bobOffset);
      ctx.fillText("‚òÖ", x + w*0.5, y + h*0.8 + bobOffset);
      ctx.globalAlpha = 1;
      
      // Simple head shape
      ctx.fillStyle = player.color;
      ctx.fillRect(x + w*0.35, y + h*0.15 + bobOffset, w*0.3, h*0.22);
      
      // Glowing eyes
      ctx.fillStyle = player.bulletColor;
      ctx.shadowBlur = 12;
      ctx.shadowColor = player.bulletColor;
      ctx.fillRect(x + w*0.4, y + h*0.22 + bobOffset, w*0.08, h*0.08);
      ctx.fillRect(x + w*0.52, y + h*0.22 + bobOffset, w*0.08, h*0.08);
      ctx.shadowBlur = 0;
      
      // Massive fists
      ctx.fillStyle = player.accent;
      ctx.fillRect(x + w*0.02, y + h*0.55 + bobOffset, w*0.15, h*0.18);
      ctx.fillRect(x + w*0.83, y + h*0.55 + bobOffset, w*0.15, h*0.18);
    }
    
    function drawEngineerSprite(x, y, w, h, animFrame, isMoving, bobOffset) {
      // Engineer - Turret placer with wrench
      // Work coveralls
      ctx.fillStyle = player.color;
      ctx.fillRect(x + w*0.3, y + h*0.42 + bobOffset, w*0.4, h*0.48);
      
      // Tool belt
      ctx.fillStyle = "#8B4513";
      ctx.fillRect(x + w*0.28, y + h*0.68 + bobOffset, w*0.44, h*0.08);
      
      // Tools on belt
      ctx.fillStyle = "#C0C0C0";
      for(let i = 0; i < 4; i++) {
        ctx.fillRect(x + w*0.32 + i*w*0.09, y + h*0.66 + bobOffset, w*0.04, h*0.1);
      }
      
      // Head with hardhat
      ctx.fillStyle = "#ffd4a3";
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.3 + bobOffset, w*0.16, 0, Math.PI * 2);
      ctx.fill();
      
      // Hardhat
      ctx.fillStyle = "#FFD700";
      ctx.fillRect(x + w*0.32, y + h*0.18 + bobOffset, w*0.36, h*0.08);
      ctx.fillRect(x + w*0.36, y + h*0.14 + bobOffset, w*0.28, h*0.06);
      
      // Safety goggles
      ctx.fillStyle = "#87CEEB";
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x + w*0.42, y + h*0.28 + bobOffset, w*0.06, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(x + w*0.58, y + h*0.28 + bobOffset, w*0.06, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      
      // Large wrench
      ctx.fillStyle = "#C0C0C0";
      ctx.fillRect(x + w*0.75, y + h*0.5 + bobOffset, w*0.08, h*0.35);
      ctx.fillRect(x + w*0.72, y + h*0.48 + bobOffset, w*0.14, h*0.08);
      ctx.fillRect(x + w*0.72, y + h*0.83 + bobOffset, w*0.14, h*0.08);
      
      // Blueprint/schematic
      ctx.fillStyle = "#ADD8E6";
      ctx.fillRect(x + w*0.12, y + h*0.55 + bobOffset, w*0.15, h*0.2);
      ctx.strokeStyle = "#0000FF";
      ctx.lineWidth = 1;
      ctx.strokeRect(x + w*0.12, y + h*0.55 + bobOffset, w*0.15, h*0.2);
      
      // Miniature turret icon on blueprint
      ctx.fillStyle = "#0000FF";
      ctx.fillRect(x + w*0.16, y + h*0.6 + bobOffset, w*0.04, h*0.08);
      ctx.beginPath();
      ctx.moveTo(x + w*0.14, y + h*0.6 + bobOffset);
      ctx.lineTo(x + w*0.18, y + h*0.55 + bobOffset);
      ctx.lineTo(x + w*0.22, y + h*0.6 + bobOffset);
      ctx.closePath();
      ctx.fill();
    }
    
    function drawGuardianTankSprite(x, y, w, h, animFrame, isMoving, bobOffset) {
      // GuardianTank - Defensive specialist with high HP
      // Massive plate armor
      ctx.fillStyle = player.color;
      ctx.fillRect(x + w*0.22, y + h*0.36 + bobOffset, w*0.56, h*0.56);
      
      // Extra thick shoulder plates
      ctx.fillStyle = player.accent;
      ctx.fillRect(x + w*0.12, y + h*0.36 + bobOffset, w*0.22, h*0.18);
      ctx.fillRect(x + w*0.66, y + h*0.36 + bobOffset, w*0.22, h*0.18);
      
      // Chest plate rivets
      ctx.fillStyle = "#C0C0C0";
      for(let row = 0; row < 3; row++) {
        for(let col = 0; col < 4; col++) {
          ctx.beginPath();
          ctx.arc(x + w*0.3 + col*w*0.13, y + h*0.5 + row*h*0.12 + bobOffset, w*0.02, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      // Great helm
      ctx.fillStyle = player.accent;
      ctx.fillRect(x + w*0.33, y + h*0.16 + bobOffset, w*0.34, h*0.26);
      
      // Helmet crest
      ctx.fillStyle = player.bulletColor;
      ctx.beginPath();
      ctx.moveTo(x + w*0.5, y + h*0.1 + bobOffset);
      ctx.lineTo(x + w*0.45, y + h*0.16 + bobOffset);
      ctx.lineTo(x + w*0.55, y + h*0.16 + bobOffset);
      ctx.closePath();
      ctx.fill();
      
      // Visor cross
      ctx.fillStyle = "#000";
      ctx.fillRect(x + w*0.48, y + h*0.24 + bobOffset, w*0.04, h*0.12);
      ctx.fillRect(x + w*0.38, y + h*0.28 + bobOffset, w*0.24, h*0.04);
      
      // Massive tower shield
      ctx.fillStyle = player.bulletColor;
      ctx.fillRect(x + w*0.05, y + h*0.35 + bobOffset, w*0.18, h*0.5);
      
      // Shield cross emblem
      ctx.fillStyle = "#FFD700";
      ctx.fillRect(x + w*0.12, y + h*0.45 + bobOffset, w*0.04, h*0.25);
      ctx.fillRect(x + w*0.08, y + h*0.55 + bobOffset, w*0.12, h*0.04);
      
      // Heavy mace
      ctx.fillStyle = "#8B4513";
      ctx.fillRect(x + w*0.82, y + h*0.5 + bobOffset, w*0.06, h*0.35);
      ctx.fillStyle = "#696969";
      ctx.beginPath();
      ctx.arc(x + w*0.85, y + h*0.45 + bobOffset, w*0.08, 0, Math.PI * 2);
      ctx.fill();
      
      // Spikes on mace
      for(let i = 0; i < 6; i++) {
        const angle = i * Math.PI / 3;
        ctx.fillStyle = "#C0C0C0";
        ctx.save();
        ctx.translate(x + w*0.85, y + h*0.45 + bobOffset);
        ctx.rotate(angle);
        ctx.fillRect(-w*0.02, -w*0.12, w*0.04, w*0.08);
        ctx.restore();
      }
    }
    
    function drawBerserkSprite(x, y, w, h, animFrame, isMoving, bobOffset) {
      // Berserk - Rage damage scaling
      // Torn barbarian clothing
      ctx.fillStyle = player.color;
      ctx.fillRect(x + w*0.3, y + h*0.44 + bobOffset, w*0.4, h*0.48);
      
      // Torn edges
      for(let i = 0; i < 8; i++) {
        ctx.fillStyle = player.accent;
        ctx.fillRect(x + w*0.28 + i*w*0.06, y + h*0.88 + bobOffset, w*0.04, h*0.06);
      }
      
      // Muscular head
      ctx.fillStyle = "#d4a574";
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.3 + bobOffset, w*0.19, 0, Math.PI * 2);
      ctx.fill();
      
      // War paint
      ctx.fillStyle = player.bulletColor;
      ctx.fillRect(x + w*0.35, y + h*0.26 + bobOffset, w*0.3, h*0.04);
      ctx.fillRect(x + w*0.48, y + h*0.22 + bobOffset, w*0.04, h*0.12);
      
      // Rage eyes (glowing red)
      ctx.fillStyle = "#FF0000";
      ctx.shadowBlur = 12;
      ctx.shadowColor = "#FF0000";
      ctx.beginPath();
      ctx.arc(x + w*0.42, y + h*0.28 + bobOffset, w*0.05, 0, Math.PI * 2);
      ctx.arc(x + w*0.58, y + h*0.28 + bobOffset, w*0.05, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      
      // Massive battle axe
      ctx.strokeStyle = "#8B4513";
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.moveTo(x + w*0.85, y + h*0.35 + bobOffset);
      ctx.lineTo(x + w*0.85, y + h*0.85 + bobOffset);
      ctx.stroke();
      
      // Axe blade
      ctx.fillStyle = "#C0C0C0";
      ctx.beginPath();
      ctx.moveTo(x + w*0.85, y + h*0.35 + bobOffset);
      ctx.lineTo(x + w*1.05, y + h*0.25 + bobOffset);
      ctx.lineTo(x + w*1.05, y + h*0.45 + bobOffset);
      ctx.closePath();
      ctx.fill();
      
      // Blood on axe
      ctx.fillStyle = "#8B0000";
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.arc(x + w*0.95, y + h*0.35 + bobOffset, w*0.05, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
      
      // Rage aura
      const ragePulse = Math.sin(Date.now() / 150) * 10;
      ctx.strokeStyle = "#FF4500";
      ctx.globalAlpha = 0.6;
      ctx.lineWidth = 4;
      for(let i = 0; i < 2; i++) {
        ctx.beginPath();
        ctx.arc(x + w*0.5, y + h*0.6 + bobOffset, w*0.45 + ragePulse + i*w*0.1, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      
      // Muscles (arms)
      ctx.fillStyle = "#d4a574";
      ctx.beginPath();
      ctx.arc(x + w*0.2, y + h*0.55 + bobOffset, w*0.12, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + w*0.8, y + h*0.55 + bobOffset, w*0.12, 0, Math.PI * 2);
      ctx.fill();
    }
    
    function drawSamuraiSprite(x, y, w, h, animFrame, isMoving, bobOffset) {
      // Samurai - Screen-wide slashes
      // Traditional armor
      ctx.fillStyle = player.color;
      ctx.fillRect(x + w*0.28, y + h*0.4 + bobOffset, w*0.44, h*0.5);
      
      // Shoulder guards (sode)
      ctx.fillStyle = player.accent;
      ctx.fillRect(x + w*0.18, y + h*0.4 + bobOffset, w*0.2, h*0.18);
      ctx.fillRect(x + w*0.62, y + h*0.4 + bobOffset, w*0.2, h*0.18);
      
      // Armor plates (horizontal lines)
      ctx.strokeStyle = "#FFD700";
      ctx.lineWidth = 2;
      for(let i = 0; i < 5; i++) {
        ctx.beginPath();
        ctx.moveTo(x + w*0.28, y + h*0.5 + i*h*0.08 + bobOffset);
        ctx.lineTo(x + w*0.72, y + h*0.5 + i*h*0.08 + bobOffset);
        ctx.stroke();
      }
      
      // Kabuto helmet
      ctx.fillStyle = player.accent;
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.25 + bobOffset, w*0.2, Math.PI, Math.PI * 2);
      ctx.fill();
      ctx.fillRect(x + w*0.3, y + h*0.25 + bobOffset, w*0.4, h*0.12);
      
      // Crescent horns (maedate)
      ctx.fillStyle = "#FFD700";
      ctx.beginPath();
      ctx.arc(x + w*0.35, y + h*0.18 + bobOffset, w*0.08, Math.PI, Math.PI * 1.5);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + w*0.65, y + h*0.18 + bobOffset, w*0.08, Math.PI * 1.5, Math.PI * 2);
      ctx.fill();
      
      // Face mask (menpo)
      ctx.fillStyle = "#8B0000";
      ctx.fillRect(x + w*0.38, y + h*0.3 + bobOffset, w*0.24, h*0.12);
      
      // Katana (long curved blade)
      ctx.strokeStyle = "#C0C0C0";
      ctx.lineWidth = 3;
      ctx.shadowBlur = 8;
      ctx.shadowColor = "#00FFFF";
      ctx.beginPath();
      ctx.moveTo(x + w*0.8, y + h*0.45 + bobOffset);
      ctx.quadraticCurveTo(x + w*1, y + h*0.4 + bobOffset, x + w*1.15, y + h*0.38 + bobOffset);
      ctx.stroke();
      ctx.shadowBlur = 0;
      
      // Katana handle (tsuka)
      ctx.fillStyle = "#000";
      ctx.fillRect(x + w*0.72, y + h*0.43 + bobOffset, w*0.12, h*0.05);
      
      // Tsuba (guard)
      ctx.fillStyle = "#FFD700";
      ctx.beginPath();
      ctx.arc(x + w*0.8, y + h*0.455 + bobOffset, w*0.04, 0, Math.PI * 2);
      ctx.fill();
      
      // Slash effect trail
      if(isMoving || animFrame % 20 < 10) {
        ctx.strokeStyle = player.bulletColor;
        ctx.globalAlpha = 0.5;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(x + w*0.6, y + h*0.3 + bobOffset);
        ctx.lineTo(x + w*1.2, y + h*0.5 + bobOffset);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
    }
    
    function drawWarlockSprite(x, y, w, h, animFrame, isMoving, bobOffset) {
      // Warlock - Shield piercing dark magic
      // Dark corrupted robes
      ctx.fillStyle = player.color;
      ctx.beginPath();
      ctx.moveTo(x + w*0.5, y + h*0.36 + bobOffset);
      ctx.lineTo(x + w*0.24, y + h*0.5 + bobOffset);
      ctx.lineTo(x + w*0.18, y + h*0.96 + bobOffset);
      ctx.lineTo(x + w*0.82, y + h*0.96 + bobOffset);
      ctx.lineTo(x + w*0.76, y + h*0.5 + bobOffset);
      ctx.closePath();
      ctx.fill();
      
      // Demonic symbols on robe
      ctx.fillStyle = player.bulletColor;
      ctx.globalAlpha = 0.8;
      ctx.font = `${w*0.15}px Arial`;
      ctx.fillText("‚õß", x + w*0.43, y + h*0.65 + bobOffset);
      ctx.globalAlpha = 1;
      
      // Horned hood
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.26 + bobOffset, w*0.2, 0, Math.PI * 2);
      ctx.fill();
      
      // Horns
      ctx.fillStyle = "#8B0000";
      ctx.beginPath();
      ctx.moveTo(x + w*0.35, y + h*0.18 + bobOffset);
      ctx.lineTo(x + w*0.3, y + h*0.08 + bobOffset);
      ctx.lineTo(x + w*0.38, y + h*0.15 + bobOffset);
      ctx.closePath();
      ctx.fill();
      
      ctx.beginPath();
      ctx.moveTo(x + w*0.65, y + h*0.18 + bobOffset);
      ctx.lineTo(x + w*0.7, y + h*0.08 + bobOffset);
      ctx.lineTo(x + w*0.62, y + h*0.15 + bobOffset);
      ctx.closePath();
      ctx.fill();
      
      // Fel green eyes
      ctx.fillStyle = "#00FF00";
      ctx.shadowBlur = 15;
      ctx.shadowColor = "#00FF00";
      ctx.beginPath();
      ctx.arc(x + w*0.42, y + h*0.24 + bobOffset, w*0.045, 0, Math.PI * 2);
      ctx.arc(x + w*0.58, y + h*0.24 + bobOffset, w*0.045, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      
      // Cursed tome/grimoire
      ctx.fillStyle = "#4B0082";
      ctx.fillRect(x + w*0.15, y + h*0.55 + bobOffset, w*0.14, h*0.2);
      ctx.fillStyle = "#8B008B";
      ctx.fillRect(x + w*0.17, y + h*0.57 + bobOffset, w*0.1, h*0.16);
      
      // Skull on tome
      ctx.fillStyle = "#E0E0E0";
      ctx.beginPath();
      ctx.arc(x + w*0.22, y + h*0.65 + bobOffset, w*0.04, 0, Math.PI * 2);
      ctx.fill();
      
      // Chaos staff
      ctx.strokeStyle = "#4B0082";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(x + w*0.85, y + h*0.28 + bobOffset);
      ctx.lineTo(x + w*0.85, y + h*0.88 + bobOffset);
      ctx.stroke();
      
      // Demonic skull on staff
      ctx.fillStyle = "#8B0000";
      ctx.beginPath();
      ctx.arc(x + w*0.85, y + h*0.24 + bobOffset, w*0.08, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#00FF00";
      ctx.shadowBlur = 10;
      ctx.shadowColor = "#00FF00";
      ctx.fillRect(x + w*0.81, y + h*0.22 + bobOffset, w*0.03, h*0.03);
      ctx.fillRect(x + w*0.88, y + h*0.22 + bobOffset, w*0.03, h*0.03);
      ctx.shadowBlur = 0;
      
      // Dark energy wisps
      const wispTime = Date.now() / 300;
      for(let i = 0; i < 4; i++) {
        const angle = wispTime + i * Math.PI / 2;
        const wx = x + w*0.5 + Math.cos(angle) * w*0.35;
        const wy = y + h*0.65 + Math.sin(angle) * w*0.25 + bobOffset;
        ctx.fillStyle = "#8B008B";
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.arc(wx, wy, w*0.05, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }
    
    function drawDruidSprite(x, y, w, h, animFrame, isMoving, bobOffset) {
      // Druid - Nature root barriers
      // Nature robes with leaves
      ctx.fillStyle = player.color;
      ctx.beginPath();
      ctx.moveTo(x + w*0.5, y + h*0.37 + bobOffset);
      ctx.lineTo(x + w*0.26, y + h*0.49 + bobOffset);
      ctx.lineTo(x + w*0.22, y + h*0.93 + bobOffset);
      ctx.lineTo(x + w*0.78, y + h*0.93 + bobOffset);
      ctx.lineTo(x + w*0.74, y + h*0.49 + bobOffset);
      ctx.closePath();
      ctx.fill();
      
      // Leaf patterns on robe
      ctx.fillStyle = "#228B22";
      for(let i = 0; i < 8; i++) {
        const lx = x + w*0.3 + (i%2)*w*0.2;
        const ly = y + h*0.55 + Math.floor(i/2)*h*0.1 + bobOffset;
        ctx.beginPath();
        ctx.ellipse(lx, ly, w*0.04, w*0.06, Math.PI/4, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Head with nature crown
      ctx.fillStyle = "#ffd4a3";
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.27 + bobOffset, w*0.17, 0, Math.PI * 2);
      ctx.fill();
      
      // Leaf/vine crown
      ctx.strokeStyle = "#228B22";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.18 + bobOffset, w*0.18, 0, Math.PI);
      ctx.stroke();
      
      // Leaves on crown
      for(let i = 0; i < 5; i++) {
        ctx.fillStyle = "#32CD32";
        const angle = Math.PI * i / 4;
        const lx = x + w*0.5 + Math.cos(angle) * w*0.18;
        const ly = y + h*0.18 + Math.sin(angle) * w*0.18 + bobOffset;
        ctx.beginPath();
        ctx.ellipse(lx, ly, w*0.05, w*0.07, angle, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Wise eyes
      ctx.fillStyle = "#228B22";
      ctx.beginPath();
      ctx.arc(x + w*0.43, y + h*0.26 + bobOffset, w*0.04, 0, Math.PI * 2);
      ctx.arc(x + w*0.57, y + h*0.26 + bobOffset, w*0.04, 0, Math.PI * 2);
      ctx.fill();
      
      // Wooden staff with living vines
      ctx.strokeStyle = "#8B4513";
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.moveTo(x + w*0.12, y + h*0.3 + bobOffset);
      ctx.lineTo(x + w*0.12, y + h*0.87 + bobOffset);
      ctx.stroke();
      
      // Growing vine on staff
      ctx.strokeStyle = "#228B22";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(x + w*0.12, y + h*0.85 + bobOffset);
      for(let i = 0; i < 8; i++) {
        const vy = y + h*0.85 - i*h*0.07 + bobOffset;
        const vx = x + w*0.12 + (i%2 ? w*0.03 : -w*0.03);
        ctx.lineTo(vx, vy);
      }
      ctx.stroke();
      
      // Glowing crystal on staff top
      ctx.fillStyle = "#32CD32";
      ctx.shadowBlur = 15;
      ctx.shadowColor = "#32CD32";
      ctx.beginPath();
      ctx.arc(x + w*0.12, y + h*0.25 + bobOffset, w*0.08, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      
      // Floating leaves
      const leafFloat = Math.sin(Date.now() / 400);
      for(let i = 0; i < 3; i++) {
        const angle = Date.now() / 600 + i * Math.PI * 2/3;
        const lx = x + w*0.5 + Math.cos(angle) * w*0.4;
        const ly = y + h*0.55 + Math.sin(angle) * w*0.3 + leafFloat*5 + bobOffset;
        ctx.fillStyle = "#90EE90";
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.ellipse(lx, ly, w*0.04, w*0.06, angle, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }
    
    function drawGunslingerSprite(x, y, w, h, animFrame, isMoving, bobOffset) {
      // Gunslinger - Dual pistol ricochet master
      // Western duster coat
      ctx.fillStyle = player.color;
      ctx.beginPath();
      ctx.moveTo(x + w*0.5, y + h*0.38 + bobOffset);
      ctx.lineTo(x + w*0.27, y + h*0.47 + bobOffset);
      ctx.lineTo(x + w*0.23, y + h*0.95 + bobOffset);
      ctx.lineTo(x + w*0.77, y + h*0.95 + bobOffset);
      ctx.lineTo(x + w*0.73, y + h*0.47 + bobOffset);
      ctx.closePath();
      ctx.fill();
      
      // Head with cowboy hat
      ctx.fillStyle = "#ffd4a3";
      ctx.beginPath();
      ctx.arc(x + w*0.5, y + h*0.28 + bobOffset, w*0.16, 0, Math.PI * 2);
      ctx.fill();
      
      // Cowboy hat
      ctx.fillStyle = player.accent;
      ctx.fillRect(x + w*0.3, y + h*0.18 + bobOffset, w*0.4, h*0.04);
      ctx.beginPath();
      ctx.ellipse(x + w*0.5, y + h*0.16 + bobOffset, w*0.15, w*0.08, 0, Math.PI, Math.PI * 2);
      ctx.fill();
      
      // Bandana/scarf
      ctx.fillStyle = "#FF4500";
      ctx.fillRect(x + w*0.42, y + h*0.35 + bobOffset, w*0.16, h*0.06);
      
      // Steely eyes
      ctx.fillStyle = "#87CEEB";
      ctx.beginPath();
      ctx.arc(x + w*0.43, y + h*0.27 + bobOffset, w*0.035, 0, Math.PI * 2);
      ctx.arc(x + w*0.57, y + h*0.27 + bobOffset, w*0.035, 0, Math.PI * 2);
      ctx.fill();
      
      // Dual revolvers
      ctx.fillStyle = "#C0C0C0";
      // Left gun
      ctx.fillRect(x + w*0.12, y + h*0.52 + bobOffset, w*0.15, h*0.06);
      ctx.fillRect(x + w*0.1, y + h*0.53 + bobOffset, w*0.04, h*0.04);
      // Right gun
      ctx.fillRect(x + w*0.73, y + h*0.52 + bobOffset, w*0.15, h*0.06);
      ctx.fillRect(x + w*0.86, y + h*0.53 + bobOffset, w*0.04, h*0.04);
      
      // Gun handles (grip)
      ctx.fillStyle = "#8B4513";
      ctx.fillRect(x + w*0.22, y + h*0.51 + bobOffset, w*0.05, h*0.08);
      ctx.fillRect(x + w*0.73, y + h*0.51 + bobOffset, w*0.05, h*0.08);
      
      // Bullet belt
      ctx.fillStyle = "#8B4513";
      ctx.fillRect(x + w*0.28, y + h*0.67 + bobOffset, w*0.44, h*0.06);
      
      // Bullets
      ctx.fillStyle = "#FFD700";
      for(let i = 0; i < 8; i++) {
        ctx.fillRect(x + w*0.3 + i*w*0.05, y + h*0.65 + bobOffset, w*0.02, h*0.08);
      }
      
      // Muzzle flashes (if moving/attacking)
      if(animFrame % 10 < 5) {
        ctx.fillStyle = "#FFA500";
        ctx.shadowBlur = 10;
        ctx.shadowColor = "#FFA500";
        ctx.beginPath();
        ctx.moveTo(x + w*0.1, y + h*0.55 + bobOffset);
        for(let i = 0; i < 6; i++) {
          const angle = i * Math.PI / 3;
          ctx.lineTo(
            x + w*0.1 + Math.cos(angle) * w*0.06,
            y + h*0.55 + Math.sin(angle) * w*0.06 + bobOffset
          );
        }
        ctx.closePath();
        ctx.fill();
        
        ctx.beginPath();
        ctx.moveTo(x + w*0.9, y + h*0.55 + bobOffset);
        for(let i = 0; i < 6; i++) {
          const angle = i * Math.PI / 3;
          ctx.lineTo(
            x + w*0.9 + Math.cos(angle) * w*0.06,
            y + h*0.55 + Math.sin(angle) * w*0.06 + bobOffset
          );
        }
        ctx.closePath();
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }
    
    // Helper function to draw stars
    function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
      let rot = Math.PI / 2 * 3;
      let step = Math.PI / spikes;
      
      ctx.beginPath();
      ctx.moveTo(cx, cy - outerRadius);
      
      for(let i = 0; i < spikes; i++) {
        let x = cx + Math.cos(rot) * outerRadius;
        let y = cy + Math.sin(rot) * outerRadius;
        ctx.lineTo(x, y);
        rot += step;
        
        x = cx + Math.cos(rot) * innerRadius;
        y = cy + Math.sin(rot) * innerRadius;
        ctx.lineTo(x, y);
        rot += step;
      }
      
      ctx.lineTo(cx, cy - outerRadius);
      ctx.closePath();
      ctx.fill();
    }

    function drawEnemies() {
      for (const e of enemies) {
        ctx.shadowColor = e.glowColor;
        ctx.shadowBlur = e.isBoss ? 25 : e.isMiniBoss ? 18 : 12;

        const wobble = Math.sin(e.animFrame * Math.PI * 2) * 2;
        ctx.fillStyle = e.color;
        
        // Draw different shapes based on enemy type
        if (e.shape === "triangle") {
          // Triangle shape
          ctx.beginPath();
          ctx.moveTo(e.x + e.w / 2, e.y + wobble); // Top point
          ctx.lineTo(e.x + e.w, e.y + e.h + wobble); // Bottom right
          ctx.lineTo(e.x, e.y + e.h + wobble); // Bottom left
          ctx.closePath();
          ctx.fill();
        } else if (e.shape === "circle") {
          // Circle shape
          ctx.beginPath();
          ctx.arc(e.x + e.w / 2, e.y + e.h / 2 + wobble, e.w / 2, 0, Math.PI * 2);
          ctx.fill();
        } else {
          // Square shape (default)
          ctx.fillRect(e.x + 2, e.y + wobble, e.w - 4, e.h - 4);
        }

        ctx.shadowBlur = 0;
        
        // Labels
        if (e.pattern) {
          ctx.fillStyle = "#ffffff";
          ctx.font = "bold 12px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText(e.pattern.name.toUpperCase(), e.x + e.w / 2, e.y - 22);
        } else if (e.isBoss) {
          ctx.fillStyle = "#ffffff";
          ctx.font = "bold 12px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText("BOSS", e.x + e.w / 2, e.y - 22);
        } else if (e.isMiniBoss) {
          ctx.fillStyle = "#ffff00";
          ctx.font = "bold 10px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText("MINI-BOSS", e.x + e.w / 2, e.y - 22);
        } else if (e.type === "triangle") {
          ctx.fillStyle = "#ffff00";
          ctx.font = "bold 8px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText("SPEEDY", e.x + e.w / 2, e.y - 22);
        } else if (e.type === "circle") {
          ctx.fillStyle = "#00ff88";
          ctx.font = "bold 8px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText("HEALER", e.x + e.w / 2, e.y - 22);
        } else if (e.type === "jumper") {
          ctx.fillStyle = "#ff00ff";
          ctx.font = "bold 8px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText("JUMPER", e.x + e.w / 2, e.y - 22);
        } else if (e.type === "kamikaze") {
          ctx.fillStyle = "#ff8800";
          ctx.font = "bold 8px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText("BOMBER", e.x + e.w / 2, e.y - 22);
        } else if (e.isRanged) {
          ctx.fillStyle = "#ffaa00";
          ctx.font = "bold 8px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText("SHOOTER", e.x + e.w / 2, e.y - 22);
        } else if (e.hasShield && e.shieldHP > 0) {
          ctx.fillStyle = "#00aaff";
          ctx.font = "bold 8px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText("SHIELDED", e.x + e.w / 2, e.y - 22);
        }
        ctx.textAlign = "left";
        
        // Eyes
        ctx.fillStyle = "#ffff00";
        const eyeSize = e.isBoss ? 8 : e.isMiniBoss ? 6 : 5;
        ctx.fillRect(e.x + e.w * 0.25, e.y + e.h * 0.2, eyeSize, eyeSize);
        ctx.fillRect(e.x + e.w * 0.65, e.y + e.h * 0.2, eyeSize, eyeSize);

        // Shield bar
        if (e.hasShield && e.maxShieldHP > 0) {
          const shieldRatio = e.shieldHP / e.maxShieldHP;
          const barWidth = e.w;
          ctx.fillStyle = "rgba(0, 40, 80, 0.8)";
          ctx.fillRect(e.x, e.y - 14, barWidth, 4);
          
          ctx.fillStyle = "#00aaff";
          ctx.fillRect(e.x, e.y - 14, barWidth * shieldRatio, 4);
        }

        // HP bar
        const hpRatio = e.hp / e.maxHP;
        const barWidth = e.w;
        const barHeight = e.isBoss ? 8 : e.isMiniBoss ? 6 : 5;
        ctx.fillStyle = "rgba(60, 0, 0, 0.8)";
        ctx.fillRect(e.x, e.y - 8, barWidth, barHeight);
        
        const hpColor = hpRatio > 0.5 ? "#44ff44" : hpRatio > 0.25 ? "#ffaa44" : "#ff4444";
        ctx.fillStyle = hpColor;
        ctx.fillRect(e.x, e.y - 8, barWidth * hpRatio, barHeight);
      }
      ctx.shadowBlur = 0;
    }

    function drawProjectiles() {
      for (const p of projectiles) {
        // Special rendering for dragon beam
        if (p.isDragonBeam) {
          ctx.save();
          
          // Thick glowing laser
          ctx.shadowColor = p.glowColor;
          ctx.shadowBlur = 30;
          ctx.strokeStyle = p.color;
          ctx.lineWidth = p.radius * 2;
          ctx.globalAlpha = 0.8;
          ctx.beginPath();
          ctx.moveTo(0, p.y);
          ctx.lineTo(canvas.width, p.y);
          ctx.stroke();
          
          // Inner bright beam
          ctx.shadowBlur = 20;
          ctx.strokeStyle = "#ffff00";
          ctx.lineWidth = p.radius;
          ctx.beginPath();
          ctx.moveTo(0, p.y);
          ctx.lineTo(canvas.width, p.y);
          ctx.stroke();
          
          ctx.restore();
          continue;
        }
        
        // Special rendering for Guardian Tank shield
        if (p.isShield) {
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rotation || 0);
          
          // Draw rotating shield
          ctx.shadowColor = p.glowColor || "#87ceeb";
          ctx.shadowBlur = 20;
          ctx.fillStyle = p.color;
          ctx.fillRect(-12, -12, 24, 24);
          
          // Shield border
          ctx.strokeStyle = "#87ceeb";
          ctx.lineWidth = 3;
          ctx.strokeRect(-12, -12, 24, 24);
          
          // Shield emblem (cross)
          ctx.strokeStyle = "#ffffff";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(0, -8);
          ctx.lineTo(0, 8);
          ctx.moveTo(-8, 0);
          ctx.lineTo(8, 0);
          ctx.stroke();
          
          ctx.restore();
          continue;
        }
        
        // Normal projectile rendering
        ctx.globalAlpha = 0.3;
        ctx.strokeStyle = p.color;
        ctx.lineWidth = p.radius;
        ctx.beginPath();
        for (let i = 0; i < p.trail.length; i++) {
          const t = p.trail[i];
          if (i === 0) ctx.moveTo(t.x, t.y);
          else ctx.lineTo(t.x, t.y);
        }
        ctx.stroke();
        ctx.globalAlpha = 1.0;

        ctx.shadowColor = p.glowColor;
        ctx.shadowBlur = 15;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }

    function drawMinions() {
      if (!player || player.className !== "Summoner") return;
      
      for (const m of minions) {
        ctx.shadowColor = "#88ff88";
        ctx.shadowBlur = 15;
        ctx.fillStyle = "#88ff88";
        ctx.beginPath();
        ctx.arc(m.drawX, m.drawY, 8, 0, Math.PI * 2);
        ctx.fill();

        ctx.shadowBlur = 0;
        ctx.fillStyle = "#ffffff";
        ctx.beginPath();
        ctx.arc(m.drawX, m.drawY, 4, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;
    }

    function drawParticles() {
      for (const p of particles) {
        ctx.globalAlpha = p.life * 0.8;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
      }
      ctx.globalAlpha = 1.0;
    }
    
    function drawFireZones() {
      fireZones.forEach(zone => {
        ctx.save();
        
        // Pulsing fire effect
        const pulse = Math.sin(Date.now() / 100) * 0.2 + 0.8;
        ctx.globalAlpha = 0.6 * pulse;
        
        // Outer glow
        const gradient = ctx.createRadialGradient(zone.x, zone.y, 0, zone.x, zone.y, zone.radius);
        gradient.addColorStop(0, "#ff8800");
        gradient.addColorStop(0.5, "#ff4400");
        gradient.addColorStop(1, "rgba(255, 68, 0, 0)");
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Inner hot spot
        ctx.globalAlpha = 0.8;
        ctx.fillStyle = "#ffff00";
        ctx.beginPath();
        ctx.arc(zone.x, zone.y, zone.radius * 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Fire particles
        if (Math.random() < 0.3) {
          particles.push({
            x: zone.x + (Math.random() - 0.5) * zone.radius,
            y: zone.y + (Math.random() - 0.5) * zone.radius,
            vx: 0,
            vy: -2,
            radius: 3,
            color: Math.random() < 0.5 ? "#ff4400" : "#ff8800",
            life: 0.5
          });
        }
        
        ctx.restore();
      });
    }
    
    function drawPoisonClouds() {
      poisonClouds.forEach(cloud => {
        ctx.save();
        const pulse = Math.sin(Date.now() / 150) * 0.15 + 0.5;
        ctx.globalAlpha = pulse;
        
        const gradient = ctx.createRadialGradient(cloud.x, cloud.y, 0, cloud.x, cloud.y, cloud.radius);
        gradient.addColorStop(0, "#32cd32");
        gradient.addColorStop(0.5, "#90ee90");
        gradient.addColorStop(1, "rgba(50, 205, 50, 0)");
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(cloud.x, cloud.y, cloud.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }
    
    function drawIceShards() {
      iceShards.forEach(shard => {
        ctx.save();
        ctx.fillStyle = "#00bfff";
        ctx.strokeStyle = "#87ceeb";
        ctx.lineWidth = 2;
        
        ctx.translate(shard.x, shard.y);
        ctx.rotate(shard.angle);
        
        ctx.beginPath();
        ctx.moveTo(0, -10);
        ctx.lineTo(5, 10);
        ctx.lineTo(-5, 10);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        ctx.restore();
      });
    }
    
    function drawTurrets() {
      turrets.forEach(turret => {
        ctx.save();
        ctx.fillStyle = "#FF8C00";
        ctx.strokeStyle = "#FFA500";
        ctx.lineWidth = 2;
        
        // Base
        ctx.beginPath();
        ctx.arc(turret.x, turret.y, 15, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        // Cannon
        ctx.strokeStyle = "#FF8C00";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(turret.x, turret.y);
        ctx.lineTo(turret.x + 20, turret.y - 10);
        ctx.stroke();
        
        // HP bar
        const hpPercent = turret.hp / 150;
        ctx.fillStyle = "#ff0000";
        ctx.fillRect(turret.x - 20, turret.y - 30, 40, 4);
        ctx.fillStyle = "#00ff00";
        ctx.fillRect(turret.x - 20, turret.y - 30, 40 * hpPercent, 4);
        
        ctx.restore();
      });
    }
    
    function drawRootBarriers() {
      rootBarriers.forEach(barrier => {
        ctx.save();
        ctx.fillStyle = "#228B22";
        ctx.strokeStyle = "#32CD32";
        ctx.lineWidth = 3;
        
        // Root barrier visual
        ctx.beginPath();
        ctx.arc(barrier.x, barrier.y, 30, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        // Thorns
        for (let i = 0; i < 8; i++) {
          const angle = (i / 8) * Math.PI * 2;
          ctx.beginPath();
          ctx.moveTo(barrier.x, barrier.y);
          ctx.lineTo(barrier.x + Math.cos(angle) * 40, barrier.y + Math.sin(angle) * 40);
          ctx.strokeStyle = "#8B4513";
          ctx.stroke();
        }
        
        // HP bar
        const hpPercent = barrier.hp / 200;
        ctx.fillStyle = "#ff0000";
        ctx.fillRect(barrier.x - 25, barrier.y - 50, 50, 4);
        ctx.fillStyle = "#00ff00";
        ctx.fillRect(barrier.x - 25, barrier.y - 50, 50 * hpPercent, 4);
        
        ctx.restore();
      });
    }
    
    function drawHelperStars() {
      helperStars.forEach(star => {
        ctx.save();
        ctx.fillStyle = "#9400d3";
        ctx.strokeStyle = "#ba55d3";
        ctx.lineWidth = 2;
        
        // Draw star shape
        ctx.translate(star.x, star.y);
        ctx.rotate(Date.now() / 1000);
        
        ctx.beginPath();
        for (let i = 0; i < 5; i++) {
          const angle = (i / 5) * Math.PI * 2 - Math.PI / 2;
          const x = Math.cos(angle) * 10;
          const y = Math.sin(angle) * 10;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
          
          const angle2 = ((i + 0.5) / 5) * Math.PI * 2 - Math.PI / 2;
          const x2 = Math.cos(angle2) * 5;
          const y2 = Math.sin(angle2) * 5;
          ctx.lineTo(x2, y2);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        ctx.restore();
      });
    }

    function drawFloatingTexts() {
      for (const t of floatingTexts) {
        ctx.globalAlpha = t.life;
        ctx.fillStyle = t.color;
        ctx.font = "bold 14px 'Courier New'";
        ctx.textAlign = "center";
        ctx.fillText(t.text, t.x, t.y);
      }
      ctx.globalAlpha = 1.0;
      ctx.textAlign = "left";
    }

    function drawCurrency() {
      for (const drop of currencyDrops) {
        ctx.globalAlpha = Math.min(drop.life, 1.0);
        
        if (drop.type === "coin") {
          ctx.shadowColor = "#ffff00";
          ctx.shadowBlur = 10;
          ctx.fillStyle = "#ffff00";
          ctx.font = "bold 16px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText("üí∞", drop.x, drop.y);
        } else {
          ctx.shadowColor = "#00ffff";
          ctx.shadowBlur = 10;
          ctx.fillStyle = "#00ffff";
          ctx.font = "bold 16px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText("üíé", drop.x, drop.y);
        }
        
        ctx.shadowBlur = 0;
      }
      ctx.globalAlpha = 1.0;
      ctx.textAlign = "left";
    }

    function drawHUD() {
      if (!player) return;

      // Main HUD
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(10, 10, 300, 130); // Increased from 110 to 130
      
      ctx.strokeStyle = "#00ffff";
      ctx.lineWidth = 2;
      ctx.strokeRect(10, 10, 300, 130); // Increased from 110 to 130

      ctx.fillStyle = "#00ffff";
      ctx.font = "bold 14px 'Courier New'";
      ctx.fillText("‚öîÔ∏è " + player.className, 20, 30);
      ctx.fillText("üó∫Ô∏è Map: " + currentMap, 20, 50);
      ctx.fillText("üåä Wave: " + wave, 130, 50);
      ctx.fillText("‚≠ê Level: " + player.level, 230, 50);
      
      // Currency display (bottom of HUD, below XP bar)
      ctx.fillStyle = "#ffff00";
      ctx.fillText("üí∞ " + gameData.totalCoins, 20, 125); // Moved from 105 to 125
      ctx.fillStyle = "#00ffff";
      ctx.fillText("üíé " + gameData.totalGems, 160, 125); // Moved from 105 to 125
      
      // Auto-start indicator (top-right)
      ctx.fillStyle = autoStartWave ? "rgba(0, 255, 0, 0.8)" : "rgba(255, 0, 0, 0.8)";
      ctx.fillRect(canvas.width - 160, 10, 150, 30);
      ctx.strokeStyle = autoStartWave ? "#00ff00" : "#ff0000";
      ctx.lineWidth = 2;
      ctx.strokeRect(canvas.width - 160, 10, 150, 30);
      ctx.fillStyle = "#000000";
      ctx.font = "bold 12px 'Courier New'";
      ctx.fillText("‚ö° Auto-Start: " + (autoStartWave ? "ON" : "OFF"), canvas.width - 150, 28);
      ctx.fillStyle = "#ffff00";
      ctx.font = "10px 'Courier New'";
      ctx.fillText("[R] to toggle", canvas.width - 150, 38);
      
      // Game speed indicator
      ctx.fillStyle = gameSpeed === 2 ? "rgba(255, 136, 0, 0.8)" : "rgba(100, 100, 100, 0.8)";
      ctx.fillRect(canvas.width - 160, 45, 150, 30);
      ctx.strokeStyle = gameSpeed === 2 ? "#ff8800" : "#666666";
      ctx.lineWidth = 2;
      ctx.strokeRect(canvas.width - 160, 45, 150, 30);
      ctx.fillStyle = gameSpeed === 2 ? "#ffffff" : "#cccccc";
      ctx.font = "bold 12px 'Courier New'";
      ctx.fillText("‚è© Speed: " + gameSpeed + "x", canvas.width - 150, 63);
      ctx.fillStyle = "#ffff00";
      ctx.font = "10px 'Courier New'";
      ctx.fillText("[F] to toggle", canvas.width - 150, 73);

      // Shield bar
      if (player.maxShield > 0) {
        const shieldRatio = player.shield / player.maxShield;
        ctx.fillText("üõ°Ô∏è Shield", 20, 70);
        ctx.fillStyle = "rgba(0, 40, 80, 0.8)";
        ctx.fillRect(70, 60, 230, 8);
        
        ctx.fillStyle = "#00aaff";
        ctx.fillRect(70, 60, 230 * shieldRatio, 8);
        
        ctx.strokeStyle = "#00ffff";
        ctx.strokeRect(70, 60, 230, 8);
      }

      // HP bar
      const hpRatio = player.hp / player.maxHP;
      ctx.fillStyle = "#00ffff";
      const hpY = player.maxShield > 0 ? 84 : 70;
      const hpBarY = player.maxShield > 0 ? 74 : 60;
      ctx.fillText("‚ù§Ô∏è HP", 20, hpY);
      ctx.fillStyle = "rgba(60, 0, 0, 0.8)";
      ctx.fillRect(70, hpBarY, 230, 12);
      
      ctx.fillStyle = hpRatio > 0.5 ? "#44ff44" : hpRatio > 0.25 ? "#ffaa44" : "#ff4444";
      ctx.fillRect(70, hpBarY, 230 * hpRatio, 12);
      
      ctx.strokeStyle = "#ff4444";
      ctx.strokeRect(70, hpBarY, 230, 12);

      // XP bar
      const xpRatio = player.xp / player.xpToNext;
      ctx.fillStyle = "#00ffff";
      ctx.fillText("‚ú® XP: " + Math.floor(player.xp) + "/" + player.xpToNext, 20, 102);
      ctx.fillStyle = "rgba(0, 50, 80, 0.8)";
      ctx.fillRect(70, 92, 230, 10);
      
      ctx.fillStyle = "#0088ff";
      ctx.fillRect(70, 92, 230 * xpRatio, 10);
      
      ctx.strokeStyle = "#00ffff";
      ctx.strokeRect(70, 92, 230, 10);

      
      // Combo
      if (combo > 0) {
        ctx.fillStyle = "#ff8800";
        ctx.font = "bold 16px 'Courier New'";
        ctx.fillText("üî• COMBO: " + combo + "x", canvas.width - 200, 80);
      }
      
      // Wave timer
      if (waveTimerActive) {
        ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
        ctx.fillRect(canvas.width / 2 - 100, 10, 200, 50);
        ctx.strokeStyle = "#ffff00";
        ctx.lineWidth = 3;
        ctx.strokeRect(canvas.width / 2 - 100, 10, 200, 50);
        
        ctx.fillStyle = "#ffff00";
        ctx.font = "bold 18px 'Courier New'";
        ctx.textAlign = "center";
        ctx.fillText("‚è∞ Next Wave In:", canvas.width / 2, 30);
        ctx.font = "bold 24px 'Courier New'";
        ctx.fillStyle = waveTimer <= 5 ? "#ff0000" : "#00ff00";
        ctx.fillText(Math.ceil(waveTimer) + "s", canvas.width / 2, 52);
        ctx.textAlign = "left";
      }
      
      // Active potion effects
      let effectY = canvas.height - 140;
      if (potionEffects.critActive) {
        ctx.fillStyle = "rgba(255, 0, 0, 0.8)";
        ctx.fillRect(10, effectY, 180, 30);
        ctx.strokeStyle = "#ff0000";
        ctx.lineWidth = 2;
        ctx.strokeRect(10, effectY, 180, 30);
        ctx.fillStyle = "#ffff00";
        ctx.font = "bold 14px 'Courier New'";
        ctx.fillText("üí• CRIT BOOST: " + Math.ceil(potionEffects.critTimer) + "s", 20, effectY + 20);
        effectY -= 35;
      }
      
      if (potionEffects.damageActive) {
        ctx.fillStyle = "rgba(255, 136, 0, 0.8)";
        ctx.fillRect(10, effectY, 180, 30);
        ctx.strokeStyle = "#ff8800";
        ctx.lineWidth = 2;
        ctx.strokeRect(10, effectY, 180, 30);
        ctx.fillStyle = "#ffff00";
        ctx.font = "bold 14px 'Courier New'";
        ctx.fillText("‚öîÔ∏è DAMAGE UP: " + Math.ceil(potionEffects.damageTimer) + "s", 20, effectY + 20);
        effectY -= 35;
      }
      
      if (potionEffects.speedActive) {
        ctx.fillStyle = "rgba(255, 255, 0, 0.8)";
        ctx.fillRect(10, effectY, 180, 30);
        ctx.strokeStyle = "#ffff00";
        ctx.lineWidth = 2;
        ctx.strokeRect(10, effectY, 180, 30);
        ctx.fillStyle = "#000000";
        ctx.font = "bold 14px 'Courier New'";
        ctx.fillText("‚ö° SPEED UP: " + Math.ceil(potionEffects.speedTimer) + "s", 20, effectY + 20);
        effectY -= 35;
      }
      
      // Potion inventory display at bottom center
      const potionBarY = canvas.height - 60;
      const potionBarWidth = 480;
      const potionBarX = (canvas.width - potionBarWidth) / 2;
      
      ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
      ctx.fillRect(potionBarX, potionBarY, potionBarWidth, 50);
      ctx.strokeStyle = "#00ffff";
      ctx.lineWidth = 2;
      ctx.strokeRect(potionBarX, potionBarY, potionBarWidth, 50);
      
      const potionSlotWidth = 75;
      const potionsList = [
        { key: '1', icon: '‚ù§Ô∏è', name: 'Heal', count: potions.heal, color: '#ff4444' },
        { key: '2', icon: 'üõ°Ô∏è', name: 'Shield', count: potions.shield, color: '#4444ff' },
        { key: '3', icon: 'üí•', name: 'Crit', count: potions.crit, color: '#ff0000' },
        { key: '4', icon: '‚öîÔ∏è', name: 'Damage', count: potions.damage, color: '#ff8800' },
        { key: '5', icon: '‚ö°', name: 'Speed', count: potions.speed, color: '#ffff00' },
        { key: '6', icon: 'üêâ', name: 'Dragon', count: potions.dragon, color: '#ff00ff' }
      ];
      
      potionsList.forEach((potion, i) => {
        const slotX = potionBarX + 10 + (i * potionSlotWidth);
        const slotY = potionBarY + 5;
        
        // Draw slot
        ctx.fillStyle = potion.count > 0 ? "rgba(0, 50, 50, 0.8)" : "rgba(50, 50, 50, 0.5)";
        ctx.fillRect(slotX, slotY, 70, 40);
        ctx.strokeStyle = potion.count > 0 ? potion.color : "#444444";
        ctx.lineWidth = 2;
        ctx.strokeRect(slotX, slotY, 70, 40);
        
        // Draw icon and count
        ctx.fillStyle = potion.count > 0 ? "#ffffff" : "#666666";
        ctx.font = "20px 'Courier New'";
        ctx.textAlign = "center";
        ctx.fillText(potion.icon, slotX + 20, slotY + 28);
        
        ctx.fillStyle = potion.count > 0 ? "#00ff00" : "#666666";
        ctx.font = "bold 16px 'Courier New'";
        ctx.fillText("√ó" + potion.count, slotX + 50, slotY + 28);
        
        // Draw hotkey
        ctx.fillStyle = "#ffff00";
        ctx.font = "10px 'Courier New'";
        ctx.fillText("[" + potion.key + "]", slotX + 35, slotY + 38);
      });
      
      ctx.textAlign = "left";
    }
    
    function drawAbilityEffects() {
      // Upside Down dimension effect
      if (upsideDownActive) {
        ctx.save();
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = "#8B0000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.globalAlpha = 1;
        ctx.restore();
        
        // Distorted text
        ctx.save();
        ctx.fillStyle = "#ff0000";
        ctx.font = "bold 24px 'Courier New'";
        ctx.textAlign = "center";
        ctx.fillText("üåÄ UPSIDE DOWN üåÄ", canvas.width / 2, 50);
        ctx.fillStyle = "#ffff00";
        ctx.font = "16px 'Courier New'";
        ctx.fillText(`${Math.ceil(upsideDownTimer)}s remaining`, canvas.width / 2, 75);
        ctx.restore();
      }
      
      // Hive Mind links
      if (hiveMindActive) {
        ctx.save();
        ctx.strokeStyle = "#ff0000";
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        
        for (let i = 0; i < enemies.length; i++) {
          for (let j = i + 1; j < enemies.length; j++) {
            if (enemies[i].hiveMindLinked && enemies[j].hiveMindLinked) {
              ctx.beginPath();
              ctx.moveTo(enemies[i].x, enemies[i].y);
              ctx.lineTo(enemies[j].x, enemies[j].y);
              ctx.stroke();
            }
          }
        }
        
        ctx.setLineDash([]);
        ctx.restore();
        
        // Display text
        ctx.save();
        ctx.fillStyle = "#ff0000";
        ctx.font = "bold 24px 'Courier New'";
        ctx.textAlign = "center";
        ctx.fillText("üëÅÔ∏è HIVE MIND ACTIVE üëÅÔ∏è", canvas.width / 2, 50);
        ctx.fillStyle = "#ffff00";
        ctx.font = "16px 'Courier New'";
        ctx.fillText(`${Math.ceil(hiveMindTimer)}s remaining`, canvas.width / 2, 75);
        ctx.restore();
      }
      
      // Blade Storm effect
      if (bladeStormActive && player) {
        ctx.save();
        ctx.strokeStyle = "#9933ff";
        ctx.lineWidth = 3;
        const numBlades = 8;
        const time = Date.now() / 100;
        
        for (let i = 0; i < numBlades; i++) {
          const angle = (Math.PI * 2 / numBlades) * i + time;
          const x1 = player.x + Math.cos(angle) * 100;
          const y1 = player.y + Math.sin(angle) * 100;
          const x2 = player.x + Math.cos(angle + 0.5) * 150;
          const y2 = player.y + Math.sin(angle + 0.5) * 150;
          
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }
        ctx.restore();
      }
      
      // Time Freeze effect
      if (timeFreezeActive) {
        ctx.save();
        ctx.strokeStyle = "#00ffff";
        ctx.lineWidth = 2;
        
        enemies.forEach(e => {
          if (e.frozen) {
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.radius + 5, 0, Math.PI * 2);
            ctx.stroke();
          }
        });
        
        ctx.fillStyle = "#00ffff";
        ctx.font = "bold 24px 'Courier New'";
        ctx.textAlign = "center";
        ctx.fillText("‚ùÑÔ∏è TIME FROZEN ‚ùÑÔ∏è", canvas.width / 2, 50);
        ctx.restore();
      }
      
      // Vecna monsters
      vecnaMonsters.forEach(m => {
        ctx.save();
        ctx.fillStyle = m.color;
        ctx.beginPath();
        ctx.arc(m.x, m.y, m.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // HP bar
        const barWidth = 30;
        const barHeight = 4;
        const hpPercent = m.hp / m.maxHP;
        
        ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
        ctx.fillRect(m.x - barWidth / 2, m.y - m.radius - 10, barWidth, barHeight);
        
        ctx.fillStyle = "#00ff00";
        ctx.fillRect(m.x - barWidth / 2, m.y - m.radius - 10, barWidth * hpPercent, barHeight);
        
        ctx.restore();
      });
    }

    function draw() {
      // Only draw game elements when actually playing
      if (!gameRunning || gameState === "title") {
        return;
      }
      
      ctx.save();
      if (screenShake > 0) {
        const shakeX = (Math.random() - 0.5) * screenShake;
        const shakeY = (Math.random() - 0.5) * screenShake;
        ctx.translate(shakeX, shakeY);
      }

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      drawBackground();
      drawGround();
      drawFireZones();
      drawPoisonClouds();
      drawIceShards();
      drawRootBarriers();
      drawTurrets();
      if (player) drawPlayer();
      drawHelperStars();
      drawEnemies();
      drawProjectiles();
      drawMinions();
      drawParticles();
      drawFloatingTexts();
      drawCurrency();
      drawHUD();
      
      // Special ability visual effects
      drawAbilityEffects();

      ctx.restore();
    }

    function gameLoop(timestamp) {
      const baseDt = Math.min((timestamp - lastTime) / 1000, 0.1);
      const dt = baseDt * gameSpeed; // Apply game speed multiplier
      lastTime = timestamp;

      if (gameRunning && !gamePaused) {
        update(dt);
      }
      
      draw();
      requestAnimationFrame(gameLoop);
    }

    // Load character sprites
    loadCharacterSprites();

    // Start draw loop
    draw();
  </script>
</body>
</html>