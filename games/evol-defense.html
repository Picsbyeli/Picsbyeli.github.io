<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>EVOL LEGENDS - Tower Defense</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      font-family: 'Courier New', monospace;
      color: #fff;
      overflow: hidden;
    }
    #gameContainer {
      position: relative;
      background: #111;
      box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
    }
    canvas {
      display: block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    
    /* Title Screen */
    #titleScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: linear-gradient(135deg, #0a0015 0%, #1a0030 100%);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }
    #titleScreen.hidden { display: none; }
    
    .title {
      font-size: 72px;
      font-weight: bold;
      color: #00ffff;
      text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
      margin-bottom: 20px;
      animation: glow 2s ease-in-out infinite;
    }
    @keyframes glow {
      0%, 100% { text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff; }
      50% { text-shadow: 0 0 30px #00ffff, 0 0 60px #00ffff, 0 0 80px #00ffff; }
    }
    
    .subtitle {
      font-size: 24px;
      color: #ff00ff;
      margin-bottom: 40px;
      text-shadow: 0 0 10px #ff00ff;
    }
    
    .start-btn {
      padding: 20px 60px;
      font-size: 28px;
      font-weight: bold;
      background: linear-gradient(135deg, #ff0080 0%, #ff8c00 100%);
      color: #fff;
      border: 4px solid #00ffff;
      border-radius: 15px;
      cursor: pointer;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
      transition: all 0.3s;
    }
    .start-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
    }
    
    /* Class Selection Screen */
    #classSelection {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: linear-gradient(135deg, #0a0015 0%, #1a0030 100%);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      overflow-y: auto;
      padding: 20px;
    }
    #classSelection.active { display: flex; }
    
    .class-title {
      font-size: 42px;
      color: #00ffff;
      text-shadow: 0 0 20px #00ffff;
      margin-bottom: 10px;
    }
    
    .class-subtitle {
      font-size: 16px;
      color: #ffff00;
      margin-bottom: 30px;
    }
    
    .class-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      max-width: 900px;
      width: 100%;
    }
    
    .class-card {
      background: linear-gradient(135deg, #1a1a3a 0%, #2a1a3a 100%);
      border: 3px solid #00ffff;
      border-radius: 15px;
      padding: 20px;
      cursor: pointer;
      transition: all 0.3s;
      position: relative;
    }
    .class-card:hover:not(.locked) {
      transform: translateY(-10px);
      box-shadow: 0 10px 30px rgba(0, 255, 255, 0.5);
      border-color: #ffff00;
    }
    .class-card.locked {
      opacity: 0.5;
      cursor: not-allowed;
      border-color: #666;
    }
    .class-card.locked::after {
      content: "üîí";
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 32px;
    }
    
    .class-icon {
      font-size: 48px;
      text-align: center;
      margin-bottom: 10px;
    }
    .class-name {
      font-size: 22px;
      font-weight: bold;
      text-align: center;
      margin-bottom: 10px;
    }
    .class-stats {
      font-size: 12px;
      color: #aaa;
      line-height: 1.6;
    }
    .class-unlock {
      font-size: 12px;
      color: #ff8800;
      text-align: center;
      margin-top: 10px;
      font-weight: bold;
    }
    
    /* Shop Screen */
    #shopScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      flex-direction: column;
      align-items: center;
      z-index: 90;
      overflow-y: auto;
      padding: 20px;
    }
    #shopScreen.active { display: flex; }
    
    .shop-header {
      width: 100%;
      max-width: 900px;
      background: linear-gradient(135deg, #1a1a3a 0%, #2a1a3a 100%);
      border: 3px solid #00ffff;
      border-radius: 15px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .shop-title {
      font-size: 36px;
      color: #ffff00;
      text-shadow: 0 0 20px #ffff00;
      text-align: center;
      margin-bottom: 10px;
    }
    .shop-currency {
      display: flex;
      justify-content: center;
      gap: 40px;
      font-size: 20px;
      color: #00ffff;
    }
    
    .shop-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
      max-width: 900px;
      width: 100%;
      margin-bottom: 20px;
    }
    
    .shop-item {
      background: linear-gradient(135deg, #2a1a3a 0%, #3a2a4a 100%);
      border: 2px solid #00ffff;
      border-radius: 10px;
      padding: 15px;
      cursor: pointer;
      transition: all 0.3s;
    }
    .shop-item:hover:not(.maxed) {
      transform: scale(1.05);
      box-shadow: 0 5px 20px rgba(0, 255, 255, 0.5);
    }
    .shop-item.maxed {
      opacity: 0.6;
      cursor: not-allowed;
      border-color: #666;
    }
    
    .shop-item-name {
      font-size: 18px;
      font-weight: bold;
      color: #ffff00;
      margin-bottom: 5px;
    }
    .shop-item-desc {
      font-size: 12px;
      color: #aaa;
      margin-bottom: 10px;
    }
    .shop-item-level {
      font-size: 14px;
      color: #00ff00;
      margin-bottom: 5px;
    }
    .shop-item-cost {
      font-size: 16px;
      color: #ff8800;
      font-weight: bold;
    }
    
    .shop-close-btn {
      padding: 15px 40px;
      font-size: 20px;
      background: #ff0000;
      color: #fff;
      border: 2px solid #fff;
      border-radius: 10px;
      cursor: pointer;
      font-weight: bold;
    }
    .shop-close-btn:hover {
      background: #cc0000;
      transform: scale(1.05);
    }
    
    /* Upgrade Screen */
    #upgradeScreen {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #1a0030 0%, #2a0050 100%);
      border: 4px solid #00ffff;
      border-radius: 20px;
      padding: 30px;
      display: none;
      flex-direction: column;
      align-items: center;
      z-index: 90;
      box-shadow: 0 0 50px rgba(0, 255, 255, 0.5);
    }
    #upgradeScreen.active { display: flex; }
    
    .upgrade-title {
      font-size: 32px;
      color: #ffff00;
      text-shadow: 0 0 20px #ffff00;
      margin-bottom: 10px;
    }
    .upgrade-subtitle {
      font-size: 16px;
      color: #00ffff;
      margin-bottom: 20px;
    }
    
    #upgradeOptions {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .upgrade-card {
      background: linear-gradient(135deg, #2a1a3a 0%, #3a2a4a 100%);
      border: 3px solid #00ffff;
      border-radius: 15px;
      padding: 20px;
      width: 200px;
      cursor: pointer;
      transition: all 0.3s;
    }
    .upgrade-card:hover {
      transform: translateY(-10px);
      box-shadow: 0 10px 30px rgba(0, 255, 255, 0.5);
      border-color: #ffff00;
    }
    
    .upgrade-card-icon {
      font-size: 48px;
      text-align: center;
      margin-bottom: 10px;
    }
    .upgrade-card-title {
      font-size: 18px;
      font-weight: bold;
      color: #ffff00;
      text-align: center;
      margin-bottom: 8px;
    }
    .upgrade-card-desc {
      font-size: 13px;
      color: #aaa;
      text-align: center;
    }
    
    /* Round Break Screen */
    #roundBreakScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 80;
    }
    #roundBreakScreen.active { display: flex; }
    
    .break-title {
      font-size: 48px;
      color: #00ffff;
      text-shadow: 0 0 20px #00ffff;
      margin-bottom: 20px;
    }
    .break-info {
      font-size: 20px;
      color: #ffff00;
      text-align: center;
      line-height: 1.8;
    }
    .break-timer {
      font-size: 72px;
      color: #ff00ff;
      text-shadow: 0 0 30px #ff00ff;
      margin: 20px 0;
    }
    
    #gameOverScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      color: white;
    }
    #gameOverScreen.active { display: flex; }
    
    .gameover-title {
      font-size: 64px;
      color: #ff0000;
      text-shadow: 0 0 30px #ff0000;
      margin-bottom: 30px;
      animation: pulse 2s infinite;
    }
    
    .gameover-stats {
      background: rgba(20, 20, 20, 0.8);
      border: 3px solid #00ffff;
      border-radius: 15px;
      padding: 30px 50px;
      margin: 20px 0;
      min-width: 500px;
    }
    
    .gameover-stat-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 0;
      border-bottom: 1px solid rgba(0, 255, 255, 0.2);
      font-size: 20px;
    }
    
    .gameover-stat-row:last-child {
      border-bottom: none;
    }
    
    .gameover-stat-label {
      color: #00ffff;
      font-weight: bold;
    }
    
    .gameover-stat-value {
      color: #ffff00;
      font-size: 24px;
      font-weight: bold;
    }
    
    .gameover-earnings {
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(0, 255, 255, 0.2));
      border: 3px solid #ffff00;
      border-radius: 15px;
      padding: 25px 50px;
      margin: 20px 0;
      min-width: 500px;
    }
    
    .gameover-earnings-title {
      font-size: 28px;
      color: #ffff00;
      text-align: center;
      margin-bottom: 20px;
      text-shadow: 0 0 10px #ffff00;
    }
    
    .gameover-continue {
      margin-top: 30px;
      padding: 15px 40px;
      font-size: 20px;
      background: linear-gradient(135deg, #ff0000, #ff8800);
      color: white;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-weight: bold;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
      box-shadow: 0 4px 15px rgba(255, 0, 0, 0.5);
      transition: all 0.3s;
    }
    
    .gameover-continue:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 20px rgba(255, 0, 0, 0.7);
    }
    
    #statusText {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 24px;
      font-weight: bold;
      color: #ff0000;
      text-shadow: 0 0 10px #ff0000;
      text-align: center;
      z-index: 70;
      display: none;
      background: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border: 2px solid #ff0000;
      border-radius: 10px;
    }
    
    #potionBar {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      z-index: 60;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px 20px;
      border-radius: 15px;
      border: 3px solid #00ffff;
    }
    
    .potion-slot {
      width: 60px;
      height: 70px;
      background: rgba(40, 40, 40, 0.9);
      border: 2px solid #666;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    
    .potion-slot:hover:not(.cooldown) {
      transform: scale(1.1);
      border-color: #00ffff;
      box-shadow: 0 0 15px #00ffff;
    }
    
    .potion-slot.cooldown {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .potion-icon {
      font-size: 32px;
      margin-bottom: 5px;
    }
    
    .potion-count {
      font-size: 14px;
      font-weight: bold;
      color: #ffff00;
      text-shadow: 0 0 5px #000;
    }
    
    .potion-key {
      position: absolute;
      top: 2px;
      left: 4px;
      font-size: 10px;
      color: #aaa;
      font-weight: bold;
    }
    
    .potion-cooldown-overlay {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.7);
      height: 100%;
      transition: height 0.1s;
    }
    
    .potion-effect-indicator {
      position: absolute;
      top: 70px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 255, 0, 0.8);
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 12px;
      color: white;
      white-space: nowrap;
      animation: pulse 1s infinite;
    }
    
    .back-arrow-btn {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #00ffff;
      color: #00ffff;
      font-size: 28px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s;
      z-index: 100;
    }
    
    .back-arrow-btn:hover {
      background: #00ffff;
      color: #000;
      transform: scale(1.1);
      box-shadow: 0 0 20px #00ffff;
    }
    
    .ability-btn {
      position: fixed;
      bottom: 150px;
      background: rgba(0, 0, 0, 0.8);
      border: 3px solid #ff00ff;
      color: #ffff00;
      padding: 15px 20px;
      border-radius: 10px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-weight: bold;
      font-size: 14px;
      transition: all 0.2s;
      min-width: 150px;
      text-align: center;
    }
    
    .ability-btn:hover:not(.cooldown) {
      transform: scale(1.05);
      box-shadow: 0 0 20px #ff00ff;
    }
    
    .ability-btn.cooldown {
      opacity: 0.5;
      cursor: not-allowed;
      border-color: #666;
    }
    
    .ability-btn.ready {
      border-color: #00ff00;
      animation: pulse 1s infinite;
    }
    
    #ability1Btn {
      right: 20px;
    }
    
    #ability2Btn {
      right: 190px;
    }
    
    /* Overworld Map Screen */
    #overworldScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: linear-gradient(135deg, #0a0015 0%, #1a0030 50%, #0a0520 100%);
      display: none;
      flex-direction: column;
      align-items: center;
      z-index: 95;
      overflow: hidden;
    }
    #overworldScreen.active { display: flex; }
    
    .overworld-header {
      width: 100%;
      padding: 20px;
      background: rgba(0, 0, 0, 0.7);
      border-bottom: 3px solid #00ffff;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .overworld-title {
      font-size: 32px;
      color: #00ffff;
      text-shadow: 0 0 20px #00ffff;
      font-weight: bold;
    }
    
    .overworld-stats {
      display: flex;
      gap: 30px;
      font-size: 18px;
      color: #fff;
    }
    
    .overworld-map-container {
      flex: 1;
      width: 100%;
      position: relative;
      overflow: hidden;
    }
    
    #overworldCanvas {
      width: 100%;
      height: 100%;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    
    .overworld-menu {
      position: absolute;
      right: 20px;
      top: 100px;
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .overworld-menu-btn {
      padding: 15px 30px;
      font-size: 18px;
      font-weight: bold;
      background: linear-gradient(135deg, #ff0080 0%, #ff8c00 100%);
      color: #fff;
      border: 3px solid #00ffff;
      border-radius: 10px;
      cursor: pointer;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
      transition: all 0.3s;
      min-width: 200px;
      text-align: center;
    }
    
    .overworld-menu-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
    }
    
    .node-info-panel {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.9);
      border: 3px solid #00ffff;
      border-radius: 15px;
      padding: 20px 40px;
      display: none;
      min-width: 400px;
      text-align: center;
    }
    
    .node-info-panel.active {
      display: block;
    }
    
    .node-info-name {
      font-size: 28px;
      color: #ffff00;
      text-shadow: 0 0 10px #ffff00;
      margin-bottom: 15px;
    }
    
    .node-info-details {
      font-size: 16px;
      color: #fff;
      margin-bottom: 20px;
      line-height: 1.8;
    }
    
    .node-info-rewards {
      font-size: 14px;
      color: #00ff00;
      margin-bottom: 20px;
    }
    
    .node-enter-btn {
      padding: 12px 40px;
      font-size: 20px;
      font-weight: bold;
      background: linear-gradient(135deg, #00ff00 0%, #00aa00 100%);
      color: #fff;
      border: 3px solid #ffff00;
      border-radius: 10px;
      cursor: pointer;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
      box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
      transition: all 0.3s;
    }
    
    .node-enter-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 0 30px rgba(0, 255, 0, 0.8);
    }
    
    /* Class Upgrade Panel */
    .class-upgrade-panel {
      background: rgba(0, 0, 0, 0.95);
      border: 3px solid #ff00ff;
      border-radius: 15px;
      padding: 30px;
      max-width: 800px;
      width: 90%;
      max-height: 80%;
      overflow-y: auto;
    }
    
    .upgrade-tier {
      margin-bottom: 30px;
    }
    
    .upgrade-tier-title {
      font-size: 24px;
      color: #ffff00;
      text-shadow: 0 0 10px #ffff00;
      margin-bottom: 15px;
      text-align: center;
    }
    
    .upgrade-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 15px;
    }
    
    .upgrade-node {
      background: linear-gradient(135deg, #1a1a3a, #2a1a4a);
      border: 2px solid #00ffff;
      border-radius: 10px;
      padding: 15px;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .upgrade-node:hover:not(.locked):not(.purchased) {
      transform: scale(1.05);
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
    }
    
    .upgrade-node.locked {
      opacity: 0.4;
      cursor: not-allowed;
      border-color: #666;
    }
    
    .upgrade-node.purchased {
      background: linear-gradient(135deg, #1a3a1a, #2a4a2a);
      border-color: #00ff00;
    }
    
    .upgrade-node-name {
      font-size: 16px;
      color: #00ffff;
      font-weight: bold;
      margin-bottom: 8px;
    }
    
    .upgrade-node-cost {
      font-size: 14px;
      color: #ffff00;
      margin-bottom: 8px;
    }
    
    .upgrade-node-effect {
      font-size: 12px;
      color: #aaa;
      line-height: 1.4;
    }
    
    /* Tower Defense Game Styles */
    .potion-slot {
      width: 60px;
      height: 70px;
      background: rgba(40, 40, 40, 0.9);
      border: 2px solid #666;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    
    .potion-slot:hover:not(.cooldown) {
      transform: scale(1.1);
      border-color: #00ffff;
      box-shadow: 0 0 15px #00ffff;
    }
    
    .potion-slot.cooldown {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .potion-icon {
      font-size: 32px;
      margin-bottom: 5px;
    }
    
    .potion-count {
      font-size: 14px;
      font-weight: bold;
      color: #ffff00;
      text-shadow: 0 0 5px #000;
    }
    
    .potion-key {
      position: absolute;
      top: 2px;
      left: 4px;
      font-size: 10px;
      color: #aaa;
      font-weight: bold;
    }
    
    .potion-cooldown-overlay {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.7);
      height: 0%;
      transition: height 0.1s;
    }
    
    .upgrade-card {
      background: linear-gradient(135deg, #2a1a3a 0%, #3a2a4a 100%);
      border: 3px solid #00ffff;
      border-radius: 15px;
      padding: 20px;
      width: 200px;
      cursor: pointer;
      transition: all 0.3s;
      text-align: center;
    }
    
    .upgrade-card:hover {
      transform: translateY(-10px);
      box-shadow: 0 10px 30px rgba(0, 255, 255, 0.5);
      border-color: #ffff00;
    }
    
    .upgrade-card-icon {
      font-size: 48px;
      margin-bottom: 10px;
    }
    
    .upgrade-card-title {
      font-size: 18px;
      font-weight: bold;
      color: #ffff00;
      margin-bottom: 8px;
    }
    
    .upgrade-card-desc {
      font-size: 13px;
      color: #aaa;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="1000" height="550"></canvas>
    
    <!-- Give Up Button (visible during gameplay) -->
    <button id="giveUpBtn" style="display: none; position: absolute; top: 10px; right: 180px; padding: 10px 20px; background: linear-gradient(135deg, #8B0000, #FF0000); color: white; font-family: 'Courier New', monospace; font-size: 14px; font-weight: bold; border: 2px solid #ff0000; border-radius: 8px; cursor: pointer; z-index: 100; box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);">
      ‚ùå GIVE UP
    </button>
    
    <!-- Title Screen -->
    <div id="titleScreen">
      <div class="title">EVOL LEGENDS</div>
      <div class="subtitle">‚öîÔ∏è TOWER DEFENSE ‚öîÔ∏è</div>
      <button class="start-btn" id="startBtn">START GAME</button>
      <div style="margin-top: 30px; font-size: 14px; color: #888;">
        <div>üèÜ Highest Wave: <span id="highestWaveDisplay">1</span></div>
        <div style="margin-top: 10px;">üí∞ <span id="totalCoinsDisplay">0</span> Coins | üíé <span id="totalGemsDisplay">0</span> Gems</div>
      </div>
      <button class="start-btn" id="shopBtn" style="margin-top: 20px; font-size: 20px; padding: 15px 40px;">üõí SHOP</button>
      <button class="start-btn" id="evolAuraBtn" style="margin-top: 10px; font-size: 20px; padding: 15px 40px; background: linear-gradient(135deg, #8B0000, #FF0000);">üåü EVOL AURA</button>
      <button class="start-btn" id="tutorialBtn" style="margin-top: 10px; font-size: 20px; padding: 15px 40px; background: linear-gradient(135deg, #00aa00, #00ff00);">üìñ HOW TO PLAY</button>
    </div>
    
    <!-- Tutorial/How to Play Screen -->
    <div id="tutorialScreen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); display: none; flex-direction: column; align-items: center; justify-content: flex-start; z-index: 100; overflow-y: auto; padding: 40px 20px;">
      <button style="position: absolute; top: 20px; left: 20px; padding: 15px 30px; font-size: 24px; background: linear-gradient(135deg, #ff0080 0%, #ff8c00 100%); color: #fff; border: 3px solid #00ffff; border-radius: 10px; cursor: pointer; font-weight: bold;" id="tutorialBackBtn">‚Üê BACK</button>
      
      <div style="max-width: 1000px; width: 100%;">
        <h1 style="font-size: 48px; color: #00ffff; text-align: center; margin-bottom: 30px; text-shadow: 0 0 20px #00ffff;">üìñ HOW TO PLAY</h1>
        
        <!-- CONTROLS -->
        <div style="background: linear-gradient(135deg, #1a1a3a 0%, #2a1a3a 100%); border: 3px solid #00ffff; border-radius: 15px; padding: 25px; margin-bottom: 20px;">
          <h2 style="font-size: 32px; color: #ffff00; margin-bottom: 20px;">üéÆ CONTROLS</h2>
          <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; font-size: 16px; color: #fff;">
            <div><span style="color: #00ff00; font-weight: bold;">[1-6]</span> - Use Potions (Heal, Shield, Crit, Damage, Speed, Dragon)</div>
            <div><span style="color: #00ff00; font-weight: bold;">[Q]</span> - Ultimate Ability 1</div>
            <div><span style="color: #00ff00; font-weight: bold;">[E]</span> - Ultimate Ability 2</div>
            <div><span style="color: #00ff00; font-weight: bold;">[T]</span> - Toggle Auto-Shoot (ON/OFF)</div>
            <div><span style="color: #00ff00; font-weight: bold;">[Y]</span> - Toggle Auto-Aim (ON/OFF)</div>
            <div><span style="color: #00ff00; font-weight: bold;">[R]</span> - Toggle Auto-Start Waves</div>
            <div><span style="color: #00ff00; font-weight: bold;">[F]</span> - Fast-Forward Mode (1x/2x Speed)</div>
            <div><span style="color: #00ff00; font-weight: bold;">[SPACE]</span> - Start Next Wave Manually</div>
          </div>
        </div>
        
        <!-- GAMEPLAY -->
        <div style="background: linear-gradient(135deg, #1a1a3a 0%, #2a1a3a 100%); border: 3px solid #ff00ff; border-radius: 15px; padding: 25px; margin-bottom: 20px;">
          <h2 style="font-size: 32px; color: #ff00ff; margin-bottom: 20px;">‚öîÔ∏è GAMEPLAY</h2>
          <div style="font-size: 16px; color: #fff; line-height: 1.8;">
            <p style="margin-bottom: 15px;">üéØ <strong>OBJECTIVE:</strong> Defend your tower from endless waves of enemies! Survive as long as possible and reach the highest wave.</p>
            <p style="margin-bottom: 15px;">üí∞ <strong>CURRENCY:</strong> Collect coins and gems from defeated enemies. Use them in the shop to unlock new classes and permanent upgrades.</p>
            <p style="margin-bottom: 15px;">‚≠ê <strong>LEVEL UP:</strong> Gain XP from kills to level up and choose powerful upgrades during battle.</p>
            <p style="margin-bottom: 15px;">üß™ <strong>POTIONS:</strong> Use potions (bottom bar) to heal, gain shields, or boost your abilities. They refill each wave!</p>
            <p style="margin-bottom: 15px;">üåü <strong>SKILL TREE:</strong> Unlock 2 ultimate abilities per class by reaching Level 10. Each class has 20 powerful options!</p>
          </div>
        </div>
        
        <!-- ENEMIES -->
        <div style="background: linear-gradient(135deg, #1a1a3a 0%, #2a1a3a 100%); border: 3px solid #ff0000; border-radius: 15px; padding: 25px; margin-bottom: 20px;">
          <h2 style="font-size: 32px; color: #ff0000; margin-bottom: 20px;">üëæ ENEMY TYPES</h2>
          <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; font-size: 16px; color: #fff;">
            <div><span style="color: #ffff00;">üî∫ SPEEDY</span> - Fast moving triangles</div>
            <div><span style="color: #00ff00;">üîµ HEALER</span> - Circles that heal nearby enemies</div>
            <div><span style="color: #ff8800;">üî∂ JUMPER</span> - Teleports toward you</div>
            <div><span style="color: #ff0000;">üí£ KAMIKAZE</span> - Explodes on contact!</div>
            <div><span style="color: #8800ff;">üéØ SHOOTER</span> - Fires projectiles from range</div>
            <div><span style="color: #ff00ff;">üëë MINI-BOSS</span> - Every 5 waves (larger, tougher)</div>
            <div><span style="color: #ff0000;">üíÄ BOSS</span> - Every 10 waves (huge health pool, special attacks)</div>
          </div>
        </div>
        
        <!-- TIPS -->
        <div style="background: linear-gradient(135deg, #1a1a3a 0%, #2a1a3a 100%); border: 3px solid #00ff00; border-radius: 15px; padding: 25px;">
          <h2 style="font-size: 32px; color: #00ff00; margin-bottom: 20px;">üí° PRO TIPS</h2>
          <div style="font-size: 16px; color: #fff; line-height: 1.8;">
            <p style="margin-bottom: 10px;">‚úÖ Use <strong>Auto-Start Waves</strong> [R] + <strong>Fast-Forward</strong> [F] to farm early waves quickly!</p>
            <p style="margin-bottom: 10px;">‚úÖ <strong>Prioritize</strong> kamikazes and healers first - they're the most dangerous!</p>
            <p style="margin-bottom: 10px;">‚úÖ Save your <strong>Dragon Beam</strong> potion [6] for tough bosses</p>
            <p style="margin-bottom: 10px;">‚úÖ Unlock the <strong>Evol Aura</strong> system for powerful permanent bonuses</p>
            <p style="margin-bottom: 10px;">‚úÖ Try different classes! Each has unique abilities and playstyles</p>
            <p style="margin-bottom: 10px;">‚úÖ The <strong>Vecna</strong> class is ultra-rare - unlock it from the shop for a challenge!</p>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Class Selection Screen -->
    <div id="classSelection">
      <div class="class-title">SELECT YOUR LEGEND</div>
      <div class="class-subtitle">Choose your class to defend the tower!</div>
      <div class="class-grid" id="classGrid"></div>
    </div>
    
    <!-- Overworld Map Screen -->
    <div id="overworldScreen">
      <div class="overworld-header">
        <div class="overworld-title">üó∫Ô∏è EVOL LEGENDS - OVERWORLD</div>
        <div class="overworld-stats">
          <div>üí∞ <span id="overworldCoins">0</span> Coins</div>
          <div>üíé <span id="overworldGems">0</span> Gems</div>
          <div>‚≠ê Nodes Completed: <span id="nodesCompleted">0</span>/<span id="totalNodes">0</span></div>
        </div>
      </div>
      
      <div class="overworld-map-container">
        <canvas id="overworldCanvas" width="1200" height="700"></canvas>
      </div>
      
      <div class="overworld-menu">
        <button class="overworld-menu-btn" id="classUpgradesBtn">‚¨ÜÔ∏è CLASS UPGRADES</button>
        <button class="overworld-menu-btn" id="redeemCodeBtn">üéÅ REDEEM CODE</button>
        <button class="overworld-menu-btn" id="overworldShopBtn">üõí SHOP</button>
        <button class="overworld-menu-btn" id="changeClassBtn">üîÑ CHANGE CLASS</button>
        <button class="overworld-menu-btn" id="returnHomeBtn">üè† MAIN MENU</button>
      </div>
      
      <div class="node-info-panel" id="nodeInfoPanel">
        <div class="node-info-name" id="nodeInfoName"></div>
        <div class="node-info-details" id="nodeInfoDetails"></div>
        <div class="node-info-rewards" id="nodeInfoRewards"></div>
        <button class="node-enter-btn" id="nodeEnterBtn">ENTER NODE</button>
      </div>
    </div>
    
    <!-- Tower Defense Game Screen -->
    <div id="tdGameScreen" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 200;">
      <canvas id="tdGameCanvas" width="1000" height="550"></canvas>
      
      <!-- Potion Bar -->
      <div id="tdPotionBar" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; z-index: 60; background: rgba(0, 0, 0, 0.8); padding: 15px 20px; border-radius: 15px; border: 3px solid #00ffff;">
        <div class="potion-slot" id="potionHeal" data-key="1">
          <div class="potion-key">1</div>
          <div class="potion-icon">‚ù§Ô∏è</div>
          <div class="potion-count" id="countHeal">3</div>
          <div class="potion-cooldown-overlay" id="cdHeal" style="height: 0%"></div>
        </div>
        <div class="potion-slot" id="potionShield" data-key="2">
          <div class="potion-key">2</div>
          <div class="potion-icon">üõ°Ô∏è</div>
          <div class="potion-count" id="countShield">2</div>
          <div class="potion-cooldown-overlay" id="cdShield" style="height: 0%"></div>
        </div>
        <div class="potion-slot" id="potionCrit" data-key="3">
          <div class="potion-key">3</div>
          <div class="potion-icon">üí•</div>
          <div class="potion-count" id="countCrit">1</div>
          <div class="potion-cooldown-overlay" id="cdCrit" style="height: 0%"></div>
        </div>
        <div class="potion-slot" id="potionDamage" data-key="4">
          <div class="potion-key">4</div>
          <div class="potion-icon">‚öîÔ∏è</div>
          <div class="potion-count" id="countDamage">1</div>
          <div class="potion-cooldown-overlay" id="cdDamage" style="height: 0%"></div>
        </div>
        <div class="potion-slot" id="potionSpeed" data-key="5">
          <div class="potion-key">5</div>
          <div class="potion-icon">‚ö°</div>
          <div class="potion-count" id="countSpeed">1</div>
          <div class="potion-cooldown-overlay" id="cdSpeed" style="height: 0%"></div>
        </div>
        <div class="potion-slot" id="potionDragon" data-key="6">
          <div class="potion-key">6</div>
          <div class="potion-icon">üêâ</div>
          <div class="potion-count" id="countDragon">1</div>
          <div class="potion-cooldown-overlay" id="cdDragon" style="height: 0%"></div>
        </div>
      </div>
      
      <!-- Upgrade Screen -->
      <div id="tdUpgradeScreen" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #1a0030 0%, #2a0050 100%); border: 4px solid #00ffff; border-radius: 20px; padding: 30px; z-index: 90; box-shadow: 0 0 50px rgba(0, 255, 255, 0.5);">
        <div class="upgrade-title" style="font-size: 32px; color: #ffff00; text-shadow: 0 0 20px #ffff00; margin-bottom: 10px; text-align: center;">üéâ LEVEL UP!</div>
        <div class="upgrade-subtitle" id="tdUpgradeSubtitle" style="font-size: 16px; color: #00ffff; margin-bottom: 20px; text-align: center;">Choose Your Power-Up</div>
        <div id="tdUpgradeOptions" style="display: flex; gap: 20px; flex-wrap: wrap; justify-content: center;"></div>
      </div>
      
      <!-- Game Over Screen for TD -->
      <div id="tdGameOverScreen" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); z-index: 100; color: white;">
        <div style="display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%;">
          <div class="gameover-title" style="font-size: 64px; color: #ff0000; text-shadow: 0 0 30px #ff0000; margin-bottom: 30px;">üíÄ DEFEATED üíÄ</div>
          <div class="gameover-stats" style="background: rgba(20, 20, 20, 0.8); border: 3px solid #00ffff; border-radius: 15px; padding: 30px 50px; margin: 20px 0; min-width: 500px;">
            <div class="gameover-stat-row" style="display: flex; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid rgba(0, 255, 255, 0.2); font-size: 20px;">
              <span style="color: #00ffff; font-weight: bold;">üåä Wave Reached:</span>
              <span id="tdFinalWave" style="color: #ffff00; font-size: 24px; font-weight: bold;">1</span>
            </div>
            <div class="gameover-stat-row" style="display: flex; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid rgba(0, 255, 255, 0.2); font-size: 20px;">
              <span style="color: #00ffff; font-weight: bold;">‚≠ê Level Reached:</span>
              <span id="tdFinalLevel" style="color: #ffff00; font-size: 24px; font-weight: bold;">1</span>
            </div>
            <div class="gameover-stat-row" style="display: flex; justify-content: space-between; padding: 12px 0; font-size: 20px;">
              <span style="color: #00ffff; font-weight: bold;">üíÄ Enemies Killed:</span>
              <span id="tdFinalKills" style="color: #ffff00; font-size: 24px; font-weight: bold;">0</span>
            </div>
          </div>
          <button id="tdReturnToOverworldBtn" style="margin-top: 30px; padding: 15px 40px; font-size: 20px; background: linear-gradient(135deg, #ff0000, #ff8800); color: white; border: none; border-radius: 10px; cursor: pointer; font-family: 'Courier New', monospace; font-weight: bold;">RETURN TO MAP</button>
        </div>
      </div>
    </div>
    
    <!-- Shop Screen -->
    <div id="shopScreen">
      <button class="back-arrow-btn" id="shopBackBtn">‚Üê</button>
      <div class="shop-header">
        <div class="shop-title">üõí PERMANENT UPGRADES</div>
        <div class="shop-currency">
          <div>üí∞ Coins: <span id="shopCoins">0</span></div>
          <div>üíé Gems: <span id="shopGems">0</span></div>
        </div>
      </div>
      <div class="shop-grid" id="shopGrid"></div>
    </div>
    
    <!-- Evol Aura Screen -->
    <div id="evolAuraScreen" style="display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.95); z-index: 50; overflow-y: auto;">
      <button class="back-arrow-btn" id="auraBackBtn">‚Üê</button>
      <div class="shop-header">
        <div class="shop-title">üåü EVOL AURA - SKILL TREES</div>
        <div class="shop-currency">
          <div>üí∞ Coins: <span id="auraCoins">0</span></div>
          <div>üíé Gems: <span id="auraGems">0</span></div>
        </div>
      </div>
      <div id="classTabsContainer" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin: 20px auto; max-width: 900px;">
      </div>
      <div class="shop-grid" id="auraSkillGrid" style="padding-bottom: 50px;"></div>
    </div>
    
    <!-- Upgrade Screen -->
    <div id="upgradeScreen">
      <div class="upgrade-title">üéâ LEVEL UP!</div>
      <div class="upgrade-subtitle" id="upgradeSubtitle">Choose Your Power-Up</div>
      <div id="upgradeOptions"></div>
      <button class="shop-close-btn" id="shuffleBtn" style="margin-top: 20px; background: #0088ff; font-size: 16px; padding: 10px 30px;">
        üîÑ SHUFFLE (<span id="shuffleCount">4</span> left)
      </button>
    </div>
    
    <!-- Round Break Screen -->
    <div id="roundBreakScreen">
      <div class="break-title" id="breakTitle">WAVE COMPLETE!</div>
      <div class="break-timer" id="breakTimer">20</div>
      <div class="break-info" id="breakInfo">
        Prepare for the next wave!<br>
        <br>Press SPACE to start immediately
      </div>
    </div>
    
    <!-- Game Over Screen -->
    <div id="gameOverScreen">
      <div class="gameover-title">üíÄ GAME OVER üíÄ</div>
      
      <div class="gameover-stats">
        <div class="gameover-stat-row">
          <span class="gameover-stat-label">üåä Wave Reached:</span>
          <span class="gameover-stat-value" id="finalWave">1</span>
        </div>
        <div class="gameover-stat-row">
          <span class="gameover-stat-label">‚≠ê Level Reached:</span>
          <span class="gameover-stat-value" id="finalLevel">1</span>
        </div>
        <div class="gameover-stat-row">
          <span class="gameover-stat-label">üíÄ Enemies Killed:</span>
          <span class="gameover-stat-value" id="finalKills">0</span>
        </div>
        <div class="gameover-stat-row">
          <span class="gameover-stat-label">üî• Max Combo:</span>
          <span class="gameover-stat-value" id="finalCombo">0</span>
        </div>
      </div>
      
      <div class="gameover-earnings">
        <div class="gameover-earnings-title">üí∞ RUN EARNINGS üí∞</div>
        <div class="gameover-stat-row">
          <span class="gameover-stat-label">üí∞ Coins Earned:</span>
          <span class="gameover-stat-value" style="color: #ffff00;" id="earnedCoins">0</span>
        </div>
        <div class="gameover-stat-row">
          <span class="gameover-stat-label">üíé Gems Earned:</span>
          <span class="gameover-stat-value" style="color: #00ffff;" id="earnedGems">0</span>
        </div>
        <div class="gameover-stat-row" style="border-top: 2px solid rgba(255, 255, 255, 0.3); margin-top: 10px; padding-top: 15px;">
          <span class="gameover-stat-label">üí∞ Total Coins:</span>
          <span class="gameover-stat-value" style="color: #ffff00;" id="totalCoinsNow">0</span>
        </div>
        <div class="gameover-stat-row">
          <span class="gameover-stat-label">üíé Total Gems:</span>
          <span class="gameover-stat-value" style="color: #00ffff;" id="totalGemsNow">0</span>
        </div>
      </div>
      
      <button class="gameover-continue" id="continueBtn">RETURN TO MENU</button>
    </div>
    
    <!-- Potion Bar -->
    <div id="potionBar">
      <div class="potion-slot" id="potionHeal" data-key="1">
        <div class="potion-key">1</div>
        <div class="potion-icon">‚ù§Ô∏è</div>
        <div class="potion-count" id="countHeal">3</div>
        <div class="potion-cooldown-overlay" id="cdHeal" style="height: 0%"></div>
      </div>
      <div class="potion-slot" id="potionShield" data-key="2">
        <div class="potion-key">2</div>
        <div class="potion-icon">üõ°Ô∏è</div>
        <div class="potion-count" id="countShield">2</div>
        <div class="potion-cooldown-overlay" id="cdShield" style="height: 0%"></div>
      </div>
      <div class="potion-slot" id="potionCrit" data-key="3">
        <div class="potion-key">3</div>
        <div class="potion-icon">üí•</div>
        <div class="potion-count" id="countCrit">1</div>
        <div class="potion-cooldown-overlay" id="cdCrit" style="height: 0%"></div>
      </div>
      <div class="potion-slot" id="potionDamage" data-key="4">
        <div class="potion-key">4</div>
        <div class="potion-icon">‚öîÔ∏è</div>
        <div class="potion-count" id="countDamage">1</div>
        <div class="potion-cooldown-overlay" id="cdDamage" style="height: 0%"></div>
      </div>
      <div class="potion-slot" id="potionSpeed" data-key="5">
        <div class="potion-key">5</div>
        <div class="potion-icon">‚ö°</div>
        <div class="potion-count" id="countSpeed">1</div>
        <div class="potion-cooldown-overlay" id="cdSpeed" style="height: 0%"></div>
      </div>
      <div class="potion-slot" id="potionDragon" data-key="6">
        <div class="potion-key">6</div>
        <div class="potion-icon">üêâ</div>
        <div class="potion-count" id="countDragon">1</div>
        <div class="potion-cooldown-overlay" id="cdDragon" style="height: 0%"></div>
      </div>
    </div>
    
    <!-- Ultimate Ability Buttons -->
    <div id="ability1Btn" class="ability-btn" style="display: none;">
      <div style="font-size: 24px; margin-bottom: 5px;" id="ability1Icon">üéØ</div>
      <div id="ability1Name">Ability 1</div>
      <div style="font-size: 12px; margin-top: 3px;" id="ability1Key">[Q]</div>
      <div style="font-size: 16px; margin-top: 5px; color: #00ff00;" id="ability1CD"></div>
    </div>
    
    <div id="ability2Btn" class="ability-btn" style="display: none;">
      <div style="font-size: 24px; margin-bottom: 5px;" id="ability2Icon">üì¶</div>
      <div id="ability2Name">Ability 2</div>
      <div style="font-size: 12px; margin-top: 3px;" id="ability2Key">[E]</div>
      <div style="font-size: 16px; margin-top: 5px; color: #00ff00;" id="ability2CD"></div>
    </div>
    
    <div id="statusText"></div>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    
    const titleScreen = document.getElementById("titleScreen");
    const startBtn = document.getElementById("startBtn");
    const shopBtn = document.getElementById("shopBtn");
    const tutorialBtn = document.getElementById("tutorialBtn");
    const tutorialScreen = document.getElementById("tutorialScreen");
    const tutorialBackBtn = document.getElementById("tutorialBackBtn");
    const classSelection = document.getElementById("classSelection");
    const classGrid = document.getElementById("classGrid");
    const shopScreen = document.getElementById("shopScreen");
    const shopGrid = document.getElementById("shopGrid");
    const shopCloseBtn = document.getElementById("shopCloseBtn");
    const upgradeScreen = document.getElementById("upgradeScreen");
    const upgradeSubtitle = document.getElementById("upgradeSubtitle");
    const upgradeOptions = document.getElementById("upgradeOptions");
    const shuffleBtn = document.getElementById("shuffleBtn");
    const shuffleCount = document.getElementById("shuffleCount");
    const roundBreakScreen = document.getElementById("roundBreakScreen");
    const breakTitle = document.getElementById("breakTitle");
    const breakTimer = document.getElementById("breakTimer");
    const breakInfo = document.getElementById("breakInfo");
    const gameOverScreen = document.getElementById("gameOverScreen");
    const finalWave = document.getElementById("finalWave");
    const finalLevel = document.getElementById("finalLevel");
    const finalKills = document.getElementById("finalKills");
    const finalCombo = document.getElementById("finalCombo");
    const earnedCoins = document.getElementById("earnedCoins");
    const earnedGems = document.getElementById("earnedGems");
    const totalCoinsNow = document.getElementById("totalCoinsNow");
    const totalGemsNow = document.getElementById("totalGemsNow");
    const continueBtn = document.getElementById("continueBtn");
    const giveUpBtn = document.getElementById("giveUpBtn");
    const statusText = document.getElementById("statusText");
    const highestWaveDisplay = document.getElementById("highestWaveDisplay");
    const totalCoinsDisplay = document.getElementById("totalCoinsDisplay");
    const totalGemsDisplay = document.getElementById("totalGemsDisplay");
    const shopCoins = document.getElementById("shopCoins");
    const shopGems = document.getElementById("shopGems");

    // GAME CONSTANTS
    const GROUND_Y = 470;
    const ROUND_BREAK_TIME = 20;
    const PLAYER_X = 100; // Fixed position

    // PERSISTENT DATA (localStorage)
    let gameData = {
      highestWave: 1,
      totalCoins: 0,
      totalGems: 0,
      permanentUpgrades: {
        damage: 0,
        health: 0,
        fireRate: 0,
        critChance: 0,
        startLevel: 0
      },
      potionUpgrades: {
        healStrength: 0,
        shieldStrength: 0,
        effectStrength: 0,
        dragonStrength: 0,
        startingHeals: 0,
        startingShields: 0,
        startingOthers: 0,
        potionGen: 0,
        potionDamage: 0,
        potionExplosion: 0
      },
      unlockedClasses: ["Hunter"],
      purchasedClasses: [], // Track purchased classes separately
      skillTrees: {}, // Track unlocked abilities for each class
      overworldProgress: {}, // Track completed/unlocked nodes
      classUpgrades: {}, // Track purchased class upgrades
      redeemedCodes: [] // Track used redeem codes
    };

    // Load saved data
    function loadGameData() {
      const saved = localStorage.getItem("evolLegendsData");
      if (saved) {
        gameData = JSON.parse(saved);
        
        // Ensure potionUpgrades exists (for backward compatibility)
        if (!gameData.potionUpgrades) {
          gameData.potionUpgrades = {
            healStrength: 0,
            shieldStrength: 0,
            effectStrength: 0,
            dragonStrength: 0,
            startingHeals: 0,
            startingShields: 0,
            startingOthers: 0,
            potionGen: 0,
            potionDamage: 0,
            potionExplosion: 0
          };
        }
        
        // Ensure skillTrees exists (for future compatibility)
        if (!gameData.skillTrees) {
          gameData.skillTrees = {};
        }
      }
      updateTitleScreenDisplay();
    }

    function saveGameData() {
      // Save overworld node states
      gameData.overworldProgress = {};
      Object.values(OVERWORLD_MAP.nodes).forEach(node => {
        gameData.overworldProgress[node.id] = {
          completed: node.completed,
          unlocked: node.unlocked
        };
      });
      
      // Save collected seals
      gameData.collectedSeals = OVERWORLD_MAP.collectedSeals;
      
      localStorage.setItem("evolLegendsData", JSON.stringify(gameData));
      updateTitleScreenDisplay();
    }
    
    function loadOverworldProgress() {
      if (gameData.overworldProgress) {
        Object.keys(gameData.overworldProgress).forEach(nodeId => {
          if (OVERWORLD_MAP.nodes[nodeId]) {
            OVERWORLD_MAP.nodes[nodeId].completed = gameData.overworldProgress[nodeId].completed || false;
            OVERWORLD_MAP.nodes[nodeId].unlocked = gameData.overworldProgress[nodeId].unlocked || false;
          }
        });
      }
      
      // Load collected seals
      if (gameData.collectedSeals) {
        OVERWORLD_MAP.collectedSeals = gameData.collectedSeals;
      }
    }

    function updateTitleScreenDisplay() {
      highestWaveDisplay.textContent = gameData.highestWave;
      totalCoinsDisplay.textContent = gameData.totalCoins;
      totalGemsDisplay.textContent = gameData.totalGems;
      shopCoins.textContent = gameData.totalCoins;
      shopGems.textContent = gameData.totalGems;
    }

    // POTION SYSTEM
    function resetPotions() {
      // Base amounts + upgrades
      potions.heal = 3 + gameData.potionUpgrades.startingHeals;
      potions.shield = 2 + gameData.potionUpgrades.startingShields;
      potions.crit = 1 + gameData.potionUpgrades.startingOthers;
      potions.damage = 1 + gameData.potionUpgrades.startingOthers;
      potions.speed = 1 + gameData.potionUpgrades.startingOthers;
      potions.dragon = 1 + gameData.potionUpgrades.startingOthers;
      
      // Potion generation chance (10% per level)
      const genChance = gameData.potionUpgrades.potionGen * 0.1;
      if (Math.random() < genChance) {
        const types = ['heal', 'shield', 'crit', 'damage', 'speed', 'dragon'];
        const randomType = types[Math.floor(Math.random() * types.length)];
        potions[randomType]++;
        addFloatingText(player.x + player.w / 2, player.y - 50, "Bonus Potion!", "#ff00ff");
      }
      
      updatePotionDisplay();
    }
    
    function updatePotionDisplay() {
      document.getElementById('countHeal').textContent = potions.heal;
      document.getElementById('countShield').textContent = potions.shield;
      document.getElementById('countCrit').textContent = potions.crit;
      document.getElementById('countDamage').textContent = potions.damage;
      document.getElementById('countSpeed').textContent = potions.speed;
      document.getElementById('countDragon').textContent = potions.dragon;
    }
    
    function usePotion(type) {
      if (!player || !player.alive) return;
      if (potions[type] <= 0) return;
      if (potionCooldowns[type] > 0) return;
      
      potions[type]--;
      potionCooldowns[type] = 1.0; // 1 second cooldown
      
      // Apply effects based on type
      switch(type) {
        case 'heal':
          const healAmount = 50 + (gameData.potionUpgrades.healStrength * 20);
          player.hp = Math.min(player.hp + healAmount, player.maxHP);
          addFloatingText(player.x + player.w / 2, player.y - 30, "+" + healAmount + " HP", "#00ff00");
          spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#00ff00", 10);
          break;
          
        case 'shield':
          const shieldAmount = 50 + (gameData.potionUpgrades.shieldStrength * 25);
          if (player.maxShield === 0) player.maxShield = shieldAmount;
          player.shield = Math.min(player.shield + shieldAmount, player.maxShield);
          addFloatingText(player.x + player.w / 2, player.y - 30, "+" + shieldAmount + " Shield", "#00aaff");
          spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#00aaff", 10);
          break;
          
        case 'crit':
          const critBonus = 0.25 + (gameData.potionUpgrades.effectStrength * 0.1);
          potionEffects.critActive = true;
          potionEffects.critTimer = 10; // 10 seconds
          player.critChance += critBonus;
          addFloatingText(player.x + player.w / 2, player.y - 30, "Crit Boost!", "#ff0000");
          spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#ff0000", 10);
          break;
          
        case 'damage':
          const damageBonus = 10 + (gameData.potionUpgrades.effectStrength * 5);
          potionEffects.damageActive = true;
          potionEffects.damageTimer = 10; // 10 seconds
          player.damage += damageBonus;
          addFloatingText(player.x + player.w / 2, player.y - 30, "Damage Boost!", "#ff8800");
          spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#ff8800", 10);
          break;
          
        case 'speed':
          const speedBonus = 0.15 + (gameData.potionUpgrades.effectStrength * 0.05);
          potionEffects.speedActive = true;
          potionEffects.speedTimer = 10; // 10 seconds
          player.fireRate *= (1 - speedBonus);
          addFloatingText(player.x + player.w / 2, player.y - 30, "Speed Boost!", "#ffff00");
          spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#ffff00", 10);
          break;
          
        case 'dragon':
          useDragonBeam();
          break;
      }
      
      // Potion explosion damage upgrade
      if (gameData.potionUpgrades.potionExplosion > 0 && enemies.length > 0) {
        const randomEnemy = enemies[Math.floor(Math.random() * enemies.length)];
        const explosionDamage = 30 * gameData.potionUpgrades.potionExplosion;
        randomEnemy.hp -= explosionDamage;
        spawnExplosion(randomEnemy.x + randomEnemy.w / 2, randomEnemy.y + randomEnemy.h / 2, "#ff00ff", 15);
        addFloatingText(randomEnemy.x + randomEnemy.w / 2, randomEnemy.y - 20, "-" + explosionDamage, "#ff00ff");
      }
      
      updatePotionDisplay();
      screenShake += 3;
    }
    
    function useDragonBeam() {
      const dragonDamage = (player.damage * 3) + (gameData.potionUpgrades.dragonStrength * 20);
      
      addFloatingText(canvas.width / 2, 200, "üêâ DRAGON BEAM! üêâ", "#ff00ff");
      screenShake += 25;
      
      // Create single massive laser beam that goes across the entire screen
      projectiles.push({
        x: player.x + player.w / 2,
        y: player.y + player.h / 2,
        vx: 30, // Very fast to cross screen
        vy: 0,
        radius: 30, // Wide beam
        damage: dragonDamage,
        color: "#ff4400",
        glowColor: "#ff8800",
        life: 3,
        trail: [],
        pierce: true,
        pierceCount: 0,
        explosive: false,
        isCrit: true,
        critMultiplier: 2.0,
        isDragonBeam: true,
        isEnemyProjectile: false
      });
      
      // Create fire zones along the ground that last 5 seconds with DOT
      const startX = player.x + player.w / 2;
      const y = GROUND_Y - 20; // On the ground
      const numZones = 25; // Create zones across screen
      
      for (let i = 0; i < numZones; i++) {
        const x = startX + (i * 40); // Space them out
        
        // Create fire zone that damages enemies
        fireZones.push({
          x: x,
          y: y,
          radius: 50,
          damage: dragonDamage * 0.2, // 20% of beam damage per second
          life: 5, // Lasts 5 seconds
          color: "#ff4400"
        });
      }
      
      // Visual particles for laser effect
      for (let i = 0; i < 80; i++) {
        particles.push({
          x: player.x + player.w / 2,
          y: player.y + player.h / 2,
          vx: Math.random() * 20 + 10,
          vy: Math.random() * 10 - 5,
          radius: Math.random() * 8 + 3,
          color: i % 2 === 0 ? "#ff4400" : "#ff8800",
          life: 2
        });
      }
    }
    
    function updateFireZones(dt) {
      for (let i = fireZones.length - 1; i >= 0; i--) {
        const zone = fireZones[i];
        zone.life -= dt;
        
        if (zone.life <= 0) {
          fireZones.splice(i, 1);
          continue;
        }
        
        // Damage enemies in fire zone
        enemies.forEach(e => {
          const dx = (e.x + e.w / 2) - zone.x;
          const dy = (e.y + e.h / 2) - zone.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < zone.radius) {
            e.hp -= zone.damage * dt;
            
            // Visual fire damage
            if (Math.random() < 0.1) {
              particles.push({
                x: e.x + e.w / 2,
                y: e.y + e.h / 2,
                vx: Math.random() * 4 - 2,
                vy: Math.random() * 4 - 2,
                radius: 3,
                color: "#ff4400",
                life: 0.5
              });
            }
          }
        });
      }
    }
    
    function updatePotionEffects(dt) {
      // Update crit effect
      if (potionEffects.critActive) {
        potionEffects.critTimer -= dt;
        if (potionEffects.critTimer <= 0) {
          potionEffects.critActive = false;
          const critBonus = 0.25 + (gameData.potionUpgrades.effectStrength * 0.1);
          player.critChance -= critBonus;
        }
      }
      
      // Update damage effect
      if (potionEffects.damageActive) {
        potionEffects.damageTimer -= dt;
        if (potionEffects.damageTimer <= 0) {
          potionEffects.damageActive = false;
          const damageBonus = 10 + (gameData.potionUpgrades.effectStrength * 5);
          player.damage -= damageBonus;
        }
      }
      
      // Update speed effect
      if (potionEffects.speedActive) {
        potionEffects.speedTimer -= dt;
        if (potionEffects.speedTimer <= 0) {
          potionEffects.speedActive = false;
          const speedBonus = 0.15 + (gameData.potionUpgrades.effectStrength * 0.05);
          player.fireRate /= (1 - speedBonus);
        }
      }
      
      // Update cooldowns
      for (let type in potionCooldowns) {
        if (potionCooldowns[type] > 0) {
          potionCooldowns[type] -= dt;
          if (potionCooldowns[type] < 0) potionCooldowns[type] = 0;
        }
      }
    }
    
    function updatePotionCooldownDisplay() {
      const types = ['heal', 'shield', 'crit', 'damage', 'speed', 'dragon'];
      types.forEach((type) => {
        const cooldownPercent = (potionCooldowns[type] / 1.0) * 100;
        document.getElementById('cd' + type.charAt(0).toUpperCase() + type.slice(1)).style.height = cooldownPercent + '%';
        
        const slot = document.getElementById('potion' + type.charAt(0).toUpperCase() + type.slice(1));
        if (potionCooldowns[type] > 0 || potions[type] <= 0) {
          slot.classList.add('cooldown');
        } else {
          slot.classList.remove('cooldown');
        }
      });
    }

    // SKILL TREE SYSTEM
    let currentSelectedClass = "Hunter";
    let selectedClassName = null;
    
    function showEvolAura() {
      document.getElementById('evolAuraScreen').style.display = 'block';
      updateAuraDisplay();
      renderClassTabs();
      displaySkillTree(currentSelectedClass);
    }
    
    function updateAuraDisplay() {
      document.getElementById('auraCoins').textContent = gameData.totalCoins;
      document.getElementById('auraGems').textContent = gameData.totalGems;
    }
    
    function renderClassTabs() {
      const container = document.getElementById('classTabsContainer');
      container.innerHTML = '';
      
      Object.entries(CLASSES).forEach(([className, classData]) => {
        const isUnlocked = gameData.unlockedClasses.includes(className) || 
                          gameData.purchasedClasses.includes(className);
        
        const tab = document.createElement('button');
        tab.style.cssText = `
          padding: 12px 20px;
          font-size: 16px;
          font-weight: bold;
          border: 2px solid ${currentSelectedClass === className ? '#00ff00' : '#00ffff'};
          background: ${currentSelectedClass === className ? 'rgba(0, 255, 0, 0.2)' : 'rgba(0, 0, 0, 0.8)'};
          color: ${isUnlocked ? '#ffff00' : '#666'};
          border-radius: 8px;
          cursor: ${isUnlocked ? 'pointer' : 'not-allowed'};
          transition: all 0.2s;
          font-family: 'Courier New', monospace;
        `;
        
        tab.innerHTML = `${classData.icon} ${className}`;
        
        if (isUnlocked) {
          tab.addEventListener('click', () => {
            currentSelectedClass = className;
            renderClassTabs();
            displaySkillTree(className);
          });
          
          tab.addEventListener('mouseenter', () => {
            if (currentSelectedClass !== className) {
              tab.style.background = 'rgba(0, 255, 255, 0.2)';
            }
          });
          
          tab.addEventListener('mouseleave', () => {
            if (currentSelectedClass !== className) {
              tab.style.background = 'rgba(0, 0, 0, 0.8)';
            }
          });
        }
        
        container.appendChild(tab);
      });
    }
    
    function displaySkillTree(className) {
      const skillGrid = document.getElementById('auraSkillGrid');
      skillGrid.innerHTML = '';
      
      if (!SKILL_TREES[className]) {
        skillGrid.innerHTML = '<div style="text-align: center; color: #ff0000; font-size: 20px; padding: 50px;">Skill tree coming soon for this class!</div>';
        return;
      }
      
      // Initialize class skill data if not exists
      if (!gameData.skillTrees[className]) {
        gameData.skillTrees[className] = {
          ultimate1: false,
          ultimate2: false
        };
      }
      
      const abilities = SKILL_TREES[className];
      
      // Ultimate 1
      const ability1 = abilities.ultimate1;
      const isUnlocked1 = gameData.skillTrees[className].ultimate1;
      
      const card1 = document.createElement('div');
      card1.className = 'shop-item';
      if (isUnlocked1) card1.classList.add('maxed');
      
      card1.innerHTML = `
        <div class="shop-item-name">${ability1.icon} ${ability1.name}</div>
        <div class="shop-item-desc">${ability1.desc}</div>
        <div class="shop-item-level">Activation: ${getActivationText(ability1)}</div>
        ${ability1.cooldown ? `<div class="shop-item-level">Cooldown: ${ability1.cooldown}s</div>` : ''}
        ${!isUnlocked1 ? `
          <div class="shop-item-cost">
            üí∞ ${ability1.cost.coins} | üíé ${ability1.cost.gems}
          </div>
        ` : '<div class="shop-item-cost" style="color: #00ff00;">‚úÖ UNLOCKED</div>'}
      `;
      
      if (!isUnlocked1) {
        card1.onclick = () => purchaseAbility(className, 'ultimate1');
      }
      
      skillGrid.appendChild(card1);
      
      // Ultimate 2
      const ability2 = abilities.ultimate2;
      const isUnlocked2 = gameData.skillTrees[className].ultimate2;
      
      const card2 = document.createElement('div');
      card2.className = 'shop-item';
      if (isUnlocked2) card2.classList.add('maxed');
      
      card2.innerHTML = `
        <div class="shop-item-name">${ability2.icon} ${ability2.name}</div>
        <div class="shop-item-desc">${ability2.desc}</div>
        <div class="shop-item-level">Activation: ${getActivationText(ability2)}</div>
        ${ability2.cooldown ? `<div class="shop-item-level">Cooldown: ${ability2.cooldown}s</div>` : ''}
        ${!isUnlocked2 ? `
          <div class="shop-item-cost">
            üí∞ ${ability2.cost.coins} | üíé ${ability2.cost.gems}
          </div>
        ` : '<div class="shop-item-cost" style="color: #00ff00;">‚úÖ UNLOCKED</div>'}
      `;
      
      if (!isUnlocked2) {
        card2.onclick = () => purchaseAbility(className, 'ultimate2');
      }
      
      skillGrid.appendChild(card2);
    }
    
    function getActivationText(ability) {
      if (ability.activation === 'kills') {
        return `After ${ability.killRequirement} kills`;
      } else if (ability.activation === 'manual') {
        return `Press ${ability.hotkey.toUpperCase()} key`;
      } else if (ability.activation === 'auto') {
        return 'Automatic when conditions met';
      }
      return 'Special';
    }
    
    function purchaseAbility(className, abilityKey) {
      const ability = SKILL_TREES[className][abilityKey];
      const cost = ability.cost;
      
      if (gameData.totalCoins >= cost.coins && gameData.totalGems >= cost.gems) {
        gameData.totalCoins -= cost.coins;
        gameData.totalGems -= cost.gems;
        gameData.skillTrees[className][abilityKey] = true;
        
        saveGameData();
        updateAuraDisplay();
        displaySkillTree(className);
        
        alert(`‚úÖ Unlocked ${ability.name}! You can now use this ability in battle!`);
      } else {
        alert("‚ùå Not enough currency!");
      }
    }

    // ABILITY ACTIVATION SYSTEM
    function initializeAbilities() {
      ability1Cooldown = 0;
      ability2Cooldown = 0;
      ability1KillCounter = 0;
      ability2KillCounter = 0;
      lastStandUsed = false;
      chainReactionShots = 0;
      headhunterShots = 0;
      overwatchActive = false;
      bladeStormActive = false;
      soulHarvestActive = false;
      timeFreezeActive = false;
      hiveMindActive = false;
      upsideDownActive = false;
      vecnaKillCounter = 0;
      
      const className = selectedClassName;
      if (!className || !gameData.skillTrees[className]) return;
      
      const ability1Unlocked = gameData.skillTrees[className].ultimate1;
      const ability2Unlocked = gameData.skillTrees[className].ultimate2;
      
      const ability1Btn = document.getElementById('ability1Btn');
      const ability2Btn = document.getElementById('ability2Btn');
      
      if (ability1Unlocked && SKILL_TREES[className]) {
        const ability = SKILL_TREES[className].ultimate1;
        document.getElementById('ability1Icon').textContent = ability.icon;
        document.getElementById('ability1Name').textContent = ability.name;
        document.getElementById('ability1Key').textContent = `[${ability.hotkey ? ability.hotkey.toUpperCase() : 'AUTO'}]`;
        ability1Btn.style.display = 'block';
      } else {
        ability1Btn.style.display = 'none';
      }
      
      if (ability2Unlocked && SKILL_TREES[className]) {
        const ability = SKILL_TREES[className].ultimate2;
        document.getElementById('ability2Icon').textContent = ability.icon;
        document.getElementById('ability2Name').textContent = ability.name;
        document.getElementById('ability2Key').textContent = `[${ability.hotkey ? ability.hotkey.toUpperCase() : 'AUTO'}]`;
        ability2Btn.style.display = 'block';
      } else {
        ability2Btn.style.display = 'none';
      }
    }
    
    function updateAbilities(dt) {
      // Update cooldowns
      if (ability1Cooldown > 0) ability1Cooldown -= dt;
      if (ability2Cooldown > 0) ability2Cooldown -= dt;
      
      // Update special timers
      if (overwatchTimer > 0) {
        overwatchTimer -= dt;
        if (overwatchTimer <= 0) overwatchActive = false;
      }
      if (bladeStormTimer > 0) {
        bladeStormTimer -= dt;
        if (bladeStormTimer <= 0) bladeStormActive = false;
      }
      if (soulHarvestTimer > 0) {
        soulHarvestTimer -= dt;
        if (soulHarvestTimer <= 0) soulHarvestActive = false;
      }
      if (timeFreezeTimer > 0) {
        timeFreezeTimer -= dt;
        if (timeFreezeTimer <= 0) {
          timeFreezeActive = false;
          enemies.forEach(e => e.frozen = false);
        }
      }
      if (hiveMindTimer > 0) {
        hiveMindTimer -= dt;
        if (hiveMindTimer <= 0) hiveMindActive = false;
      }
      if (upsideDownTimer > 0) {
        upsideDownTimer -= dt;
        if (upsideDownTimer <= 0) upsideDownActive = false;
      }
      
      // Blade storm damage
      if (bladeStormActive) {
        enemies.forEach(enemy => {
          const dx = enemy.x - player.x;
          const dy = enemy.y - player.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 150) {
            enemy.hp -= 50 * dt;
            if (enemy.hp <= 0 && !enemy.dead) {
              enemy.dead = true;
              onEnemyKilled(enemy);
            }
          }
        });
      }
      
      // Check auto-trigger abilities
      checkAutoAbilities();
      
      // Update display
      updateAbilityDisplay();
      
      // Update Vecna monsters
      if (selectedClassName === 'Vecna' && player.alive) {
        updateVecnaMonsters(dt);
      }
    }
    
    function checkAutoAbilities() {
      if (!selectedClassName || !gameData.skillTrees[selectedClassName]) return;
      
      const abilities = SKILL_TREES[selectedClassName];
      
      // Check ability 1 kill requirement
      if (abilities.ultimate1 && gameData.skillTrees[selectedClassName].ultimate1) {
        if (abilities.ultimate1.activation === 'kills' && 
            ability1KillCounter >= abilities.ultimate1.killRequirement &&
            ability1Cooldown <= 0) {
          activateAbility1();
        }
      }
      
      // Check ability 2 kill requirement
      if (abilities.ultimate2 && gameData.skillTrees[selectedClassName].ultimate2) {
        if (abilities.ultimate2.activation === 'kills' && 
            ability2KillCounter >= abilities.ultimate2.killRequirement &&
            ability2Cooldown <= 0) {
          activateAbility2();
        }
      }
      
      // Check Knight Last Stand
      if (selectedClassName === 'Knight' && 
          gameData.skillTrees.Knight?.ultimate2 &&
          player.hp < player.maxHP * 0.2 && 
          !lastStandUsed && 
          player.alive) {
        activateLastStand();
      }
    }
    
    function updateAbilityDisplay() {
      const ability1Btn = document.getElementById('ability1Btn');
      const ability2Btn = document.getElementById('ability2Btn');
      
      if (ability1Btn.style.display !== 'none') {
        const cd1 = document.getElementById('ability1CD');
        if (ability1Cooldown > 0) {
          cd1.textContent = Math.ceil(ability1Cooldown) + 's';
          ability1Btn.classList.add('cooldown');
          ability1Btn.classList.remove('ready');
        } else {
          cd1.textContent = 'READY';
          ability1Btn.classList.remove('cooldown');
          ability1Btn.classList.add('ready');
        }
      }
      
      if (ability2Btn.style.display !== 'none') {
        const cd2 = document.getElementById('ability2CD');
        if (ability2Cooldown > 0) {
          cd2.textContent = Math.ceil(ability2Cooldown) + 's';
          ability2Btn.classList.add('cooldown');
          ability2Btn.classList.remove('ready');
        } else {
          cd2.textContent = 'READY';
          ability2Btn.classList.remove('cooldown');
          ability2Btn.classList.add('ready');
        }
      }
    }
    
    function activateAbility1() {
      if (ability1Cooldown > 0 || !player.alive) return;
      
      const className = selectedClassName;
      if (!className || !gameData.skillTrees[className]?.ultimate1) return;
      
      const ability = SKILL_TREES[className].ultimate1;
      ability1Cooldown = ability.cooldown || 30;
      ability1KillCounter = 0;
      
      // Activate specific ability
      switch(className) {
        case 'Hunter': activateSniperShot(); break;
        case 'Knight': activateShieldBash(); break;
        case 'Assassin': activateShadowStrike(); break;
        case 'Wizard': activateMeteorStorm(); break;
        case 'Archer': activateArrowBarrage(); break;
        case 'Summoner': activateArmyOfDead(); break;
        case 'Bomber': activateNuke(); break;
        case 'Sniper': activateHeadhunter(); break;
        case 'Necromancer': activatePlague(); break;
        case 'Vecna': activateHiveMind(); break;
      }
    }
    
    function activateAbility2() {
      if (ability2Cooldown > 0 || !player.alive) return;
      
      const className = selectedClassName;
      if (!className || !gameData.skillTrees[className]?.ultimate2) return;
      
      const ability = SKILL_TREES[className].ultimate2;
      ability2Cooldown = ability.cooldown || 30;
      ability2KillCounter = 0;
      
      // Activate specific ability
      switch(className) {
        case 'Hunter': activateCarePackage(); break;
        case 'Knight': activateLastStand(); break;
        case 'Assassin': activateBladeStorm(); break;
        case 'Wizard': activateTimeFreeze(); break;
        case 'Archer': activateExplosiveArrow(); break;
        case 'Summoner': activateSacrifice(); break;
        case 'Bomber': activateChainReaction(); break;
        case 'Sniper': activateOverwatch(); break;
        case 'Necromancer': activateSoulHarvest(); break;
        case 'Vecna': activateVecnasCurse(); break;
      }
    }

    // ========== ABILITY IMPLEMENTATIONS ==========
    
    // HUNTER ABILITIES
    function activateSniperShot() {
      createFloatingText("üéØ SNIPER SHOT!", player.x, player.y - 30, "#00ffff");
      screenShake = 15;
      
      // Create massive cross-screen beam
      const damage = 500;
      projectiles.push({
        x: player.x,
        y: player.y,
        vx: 25,
        vy: 0,
        radius: 20,
        color: "#ff0000",
        damage: damage,
        pierce: true,
        isCrit: true,
        critMultiplier: 3,
        life: 3,
        isSniperShot: true
      });
    }
    
    function activateCarePackage() {
      createFloatingText("üì¶ CARE PACKAGE!", player.x, player.y - 30, "#00ff00");
      screenShake = 10;
      
      // Drop potions from sky
      potions.heal += 2;
      potions.shield += 1;
      potions.damage += 1;
      updatePotionDisplay();
      
      createExplosion(player.x, player.y, "#00ff00");
    }
    
    // KNIGHT ABILITIES
    function activateShieldBash() {
      createFloatingText("üõ°Ô∏è SHIELD BASH!", player.x, player.y - 30, "#0088ff");
      screenShake = 12;
      
      // Charge forward
      const chargeSpeed = 300;
      const chargeDist = 300;
      let chargeRemaining = chargeDist;
      
      const chargeInterval = setInterval(() => {
        if (chargeRemaining > 0 && player.alive) {
          player.x += 15;
          chargeRemaining -= 15;
          
          // Damage and stun enemies
          enemies.forEach(enemy => {
            const dx = enemy.x - player.x;
            const dy = enemy.y - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 80) {
              enemy.hp -= 100;
              enemy.stunned = true;
              enemy.stunnedTimer = 2;
              if (enemy.hp <= 0 && !enemy.dead) {
                enemy.dead = true;
                onEnemyKilled(enemy);
              }
            }
          });
        } else {
          clearInterval(chargeInterval);
        }
      }, 50);
    }
    
    function activateLastStand() {
      createFloatingText("‚ö° LAST STAND!", player.x, player.y - 30, "#ffff00");
      screenShake = 20;
      lastStandUsed = true;
      
      // Invincible for 5 seconds
      player.invincible = true;
      setTimeout(() => {
        player.invincible = false;
      }, 5000);
    }
    
    // ASSASSIN ABILITIES
    function activateShadowStrike() {
      if (enemies.length === 0) return;
      
      const target = enemies[Math.floor(Math.random() * enemies.length)];
      createFloatingText("üëª SHADOW STRIKE!", player.x, player.y - 30, "#9933ff");
      
      // Teleport behind enemy
      player.x = target.x - 50;
      player.y = target.y;
      
      // Deal massive damage
      target.hp -= 300;
      createExplosion(target.x, target.y, "#9933ff");
      screenShake = 15;
      
      if (target.hp <= 0 && !target.dead) {
        target.dead = true;
        onEnemyKilled(target);
      }
    }
    
    function activateBladeStorm() {
      createFloatingText("üåÄ BLADE STORM!", player.x, player.y - 30, "#ff00ff");
      screenShake = 10;
      bladeStormActive = true;
      bladeStormTimer = 5;
    }
    
    // WIZARD ABILITIES
    function activateMeteorStorm() {
      createFloatingText("‚òÑÔ∏è METEOR STORM!", player.x, player.y - 30, "#ff8800");
      screenShake = 15;
      
      // Drop 10 meteors
      for (let i = 0; i < 10; i++) {
        setTimeout(() => {
          const x = Math.random() * canvas.width;
          const y = 0;
          
          projectiles.push({
            x: x,
            y: y,
            vx: 0,
            vy: 15,
            radius: 15,
            color: "#ff8800",
            damage: 150,
            explosive: true,
            explosionRadius: 100,
            isCrit: true,
            life: 5
          });
        }, i * 200);
      }
    }
    
    function activateTimeFreeze() {
      createFloatingText("‚ùÑÔ∏è TIME FREEZE!", player.x, player.y - 30, "#00ffff");
      screenShake = 12;
      timeFreezeActive = true;
      timeFreezeTimer = 5;
      
      enemies.forEach(enemy => {
        enemy.frozen = true;
      });
    }

    // ARCHER ABILITIES
    function activateArrowBarrage() {
      createFloatingText("üèπ ARROW BARRAGE!", player.x, player.y - 30, "#00ff00");
      screenShake = 12;
      
      // Fire 50 arrows in all directions
      for (let i = 0; i < 50; i++) {
        const angle = (i / 50) * Math.PI * 2;
        projectiles.push({
          x: player.x,
          y: player.y,
          vx: Math.cos(angle) * 10,
          vy: Math.sin(angle) * 10,
          radius: 8,
          color: "#00ff00",
          damage: 30,
          pierce: true,
          life: 2
        });
      }
    }
    
    function activateExplosiveArrow() {
      createFloatingText("üí• EXPLOSIVE ARROW!", player.x, player.y - 30, "#ff0000");
      screenShake = 20;
      
      // Find nearest enemy
      let nearest = null;
      let minDist = Infinity;
      enemies.forEach(enemy => {
        const dx = enemy.x - player.x;
        const dy = enemy.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < minDist) {
          minDist = dist;
          nearest = enemy;
        }
      });
      
      if (nearest) {
        const angle = Math.atan2(nearest.y - player.y, nearest.x - player.x);
        projectiles.push({
          x: player.x,
          y: player.y,
          vx: Math.cos(angle) * 15,
          vy: Math.sin(angle) * 15,
          radius: 25,
          color: "#ff6600",
          damage: 800,
          explosive: true,
          explosionRadius: 300,
          isCrit: true,
          critMultiplier: 3,
          life: 5
        });
      }
    }
    
    // SUMMONER ABILITIES
    function activateArmyOfDead() {
      createFloatingText("üíÄ ARMY OF THE DEAD!", player.x, player.y - 30, "#9933ff");
      screenShake = 15;
      
      // Spawn 10 skeletons
      for (let i = 0; i < 10; i++) {
        const angle = (i / 10) * Math.PI * 2;
        const dist = 80;
        minions.push({
          x: player.x + Math.cos(angle) * dist,
          y: player.y + Math.sin(angle) * dist,
          hp: 40,
          maxHP: 40,
          damage: 8,
          speed: 2,
          radius: 8,
          color: "#9933ff"
        });
      }
    }
    
    function activateSacrifice() {
      createFloatingText("üîÆ SACRIFICE!", player.x, player.y - 30, "#ff00ff");
      screenShake = 10;
      
      const minionCount = minions.length;
      const shieldGain = minionCount * 30;
      
      player.shield += shieldGain;
      minions = [];
      
      createFloatingText("+" + shieldGain + " Shield", player.x, player.y, "#00ffff");
    }
    
    // BOMBER ABILITIES
    function activateNuke() {
      createFloatingText("‚ò¢Ô∏è NUKE!", player.x, player.y - 30, "#ff0000");
      screenShake = 30;
      
      // Damage all enemies
      enemies.forEach(enemy => {
        enemy.hp -= 1000;
        if (enemy.hp <= 0 && !enemy.dead) {
          enemy.dead = true;
          onEnemyKilled(enemy);
        }
      });
      
      // Massive explosion
      createExplosion(canvas.width / 2, canvas.height / 2, "#ff0000", 400);
    }
    
    function activateChainReaction() {
      createFloatingText("‚õìÔ∏è CHAIN REACTION!", player.x, player.y - 30, "#ff8800");
      screenShake = 10;
      chainReactionShots = 10;
    }
    
    // SNIPER ABILITIES
    function activateHeadhunter() {
      createFloatingText("üíÄ HEADHUNTER!", player.x, player.y - 30, "#ff0000");
      screenShake = 10;
      headhunterShots = 5;
    }
    
    function activateOverwatch() {
      createFloatingText("üî≠ OVERWATCH!", player.x, player.y - 30, "#00ffff");
      screenShake = 8;
      overwatchActive = true;
      overwatchTimer = 15;
    }
    
    // NECROMANCER ABILITIES
    function activatePlague() {
      createFloatingText("ü¶† PLAGUE!", player.x, player.y - 30, "#00ff00");
      screenShake = 12;
      
      enemies.forEach(enemy => {
        enemy.poisoned = true;
        enemy.poisonDamage = 20;
        enemy.poisonDuration = 10;
        enemy.poisonTimer = 10;
      });
    }
    
    function activateSoulHarvest() {
      createFloatingText("üëª SOUL HARVEST!", player.x, player.y - 30, "#9933ff");
      screenShake = 10;
      soulHarvestActive = true;
      soulHarvestTimer = 10;
    }
    
    // VECNA ABILITIES
    function activateHiveMind() {
      createFloatingText("üëÅÔ∏è HIVE MIND!", player.x, player.y - 30, "#8B0000");
      screenShake = 20;
      hiveMindActive = true;
      hiveMindTimer = 15;
    }
    
    function activateVecnasCurse() {
      createFloatingText("üåÄ VECNA'S CURSE!", player.x, player.y - 30, "#FF0000");
      screenShake = 25;
      upsideDownActive = true;
      upsideDownTimer = 20;
    }
    
    // VECNA SPECIAL MECHANICS
    function spawnVecnaMonster() {
      vecnaMonsters.push({
        x: player.x + (Math.random() - 0.5) * 100,
        y: player.y + (Math.random() - 0.5) * 100,
        hp: 50,
        maxHP: 50,
        damage: 10,
        speed: 2.5,
        radius: 12,
        color: "#8B0000",
        target: null
      });
    }
    
    function updateVecnaMonsters(dt) {
      vecnaMonsters.forEach((monster, idx) => {
        if (monster.hp <= 0) {
          vecnaMonsters.splice(idx, 1);
          return;
        }
        
        // Find nearest enemy
        let nearest = null;
        let minDist = Infinity;
        enemies.forEach(enemy => {
          const dx = enemy.x - monster.x;
          const dy = enemy.y - monster.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < minDist) {
            minDist = dist;
            nearest = enemy;
          }
        });
        
        if (nearest) {
          const dx = nearest.x - monster.x;
          const dy = nearest.y - monster.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist > 30) {
            monster.x += (dx / dist) * monster.speed;
            monster.y += (dy / dist) * monster.speed;
          } else {
            // Attack
            nearest.hp -= monster.damage * dt;
            if (nearest.hp <= 0 && !nearest.dead) {
              nearest.dead = true;
              onEnemyKilled(nearest);
            }
          }
        }
      });
    }

    // CLASS DEFINITIONS
    const CLASSES = {
      Hunter: {
        icon: "üèπ",
        color: "#00ff88",
        accent: "#88ffaa",
        bulletColor: "#00ff88",
        glowColor: "#00ff88",
        unlockWave: 0,
        purchasable: false,
        stats: {
          maxHP: 120,
          damage: 14,
          fireRate: 0.3,
          range: 650,
          projectileSpeed: 8
        },
        description: "Balanced ranged fighter"
      },
      Knight: {
        icon: "‚öîÔ∏è",
        color: "#4488ff",
        accent: "#88aaff",
        bulletColor: "#4488ff",
        glowColor: "#4488ff",
        unlockWave: 5,
        purchasable: false,
        stats: {
          maxHP: 160,
          damage: 28,
          fireRate: 0.65,
          range: 260,
          projectileSpeed: 6.5
        },
        description: "High damage, low range tank"
      },
      Archer: {
        icon: "üèπ",
        color: "#228b22",
        accent: "#32cd32",
        bulletColor: "#228b22",
        glowColor: "#32cd32",
        unlockWave: 15,
        purchasable: false,
        stats: {
          maxHP: 100,
          damage: 18,
          fireRate: 0.4,
          range: 950, // Highest range in game!
          projectileSpeed: 10,
          alwaysPierce: true // Special trait: Projectiles always pierce
        },
        description: "Longest range, piercing shots"
      },
      Assassin: {
        icon: "üó°Ô∏è",
        color: "#ff00ff",
        accent: "#ff88ff",
        bulletColor: "#ff00ff",
        glowColor: "#ff00ff",
        unlockWave: 35,
        purchasable: false,
        stats: {
          maxHP: 95,
          damage: 9,
          fireRate: 0.15,
          range: 400,
          projectileSpeed: 9.5
        },
        description: "Ultra-fast glass cannon"
      },
      Summoner: {
        icon: "‚ú®",
        color: "#88ff88",
        accent: "#aaffaa",
        bulletColor: "#88ff88",
        glowColor: "#88ff88",
        unlockWave: 65,
        purchasable: false,
        stats: {
          maxHP: 110,
          damage: 12,
          fireRate: 0.55,
          range: 450,
          projectileSpeed: 7
        },
        description: "Summons spirit helpers"
      },
      DarkMagician: {
        icon: "üîÆ",
        color: "#8800ff",
        accent: "#aa88ff",
        bulletColor: "#8800ff",
        glowColor: "#8800ff",
        unlockWave: 95,
        purchasable: false,
        stats: {
          maxHP: 85,
          damage: 35,
          fireRate: 0.85,
          range: 550,
          projectileSpeed: 5.5
        },
        description: "Powerful but slow caster"
      },
      // NEW PURCHASABLE CLASSES
      Bomber: {
        icon: "üí£",
        color: "#ff8800",
        accent: "#ffaa44",
        bulletColor: "#ff8800",
        glowColor: "#ff8800",
        unlockWave: 0,
        purchasable: true,
        cost: { coins: 5000, gems: 50 },
        stats: {
          maxHP: 130,
          damage: 20,
          fireRate: 0.75,
          range: 500,
          projectileSpeed: 6,
          alwaysExplosive: true // Special trait
        },
        description: "Every shot explodes! Area damage specialist"
      },
      Sniper: {
        icon: "üéØ",
        color: "#00ffff",
        accent: "#88ffff",
        bulletColor: "#00ffff",
        glowColor: "#00ffff",
        unlockWave: 0,
        purchasable: true,
        cost: { coins: 15000, gems: 150 },
        stats: {
          maxHP: 100,
          damage: 45,
          fireRate: 1.2,
          range: 900,
          projectileSpeed: 12,
          alwaysCrit: true // Special trait: 50% base crit
        },
        description: "Long range, high damage, slow fire rate"
      },
      Necromancer: {
        icon: "üíÄ",
        color: "#9933ff",
        accent: "#bb66ff",
        bulletColor: "#9933ff",
        glowColor: "#9933ff",
        unlockWave: 0,
        purchasable: true,
        cost: { coins: 25000, gems: 250 },
        stats: {
          maxHP: 105,
          damage: 15,
          fireRate: 0.45,
          range: 550,
          projectileSpeed: 7,
          alwaysPoison: true, // Special trait
          spawnSkeletonsOnKill: true // Spawns minions
        },
        description: "Poisons enemies, raises skeleton minions"
      },
      Vecna: {
        icon: "üëÅÔ∏è",
        color: "#8B0000",
        accent: "#FF0000",
        bulletColor: "#8B0000",
        glowColor: "#FF0000",
        unlockWave: 0,
        purchasable: true,
        cost: { coins: 10000000, gems: 10000 },
        stats: {
          maxHP: 110,
          damage: 18,
          fireRate: 0.5,
          range: 600,
          projectileSpeed: 7.5,
          summonMonsters: true,
          shieldOnKills: 10,
          enemyConversionChance: 0.2
        },
        description: "Master of the Upside Down. Summons monsters, converts enemies"
      }
    };

    // SKILL TREES - Ultimate Abilities for Each Class
    const SKILL_TREES = {
      Hunter: {
        ultimate1: {
          name: "Sniper Shot",
          icon: "üéØ",
          desc: "Fire devastating cross-screen shot after 15 kills",
          cost: { coins: 5000, gems: 50 },
          activation: "kills",
          killRequirement: 15,
          cooldown: 30,
          damage: 500
        },
        ultimate2: {
          name: "Care Package",
          icon: "üì¶",
          desc: "Supply drop with potions (Q key)",
          cost: { coins: 10000, gems: 100 },
          activation: "manual",
          hotkey: "q",
          cooldown: 60
        }
      },
      Knight: {
        ultimate1: {
          name: "Shield Bash",
          icon: "üõ°Ô∏è",
          desc: "Charge forward, stunning enemies (Q key)",
          cost: { coins: 5000, gems: 50 },
          activation: "manual",
          hotkey: "q",
          cooldown: 20,
          damage: 100,
          stunDuration: 2
        },
        ultimate2: {
          name: "Last Stand",
          icon: "‚ö°",
          desc: "Invincible for 5s when HP < 20%",
          cost: { coins: 10000, gems: 100 },
          activation: "auto",
          duration: 5
        }
      },
      Archer: {
        ultimate1: {
          name: "Cupid's Bow",
          icon: "üíò",
          desc: "Next 5 shots convert enemies to allies (Q key)",
          cost: { coins: 5000, gems: 50 },
          activation: "manual",
          hotkey: "q",
          cooldown: 45,
          shotsRemaining: 5
        },
        ultimate2: {
          name: "Hook Shot",
          icon: "ü™ù",
          desc: "50% chance to root enemies in place (E key to toggle)",
          cost: { coins: 10000, gems: 100 },
          activation: "toggle",
          hotkey: "e",
          rootChance: 0.5,
          rootDuration: 3
        }
      },
      Assassin: {
        ultimate1: {
          name: "Shadow Strike",
          icon: "üëª",
          desc: "Teleport behind enemy after 10 kills",
          cost: { coins: 5000, gems: 50 },
          activation: "kills",
          killRequirement: 10,
          cooldown: 25,
          damage: 300
        },
        ultimate2: {
          name: "Blade Storm",
          icon: "üåÄ",
          desc: "Spinning blades around player (Q key)",
          cost: { coins: 10000, gems: 100 },
          activation: "manual",
          hotkey: "q",
          cooldown: 45,
          duration: 5,
          damagePerSec: 50
        }
      },
      Wizard: {
        ultimate1: {
          name: "Meteor Storm",
          icon: "‚òÑÔ∏è",
          desc: "Rain 10 meteors from sky (Q key)",
          cost: { coins: 5000, gems: 50 },
          activation: "manual",
          hotkey: "q",
          cooldown: 40,
          count: 10,
          damage: 150
        },
        ultimate2: {
          name: "Time Freeze",
          icon: "‚ùÑÔ∏è",
          desc: "Freeze all enemies for 5s (E key)",
          cost: { coins: 10000, gems: 100 },
          activation: "manual",
          hotkey: "e",
          cooldown: 60,
          duration: 5
        }
      },
      Archer: {
        ultimate1: {
          name: "Arrow Barrage",
          icon: "üèπ",
          desc: "Fire 50 arrows in all directions after 20 kills",
          cost: { coins: 5000, gems: 50 },
          activation: "kills",
          killRequirement: 20,
          cooldown: 35,
          count: 50,
          damage: 30
        },
        ultimate2: {
          name: "Explosive Arrow",
          icon: "üí•",
          desc: "One massive explosive arrow (Q key)",
          cost: { coins: 10000, gems: 100 },
          activation: "manual",
          hotkey: "q",
          cooldown: 50,
          damage: 800,
          explosionRadius: 300
        }
      },
      Summoner: {
        ultimate1: {
          name: "Army of the Dead",
          icon: "üíÄ",
          desc: "Summon 10 skeletons instantly (Q key)",
          cost: { coins: 5000, gems: 50 },
          activation: "manual",
          hotkey: "q",
          cooldown: 70,
          count: 10
        },
        ultimate2: {
          name: "Sacrifice",
          icon: "üîÆ",
          desc: "Convert minions to shields (E key)",
          cost: { coins: 10000, gems: 100 },
          activation: "manual",
          hotkey: "e",
          cooldown: 40,
          shieldPerMinion: 30
        }
      },
      Bomber: {
        ultimate1: {
          name: "Nuke",
          icon: "‚ò¢Ô∏è",
          desc: "Massive screen explosion after 25 kills",
          cost: { coins: 5000, gems: 50 },
          activation: "kills",
          killRequirement: 25,
          cooldown: 80,
          damage: 1000
        },
        ultimate2: {
          name: "Chain Reaction",
          icon: "‚õìÔ∏è",
          desc: "Next 10 shots have 2x explosion radius (Q key)",
          cost: { coins: 10000, gems: 100 },
          activation: "manual",
          hotkey: "q",
          cooldown: 55,
          shotCount: 10
        }
      },
      Sniper: {
        ultimate1: {
          name: "Headhunter",
          icon: "üíÄ",
          desc: "Next 5 shots guaranteed 5x crits (Q key)",
          cost: { coins: 5000, gems: 50 },
          activation: "manual",
          hotkey: "q",
          cooldown: 35,
          shotCount: 5,
          critMultiplier: 5
        },
        ultimate2: {
          name: "Overwatch",
          icon: "üî≠",
          desc: "Auto-target highest HP enemy for 15s (E key)",
          cost: { coins: 10000, gems: 100 },
          activation: "manual",
          hotkey: "e",
          cooldown: 50,
          duration: 15
        }
      },
      Necromancer: {
        ultimate1: {
          name: "Plague",
          icon: "ü¶†",
          desc: "Poison all on-screen enemies (Q key)",
          cost: { coins: 5000, gems: 50 },
          activation: "manual",
          hotkey: "q",
          cooldown: 60,
          damagePerSec: 20,
          duration: 10
        },
        ultimate2: {
          name: "Soul Harvest",
          icon: "üëª",
          desc: "Heal from poison damage for 10s (E key)",
          cost: { coins: 10000, gems: 100 },
          activation: "manual",
          hotkey: "e",
          cooldown: 45,
          duration: 10
        }
      },
      Vecna: {
        ultimate1: {
          name: "Hive Mind",
          icon: "üëÅÔ∏è",
          desc: "Link all enemy HP - kill one, kill all (Q key)",
          cost: { coins: 50000, gems: 500 },
          activation: "manual",
          hotkey: "q",
          cooldown: 120,
          duration: 15
        },
        ultimate2: {
          name: "Vecna's Curse",
          icon: "üåÄ",
          desc: "Enter Upside Down: +50% dmg, 50% lifesteal (E key)",
          cost: { coins: 75000, gems: 750 },
          activation: "manual",
          hotkey: "e",
          cooldown: 90,
          duration: 20,
          damageBonus: 0.5,
          lifesteal: 0.5
        }
      }
    };

    // PERMANENT UPGRADES (Shop)
    const SHOP_UPGRADES = {
      damage: {
        name: "üí• Base Damage",
        desc: "Increase starting damage",
        maxLevel: 10,
        getBonus: (level) => level * 3,
        getCost: (level) => ({ coins: 50 + level * 30, gems: 0 })
      },
      health: {
        name: "‚ù§Ô∏è Base Health",
        desc: "Increase starting HP",
        maxLevel: 10,
        getBonus: (level) => level * 15,
        getCost: (level) => ({ coins: 40 + level * 25, gems: 0 })
      },
      fireRate: {
        name: "‚ö° Fire Rate",
        desc: "Shoot faster (reduces fire delay)",
        maxLevel: 5,
        getBonus: (level) => level * 0.05,
        getCost: (level) => ({ coins: 100 + level * 50, gems: level * 2 })
      },
      critChance: {
        name: "üí¢ Crit Chance",
        desc: "Start with critical hit chance",
        maxLevel: 5,
        getBonus: (level) => level * 0.05,
        getCost: (level) => ({ coins: 150 + level * 75, gems: level * 3 })
      },
      startLevel: {
        name: "‚≠ê Starting Level",
        desc: "Begin at higher level",
        maxLevel: 3,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 300 + level * 200, gems: level * 10 })
      },
      healStrength: {
        name: "‚ù§Ô∏è Heal Potion Strength",
        desc: "+20 HP restored per level",
        maxLevel: 5,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 100 + level * 50, gems: level * 2 })
      },
      shieldStrength: {
        name: "üõ°Ô∏è Shield Potion Strength",
        desc: "+25 shield per level",
        maxLevel: 5,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 100 + level * 50, gems: level * 2 })
      },
      effectStrength: {
        name: "üí• Effect Potion Strength",
        desc: "Boost crit/damage/speed potions",
        maxLevel: 5,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 150 + level * 75, gems: level * 3 })
      },
      dragonStrength: {
        name: "üêâ Dragon Beam Power",
        desc: "+20 damage per level",
        maxLevel: 5,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 200 + level * 100, gems: level * 5 })
      },
      startingHeals: {
        name: "‚ù§Ô∏è Starting Heal Potions",
        desc: "+1 heal potion at wave start",
        maxLevel: 3,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 150 + level * 75, gems: level * 3 })
      },
      startingShields: {
        name: "üõ°Ô∏è Starting Shield Potions",
        desc: "+1 shield potion at wave start",
        maxLevel: 3,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 150 + level * 75, gems: level * 3 })
      },
      startingOthers: {
        name: "‚ö° Starting Effect Potions",
        desc: "+1 to all effect potions",
        maxLevel: 3,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 200 + level * 100, gems: level * 5 })
      },
      potionGen: {
        name: "üçÄ Potion Generation",
        desc: "10% chance per level for bonus potion",
        maxLevel: 5,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 250 + level * 125, gems: level * 6 })
      },
      potionDamage: {
        name: "‚öîÔ∏è Potion Damage Bonus",
        desc: "+2 damage per potion held",
        maxLevel: 5,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 200 + level * 100, gems: level * 4 })
      },
      potionExplosion: {
        name: "üí£ Potion Explosion",
        desc: "30 damage to random enemy when using potion",
        maxLevel: 5,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 300 + level * 150, gems: level * 7 })
      }
    };

    // TEMPORARY UPGRADES (Level-up)
    const UPGRADE_TYPES = {
      damage: {
        icon: "‚öîÔ∏è",
        name: "Power Strike",
        desc: "Increase damage by 25%",
        apply: (player) => { player.damage *= 1.25; }
      },
      fireRate: {
        icon: "‚ö°",
        name: "Rapid Fire",
        desc: "Attack 20% faster",
        apply: (player) => { player.fireRate *= 0.8; }
      },
      hp: {
        icon: "‚ù§Ô∏è",
        name: "Vitality Boost",
        desc: "Gain +30 Max HP and heal fully",
        apply: (player) => { 
          player.maxHP += 30; 
          player.hp = player.maxHP; 
        }
      },
      range: {
        icon: "üéØ",
        name: "Extended Range",
        desc: "Increase attack range by 30%",
        apply: (player) => { player.range *= 1.3; }
      },
      projectileSpeed: {
        icon: "üöÄ",
        name: "Bullet Velocity",
        desc: "Projectiles fly 30% faster",
        apply: (player) => { player.projectileSpeed *= 1.3; }
      },
      multiShot: {
        icon: "üåü",
        name: "Multi-Shot",
        desc: "Fire 2 additional projectiles",
        apply: (player) => { 
          player.multiShot = (player.multiShot || 0) + 2; 
        }
      },
      pierce: {
        icon: "üî±",
        name: "Piercing Shots",
        desc: "Projectiles pierce through enemies",
        apply: (player) => { player.pierce = true; }
      },
      lifesteal: {
        icon: "ü©∏",
        name: "Life Drain",
        desc: "Heal 15% of damage dealt",
        apply: (player) => { player.lifesteal = (player.lifesteal || 0) + 0.15; }
      },
      explosive: {
        icon: "üí•",
        name: "Explosive Rounds",
        desc: "Shots explode, damaging nearby enemies",
        apply: (player) => { player.explosive = true; }
      },
      criticalHit: {
        icon: "üí¢",
        name: "Critical Strike",
        desc: "20% chance to deal 2x damage",
        apply: (player) => { 
          player.critChance = (player.critChance || 0) + 0.2;
          player.critMultiplier = 2.0;
        }
      },
      shield: {
        icon: "üõ°Ô∏è",
        name: "Energy Shield",
        desc: "Gain a shield that absorbs 50 damage",
        apply: (player) => { 
          player.shield = (player.shield || 0) + 50;
          player.maxShield = (player.maxShield || 0) + 50;
        }
      },
      regeneration: {
        icon: "üíö",
        name: "Regeneration",
        desc: "Heal 2 HP per second",
        apply: (player) => { player.regen = (player.regen || 0) + 2; }
      },
      chainLightning: {
        icon: "‚ö°",
        name: "Chain Lightning",
        desc: "Damage chains to 2 nearby enemies",
        apply: (player) => { player.chainLightning = 2; }
      },
      damageAura: {
        icon: "üî•",
        name: "Flame Aura",
        desc: "Damage nearby enemies constantly",
        apply: (player) => { 
          player.aura = { damage: 3, radius: 80 };
        }
      }
    };

    // BOSS PATTERNS
    const BOSS_PATTERNS = [
      {
        name: "The Charger",
        color: "#ff00ff",
        pattern: "charge", // Speeds up periodically
        speed: 0.8,
        attackInterval: 2,
        specialAbility: "Speed Burst"
      },
      {
        name: "The Sniper",
        color: "#ff4444",
        pattern: "ranged", // Shoots multiple projectiles
        speed: 0.5,
        attackInterval: 3,
        specialAbility: "Triple Shot"
      },
      {
        name: "The Tank",
        color: "#4444ff",
        pattern: "tank", // Extra HP and shield
        speed: 0.6,
        attackInterval: 2.5,
        specialAbility: "Shield Regen"
      },
      {
        name: "The Summoner",
        color: "#88ff88",
        pattern: "summon", // Spawns extra enemies
        speed: 0.7,
        attackInterval: 4,
        specialAbility: "Spawn Minions"
      },
      {
        name: "The Berserker",
        color: "#ff8800",
        pattern: "berserk", // Gets faster as HP lowers
        speed: 0.9,
        attackInterval: 1.5,
        specialAbility: "Rage Mode"
      },
      {
        name: "The Headless",
        color: "#8B0000",
        pattern: "headthrow", // Throws its head as projectile
        speed: 0.7,
        attackInterval: 3,
        specialAbility: "Head Throw"
      }
    ];

    // CLASS UPGRADE TREES - Tier 1-3 upgrades for each class
    const CLASS_UPGRADES = {
      Hunter: {
        tier1: [
          { id: "hunter_hp1", name: "+10% Max HP", cost: { coins: 500 }, effect: { maxHP: 1.1 } },
          { id: "hunter_speed1", name: "+15% Projectile Speed", cost: { coins: 600 }, effect: { projectileSpeed: 1.15 } },
          { id: "hunter_fr1", name: "+10% Fire Rate", cost: { coins: 700 }, effect: { fireRate: 0.9 } }
        ],
        tier2: [
          { id: "hunter_crit1", name: "+15% Crit Chance", cost: { coins: 1500, gems: 10 }, effect: { critChance: 0.15 }, requires: ["hunter_hp1"] },
          { id: "hunter_ult1cd", name: "Sniper Shot -25% CD", cost: { coins: 2000, gems: 15 }, effect: { ult1Cooldown: 0.75 }, requires: ["hunter_fr1"] },
          { id: "hunter_range1", name: "+100 Range", cost: { coins: 1800, gems: 12 }, effect: { range: 100 }, requires: ["hunter_speed1"] }
        ],
        tier3: [
          { id: "hunter_pierce", name: "Arrows Pierce +2 Enemies", cost: { coins: 5000, gems: 50 }, effect: { pierce: 2 }, requires: ["hunter_crit1", "hunter_range1"] },
          { id: "hunter_sniper_boost", name: "Sniper Shot Width +50%", cost: { coins: 6000, gems: 60 }, effect: { sniperWidth: 1.5 }, requires: ["hunter_ult1cd"] }
        ]
      },
      Knight: {
        tier1: [
          { id: "knight_hp1", name: "+10% Max HP", cost: { coins: 500 }, effect: { maxHP: 1.1 } },
          { id: "knight_damage1", name: "+20% Damage vs Mini-Bosses", cost: { coins: 800 }, effect: { miniBossDamage: 1.2 } },
          { id: "knight_shield1", name: "+50 Starting Shield", cost: { coins: 600 }, effect: { startingShield: 50 } }
        ],
        tier2: [
          { id: "knight_reflect", name: "Reflect 10% Melee Damage", cost: { coins: 2000, gems: 20 }, effect: { reflectDamage: 0.1 }, requires: ["knight_shield1"] },
          { id: "knight_charge", name: "Shield Bash +100 Distance", cost: { coins: 1800, gems: 15 }, effect: { chargeDistance: 100 }, requires: ["knight_hp1"] },
          { id: "knight_laststand", name: "Last Stand +2s Duration", cost: { coins: 2200, gems: 18 }, effect: { lastStandDuration: 2 }, requires: ["knight_damage1"] }
        ],
        tier3: [
          { id: "knight_fortress", name: "Shield Capacity +100%", cost: { coins: 6000, gems: 70 }, effect: { maxShield: 2.0 }, requires: ["knight_reflect", "knight_laststand"] },
          { id: "knight_unstoppable", name: "Charge Stuns 2x Longer", cost: { coins: 5500, gems: 60 }, effect: { stunDuration: 2.0 }, requires: ["knight_charge"] }
        ]
      },
      Assassin: {
        tier1: [
          { id: "assassin_hp1", name: "+10% Max HP", cost: { coins: 500 }, effect: { maxHP: 1.1 } },
          { id: "assassin_fr1", name: "+10% Fire Rate", cost: { coins: 700 }, effect: { fireRate: 0.9 } },
          { id: "assassin_crit1", name: "+10% Crit Chance", cost: { coins: 800 }, effect: { critChance: 0.1 } }
        ],
        tier2: [
          { id: "assassin_backstab", name: "Backstab Multiplier +50%", cost: { coins: 2000, gems: 20 }, effect: { backstabMulti: 1.5 }, requires: ["assassin_crit1"] },
          { id: "assassin_dodge", name: "5% Shadow Dodge Chance", cost: { coins: 2500, gems: 25 }, effect: { dodgeChance: 0.05 }, requires: ["assassin_hp1"] },
          { id: "assassin_bladestorm", name: "Blade Storm +50% Damage", cost: { coins: 1800, gems: 15 }, effect: { bladeStormDamage: 1.5 }, requires: ["assassin_fr1"] }
        ],
        tier3: [
          { id: "assassin_combo", name: "Unlock Combo Chain Effects", cost: { coins: 6000, gems: 80 }, effect: { comboChain: true }, requires: ["assassin_backstab", "assassin_bladestorm"] },
          { id: "assassin_phantom", name: "Shadow Strike CD -50%", cost: { coins: 5000, gems: 60 }, effect: { shadowStrikeCd: 0.5 }, requires: ["assassin_dodge"] }
        ]
      },
      Summoner: {
        tier1: [
          { id: "summoner_hp1", name: "+10% Max HP", cost: { coins: 500 }, effect: { maxHP: 1.1 } },
          { id: "summoner_minion_hp", name: "Minions +30% HP", cost: { coins: 800 }, effect: { minionHP: 1.3 } },
          { id: "summoner_summon_speed", name: "Summon Cooldown -20%", cost: { coins: 700 }, effect: { summonCd: 0.8 } }
        ],
        tier2: [
          { id: "summoner_aura", name: "Minion Damage Aura +25%", cost: { coins: 2000, gems: 20 }, effect: { minionAura: 1.25 }, requires: ["summoner_minion_hp"] },
          { id: "summoner_resurrect", name: "Resurrect 1 Minion/Wave", cost: { coins: 2500, gems: 30 }, effect: { resurrectMinion: 1 }, requires: ["summoner_hp1"] },
          { id: "summoner_army", name: "+2 Max Minions", cost: { coins: 3000, gems: 35 }, effect: { maxMinions: 2 }, requires: ["summoner_summon_speed"] }
        ],
        tier3: [
          { id: "summoner_necro", name: "Enemies Resurrect as Allies", cost: { coins: 7000, gems: 90 }, effect: { necromancy: true }, requires: ["summoner_resurrect", "summoner_army"] },
          { id: "summoner_overlord", name: "Minion Stats +100%", cost: { coins: 6000, gems: 75 }, effect: { minionStats: 2.0 }, requires: ["summoner_aura"] }
        ]
      },
      Bomber: {
        tier1: [
          { id: "bomber_hp1", name: "+10% Max HP", cost: { coins: 500 }, effect: { maxHP: 1.1 } },
          { id: "bomber_radius", name: "+40% Explosion Radius", cost: { coins: 800 }, effect: { explosionRadius: 1.4 } },
          { id: "bomber_damage1", name: "+15% Explosion Damage", cost: { coins: 700 }, effect: { explosionDamage: 1.15 } }
        ],
        tier2: [
          { id: "bomber_chain", name: "25% Chain Explosion Chance", cost: { coins: 2200, gems: 25 }, effect: { chainExplosion: 0.25 }, requires: ["bomber_radius"] },
          { id: "bomber_auto", name: "Auto-Bomb at Low HP", cost: { coins: 2000, gems: 20 }, effect: { autoBomb: true }, requires: ["bomber_hp1"] },
          { id: "bomber_pierce", name: "Bombs Pierce Shields 50%", cost: { coins: 1800, gems: 18 }, effect: { shieldPierce: 0.5 }, requires: ["bomber_damage1"] }
        ],
        tier3: [
          { id: "bomber_nuke", name: "Nuclear Explosion Size 2x", cost: { coins: 7000, gems: 85 }, effect: { nukeSize: 2.0 }, requires: ["bomber_chain", "bomber_auto"] },
          { id: "bomber_cluster", name: "Bombs Split Into 3", cost: { coins: 6500, gems: 80 }, effect: { clusterBomb: 3 }, requires: ["bomber_pierce"] }
        ]
      },
      Pyromancer: {
        tier1: [
          { id: "pyro_hp1", name: "+10% Max HP", cost: { coins: 500 }, effect: { maxHP: 1.1 } },
          { id: "pyro_burn", name: "Burn DoT Stacks", cost: { coins: 800 }, effect: { burnStacks: true } },
          { id: "pyro_speed1", name: "+15% Projectile Speed", cost: { coins: 600 }, effect: { projectileSpeed: 1.15 } }
        ],
        tier2: [
          { id: "pyro_pierce", name: "Flames Pierce Cooled Enemies", cost: { coins: 2000, gems: 22 }, effect: { pierceCooled: true }, requires: ["pyro_burn"] },
          { id: "pyro_nova", name: "Fire Nova Every 10 Kills", cost: { coins: 2500, gems: 28 }, effect: { fireNova: 10 }, requires: ["pyro_hp1"] },
          { id: "pyro_inferno", name: "Inferno Duration +50%", cost: { coins: 1800, gems: 18 }, effect: { infernoDuration: 1.5 }, requires: ["pyro_speed1"] }
        ],
        tier3: [
          { id: "pyro_hell", name: "Hell Portal Summons 3 Imps", cost: { coins: 6500, gems: 80 }, effect: { hellImps: 3 }, requires: ["pyro_nova", "pyro_inferno"] },
          { id: "pyro_meteor", name: "Burn Causes Meteor Chance", cost: { coins: 6000, gems: 75 }, effect: { burnMeteor: 0.1 }, requires: ["pyro_pierce"] }
        ]
      },
      CrioSentinel: {
        tier1: [
          { id: "crio_hp1", name: "+10% Max HP", cost: { coins: 500 }, effect: { maxHP: 1.1 } },
          { id: "crio_freeze", name: "Freeze Duration +1 sec", cost: { coins: 800 }, effect: { freezeDuration: 1.0 } },
          { id: "crio_slow", name: "Slow Area +50%", cost: { coins: 700 }, effect: { slowArea: 1.5 } }
        ],
        tier2: [
          { id: "crio_shatter", name: "Frozen Enemies Explode on Death", cost: { coins: 2500, gems: 30 }, effect: { shatterExplode: true }, requires: ["crio_freeze"] },
          { id: "crio_blizzard", name: "Blizzard Size +100%", cost: { coins: 2000, gems: 22 }, effect: { blizzardSize: 2.0 }, requires: ["crio_slow"] },
          { id: "crio_hp2", name: "+20% Max HP", cost: { coins: 1800, gems: 20 }, effect: { maxHP: 1.2 }, requires: ["crio_hp1"] }
        ],
        tier3: [
          { id: "crio_absolute", name: "Absolute Zero Unlocked", cost: { coins: 7000, gems: 90 }, effect: { absoluteZero: true }, requires: ["crio_shatter", "crio_blizzard"] },
          { id: "crio_permafrost", name: "Freeze Can't Be Broken Early", cost: { coins: 6000, gems: 75 }, effect: { permafrost: true }, requires: ["crio_hp2"] }
        ]
      },
      LightningRanger: {
        tier1: [
          { id: "lightning_hp1", name: "+10% Max HP", cost: { coins: 500 }, effect: { maxHP: 1.1 } },
          { id: "lightning_chain", name: "Chain Lightning +2 Targets", cost: { coins: 900 }, effect: { chainTargets: 2 } },
          { id: "lightning_crit1", name: "+10% Crit Chance", cost: { coins: 700 }, effect: { critChance: 0.1 } }
        ],
        tier2: [
          { id: "lightning_stun", name: "Lightning Crits Stun", cost: { coins: 2200, gems: 25 }, effect: { critStun: true }, requires: ["lightning_crit1"] },
          { id: "lightning_charged", name: "Unlock Charged Shot Ability", cost: { coins: 2500, gems: 30 }, effect: { chargedShot: true }, requires: ["lightning_chain"] },
          { id: "lightning_storm", name: "Thunderstorm Duration +50%", cost: { coins: 1800, gems: 20 }, effect: { stormDuration: 1.5 }, requires: ["lightning_hp1"] }
        ],
        tier3: [
          { id: "lightning_mjolnir", name: "Lightning Calls Thor's Hammer", cost: { coins: 7500, gems: 95 }, effect: { mjolnir: true }, requires: ["lightning_stun", "lightning_charged"] },
          { id: "lightning_arc", name: "Chain Arcs Hit 2x", cost: { coins: 6000, gems: 70 }, effect: { arcMultiplier: 2.0 }, requires: ["lightning_storm"] }
        ]
      },
      Archer: {
        tier1: [
          { id: "archer_hp1", name: "+10% Max HP", cost: { coins: 500 }, effect: { maxHP: 1.1 } },
          { id: "archer_range", name: "+100 Range", cost: { coins: 700 }, effect: { range: 100 } },
          { id: "archer_pierce1", name: "Pierce +1 Enemy", cost: { coins: 800 }, effect: { pierce: 1 } }
        ],
        tier2: [
          { id: "archer_multishot", name: "3-Arrow Multishot Unlocked", cost: { coins: 2000, gems: 20 }, effect: { multishot: 3 }, requires: ["archer_range"] },
          { id: "archer_cupid", name: "Cupid's Bow +3 Shots", cost: { coins: 2500, gems: 25 }, effect: { cupidShots: 3 }, requires: ["archer_hp1"] },
          { id: "archer_hook", name: "Hook Shot Root +1s", cost: { coins: 1800, gems: 18 }, effect: { hookDuration: 1.0 }, requires: ["archer_pierce1"] }
        ],
        tier3: [
          { id: "archer_volley", name: "Arrow Rain Ability Unlocked", cost: { coins: 6500, gems: 75 }, effect: { arrowRain: true }, requires: ["archer_multishot", "archer_cupid"] },
          { id: "archer_snipe", name: "Crits Deal 3x Damage", cost: { coins: 6000, gems: 70 }, effect: { critMultiplier: 3.0 }, requires: ["archer_hook"] }
        ]
      },
      Wizard: {
        tier1: [
          { id: "wizard_hp1", name: "+10% Max HP", cost: { coins: 500 }, effect: { maxHP: 1.1 } },
          { id: "wizard_mana", name: "+50 Max Mana", cost: { coins: 800 }, effect: { maxMana: 50 } },
          { id: "wizard_regen", name: "Mana Regen +20%", cost: { coins: 700 }, effect: { manaRegen: 1.2 } }
        ],
        tier2: [
          { id: "wizard_meteor", name: "Meteor Storm +5 Meteors", cost: { coins: 2500, gems: 28 }, effect: { meteorCount: 5 }, requires: ["wizard_mana"] },
          { id: "wizard_time", name: "Time Freeze Duration +50%", cost: { coins: 2200, gems: 25 }, effect: { timeDuration: 1.5 }, requires: ["wizard_hp1"] },
          { id: "wizard_spell", name: "Spell Damage +30%", cost: { coins: 2000, gems: 22 }, effect: { spellDamage: 1.3 }, requires: ["wizard_regen"] }
        ],
        tier3: [
          { id: "wizard_archmage", name: "Archmage: All Spells CD -50%", cost: { coins: 8000, gems: 100 }, effect: { allCooldown: 0.5 }, requires: ["wizard_meteor", "wizard_time"] },
          { id: "wizard_chaos", name: "Chaos Bolt Unlocked", cost: { coins: 7000, gems: 85 }, effect: { chaosBolt: true }, requires: ["wizard_spell"] }
        ]
      }
    };

    // OVERWORLD MAP - THE LEGEND OF THE FORGOTTEN WARRIOR
    // Five Seals tracking
    let collectedSeals = {
      crystalKeystone: false,
      abyssKey: false,
      frozenFragment: false,
      blazingSeal: false,
      tideRune: false
    };

    const OVERWORLD_MAP = {
      nodes: {
        // ===== CHAPTER I: THE CALLING =====
        beginner_village: {
          id: "beginner_village",
          type: "start",
          name: "Beginner Village",
          lore: "A quiet refuge where forgotten warriors awaken...",
          x: 120,
          y: 80,
          connections: ["new_night_1", "new_night_2"],
          completed: true,
          unlocked: true
        },
        
        // ===== NEW NIGHT MAP - The Awakening =====
        new_night_1: {
          id: "new_night_1",
          type: "survival",
          name: "Twilight Outskirts",
          lore: "Shadows whisper warnings. Learn to fight or be forgotten.",
          x: 200,
          y: 120,
          waves: 20,
          miniBossWaves: [5, 15],
          bossWaves: [10, 20],
          recommendedPower: 1,
          connections: ["new_night_2", "sunny_fields_1"],
          rewards: { coins: 100, gems: 2, story: "first_key_shard" },
          completed: false,
          unlocked: false
        },
        new_night_2: {
          id: "new_night_2",
          type: "survival",
          name: "Moonlit Hollow",
          lore: "Eternal twilight. Prove your resilience.",
          x: 180,
          y: 180,
          waves: 20,
          miniBossWaves: [5, 15],
          bossWaves: [10, 20],
          recommendedPower: 1,
          connections: ["sunny_fields_1", "sunny_fields_2"],
          rewards: { coins: 120, gems: 2 },
          completed: false,
          unlocked: false
        },
        
        // ===== SUNNY FIELDS - Trials of Light =====
        sunny_fields_1: {
          id: "sunny_fields_1",
          type: "survival",
          name: "Sunlit Meadow",
          lore: "Deceptively peaceful. Radiant magic corrupts all.",
          x: 300,
          y: 160,
          waves: 20,
          miniBossWaves: [5, 15],
          bossWaves: [10, 20],
          recommendedPower: 2,
          connections: ["sunny_fields_2", "crimson_forest_1"],
          rewards: { coins: 150, gems: 3 },
          completed: false,
          unlocked: false
        },
        sunny_fields_2: {
          id: "sunny_fields_2",
          type: "survival",
          name: "Golden Plains",
          lore: "Wave after wave. Only the resilient survive.",
          x: 280,
          y: 220,
          waves: 20,
          miniBossWaves: [5, 15],
          bossWaves: [10, 20],
          recommendedPower: 2,
          connections: ["crimson_forest_1", "crimson_forest_2"],
          rewards: { coins: 170, gems: 3 },
          completed: false,
          unlocked: false
        },
        
        // ===== CRIMSON FOREST - The Bloodwood Gauntlet =====
        crimson_forest_1: {
          id: "crimson_forest_1",
          type: "elite",
          name: "Bloodwood Edge",
          lore: "Trees soaked in cursed red flame. Two guardians await.",
          x: 420,
          y: 180,
          waves: 20,
          miniBossWaves: [8, 16],
          bossWaves: [20],
          recommendedPower: 3,
          connections: ["crimson_forest_2", "crystal_caves_gate"],
          rewards: { coins: 250, gems: 5, story: "second_key_shard" },
          completed: false,
          unlocked: false
        },
        crimson_forest_2: {
          id: "crimson_forest_2",
          type: "elite",
          name: "Crimson Depths",
          lore: "Purge the forest's corruption. Earn passage forward.",
          x: 400,
          y: 280,
          waves: 20,
          miniBossWaves: [8, 16],
          bossWaves: [20],
          recommendedPower: 3,
          connections: ["fork_gate", "abyssal_ruins_gate"],
          rewards: { coins: 270, gems: 5 },
          completed: false,
          unlocked: false
        },
        
        // ===== THE GREAT FORKING OF FATE =====
        fork_gate: {
          id: "fork_gate",
          type: "gate",
          name: "The Crossroads of Destiny",
          lore: "Two paths diverge. Choose wisely, warrior.",
          x: 550,
          y: 240,
          connections: ["crystal_caves_gate", "abyssal_ruins_gate"],
          completed: false,
          unlocked: false
        },
        
        // ===== BRANCH A: CRYSTAL CAVES =====
        crystal_caves_gate: {
          id: "crystal_caves_gate",
          type: "gate",
          name: "Crystal Cave Entrance",
          lore: "Below the earth lies a glowing labyrinth...",
          x: 600,
          y: 140,
          connections: ["crystal_caves_1"],
          completed: false,
          unlocked: false
        },
        crystal_caves_1: {
          id: "crystal_caves_1",
          type: "survival",
          name: "Singing Crystals",
          lore: "Some crystals sing. Others scream.",
          x: 720,
          y: 120,
          waves: 20,
          miniBossWaves: [5, 15],
          bossWaves: [10, 20],
          recommendedPower: 4,
          connections: ["crystal_caves_boss"],
          rewards: { coins: 300, gems: 7 },
          completed: false,
          unlocked: false
        },
        crystal_caves_boss: {
          id: "crystal_caves_boss",
          type: "boss",
          name: "Crystal Guardian",
          lore: "An ancient guardian holds the Crystal Keystone.",
          x: 850,
          y: 100,
          waves: 20,
          miniBossWaves: [10],
          bossWaves: [20],
          recommendedPower: 5,
          connections: ["frostbite_mountains"],
          rewards: { coins: 500, gems: 15, seal: "crystalKeystone", material: "crystal_heart" },
          completed: false,
          unlocked: false
        },
        
        // ===== BRANCH B: ABYSSAL RUINS =====
        abyssal_ruins_gate: {
          id: "abyssal_ruins_gate",
          type: "gate",
          name: "Abyssal Entrance",
          lore: "A sunken kingdom swallowed by darkness...",
          x: 600,
          y: 340,
          connections: ["abyssal_ruins_1"],
          completed: false,
          unlocked: false
        },
        abyssal_ruins_1: {
          id: "abyssal_ruins_1",
          type: "survival",
          name: "Flooded Halls",
          lore: "Phantoms and water-drenched horrors lurk here.",
          x: 150,
          y: 520,
          waves: 20,
          miniBossWaves: [5, 15],
          bossWaves: [10, 20],
          recommendedPower: 4,
          connections: ["abyssal_ruins_2"],
          rewards: { coins: 300, gems: 7 },
          completed: false,
          unlocked: false
        },
        abyssal_ruins_2: {
          id: "abyssal_ruins_2",
          type: "elite",
          name: "Abyss Core",
          lore: "Fragments of the Abyss Key await the worthy.",
          x: 200,
          y: 600,
          waves: 20,
          miniBossWaves: [8, 16],
          bossWaves: [20],
          recommendedPower: 5,
          connections: ["underwater_caverns"],
          rewards: { coins: 450, gems: 12, seal: "abyssKey", material: "abyssal_scale" },
          completed: false,
          unlocked: false
        },
        
        // ===== FROSTBITE MOUNTAINS =====
        frostbite_mountains: {
          id: "frostbite_mountains",
          type: "elite",
          name: "Frostbite Peak",
          lore: "Blizzards conceal ancient spirits that test endurance.",
          x: 950,
          y: 160,
          waves: 20,
          miniBossWaves: [8, 16],
          bossWaves: [20],
          recommendedPower: 6,
          connections: ["volcano_gate"],
          rewards: { coins: 550, gems: 18, seal: "frozenFragment" },
          completed: false,
          unlocked: false
        },
        
        // ===== MOUNT IGNIS (VOLCANO) =====
        volcano_gate: {
          id: "volcano_gate",
          type: "gate",
          name: "Volcano Entrance",
          lore: "A burning hellscape awaits...",
          x: 1050,
          y: 250,
          connections: ["volcano_1"],
          completed: false,
          unlocked: false
        },
        volcano_1: {
          id: "volcano_1",
          type: "survival",
          name: "Magma Fields",
          lore: "Fire elementals attack relentlessly.",
          x: 1000,
          y: 350,
          waves: 20,
          miniBossWaves: [5, 15],
          bossWaves: [10, 20],
          recommendedPower: 7,
          connections: ["volcano_boss"],
          rewards: { coins: 600, gems: 20 },
          completed: false,
          unlocked: false
        },
        volcano_boss: {
          id: "volcano_boss",
          type: "boss",
          name: "Inferno Lord",
          lore: "The Blazing Seal is yours if you survive.",
          x: 950,
          y: 450,
          waves: 20,
          miniBossWaves: [10],
          bossWaves: [20],
          recommendedPower: 8,
          connections: ["convergence_gate"],
          rewards: { coins: 800, gems: 30, seal: "blazingSeal", material: "ember_core" },
          completed: false,
          unlocked: false
        },
        
        // ===== UNDERWATER CAVERNS =====
        underwater_caverns: {
          id: "underwater_caverns",
          type: "secret",
          name: "Underwater Cavern",
          lore: "Pressure, darkness, drifting undead. The Tide Rune awaits.",
          x: 250,
          y: 680,
          waves: 20,
          miniBossWaves: [5, 15],
          bossWaves: [10, 20],
          recommendedPower: 6,
          connections: ["underwater_depths"],
          rewards: { coins: 500, gems: 15 },
          completed: false,
          unlocked: false,
          hidden: true,
          requireMaterial: "abyssal_scale"
        },
        underwater_depths: {
          id: "underwater_depths",
          type: "boss",
          name: "Tide Keeper",
          lore: "The last component. The Tide Rune.",
          x: 350,
          y: 720,
          waves: 20,
          miniBossWaves: [10],
          bossWaves: [20],
          recommendedPower: 7,
          connections: ["convergence_gate"],
          rewards: { coins: 700, gems: 25, seal: "tideRune" },
          completed: false,
          unlocked: false
        },
        
        // ===== SECRET PATHS =====
        shadow_shrine: {
          id: "shadow_shrine",
          type: "shrine",
          name: "Shadow Shrine",
          lore: "Only Assassins may enter...",
          x: 500,
          y: 100,
          shrineClass: "Assassin",
          connections: ["crystal_caves_1"],
          rewards: { coins: 300, gems: 10 },
          completed: false,
          unlocked: false,
          hidden: true,
          requireClass: "Assassin"
        },
        code_portal_1: {
          id: "code_portal_1",
          type: "secret",
          name: "Ancient Portal",
          lore: "Symbols shimmer. A code is required...",
          x: 450,
          y: 400,
          waves: 20,
          miniBossWaves: [10],
          bossWaves: [20],
          recommendedPower: 5,
          connections: ["volcano_1"],
          rewards: { coins: 600, gems: 20 },
          completed: false,
          unlocked: false,
          hidden: true,
          requireCode: "FORGOTTEN"
        },
        
        // ===== CONVERGENCE & FINAL GATE =====
        convergence_gate: {
          id: "convergence_gate",
          type: "gate",
          name: "The Five Seals Gate",
          lore: "With all five seals, the golden path appears...",
          x: 750,
          y: 500,
          connections: ["forgotten_city_approach"],
          completed: false,
          unlocked: false,
          requireAllSeals: true
        },
        forgotten_city_approach: {
          id: "forgotten_city_approach",
          type: "survival",
          name: "Path of Memory",
          lore: "A road untouched by time. Only you may walk it.",
          x: 700,
          y: 600,
          waves: 20,
          miniBossWaves: [5, 10, 15],
          bossWaves: [20],
          recommendedPower: 9,
          connections: ["forgotten_city"],
          rewards: { coins: 1000, gems: 40 },
          completed: false,
          unlocked: false
        },
        
        // ===== CHAPTER VI: THE FORGOTTEN CITY =====
        forgotten_city: {
          id: "forgotten_city",
          type: "final_boss",
          name: "The Forgotten City",
          lore: "The Memory Devourer awaits. Reclaim your name.",
          x: 800,
          y: 650,
          waves: 20,
          miniBossWaves: [5, 10, 15],
          bossWaves: [20],
          recommendedPower: 10,
          connections: [],
          rewards: { coins: 5000, gems: 200, ending: true },
          completed: false,
          unlocked: false
        }
      },
      currentNode: "beginner_village"
    };

    // ==================== TOWER DEFENSE GAME CONSTANTS ====================
    
    // GAME CONSTANTS
    const GROUND_Y = 470;
    const ROUND_BREAK_TIME = 20;
    const PLAYER_X = 100; // Fixed position

    // CLASS DEFINITIONS
    const CLASSES = {
      Hunter: {
        icon: "üèπ",
        color: "#00ff88",
        accent: "#88ffaa",
        bulletColor: "#00ff88",
        glowColor: "#00ff88",
        unlockWave: 0,
        purchasable: false,
        stats: {
          maxHP: 120,
          damage: 14,
          fireRate: 0.3,
          range: 650,
          projectileSpeed: 8
        },
        description: "Balanced ranged fighter"
      },
      Knight: {
        icon: "‚öîÔ∏è",
        color: "#4488ff",
        accent: "#88aaff",
        bulletColor: "#4488ff",
        glowColor: "#4488ff",
        unlockWave: 5,
        purchasable: false,
        stats: {
          maxHP: 160,
          damage: 28,
          fireRate: 0.65,
          range: 260,
          projectileSpeed: 6.5
        },
        description: "High damage, low range tank"
      },
      Archer: {
        icon: "üèπ",
        color: "#228b22",
        accent: "#32cd32",
        bulletColor: "#228b22",
        glowColor: "#32cd32",
        unlockWave: 15,
        purchasable: false,
        stats: {
          maxHP: 100,
          damage: 18,
          fireRate: 0.4,
          range: 950,
          projectileSpeed: 10,
          alwaysPierce: true
        },
        description: "Longest range, piercing shots"
      },
      Assassin: {
        icon: "üó°Ô∏è",
        color: "#ff00ff",
        accent: "#ff88ff",
        bulletColor: "#ff00ff",
        glowColor: "#ff00ff",
        unlockWave: 35,
        purchasable: false,
        stats: {
          maxHP: 95,
          damage: 9,
          fireRate: 0.15,
          range: 400,
          projectileSpeed: 9.5
        },
        description: "Ultra-fast glass cannon"
      },
      Summoner: {
        icon: "‚ú®",
        color: "#88ff88",
        accent: "#aaffaa",
        bulletColor: "#88ff88",
        glowColor: "#88ff88",
        unlockWave: 65,
        purchasable: false,
        stats: {
          maxHP: 110,
          damage: 12,
          fireRate: 0.55,
          range: 450,
          projectileSpeed: 7
        },
        description: "Summons spirit helpers"
      },
      Wizard: {
        icon: "üîÆ",
        color: "#8800ff",
        accent: "#aa88ff",
        bulletColor: "#8800ff",
        glowColor: "#8800ff",
        unlockWave: 95,
        purchasable: false,
        stats: {
          maxHP: 85,
          damage: 35,
          fireRate: 0.85,
          range: 550,
          projectileSpeed: 5.5
        },
        description: "Powerful but slow caster"
      }
    };

    // BOSS PATTERNS
    const BOSS_PATTERNS = [
      {
        name: "The Charger",
        color: "#ff00ff",
        pattern: "charge",
        speed: 0.8,
        attackInterval: 2,
        specialAbility: "Speed Burst"
      },
      {
        name: "The Sniper",
        color: "#ff4444",
        pattern: "ranged",
        speed: 0.5,
        attackInterval: 3,
        specialAbility: "Triple Shot"
      },
      {
        name: "The Tank",
        color: "#4444ff",
        pattern: "tank",
        speed: 0.6,
        attackInterval: 2.5,
        specialAbility: "Shield Regen"
      },
      {
        name: "The Summoner",
        color: "#88ff88",
        pattern: "summon",
        speed: 0.7,
        attackInterval: 4,
        specialAbility: "Spawn Minions"
      },
      {
        name: "The Berserker",
        color: "#ff8800",
        pattern: "berserk",
        speed: 0.9,
        attackInterval: 1.5,
        specialAbility: "Rage Mode"
      }
    ];

    // TEMPORARY UPGRADES (Level-up)
    const UPGRADE_TYPES = {
      damage: {
        icon: "‚öîÔ∏è",
        name: "Power Strike",
        desc: "Increase damage by 25%",
        apply: (player) => { player.damage *= 1.25; }
      },
      fireRate: {
        icon: "‚ö°",
        name: "Rapid Fire",
        desc: "Attack 20% faster",
        apply: (player) => { player.fireRate *= 0.8; }
      },
      hp: {
        icon: "‚ù§Ô∏è",
        name: "Vitality Boost",
        desc: "Gain +30 Max HP and heal fully",
        apply: (player) => { 
          player.maxHP += 30; 
          player.hp = player.maxHP; 
        }
      },
      range: {
        icon: "üéØ",
        name: "Extended Range",
        desc: "Increase attack range by 30%",
        apply: (player) => { player.range *= 1.3; }
      },
      projectileSpeed: {
        icon: "üöÄ",
        name: "Bullet Velocity",
        desc: "Projectiles fly 30% faster",
        apply: (player) => { player.projectileSpeed *= 1.3; }
      },
      multiShot: {
        icon: "üåü",
        name: "Multi-Shot",
        desc: "Fire 2 additional projectiles",
        apply: (player) => { 
          player.multiShot = (player.multiShot || 0) + 2; 
        }
      },
      pierce: {
        icon: "üî±",
        name: "Piercing Shots",
        desc: "Projectiles pierce through enemies",
        apply: (player) => { player.pierce = true; }
      },
      lifesteal: {
        icon: "ü©∏",
        name: "Life Drain",
        desc: "Heal 15% of damage dealt",
        apply: (player) => { player.lifesteal = (player.lifesteal || 0) + 0.15; }
      },
      explosive: {
        icon: "üí•",
        name: "Explosive Rounds",
        desc: "Shots explode, damaging nearby enemies",
        apply: (player) => { player.explosive = true; }
      },
      criticalHit: {
        icon: "üí¢",
        name: "Critical Strike",
        desc: "20% chance to deal 2x damage",
        apply: (player) => { 
          player.critChance = (player.critChance || 0) + 0.2;
          player.critMultiplier = 2.0;
        }
      },
      shield: {
        icon: "üõ°Ô∏è",
        name: "Energy Shield",
        desc: "Gain a shield that absorbs 50 damage",
        apply: (player) => { 
          player.shield = (player.shield || 0) + 50;
          player.maxShield = (player.maxShield || 0) + 50;
        }
      },
      regeneration: {
        icon: "üíö",
        name: "Regeneration",
        desc: "Heal 2 HP per second",
        apply: (player) => { player.regen = (player.regen || 0) + 2; }
      },
      chainLightning: {
        icon: "‚ö°",
        name: "Chain Lightning",
        desc: "Damage chains to 2 nearby enemies",
        apply: (player) => { player.chainLightning = 2; }
      },
      damageAura: {
        icon: "üî•",
        name: "Flame Aura",
        desc: "Damage nearby enemies constantly",
        apply: (player) => { 
          player.aura = { damage: 3, radius: 80 };
        }
      }
    };

    // GAME STATE
    let keys = {};
    let lastTime = 0;
    let gameRunning = false;
    let screenShake = 0;
    let gameState = "playing";
    let roundBreakTimer = 0;

    let player = null;
    let enemies = [];
    let projectiles = [];
    let minions = [];
    let particles = [];
    let floatingTexts = [];
    let currencyDrops = [];

    let shootTimer = 0;
    let wave = 1;
    let enemiesToSpawn = 0;
    let spawnTimer = 0;
    let autoShoot = true;
    let autoAim = true;
    let autoStartWave = false; // Auto-start next wave when ready
    let gameSpeed = 1; // Game speed multiplier (1 = normal, 2 = 2x, 3 = 3x)
    let combo = 0;
    let comboTimer = 0;
    let maxCombo = 0;
    
    let sessionCoins = 0;
    let sessionGems = 0;
    
    // New features
    let shufflesRemaining = 4; // Shuffle counter for upgrades
    let currentMap = 1; // Map tracking
    let mapsCompleted = 0;
    let enemiesKilled = 0; // Track kills for stats
    let waveTimer = 0; // Timer for next wave (30s after last spawn)
    let waveTimerActive = false; // Is wave timer counting down?
    
    // Dragon beam fire zones
    let fireZones = [];
    
    // Potion system
    let potions = {
      heal: 3,
      shield: 2,
      crit: 1,
      damage: 1,
      speed: 1,
      dragon: 1
    };
    
    let potionCooldowns = {
      heal: 0,
      shield: 0,
      crit: 0,
      damage: 0,
      speed: 0,
      dragon: 0
    };
    
    let potionEffects = {
      critActive: false,
      critTimer: 0,
      damageActive: false,
      damageTimer: 0,
      speedActive: false,
      speedTimer: 0
    };

    // ABILITY SYSTEM
    let ability1Cooldown = 0;
    let ability2Cooldown = 0;
    let ability1KillCounter = 0;
    let ability2KillCounter = 0;
    let ability1Active = false;
    let ability2Active = false;
    
    // Special ability states
    let lastStandUsed = false;
    let chainReactionShots = 0;
    let headhunterShots = 0;
    let overwatchActive = false;
    let overwatchTimer = 0;
    let bladeStormActive = false;
    let bladeStormTimer = 0;
    let soulHarvestActive = false;
    let soulHarvestTimer = 0;
    let timeFreezeActive = false;
    let timeFreezeTimer = 0;
    
    // Vecna special states
    let hiveMindActive = false;
    let hiveMindTimer = 0;
    let upsideDownActive = false;
    let upsideDownTimer = 0;
    let vecnaKillCounter = 0;
    let vecnaMonsters = [];
    let vecnaMonsterKillCounter = 0;
    let convertedEnemies = [];

    // ==================== TOWER DEFENSE CORE FUNCTIONS ====================
    
    // XP & LEVELING
    function xpForLevel(level) {
      return Math.floor(60 * Math.pow(level, 2.1));
    }

    function giveXP(amount) {
      player.xp += amount;
      if (player.xp >= player.xpToNext) {
        player.level++;
        player.xp -= player.xpToNext;
        player.xpToNext = xpForLevel(player.level);
        showTDUpgradeScreen();
      }
    }

    // ENEMY CALCULATIONS
    function calcEnemiesForWave(w) {
      if (w === 1) return 5;
      if (w === 2) return 7;
      if (w === 3) return 9;
      if (w === 4) return 11;
      if (w === 5) return 15;
      
      const base = 15;
      const increment = (w - 5) * 3;
      const waveBonus = Math.floor(w / 5) * 5;
      return base + increment + waveBonus;
    }

    function getEnemyHP(wave, isBoss = false, isMiniBoss = false) {
      const baseHP = 50;
      const linearGrowth = wave * 15;
      const exponentialGrowth = Math.pow(wave, 2.0) * 1.2;
      let hp = baseHP + linearGrowth + exponentialGrowth;
      
      if (isBoss) hp *= 12;
      else if (isMiniBoss) hp *= 5;
      
      return Math.floor(hp);
    }

    // PARTICLE EFFECTS
    function spawnHitParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 4,
          vy: (Math.random() - 0.5) * 4,
          life: 0.5,
          color,
          radius: 2
        });
      }
    }

    function spawnExplosion(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 8,
          vy: (Math.random() - 0.5) * 8,
          life: 0.8,
          color,
          radius: 3
        });
      }
    }

    function addFloatingText(x, y, text, color) {
      floatingTexts.push({ x, y, text, color, life: 1.5, vy: -1.5 });
    }

    function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= dt;
        if (p.life <= 0) {
          particles.splice(i, 1);
        }
      }
    }

    function updateFloatingTexts(dt) {
      for (let i = floatingTexts.length - 1; i >= 0; i--) {
        const t = floatingTexts[i];
        t.y += t.vy;
        t.life -= dt;
        if (t.life <= 0) {
          floatingTexts.splice(i, 1);
        }
      }
    }

    // POTION SYSTEM
    function resetPotions() {
      potions.heal = 3;
      potions.shield = 2;
      potions.crit = 1;
      potions.damage = 1;
      potions.speed = 1;
      potions.dragon = 1;
      updatePotionDisplay();
    }
    
    function updatePotionDisplay() {
      document.getElementById('countHeal').textContent = potions.heal;
      document.getElementById('countShield').textContent = potions.shield;
      document.getElementById('countCrit').textContent = potions.crit;
      document.getElementById('countDamage').textContent = potions.damage;
      document.getElementById('countSpeed').textContent = potions.speed;
      document.getElementById('countDragon').textContent = potions.dragon;
    }
    
    function usePotion(type) {
      if (!player || !player.alive) return;
      if (potions[type] <= 0) return;
      if (potionCooldowns[type] > 0) return;
      
      potions[type]--;
      potionCooldowns[type] = 1.0;
      
      switch(type) {
        case 'heal':
          const healAmount = 50;
          player.hp = Math.min(player.hp + healAmount, player.maxHP);
          addFloatingText(player.x + player.w / 2, player.y - 30, "+" + healAmount + " HP", "#00ff00");
          spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#00ff00", 10);
          break;
          
        case 'shield':
          const shieldAmount = 50;
          if (player.maxShield === 0) player.maxShield = shieldAmount;
          player.shield = Math.min(player.shield + shieldAmount, player.maxShield);
          addFloatingText(player.x + player.w / 2, player.y - 30, "+" + shieldAmount + " Shield", "#00aaff");
          spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#00aaff", 10);
          break;
          
        case 'crit':
          potionEffects.critActive = true;
          potionEffects.critTimer = 10;
          player.critChance += 0.25;
          addFloatingText(player.x + player.w / 2, player.y - 30, "Crit Boost!", "#ff0000");
          break;
          
        case 'damage':
          potionEffects.damageActive = true;
          potionEffects.damageTimer = 10;
          player.damage += 10;
          addFloatingText(player.x + player.w / 2, player.y - 30, "Damage Boost!", "#ff8800");
          break;
          
        case 'speed':
          potionEffects.speedActive = true;
          potionEffects.speedTimer = 10;
          player.fireRate *= 0.85;
          addFloatingText(player.x + player.w / 2, player.y - 30, "Speed Boost!", "#ffff00");
          break;
          
        case 'dragon':
          useDragonBeam();
          break;
      }
      
      updatePotionDisplay();
      screenShake += 3;
    }
    
    function useDragonBeam() {
      const dragonDamage = player.damage * 3;
      
      addFloatingText(tdGameCanvas.width / 2, 200, "üêâ DRAGON BEAM! üêâ", "#ff00ff");
      screenShake += 25;
      
      projectiles.push({
        x: player.x + player.w / 2,
        y: player.y + player.h / 2,
        vx: 30,
        vy: 0,
        radius: 30,
        damage: dragonDamage,
        color: "#ff4400",
        glowColor: "#ff8800",
        life: 3,
        trail: [],
        pierce: true,
        isDragonBeam: true
      });
      
      for (let i = 0; i < 80; i++) {
        particles.push({
          x: player.x + player.w / 2,
          y: player.y + player.h / 2,
          vx: Math.random() * 20 + 10,
          vy: Math.random() * 10 - 5,
          radius: Math.random() * 8 + 3,
          color: i % 2 === 0 ? "#ff4400" : "#ff8800",
          life: 2
        });
      }
    }
    
    function updatePotionEffects(dt) {
      if (potionEffects.critActive) {
        potionEffects.critTimer -= dt;
        if (potionEffects.critTimer <= 0) {
          potionEffects.critActive = false;
          player.critChance -= 0.25;
        }
      }
      
      if (potionEffects.damageActive) {
        potionEffects.damageTimer -= dt;
        if (potionEffects.damageTimer <= 0) {
          potionEffects.damageActive = false;
          player.damage -= 10;
        }
      }
      
      if (potionEffects.speedActive) {
        potionEffects.speedTimer -= dt;
        if (potionEffects.speedTimer <= 0) {
          potionEffects.speedActive = false;
          player.fireRate /= 0.85;
        }
      }
      
      for (let type in potionCooldowns) {
        if (potionCooldowns[type] > 0) {
          potionCooldowns[type] -= dt;
          if (potionCooldowns[type] < 0) potionCooldowns[type] = 0;
        }
      }
    }

    // ENEMY SPAWNING
    function spawnEnemy(wave, type = "grunt", isBoss = false, isMiniBoss = false) {
      const enemy = {
        x: tdGameCanvas.width + 50,
        y: GROUND_Y - 40,
        w: 40,
        h: 40,
        hp: getEnemyHP(wave, isBoss, isMiniBoss),
        maxHP: getEnemyHP(wave, isBoss, isMiniBoss),
        speed: 1 + wave * 0.05,
        type: type,
        color: "#ff0000",
        isBoss: isBoss,
        isMiniBoss: isMiniBoss,
        coins: isBoss ? 50 : (isMiniBoss ? 20 : 5),
        gems: isBoss ? 5 : (isMiniBoss ? 2 : 0),
        xpValue: isBoss ? 100 : (isMiniBoss ? 40 : 10),
        alive: true,
        shootTimer: 0,
        shootInterval: 2.0,
        shield: 0,
        maxShield: 0
      };

      if (type === "triangle") {
        enemy.speed *= 1.5;
        enemy.hp *= 0.7;
        enemy.maxHP = enemy.hp;
        enemy.w = 30;
        enemy.h = 30;
        enemy.color = "#ff8800";
      } else if (type === "circle") {
        enemy.speed *= 0.7;
        enemy.hp *= 1.5;
        enemy.maxHP = enemy.hp;
        enemy.w = 50;
        enemy.h = 50;
        enemy.color = "#8800ff";
      } else if (type === "jumper") {
        enemy.speed *= 1.2;
        enemy.jumpTimer = Math.random() * 2;
        enemy.jumpInterval = 2;
        enemy.isJumping = false;
        enemy.jumpVelocity = 0;
        enemy.color = "#00ff88";
      } else if (type === "kamikaze") {
        enemy.speed *= 2;
        enemy.hp *= 0.5;
        enemy.maxHP = enemy.hp;
        enemy.damage = 30;
        enemy.color = "#ffff00";
      } else if (type === "shielded") {
        enemy.shield = enemy.hp * 0.5;
        enemy.maxShield = enemy.shield;
        enemy.speed *= 0.9;
        enemy.color = "#00aaff";
      } else if (type === "shooter") {
        enemy.speed *= 0.6;
        enemy.hp *= 0.8;
        enemy.maxHP = enemy.hp;
        enemy.shootInterval = 1.5;
        enemy.color = "#ff00ff";
      }

      if (isBoss) {
        enemy.w = 80;
        enemy.h = 80;
        const patternIndex = Math.floor(wave / 10) % BOSS_PATTERNS.length;
        enemy.pattern = BOSS_PATTERNS[patternIndex];
        enemy.color = enemy.pattern.color;
        enemy.patternTimer = 0;
        enemy.rageMode = false;
      } else if (isMiniBoss) {
        enemy.w = 60;
        enemy.h = 60;
        enemy.color = "#ff00aa";
      }

      enemies.push(enemy);
    }

    function handleSpawning(dt) {
      if (enemiesToSpawn > 0) {
        spawnTimer += dt;
        if (spawnTimer >= SPAWN_INTERVAL) {
          spawnTimer = 0;
          
          const isBossWave = tdBossWaves.includes(wave);
          const isMiniBossWave = tdMiniBossWaves.includes(wave);
          
          if (isBossWave && enemies.length === 0) {
            spawnEnemy(wave, "grunt", true, false);
          } else if (isMiniBossWave && enemies.length === 0) {
            spawnEnemy(wave, "grunt", false, true);
          } else if (!isBossWave && !isMiniBossWave) {
            const rand = Math.random();
            let type = "grunt";
            
            if (wave >= 3 && rand < 0.2) type = "triangle";
            else if (wave >= 5 && rand < 0.4) type = "circle";
            else if (wave >= 7 && rand < 0.5) type = "jumper";
            else if (wave >= 10 && rand < 0.6) type = "kamikaze";
            else if (wave >= 12 && rand < 0.7) type = "shielded";
            else if (wave >= 15 && rand < 0.8) type = "shooter";
            
            spawnEnemy(wave, type, false, false);
          }
          
          enemiesToSpawn--;
        }
      }
    }

    // SHOOTING & PROJECTILES
    function getTargetEnemy() {
      let closest = null;
      let minDist = Infinity;
      
      for (const enemy of enemies) {
        if (!enemy.alive) continue;
        const dx = enemy.x - player.x;
        const dy = enemy.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist <= player.range && dist < minDist) {
          minDist = dist;
          closest = enemy;
        }
      }
      
      return closest;
    }

    function shootProjectile(targetX, targetY) {
      const centerX = player.x + player.w / 2;
      const centerY = player.y + player.h / 2;
      const dx = targetX - centerX;
      const dy = targetY - centerY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const vx = (dx / dist) * player.projectileSpeed;
      const vy = (dy / dist) * player.projectileSpeed;

      const isCrit = Math.random() < player.critChance;
      const finalDamage = isCrit ? player.damage * 2 : player.damage;

      const projectile = {
        x: centerX,
        y: centerY,
        vx: vx,
        vy: vy,
        radius: 5,
        damage: finalDamage,
        color: player.color.main,
        glowColor: player.color.glow,
        life: 3,
        trail: [],
        pierce: player.pierce > 0 || player.alwaysPierce,
        pierceRemaining: player.pierce,
        isCrit: isCrit
      };

      projectiles.push(projectile);

      if (player.multiShot > 0) {
        for (let i = 0; i < player.multiShot; i++) {
          const angle = (Math.PI / 12) * (i + 1) * (i % 2 === 0 ? 1 : -1);
          const cos = Math.cos(angle);
          const sin = Math.sin(angle);
          const rotVx = vx * cos - vy * sin;
          const rotVy = vx * sin + vy * cos;

          projectiles.push({
            x: centerX,
            y: centerY,
            vx: rotVx,
            vy: rotVy,
            radius: 4,
            damage: finalDamage * 0.7,
            color: player.color.main,
            glowColor: player.color.glow,
            life: 3,
            trail: [],
            pierce: player.pierce > 0 || player.alwaysPierce,
            pierceRemaining: player.pierce,
            isCrit: isCrit
          });
        }
      }
    }

    function handleShooting(dt) {
      if (!player || !player.alive) return;
      
      shootTimer += dt;
      if (shootTimer >= player.fireRate) {
        shootTimer = 0;
        const target = getTargetEnemy();
        if (target) {
          shootProjectile(target.x + target.w / 2, target.y + target.h / 2);
        }
      }
    }

    function updateProjectiles(dt) {
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const proj = projectiles[i];
        
        proj.trail.push({ x: proj.x, y: proj.y, life: 0.3 });
        if (proj.trail.length > 5) proj.trail.shift();
        
        proj.x += proj.vx * dt * 60;
        proj.y += proj.vy * dt * 60;
        proj.life -= dt;

        for (let t = proj.trail.length - 1; t >= 0; t--) {
          proj.trail[t].life -= dt;
          if (proj.trail[t].life <= 0) proj.trail.splice(t, 1);
        }

        if (proj.life <= 0 || proj.x > tdGameCanvas.width + 100 || proj.x < -100 || proj.y < -100 || proj.y > tdGameCanvas.height + 100) {
          projectiles.splice(i, 1);
          continue;
        }

        for (let j = enemies.length - 1; j >= 0; j--) {
          const enemy = enemies[j];
          if (!enemy.alive) continue;

          const dx = proj.x - (enemy.x + enemy.w / 2);
          const dy = proj.y - (enemy.y + enemy.h / 2);
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < proj.radius + enemy.w / 2) {
            let damage = proj.damage;
            
            if (enemy.shield > 0) {
              const shieldDamage = Math.min(damage, enemy.shield);
              enemy.shield -= shieldDamage;
              damage -= shieldDamage;
              spawnHitParticles(enemy.x + enemy.w / 2, enemy.y + enemy.h / 2, "#00aaff", 3);
            }
            
            enemy.hp -= damage;
            spawnHitParticles(enemy.x + enemy.w / 2, enemy.y + enemy.h / 2, proj.color, 5);
            addFloatingText(enemy.x + enemy.w / 2, enemy.y - 10, "-" + Math.floor(damage), proj.isCrit ? "#ffff00" : "#ffffff");
            screenShake += proj.isCrit ? 4 : 2;

            if (player.lifesteal > 0) {
              const healAmount = damage * player.lifesteal;
              player.hp = Math.min(player.hp + healAmount, player.maxHP);
              addFloatingText(player.x + player.w / 2, player.y - 30, "+" + Math.floor(healAmount), "#00ff00");
            }

            if (player.chainLightning > 0 && Math.random() < 0.3) {
              const chainTargets = enemies.filter(e => e.alive && e !== enemy);
              if (chainTargets.length > 0) {
                const chainTarget = chainTargets[Math.floor(Math.random() * chainTargets.length)];
                chainTarget.hp -= proj.damage * 0.5;
                spawnHitParticles(chainTarget.x + chainTarget.w / 2, chainTarget.y + chainTarget.h / 2, "#00ffff", 8);
                addFloatingText(chainTarget.x + chainTarget.w / 2, chainTarget.y - 10, "‚ö°", "#00ffff");
              }
            }

            if (player.explosiveRadius > 0) {
              spawnExplosion(enemy.x + enemy.w / 2, enemy.y + enemy.h / 2, "#ff8800", 15);
              for (const other of enemies) {
                if (other === enemy || !other.alive) continue;
                const dx2 = (other.x + other.w / 2) - (enemy.x + enemy.w / 2);
                const dy2 = (other.y + other.h / 2) - (enemy.y + enemy.h / 2);
                const dist2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                if (dist2 < player.explosiveRadius) {
                  other.hp -= proj.damage * 0.5;
                  spawnHitParticles(other.x + other.w / 2, other.y + other.h / 2, "#ff8800", 5);
                }
              }
            }

            if (enemy.hp <= 0) {
              enemy.alive = false;
              enemiesKilled++;
              giveXP(enemy.xpValue);
              dropCurrency(enemy.x + enemy.w / 2, enemy.y + enemy.h / 2, enemy.coins, enemy.gems);
              spawnExplosion(enemy.x + enemy.w / 2, enemy.y + enemy.h / 2, enemy.color, 20);
              
              combo++;
              comboTimer = 3;
              if (combo > maxCombo) maxCombo = combo;
            }

            if (!proj.pierce) {
              projectiles.splice(i, 1);
              break;
            } else {
              proj.pierceRemaining--;
              if (proj.pierceRemaining <= 0 && !player.alwaysPierce) {
                projectiles.splice(i, 1);
                break;
              }
            }
          }
        }
      }
    }

    // ENEMY AI & UPDATES
    function updateEnemies(dt) {
      for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        
        if (!enemy.alive) {
          enemies.splice(i, 1);
          continue;
        }

        if (enemy.type === "jumper") {
          enemy.jumpTimer += dt;
          if (!enemy.isJumping && enemy.jumpTimer >= enemy.jumpInterval) {
            enemy.isJumping = true;
            enemy.jumpVelocity = -12;
            enemy.jumpTimer = 0;
          }
          
          if (enemy.isJumping) {
            enemy.jumpVelocity += 0.5;
            enemy.y += enemy.jumpVelocity;
            if (enemy.y >= GROUND_Y - enemy.h) {
              enemy.y = GROUND_Y - enemy.h;
              enemy.isJumping = false;
              enemy.jumpVelocity = 0;
            }
          }
        }

        if (enemy.type === "shooter") {
          enemy.shootTimer += dt;
          if (enemy.shootTimer >= enemy.shootInterval && player && player.alive) {
            enemy.shootTimer = 0;
            const dx = player.x - enemy.x;
            const dy = player.y - enemy.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            projectiles.push({
              x: enemy.x + enemy.w / 2,
              y: enemy.y + enemy.h / 2,
              vx: (dx / dist) * 8,
              vy: (dy / dist) * 8,
              radius: 6,
              damage: 15,
              color: "#ff00ff",
              glowColor: "#ff88ff",
              life: 4,
              trail: [],
              isEnemyProjectile: true
            });
          }
        }

        if (enemy.isBoss) {
          enemy.patternTimer += dt;
          
          if (enemy.hp < enemy.maxHP * 0.3 && !enemy.rageMode) {
            enemy.rageMode = true;
            enemy.speed *= 1.5;
            addFloatingText(enemy.x + enemy.w / 2, enemy.y - 50, "RAGE MODE!", "#ff0000");
            spawnExplosion(enemy.x + enemy.w / 2, enemy.y + enemy.h / 2, "#ff0000", 30);
          }
          
          if (enemy.pattern.pattern === "charger" && enemy.patternTimer >= 3) {
            enemy.patternTimer = 0;
            enemy.speed = enemy.pattern.speed * 3;
            setTimeout(() => { if (enemy.alive) enemy.speed = enemy.pattern.speed; }, 1000);
          }
          
          if (enemy.pattern.pattern === "sniper" && enemy.patternTimer >= enemy.pattern.attackInterval) {
            enemy.patternTimer = 0;
            for (let a = 0; a < 3; a++) {
              const angle = (Math.PI / 6) * (a - 1);
              projectiles.push({
                x: enemy.x + enemy.w / 2,
                y: enemy.y + enemy.h / 2,
                vx: Math.cos(angle) * -10,
                vy: Math.sin(angle) * -10,
                radius: 8,
                damage: 25,
                color: "#ff0000",
                glowColor: "#ff8888",
                life: 5,
                trail: [],
                isEnemyProjectile: true
              });
            }
          }
          
          if (enemy.pattern.pattern === "tank") {
            if (enemy.shield < enemy.maxShield * 0.5) {
              enemy.shield = Math.min(enemy.shield + enemy.maxShield * 0.02 * dt, enemy.maxShield);
            }
          }
          
          if (enemy.pattern.pattern === "summoner" && enemy.patternTimer >= enemy.pattern.attackInterval) {
            enemy.patternTimer = 0;
            for (let s = 0; s < 2; s++) {
              spawnEnemy(wave, "grunt", false, false);
            }
          }
        }

        enemy.x -= enemy.speed * dt * 60;

        if (enemy.x + enemy.w < player.x && player.alive) {
          const damage = enemy.type === "kamikaze" ? enemy.damage : 10;
          if (player.shield > 0) {
            const shieldDamage = Math.min(damage, player.shield);
            player.shield -= shieldDamage;
            const remainingDamage = damage - shieldDamage;
            player.hp -= remainingDamage;
          } else {
            player.hp -= damage;
          }
          
          spawnHitParticles(player.x + player.w / 2, player.y + player.h / 2, "#ff0000", 10);
          screenShake += 8;
          
          if (enemy.type === "kamikaze") {
            spawnExplosion(enemy.x + enemy.w / 2, enemy.y + enemy.h / 2, "#ffff00", 25);
          }
          
          enemy.alive = false;
          combo = 0;
          
          if (player.hp <= 0) {
            player.hp = 0;
            player.alive = false;
            showTDGameOver();
          }
        }
      }
    }

    // MINION SYSTEM (for Summoner class)
    function spawnMinion() {
      minions.push({
        x: player.x + player.w / 2,
        y: player.y - 50,
        w: 20,
        h: 20,
        hp: 30,
        maxHP: 30,
        speed: 2,
        damage: player.damage * 0.4,
        lifetime: 10,
        shootTimer: 0,
        shootInterval: 1.0,
        color: "#88ff88"
      });
    }

    function updateMinions(dt) {
      for (let i = minions.length - 1; i >= 0; i--) {
        const minion = minions[i];
        
        minion.lifetime -= dt;
        if (minion.lifetime <= 0 || minion.hp <= 0) {
          spawnExplosion(minion.x + minion.w / 2, minion.y + minion.h / 2, minion.color, 10);
          minions.splice(i, 1);
          continue;
        }

        const target = getTargetEnemy();
        if (target) {
          const dx = target.x - minion.x;
          if (Math.abs(dx) > 100) {
            minion.x += Math.sign(dx) * minion.speed;
          }
          
          minion.shootTimer += dt;
          if (minion.shootTimer >= minion.shootInterval) {
            minion.shootTimer = 0;
            const dy = target.y - minion.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            projectiles.push({
              x: minion.x + minion.w / 2,
              y: minion.y + minion.h / 2,
              vx: (dx / dist) * 12,
              vy: (dy / dist) * 12,
              radius: 4,
              damage: minion.damage,
              color: minion.color,
              glowColor: "#aaffaa",
              life: 2,
              trail: [],
              pierce: false
            });
          }
        }
      }
    }

    // CURRENCY DROPS
    function dropCurrency(x, y, coins, gems) {
      if (coins > 0) {
        currencyDrops.push({
          x: x + (Math.random() - 0.5) * 20,
          y: y + (Math.random() - 0.5) * 20,
          vx: (Math.random() - 0.5) * 3,
          vy: -Math.random() * 5 - 3,
          type: "coin",
          value: coins,
          lifetime: 10
        });
      }
      
      if (gems > 0) {
        currencyDrops.push({
          x: x + (Math.random() - 0.5) * 20,
          y: y + (Math.random() - 0.5) * 20,
          vx: (Math.random() - 0.5) * 3,
          vy: -Math.random() * 5 - 3,
          type: "gem",
          value: gems,
          lifetime: 10
        });
      }
    }

    function updateCurrencyDrops(dt) {
      for (let i = currencyDrops.length - 1; i >= 0; i--) {
        const drop = currencyDrops[i];
        
        drop.vy += 0.3;
        drop.x += drop.vx;
        drop.y += drop.vy;
        drop.lifetime -= dt;
        
        if (drop.y > GROUND_Y - 10) {
          drop.y = GROUND_Y - 10;
          drop.vy = 0;
          drop.vx *= 0.9;
        }

        if (player && player.alive) {
          const dx = player.x + player.w / 2 - drop.x;
          const dy = player.y + player.h / 2 - drop.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < 150) {
            const magnetSpeed = 8;
            drop.x += (dx / dist) * magnetSpeed;
            drop.y += (dy / dist) * magnetSpeed;
          }
          
          if (dist < 30) {
            if (drop.type === "coin") {
              gameData.coins += drop.value;
              sessionCoins += drop.value;
              addFloatingText(drop.x, drop.y - 20, "+" + drop.value + " ü™ô", "#ffff00");
            } else if (drop.type === "gem") {
              gameData.gems += drop.value;
              sessionGems += drop.value;
              addFloatingText(drop.x, drop.y - 20, "+" + drop.value + " üíé", "#00ffff");
            }
            currencyDrops.splice(i, 1);
            continue;
          }
        }
        
        if (drop.lifetime <= 0) {
          currencyDrops.splice(i, 1);
        }
      }
    }

    // UPGRADE SCREEN
    function showTDUpgradeScreen() {
      document.getElementById('tdUpgradeScreen').style.display = 'flex';
      
      const upgradeKeys = Object.keys(UPGRADE_TYPES);
      const shuffled = upgradeKeys.sort(() => Math.random() - 0.5);
      const choices = shuffled.slice(0, 3);
      
      const cardsContainer = document.getElementById('upgradeCardsContainer');
      cardsContainer.innerHTML = '';
      
      choices.forEach(key => {
        const upgrade = UPGRADE_TYPES[key];
        const card = document.createElement('div');
        card.className = 'upgrade-card';
        card.innerHTML = `
          <div class="upgrade-icon">${upgrade.icon}</div>
          <h3>${upgrade.name}</h3>
          <p>${upgrade.desc}</p>
        `;
        card.onclick = () => selectUpgrade(key);
        cardsContainer.appendChild(card);
      });
    }

    function selectUpgrade(upgradeKey) {
      const upgrade = UPGRADE_TYPES[upgradeKey];
      upgrade.apply(player);
      
      addFloatingText(player.x + player.w / 2, player.y - 50, upgrade.name + "!", "#ffff00");
      spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#ffff00", 20);
      
      document.getElementById('tdUpgradeScreen').style.display = 'none';
    }

    function showTDGameOver() {
      document.getElementById('tdGameOverScreen').style.display = 'flex';
      document.getElementById('finalWave').textContent = wave;
      document.getElementById('finalLevel').textContent = player ? player.level : 1;
      document.getElementById('finalKills').textContent = enemiesKilled;
      document.getElementById('coinsEarned').textContent = sessionCoins;
      document.getElementById('gemsEarned').textContent = sessionGems;
    }

    // Initialize
    loadGameData();
    updateShopDisplay();
    updateTitleScreenDisplay();
    
    // Ensure correct initial screen state
    titleScreen.classList.remove("hidden");
    classSelection.classList.remove("active");
    shopScreen.classList.remove("active");
    tutorialScreen.style.display = "none";
    roundBreakScreen.classList.remove("active");
    gameOverScreen.classList.remove("active");
    upgradeScreen.classList.remove("active");

    // EVENT LISTENERS
    startBtn.addEventListener("click", () => {
      titleScreen.classList.add("hidden");
      document.getElementById('overworldScreen').classList.add('active');
      if (!overworldInitialized) {
        initializeOverworld();
        overworldInitialized = true;
      }
    });

    shopBtn.addEventListener("click", () => {
      titleScreen.classList.add("hidden");
      showShop();
    });
    
    evolAuraBtn.addEventListener("click", () => {
      titleScreen.classList.add("hidden");
      showEvolAura();
    });

    shopBackBtn.addEventListener("click", () => {
      shopScreen.classList.remove("active");
      titleScreen.classList.remove("hidden");
    });
    
    auraBackBtn.addEventListener("click", () => {
      document.getElementById('evolAuraScreen').style.display = 'none';
      titleScreen.classList.remove("hidden");
    });
    
    tutorialBtn.addEventListener("click", () => {
      titleScreen.classList.add("hidden");
      tutorialScreen.style.display = "flex";
    });
    
    tutorialBackBtn.addEventListener("click", () => {
      tutorialScreen.style.display = "none";
      titleScreen.classList.remove("hidden");
    });
    
    // OVERWORLD EVENT LISTENERS
    overworldCanvas.addEventListener('click', onOverworldClick);
    overworldCanvas.addEventListener('mousemove', onOverworldMove);
    
    document.getElementById('classUpgradesBtn').addEventListener('click', () => {
      showClassUpgradePanel();
    });
    
    document.getElementById('redeemCodeBtn').addEventListener('click', () => {
      showRedeemCodePanel();
    });
    
    document.getElementById('overworldShopBtn').addEventListener('click', () => {
      openShopFromOverworld();
    });
    
    document.getElementById('changeClassBtn').addEventListener('click', () => {
      document.getElementById('overworldScreen').classList.remove('active');
      showClassSelection();
    });
    
    document.getElementById('returnHomeBtn').addEventListener('click', () => {
      document.getElementById('overworldScreen').classList.remove('active');
      titleScreen.classList.remove('hidden');
    });
    
    // Initialize overworld on first load
    function initializeOverworld() {
      // Load saved progress
      loadOverworldProgress();
      
      // Ensure starting nodes are unlocked if no save
      if (!OVERWORLD_MAP.nodes.beginner_village.completed) {
        OVERWORLD_MAP.nodes.beginner_village.unlocked = true;
        OVERWORLD_MAP.nodes.beginner_village.completed = true;
        OVERWORLD_MAP.nodes.new_night_1.unlocked = true;
        OVERWORLD_MAP.nodes.new_night_2.unlocked = true;
      }
      
      updateOverworldStats();
      drawOverworldMap();
    }
    
    // Potion click handlers
    document.getElementById('potionHeal').addEventListener('click', () => usePotion('heal'));
    document.getElementById('potionShield').addEventListener('click', () => usePotion('shield'));
    document.getElementById('potionCrit').addEventListener('click', () => usePotion('crit'));
    document.getElementById('potionDamage').addEventListener('click', () => usePotion('damage'));
    document.getElementById('potionSpeed').addEventListener('click', () => usePotion('speed'));
    document.getElementById('potionDragon').addEventListener('click', () => usePotion('dragon'));
    
    // Ability button click handlers
    document.getElementById('ability1Btn').addEventListener('click', () => activateAbility1());
    document.getElementById('ability2Btn').addEventListener('click', () => activateAbility2());

    window.addEventListener("keydown", (e) => {
      keys[e.key] = true;
      if (e.key === " " || e.code === "Space") {
        e.preventDefault();
        if (gameState === "roundBreak") {
          endRoundBreak();
        } else if (waveTimerActive && waveTimer <= 0 && !autoStartWave) {
          // Manually start next wave
          wave++;
          waveTimerActive = false;
          
          // Check for map progression (every 20 waves)
          if (wave % 20 === 1 && wave > 1) {
            currentMap++;
            mapsCompleted++;
            shufflesRemaining = 4;
            addFloatingText(canvas.width / 2, 200, `üó∫Ô∏è MAP ${currentMap} üó∫Ô∏è`, "#ff00ff");
            addFloatingText(canvas.width / 2, 230, "SHUFFLES RESET!", "#00ffff");
            screenShake += 15;
          }
          
          // Give wave bonus XP
          const waveBonus = 50 + wave * 10;
          giveXP(waveBonus);
          addFloatingText(canvas.width / 2, 150, "WAVE " + wave + " START!", "#00ffff");
          
          // Potions DO NOT reset - Summoner ability only!
          
          // Reset Last Stand for new wave
          lastStandUsed = false;
          
          // Start next wave
          enemiesToSpawn = calcEnemiesForWave(wave);
          spawnTimer = 0;
          
          // Spawn boss/mini-boss immediately if applicable
          if (wave % 10 === 0) {
            spawnEnemy(true, false);
            enemiesToSpawn--;
          } else if (wave % 5 === 0) {
            spawnEnemy(false, true);
            enemiesToSpawn--;
          }
        }
      }
      if (e.key === "t" || e.key === "T") {
        autoShoot = !autoShoot;
      }
      if (e.key === "y" || e.key === "Y") {
        autoAim = !autoAim;
      }
      if (e.key === "r" || e.key === "R") {
        autoStartWave = !autoStartWave;
        addFloatingText(canvas.width / 2, 150, autoStartWave ? "Auto-Start: ON" : "Auto-Start: OFF", autoStartWave ? "#00ff00" : "#ff0000");
      }
      if (e.key === "f" || e.key === "F") {
        gameSpeed = gameSpeed === 1 ? 2 : 1; // Toggle between 1x and 2x
        addFloatingText(canvas.width / 2, 180, "Game Speed: " + gameSpeed + "x", gameSpeed === 2 ? "#ff8800" : "#ffffff");
      }
      
      // Potion hotkeys
      if (e.key === "1") usePotion('heal');
      if (e.key === "2") usePotion('shield');
      if (e.key === "3") usePotion('crit');
      if (e.key === "4") usePotion('damage');
      if (e.key === "5") usePotion('speed');
      if (e.key === "6") usePotion('dragon');
      
      // Ability hotkeys
      if ((e.key === "q" || e.key === "Q") && gameState === "playing") {
        activateAbility1();
      }
      if ((e.key === "e" || e.key === "E") && gameState === "playing") {
        activateAbility2();
      }
    });
    
    window.addEventListener("keyup", (e) => {
      keys[e.key] = false;
    });

    // CLASS SELECTION
    function showClassSelection() {
      classSelection.classList.add("active");
      classGrid.innerHTML = "";
      
      Object.entries(CLASSES).forEach(([className, classData]) => {
        const card = document.createElement("div");
        card.className = "class-card";
        
        let isUnlocked = false;
        let lockReason = "";
        
        if (classData.purchasable) {
          // Purchasable class
          isUnlocked = gameData.purchasedClasses.includes(className);
          if (!isUnlocked) {
            lockReason = `üí∞ ${classData.cost.coins} coins, üíé ${classData.cost.gems} gems`;
          }
        } else {
          // Wave-unlock class
          isUnlocked = gameData.unlockedClasses.includes(className);
          if (!isUnlocked && gameData.highestWave < classData.unlockWave) {
            lockReason = `Unlock at Wave ${classData.unlockWave}`;
          }
        }
        
        const isLocked = !isUnlocked;
        
        if (isLocked) {
          card.classList.add("locked");
        }
        
        card.innerHTML = `
          <div class="class-icon">${classData.icon}</div>
          <div class="class-name" style="color: ${classData.color}">${className}</div>
          <div class="class-stats">
            HP: ${classData.stats.maxHP}<br>
            DMG: ${classData.stats.damage}<br>
            ${classData.description}
          </div>
          ${isLocked ? `<div class="class-unlock">${lockReason}</div>` : ""}
          ${classData.purchasable && isLocked ? '<div class="class-unlock" style="color: #00ff00; margin-top: 5px;">Available in Shop!</div>' : ""}
        `;
        
        if (!isLocked) {
          card.onclick = () => selectClass(className);
        }
        
        classGrid.appendChild(card);
      });
    }

    function selectClass(className) {
      classSelection.classList.remove("active");
      startGame(className);
    }

    // SHOP
    function showShop() {
      shopScreen.classList.add("active");
      updateShopDisplay();
    }

    function updateShopDisplay() {
      shopGrid.innerHTML = "";
      shopCoins.textContent = gameData.totalCoins;
      shopGems.textContent = gameData.totalGems;
      
      // PURCHASABLE CLASSES SECTION
      const classesHeader = document.createElement("div");
      classesHeader.style.gridColumn = "1 / -1";
      classesHeader.style.fontSize = "24px";
      classesHeader.style.color = "#ff00ff";
      classesHeader.style.fontWeight = "bold";
      classesHeader.style.marginTop = "10px";
      classesHeader.style.marginBottom = "10px";
      classesHeader.textContent = "üéØ UNLOCK CLASSES";
      shopGrid.appendChild(classesHeader);
      
      Object.entries(CLASSES).forEach(([className, classData]) => {
        if (!classData.purchasable) return;
        
        const isPurchased = gameData.purchasedClasses.includes(className);
        
        const card = document.createElement("div");
        card.className = "shop-item";
        if (isPurchased) card.classList.add("maxed");
        
        card.innerHTML = `
          <div class="shop-item-name">${classData.icon} ${className}</div>
          <div class="shop-item-desc">${classData.description}</div>
          <div class="shop-item-level">HP: ${classData.stats.maxHP} | DMG: ${classData.stats.damage}</div>
          ${!isPurchased ? `
            <div class="shop-item-cost">
              üí∞ ${classData.cost.coins} | üíé ${classData.cost.gems}
            </div>
          ` : '<div class="shop-item-cost" style="color: #00ff00;">‚úÖ OWNED</div>'}
        `;
        
        if (!isPurchased) {
          card.onclick = () => purchaseClass(className);
        }
        
        shopGrid.appendChild(card);
      });
      
      // PERMANENT UPGRADES SECTION
      const upgradesHeader = document.createElement("div");
      upgradesHeader.style.gridColumn = "1 / -1";
      upgradesHeader.style.fontSize = "24px";
      upgradesHeader.style.color = "#ffff00";
      upgradesHeader.style.fontWeight = "bold";
      upgradesHeader.style.marginTop = "20px";
      upgradesHeader.style.marginBottom = "10px";
      upgradesHeader.textContent = "‚¨ÜÔ∏è PERMANENT UPGRADES";
      shopGrid.appendChild(upgradesHeader);
      
      const permanentUpgradeKeys = ['damage', 'health', 'fireRate', 'critChance', 'startLevel'];
      permanentUpgradeKeys.forEach((key) => {
        const upgrade = SHOP_UPGRADES[key];
        const currentLevel = gameData.permanentUpgrades[key];
        const isMaxed = currentLevel >= upgrade.maxLevel;
        const cost = isMaxed ? null : upgrade.getCost(currentLevel);
        const bonus = upgrade.getBonus(currentLevel);
        const nextBonus = isMaxed ? 0 : upgrade.getBonus(currentLevel + 1);
        
        const card = document.createElement("div");
        card.className = "shop-item";
        if (isMaxed) card.classList.add("maxed");
        
        card.innerHTML = `
          <div class="shop-item-name">${upgrade.name}</div>
          <div class="shop-item-desc">${upgrade.desc}</div>
          <div class="shop-item-level">Level: ${currentLevel}/${upgrade.maxLevel}</div>
          <div class="shop-item-level">Current: +${bonus}${key === 'fireRate' ? 's faster' : ''}</div>
          ${!isMaxed ? `
            <div class="shop-item-level" style="color: #00ff00;">Next: +${nextBonus}</div>
            <div class="shop-item-cost">
              ${cost.coins > 0 ? `üí∞ ${cost.coins}` : ''}
              ${cost.gems > 0 ? ` üíé ${cost.gems}` : ''}
            </div>
          ` : '<div class="shop-item-cost" style="color: #00ff00;">MAX LEVEL</div>'}
        `;
        
        if (!isMaxed) {
          card.onclick = () => purchaseUpgrade(key);
        }
        
        shopGrid.appendChild(card);
      });
      
      // POTION UPGRADES SECTION
      const potionHeader = document.createElement("div");
      potionHeader.style.gridColumn = "1 / -1";
      potionHeader.style.fontSize = "24px";
      potionHeader.style.color = "#ff00ff";
      potionHeader.style.fontWeight = "bold";
      potionHeader.style.marginTop = "20px";
      potionHeader.style.marginBottom = "10px";
      potionHeader.textContent = "üß™ POTION UPGRADES";
      shopGrid.appendChild(potionHeader);
      
      const potionUpgradeKeys = ['healStrength', 'shieldStrength', 'effectStrength', 'dragonStrength', 
                                  'startingHeals', 'startingShields', 'startingOthers', 
                                  'potionGen', 'potionDamage', 'potionExplosion'];
      potionUpgradeKeys.forEach((key) => {
        const upgrade = SHOP_UPGRADES[key];
        const currentLevel = gameData.potionUpgrades[key];
        const isMaxed = currentLevel >= upgrade.maxLevel;
        const cost = isMaxed ? null : upgrade.getCost(currentLevel);
        const bonus = upgrade.getBonus(currentLevel);
        const nextBonus = isMaxed ? 0 : upgrade.getBonus(currentLevel + 1);
        
        const card = document.createElement("div");
        card.className = "shop-item";
        if (isMaxed) card.classList.add("maxed");
        
        card.innerHTML = `
          <div class="shop-item-name">${upgrade.name}</div>
          <div class="shop-item-desc">${upgrade.desc}</div>
          <div class="shop-item-level">Level: ${currentLevel}/${upgrade.maxLevel}</div>
          <div class="shop-item-level">Current: Level ${currentLevel}</div>
          ${!isMaxed ? `
            <div class="shop-item-level" style="color: #00ff00;">Next: Level ${currentLevel + 1}</div>
            <div class="shop-item-cost">
              ${cost.coins > 0 ? `üí∞ ${cost.coins}` : ''}
              ${cost.gems > 0 ? ` üíé ${cost.gems}` : ''}
            </div>
          ` : '<div class="shop-item-cost" style="color: #00ff00;">MAX LEVEL</div>'}
        `;
        
        if (!isMaxed) {
          card.onclick = () => purchaseUpgrade(key);
        }
        
        shopGrid.appendChild(card);
      });
    }

    function purchaseClass(className) {
      const classData = CLASSES[className];
      const cost = classData.cost;
      
      if (gameData.totalCoins >= cost.coins && gameData.totalGems >= cost.gems) {
        gameData.totalCoins -= cost.coins;
        gameData.totalGems -= cost.gems;
        gameData.purchasedClasses.push(className);
        gameData.unlockedClasses.push(className); // Also add to unlocked
        
        saveGameData();
        updateShopDisplay();
        
        alert(`‚úÖ Unlocked ${className}! You can now play as this class!`);
      } else {
        alert("‚ùå Not enough currency!");
      }
    }

    function purchaseUpgrade(upgradeKey) {
      const upgrade = SHOP_UPGRADES[upgradeKey];
      
      // Determine which upgrade category this belongs to
      const isPotionUpgrade = upgradeKey in gameData.potionUpgrades;
      const currentLevel = isPotionUpgrade ? 
        gameData.potionUpgrades[upgradeKey] : 
        gameData.permanentUpgrades[upgradeKey];
      
      if (currentLevel >= upgrade.maxLevel) return;
      
      const cost = upgrade.getCost(currentLevel);
      
      if (gameData.totalCoins >= cost.coins && gameData.totalGems >= cost.gems) {
        gameData.totalCoins -= cost.coins;
        gameData.totalGems -= cost.gems;
        
        if (isPotionUpgrade) {
          gameData.potionUpgrades[upgradeKey]++;
        } else {
          gameData.permanentUpgrades[upgradeKey]++;
        }
        
        saveGameData();
        updateShopDisplay();
        
        // Visual feedback
        const newLevel = isPotionUpgrade ? 
          gameData.potionUpgrades[upgradeKey] : 
          gameData.permanentUpgrades[upgradeKey];
        alert(`‚úÖ Upgraded ${upgrade.name} to level ${newLevel}!`);
      } else {
        alert("‚ùå Not enough currency!");
      }
    }

    // ABILITY ACTIVATION SYSTEM
    function initializeAbilities(className) {
      selectedClassName = className;
      ability1Cooldown = 0;
      ability2Cooldown = 0;
      ability1KillCounter = 0;
      ability2KillCounter = 0;
      lastStandUsed = false;
      chainReactionShots = 0;
      headhunterShots = 0;
      overwatchActive = false;
      bladeStormActive = false;
      soulHarvestActive = false;
      timeFreezeActive = false;
      hiveMindActive = false;
      upsideDownActive = false;
      vecnaKillCounter = 0;
      vecnaMonsters = [];
      vecnaMonsterKillCounter = 0;
      convertedEnemies = [];
      cupidsBowActive = false;
      cupidsBowShots = 0;
      hookShotActive = false;
      
      updateAbilityDisplay();
    }
    
    function updateAbilities(dt) {
      if (!selectedClassName) return;
      
      // Update cooldowns
      if (ability1Cooldown > 0) ability1Cooldown -= dt;
      if (ability2Cooldown > 0) ability2Cooldown -= dt;
      
      // Update special ability timers
      if (overwatchTimer > 0) {
        overwatchTimer -= dt;
        if (overwatchTimer <= 0) overwatchActive = false;
      }
      
      if (bladeStormTimer > 0) {
        bladeStormTimer -= dt;
        if (bladeStormTimer <= 0) bladeStormActive = false;
      }
      
      if (soulHarvestTimer > 0) {
        soulHarvestTimer -= dt;
        if (soulHarvestTimer <= 0) soulHarvestActive = false;
      }
      
      if (timeFreezeTimer > 0) {
        timeFreezeTimer -= dt;
        if (timeFreezeTimer <= 0) timeFreezeActive = false;
      }
      
      if (hiveMindTimer > 0) {
        hiveMindTimer -= dt;
        if (hiveMindTimer <= 0) hiveMindActive = false;
      }
      
      if (upsideDownTimer > 0) {
        upsideDownTimer -= dt;
        if (upsideDownTimer <= 0) {
          upsideDownActive = false;
          // Reset damage and remove lifesteal
          if (player.damage > player.baseDamage) {
            player.damage = player.baseDamage;
          }
        }
      }
      
      // Update Vecna monsters
      vecnaMonsters = vecnaMonsters.filter(monster => {
        if (monster.hp <= 0) return false;
        
        // Find nearest enemy
        let nearest = null;
        let minDist = Infinity;
        enemies.forEach(e => {
          const dist = Math.hypot(e.x - monster.x, e.y - monster.y);
          if (dist < minDist) {
            minDist = dist;
            nearest = e;
          }
        });
        
        if (nearest) {
          const dx = nearest.x - monster.x;
          const dy = nearest.y - monster.y;
          const dist = Math.hypot(dx, dy);
          
          if (dist > 30) {
            monster.x += (dx / dist) * 2;
            monster.y += (dy / dist) * 2;
          } else {
            // Attack
            monster.attackTimer -= dt;
            if (monster.attackTimer <= 0) {
              nearest.hp -= 10;
              if (nearest.hp <= 0) {
                onEnemyKilled(nearest);
              }
              monster.attackTimer = 1;
            }
          }
        }
        
        return true;
      });
      
      // Update converted enemies
      convertedEnemies = convertedEnemies.filter(e => {
        e.convertTimer -= dt;
        if (e.convertTimer <= 0) {
          e.isConverted = false;
          e.color = e.originalColor;
          return false;
        }
        
        // Attack other enemies
        let nearest = null;
        let minDist = Infinity;
        enemies.forEach(enemy => {
          if (enemy === e || enemy.isConverted) return;
          const dist = Math.hypot(enemy.x - e.x, enemy.y - e.y);
          if (dist < minDist) {
            minDist = dist;
            nearest = enemy;
          }
        });
        
        if (nearest && minDist < 100) {
          e.attackTimer = (e.attackTimer || 0) - dt;
          if (e.attackTimer <= 0) {
            nearest.hp -= e.damage;
            if (nearest.hp <= 0) {
              onEnemyKilled(nearest);
            }
            e.attackTimer = 1;
          }
        }
        
        return true;
      });
      
      // Blade storm damage
      if (bladeStormActive) {
        enemies.forEach(e => {
          const dist = Math.hypot(e.x - player.x, e.y - player.y);
          if (dist < 150) {
            e.hp -= 50 * dt;
            if (e.hp <= 0) {
              onEnemyKilled(e);
            }
          }
        });
      }
      
      // Check auto-activation abilities
      checkAutoAbilities();
      
      // Check for Last Stand
      if (selectedClassName === "Knight" && gameData.skillTrees.Knight?.ultimate2 && !lastStandUsed) {
        if (player.hp < player.maxHP * 0.2) {
          activateLastStand();
        }
      }
      
      // Vecna shield on kills
      if (selectedClassName === "Vecna") {
        if (vecnaKillCounter >= 10) {
          player.shield = Math.min(player.shield + 50, 200);
          vecnaKillCounter = 0;
          floatingText("üí† SHIELD +50", player.x, player.y - 30, "#00ffff", 1.5);
        }
      }
      
      updateAbilityDisplay();
    }
    
    function checkAutoAbilities() {
      if (!selectedClassName || !SKILL_TREES[selectedClassName]) return;
      
      const abilities = SKILL_TREES[selectedClassName];
      const classSkills = gameData.skillTrees[selectedClassName];
      if (!classSkills) return;
      
      // Check ability 1 (kills-based)
      if (classSkills.ultimate1 && abilities.ultimate1.activation === 'kills') {
        if (ability1KillCounter >= abilities.ultimate1.killRequirement && ability1Cooldown <= 0) {
          activateAbility(1);
        }
      }
      
      // Check ability 2 (kills-based)
      if (classSkills.ultimate2 && abilities.ultimate2.activation === 'kills') {
        if (ability2KillCounter >= abilities.ultimate2.killRequirement && ability2Cooldown <= 0) {
          activateAbility(2);
        }
      }
    }
    
    function updateAbilityDisplay() {
      if (!selectedClassName || !SKILL_TREES[selectedClassName]) {
        document.getElementById('ability1Btn').style.display = 'none';
        document.getElementById('ability2Btn').style.display = 'none';
        return;
      }
      
      const abilities = SKILL_TREES[selectedClassName];
      const classSkills = gameData.skillTrees[selectedClassName];
      
      // Ability 1
      if (classSkills?.ultimate1) {
        const btn = document.getElementById('ability1Btn');
        btn.style.display = 'block';
        document.getElementById('ability1Icon').textContent = abilities.ultimate1.icon;
        document.getElementById('ability1Name').textContent = abilities.ultimate1.name;
        document.getElementById('ability1Key').textContent = `[${abilities.ultimate1.hotkey?.toUpperCase() || 'Q'}]`;
        
        if (ability1Cooldown > 0) {
          document.getElementById('ability1CD').textContent = `${Math.ceil(ability1Cooldown)}s`;
          btn.classList.add('cooldown');
          btn.classList.remove('ready');
        } else if (abilities.ultimate1.activation === 'kills') {
          const progress = `${ability1KillCounter}/${abilities.ultimate1.killRequirement}`;
          document.getElementById('ability1CD').textContent = progress;
          if (ability1KillCounter >= abilities.ultimate1.killRequirement) {
            btn.classList.add('ready');
            btn.classList.remove('cooldown');
          } else {
            btn.classList.remove('ready', 'cooldown');
          }
        } else {
          document.getElementById('ability1CD').textContent = 'READY';
          btn.classList.add('ready');
          btn.classList.remove('cooldown');
        }
      } else {
        document.getElementById('ability1Btn').style.display = 'none';
      }
      
      // Ability 2
      if (classSkills?.ultimate2) {
        const btn = document.getElementById('ability2Btn');
        btn.style.display = 'block';
        document.getElementById('ability2Icon').textContent = abilities.ultimate2.icon;
        document.getElementById('ability2Name').textContent = abilities.ultimate2.name;
        document.getElementById('ability2Key').textContent = `[${abilities.ultimate2.hotkey?.toUpperCase() || 'E'}]`;
        
        if (ability2Cooldown > 0) {
          document.getElementById('ability2CD').textContent = `${Math.ceil(ability2Cooldown)}s`;
          btn.classList.add('cooldown');
          btn.classList.remove('ready');
        } else if (abilities.ultimate2.activation === 'kills') {
          const progress = `${ability2KillCounter}/${abilities.ultimate2.killRequirement}`;
          document.getElementById('ability2CD').textContent = progress;
          if (ability2KillCounter >= abilities.ultimate2.killRequirement) {
            btn.classList.add('ready');
            btn.classList.remove('cooldown');
          } else {
            btn.classList.remove('ready', 'cooldown');
          }
        } else {
          document.getElementById('ability2CD').textContent = 'READY';
          btn.classList.add('ready');
          btn.classList.remove('cooldown');
        }
      } else {
        document.getElementById('ability2Btn').style.display = 'none';
      }
    }
    
    function onEnemyKilled(enemy) {
      ability1KillCounter++;
      ability2KillCounter++;
      vecnaKillCounter++;
      
      // Enemy conversion chance for Vecna
      if (selectedClassName === "Vecna" && Math.random() < 0.2 && !enemy.isConverted) {
        enemy.isConverted = true;
        enemy.originalColor = enemy.color;
        enemy.color = "#9933ff";
        enemy.convertTimer = 15;
        convertedEnemies.push(enemy);
        floatingText("üëÅÔ∏è CONVERTED!", enemy.x, enemy.y, "#9933ff", 1);
      }
      
      // Vecna monster spawning (every 5 kills)
      if (selectedClassName === "Vecna") {
        vecnaMonsterKillCounter++;
        if (vecnaMonsterKillCounter >= 5 && vecnaMonsters.length < 3) {
          spawnVecnaMonster();
          vecnaMonsterKillCounter = 0;
        }
      }
    }
    
    function activateAbility1() {
      activateAbility(1);
    }
    
    function activateAbility2() {
      activateAbility(2);
    }

    // ABILITY IMPLEMENTATIONS
    function activateAbility(abilityNum) {
      if (!selectedClassName || !SKILL_TREES[selectedClassName]) return;
      
      const abilities = SKILL_TREES[selectedClassName];
      const ability = abilityNum === 1 ? abilities.ultimate1 : abilities.ultimate2;
      
      if (abilityNum === 1 && ability1Cooldown > 0) return;
      if (abilityNum === 2 && ability2Cooldown > 0) return;
      
      // Set cooldown
      if (abilityNum === 1) {
        ability1Cooldown = ability.cooldown;
        ability1KillCounter = 0;
      } else {
        ability2Cooldown = ability.cooldown;
        ability2KillCounter = 0;
      }
      
      // Execute ability based on class and ability
      const abilityName = ability.name;
      
      // Hunter abilities
      if (abilityName === "Sniper Shot") {
        activateSniperShot();
      } else if (abilityName === "Care Package") {
        activateCarePackage();
      }
      // Knight abilities
      else if (abilityName === "Shield Bash") {
        activateShieldBash();
      } else if (abilityName === "Last Stand") {
        activateLastStand();
      }
      // Assassin abilities
      else if (abilityName === "Shadow Strike") {
        activateShadowStrike();
      } else if (abilityName === "Blade Storm") {
        activateBladeStorm();
      }
      // Archer abilities (NEW Archer class)
      else if (abilityName === "Cupid's Bow") {
        activateCupidsBow();
      } else if (abilityName === "Hook Shot") {
        activateHookShot();
      }
      // Wizard abilities
      else if (abilityName === "Meteor Storm") {
        activateMeteorStorm();
      } else if (abilityName === "Time Freeze") {
        activateTimeFreeze();
      }
      // Archer abilities
      else if (abilityName === "Arrow Barrage") {
        activateArrowBarrage();
      } else if (abilityName === "Explosive Arrow") {
        activateExplosiveArrow();
      }
      // Summoner abilities
      else if (abilityName === "Army of the Dead") {
        activateArmyOfDead();
      } else if (abilityName === "Sacrifice") {
        activateSacrifice();
      }
      // Bomber abilities
      else if (abilityName === "Nuke") {
        activateNuke();
      } else if (abilityName === "Chain Reaction") {
        activateChainReaction();
      }
      // Sniper abilities
      else if (abilityName === "Headhunter") {
        activateHeadhunter();
      } else if (abilityName === "Overwatch") {
        activateOverwatch();
      }
      // Necromancer abilities
      else if (abilityName === "Plague") {
        activatePlague();
      } else if (abilityName === "Soul Harvest") {
        activateSoulHarvest();
      }
      // Vecna abilities
      else if (abilityName === "Hive Mind") {
        activateHiveMind();
      } else if (abilityName === "Vecna's Curse") {
        activateVecnasCurse();
      }
      
      updateAbilityDisplay();
    }
    
    // HUNTER ABILITIES
    function activateSniperShot() {
      screenShake = 15;
      floatingText("üéØ SNIPER SHOT!", canvas.width / 2, 100, "#00ffff", 2);
      
      // Create massive laser beam across screen
      const beam = {
        x: player.x,
        y: player.y,
        vx: 20,
        vy: 0,
        radius: 15,
        damage: 500,
        color: "#ff0000",
        pierce: true,
        life: 2,
        isSniperShot: true
      };
      projectiles.push(beam);
      
      // Add visual effect
      for (let i = 0; i < 30; i++) {
        particles.push({
          x: player.x,
          y: player.y,
          vx: Math.random() * 10 - 5,
          vy: Math.random() * 10 - 5,
          radius: Math.random() * 3 + 2,
          color: "#ff0000",
          life: 1
        });
      }
    }
    
    function activateCarePackage() {
      floatingText("üì¶ CARE PACKAGE!", player.x, player.y - 50, "#ffff00", 2);
      
      // Add potions
      potions.heal += 2;
      potions.shield += 1;
      potions.damage += 1;
      updatePotionDisplay();
      
      // Visual effect - parachute drop
      for (let i = 0; i < 20; i++) {
        particles.push({
          x: player.x,
          y: player.y - 100,
          vx: Math.random() * 4 - 2,
          vy: Math.random() * 2 + 2,
          radius: Math.random() * 4 + 2,
          color: "#00ff00",
          life: 1.5
        });
      }
      
      screenShake = 8;
    }
    
    // KNIGHT ABILITIES
    function activateShieldBash() {
      floatingText("üõ°Ô∏è SHIELD BASH!", player.x, player.y - 50, "#0088ff", 2);
      
      // Dash forward
      const dashDistance = 300;
      const dashSpeed = 15;
      let dashedDistance = 0;
      
      const dashInterval = setInterval(() => {
        if (dashedDistance >= dashDistance || !gameActive) {
          clearInterval(dashInterval);
          return;
        }
        
        player.x += dashSpeed;
        dashedDistance += dashSpeed;
        
        // Damage enemies in path
        enemies.forEach(e => {
          const dist = Math.hypot(e.x - player.x, e.y - player.y);
          if (dist < 80) {
            e.hp -= 100;
            e.stunned = true;
            e.stunnedTimer = 2;
            if (e.hp <= 0) {
              onEnemyKilled(e);
            }
          }
        });
        
        // Particles
        particles.push({
          x: player.x,
          y: player.y,
          vx: Math.random() * 4 - 2,
          vy: Math.random() * 4 - 2,
          radius: 5,
          color: "#0088ff",
          life: 0.5
        });
      }, 50);
      
      screenShake = 10;
    }
    
    function activateLastStand() {
      floatingText("‚ö° LAST STAND!", player.x, player.y - 50, "#ffff00", 2);
      player.invincible = true;
      lastStandUsed = true;
      
      setTimeout(() => {
        player.invincible = false;
      }, 5000);
      
      // Golden aura particles
      const particleInterval = setInterval(() => {
        if (!player.invincible) {
          clearInterval(particleInterval);
          return;
        }
        for (let i = 0; i < 5; i++) {
          particles.push({
            x: player.x,
            y: player.y,
            vx: Math.random() * 6 - 3,
            vy: Math.random() * 6 - 3,
            radius: 4,
            color: "#ffff00",
            life: 0.5
          });
        }
      }, 100);
      
      screenShake = 12;
    }
    
    // ARCHER ABILITIES
    function activateCupidsBow() {
      floatingText("üíò CUPID'S BOW!", player.x, player.y - 50, "#ff1493", 2);
      
      cupidsBowActive = true;
      cupidsBowShots = 5;
      
      // Pink heart particles
      for (let i = 0; i < 30; i++) {
        particles.push({
          x: player.x,
          y: player.y,
          vx: Math.random() * 8 - 4,
          vy: Math.random() * 8 - 4,
          radius: Math.random() * 4 + 2,
          color: "#ff1493",
          life: 1
        });
      }
      
      screenShake = 8;
    }
    
    function activateHookShot() {
      hookShotActive = !hookShotActive;
      
      if (hookShotActive) {
        floatingText("ü™ù HOOK SHOT ON!", player.x, player.y - 50, "#00ff00", 2);
      } else {
        floatingText("ü™ù HOOK SHOT OFF!", player.x, player.y - 50, "#ff0000", 2);
      }
      
      // Chain particles when toggling on
      if (hookShotActive) {
        for (let i = 0; i < 20; i++) {
          particles.push({
            x: player.x,
            y: player.y,
            vx: Math.random() * 6 - 3,
            vy: Math.random() * 6 - 3,
            radius: Math.random() * 3 + 1,
            color: "#888888",
            life: 0.8
          });
        }
      }
      
      screenShake = 5;
    }
    
    // ASSASSIN ABILITIES
    function activateShadowStrike() {
      if (enemies.length === 0) return;
      
      // Find random enemy
      const target = enemies[Math.floor(Math.random() * enemies.length)];
      
      floatingText("üëª SHADOW STRIKE!", player.x, player.y - 50, "#9933ff", 2);
      
      // Teleport behind enemy
      player.x = target.x - 50;
      player.y = target.y;
      
      // Deal backstab damage
      target.hp -= 300;
      if (target.hp <= 0) {
        onEnemyKilled(target);
      }
      
      // Smoke effect
      for (let i = 0; i < 40; i++) {
        particles.push({
          x: player.x,
          y: player.y,
          vx: Math.random() * 8 - 4,
          vy: Math.random() * 8 - 4,
          radius: Math.random() * 6 + 2,
          color: "#000000",
          life: 1
        });
      }
      
      screenShake = 10;
    }
    
    function activateBladeStorm() {
      floatingText("üåÄ BLADE STORM!", player.x, player.y - 50, "#9933ff", 2);
      bladeStormActive = true;
      bladeStormTimer = 5;
      screenShake = 8;
    }
    
    // WIZARD ABILITIES
    function activateMeteorStorm() {
      floatingText("‚òÑÔ∏è METEOR STORM!", canvas.width / 2, 100, "#ff8800", 2);
      
      for (let i = 0; i < 10; i++) {
        setTimeout(() => {
          const x = Math.random() * canvas.width;
          const y = 0;
          
          projectiles.push({
            x: x,
            y: y,
            vx: 0,
            vy: 8,
            radius: 20,
            damage: 150,
            color: "#ff8800",
            explosive: true,
            life: 3,
            isMeteor: true
          });
          
          screenShake = 5;
        }, i * 200);
      }
    }
    
    function activateTimeFreeze() {
      floatingText("‚ùÑÔ∏è TIME FREEZE!", canvas.width / 2, 100, "#00ffff", 2);
      timeFreezeActive = true;
      timeFreezeTimer = 5;
      
      // Freeze all enemies
      enemies.forEach(e => {
        e.frozen = true;
      });
      
      setTimeout(() => {
        enemies.forEach(e => {
          e.frozen = false;
        });
      }, 5000);
      
      screenShake = 10;
    }

    // ARCHER ABILITIES
    function activateArrowBarrage() {
      floatingText("üèπ ARROW BARRAGE!", player.x, player.y - 50, "#00ff88", 2);
      
      for (let i = 0; i < 50; i++) {
        const angle = (Math.PI * 2 / 50) * i;
        projectiles.push({
          x: player.x,
          y: player.y,
          vx: Math.cos(angle) * 10,
          vy: Math.sin(angle) * 10,
          radius: 8,
          damage: 30,
          color: "#00ff88",
          pierce: true,
          life: 2
        });
      }
      
      screenShake = 12;
    }
    
    function activateExplosiveArrow() {
      floatingText("üí• EXPLOSIVE ARROW!", player.x, player.y - 50, "#ff0000", 2);
      
      projectiles.push({
        x: player.x,
        y: player.y,
        vx: 15,
        vy: 0,
        radius: 25,
        damage: 800,
        color: "#ff4400",
        explosive: true,
        explosionRadius: 300,
        life: 3,
        isExplosiveArrow: true
      });
      
      screenShake = 15;
    }
    
    // SUMMONER ABILITIES
    function activateArmyOfDead() {
      floatingText("üíÄ ARMY OF THE DEAD!", player.x, player.y - 50, "#9933ff", 2);
      
      for (let i = 0; i < 10; i++) {
        const angle = (Math.PI * 2 / 10) * i;
        const distance = 80;
        
        minions.push({
          x: player.x + Math.cos(angle) * distance,
          y: player.y + Math.sin(angle) * distance,
          hp: 50,
          maxHP: 50,
          damage: 15,
          speed: 2,
          radius: 15,
          color: "#9933ff",
          attackTimer: 0,
          isArmy: true
        });
      }
      
      // Ground eruption effect
      for (let i = 0; i < 50; i++) {
        particles.push({
          x: player.x,
          y: player.y,
          vx: Math.random() * 12 - 6,
          vy: Math.random() * 12 - 6,
          radius: Math.random() * 5 + 2,
          color: "#9933ff",
          life: 1.5
        });
      }
      
      screenShake = 10;
    }
    
    function activateSacrifice() {
      if (minions.length === 0) {
        floatingText("‚ùå No minions to sacrifice!", player.x, player.y - 50, "#ff0000", 1.5);
        return;
      }
      
      const minionCount = minions.length;
      floatingText(`üîÆ SACRIFICE ${minionCount} MINIONS!`, player.x, player.y - 50, "#9933ff", 2);
      
      // Convert minions to shields
      player.shield += minionCount * 30;
      
      // Remove minions with soul effect
      minions.forEach(m => {
        for (let i = 0; i < 10; i++) {
          particles.push({
            x: m.x,
            y: m.y,
            vx: (player.x - m.x) / 20 + Math.random() * 2 - 1,
            vy: (player.y - m.y) / 20 + Math.random() * 2 - 1,
            radius: 4,
            color: "#9933ff",
            life: 1
          });
        }
      });
      
      minions.length = 0;
      screenShake = 8;
    }
    
    // BOMBER ABILITIES
    function activateNuke() {
      floatingText("‚ò¢Ô∏è NUCLEAR STRIKE!", canvas.width / 2, canvas.height / 2, "#ff0000", 3);
      
      // Damage all enemies
      enemies.forEach(e => {
        e.hp -= 1000;
        if (e.hp <= 0) {
          onEnemyKilled(e);
        }
      });
      
      // Massive explosion effect
      for (let i = 0; i < 100; i++) {
        particles.push({
          x: canvas.width / 2,
          y: canvas.height / 2,
          vx: Math.random() * 20 - 10,
          vy: Math.random() * 20 - 10,
          radius: Math.random() * 10 + 5,
          color: i % 2 === 0 ? "#ff8800" : "#ffff00",
          life: 2
        });
      }
      
      screenShake = 25;
    }
    
    function activateChainReaction() {
      floatingText("‚õìÔ∏è CHAIN REACTION!", player.x, player.y - 50, "#ff8800", 2);
      chainReactionShots = 10;
      screenShake = 8;
    }
    
    // SNIPER ABILITIES
    function activateHeadhunter() {
      floatingText("üíÄ HEADHUNTER MODE!", player.x, player.y - 50, "#00ffff", 2);
      headhunterShots = 5;
      screenShake = 8;
    }
    
    function activateOverwatch() {
      floatingText("üî≠ OVERWATCH ACTIVE!", player.x, player.y - 50, "#00ffff", 2);
      overwatchActive = true;
      overwatchTimer = 15;
      screenShake = 8;
    }
    
    // NECROMANCER ABILITIES
    function activatePlague() {
      floatingText("ü¶† PLAGUE UNLEASHED!", canvas.width / 2, 100, "#00ff00", 2);
      
      enemies.forEach(e => {
        if (!e.poisoned) {
          e.poisoned = true;
          e.poisonDamage = 20;
          e.poisonTimer = 10;
        }
      });
      
      // Green gas effect
      for (let i = 0; i < 80; i++) {
        particles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          vx: Math.random() * 4 - 2,
          vy: Math.random() * 4 - 2,
          radius: Math.random() * 8 + 3,
          color: "#00ff00",
          life: 3
        });
      }
      
      screenShake = 10;
    }
    
    function activateSoulHarvest() {
      floatingText("üëª SOUL HARVEST!", player.x, player.y - 50, "#9933ff", 2);
      soulHarvestActive = true;
      soulHarvestTimer = 10;
      screenShake = 8;
    }
    
    // VECNA ABILITIES
    function activateHiveMind() {
      if (enemies.length === 0) {
        floatingText("‚ùå No enemies to link!", player.x, player.y - 50, "#ff0000", 1.5);
        return;
      }
      
      floatingText("üëÅÔ∏è HIVE MIND ACTIVATED!", canvas.width / 2, 100, "#ff0000", 3);
      hiveMindActive = true;
      hiveMindTimer = 15;
      
      // Mark all enemies as linked
      enemies.forEach(e => {
        e.hiveMindLinked = true;
      });
      
      screenShake = 15;
    }
    
    function activateVecnasCurse() {
      floatingText("üåÄ ENTERING THE UPSIDE DOWN!", canvas.width / 2, canvas.height / 2, "#8B0000", 3);
      upsideDownActive = true;
      upsideDownTimer = 20;
      
      // Store base damage
      player.baseDamage = player.damage;
      
      // Apply damage boost
      player.damage = player.baseDamage * 1.5;
      
      screenShake = 20;
    }
    
    function spawnVecnaMonster() {
      vecnaMonsters.push({
        x: player.x + Math.random() * 100 - 50,
        y: player.y + Math.random() * 100 - 50,
        hp: 50,
        maxHP: 50,
        damage: 10,
        radius: 12,
        color: "#8B0000",
        attackTimer: 1
      });
      
      floatingText("üëÅÔ∏è Monster Spawned!", player.x, player.y - 50, "#8B0000", 1);
    }

    // GAME INITIALIZATION
    function startGame(className) {
      const cls = CLASSES[className];
      
      // Apply permanent upgrades
      const baseDamage = cls.stats.damage + SHOP_UPGRADES.damage.getBonus(gameData.permanentUpgrades.damage);
      const baseHP = cls.stats.maxHP + SHOP_UPGRADES.health.getBonus(gameData.permanentUpgrades.health);
      const fireRateBonus = SHOP_UPGRADES.fireRate.getBonus(gameData.permanentUpgrades.fireRate);
      const startCrit = SHOP_UPGRADES.critChance.getBonus(gameData.permanentUpgrades.critChance);
      const startLevel = 1 + SHOP_UPGRADES.startLevel.getBonus(gameData.permanentUpgrades.startLevel);
      
      player = {
        className: className,
        x: PLAYER_X,
        y: GROUND_Y - 44,
        w: 36,
        h: 44,
        maxHP: baseHP,
        hp: baseHP,
        fireRate: cls.stats.fireRate * (1 - fireRateBonus),
        damage: baseDamage,
        range: cls.stats.range,
        projectileSpeed: cls.stats.projectileSpeed,
        color: cls.color,
        accent: cls.accent,
        bulletColor: cls.bulletColor,
        glowColor: cls.glowColor,
        xp: 0,
        level: startLevel,
        xpToNext: xpForLevel(startLevel),
        alive: true,
        // Upgrades
        multiShot: 0,
        pierce: cls.stats.alwaysPierce || false, // Archer gets piercing by default
        lifesteal: 0,
        explosive: cls.stats.alwaysExplosive || false, // Bomber gets this
        critChance: cls.stats.alwaysCrit ? 0.5 : startCrit, // Sniper gets 50% base crit
        critMultiplier: 1.0,
        shield: 0,
        maxShield: 0,
        regen: 0,
        chainLightning: 0,
        aura: null,
        // Necromancer traits
        poison: cls.stats.alwaysPoison ? { damage: 5, duration: 3 } : null,
        spawnSkeletonsOnKill: cls.stats.spawnSkeletonsOnKill || false
      };

      enemies = [];
      projectiles = [];
      minions = [];
      particles = [];
      floatingTexts = [];
      currencyDrops = [];
      shootTimer = 0;
      wave = 1;
      enemiesToSpawn = calcEnemiesForWave(wave);
      spawnTimer = 0;
      combo = 0;
      comboTimer = 0;
      maxCombo = 0;
      screenShake = 0;
      gameState = "playing";
      roundBreakTimer = 0;
      sessionCoins = 0;
      sessionGems = 0;
      shufflesRemaining = 4; // Reset shuffle counter
      currentMap = 1;
      mapsCompleted = 0;
      enemiesKilled = 0; // Reset kill counter
      waveTimer = 0; // Reset wave timer
      waveTimerActive = false; // Wave timer not active yet

      if (className === "Summoner") {
        spawnMinion();
        spawnMinion();
      }
      
      // Initialize potions for first wave
      resetPotions();
      
      // Initialize abilities
      initializeAbilities(className);

      // Give up button removed - player must finish the run!
      giveUpBtn.style.display = "none";
      
      gameRunning = true;
      statusText.style.display = "none";
      lastTime = performance.now();
      requestAnimationFrame(gameLoop);
    }

    function xpForLevel(level) {
      // Much steeper XP curve - exponential growth
      // Level 1: 60 XP
      // Level 5: 670 XP
      // Level 10: 3,100 XP
      // Level 15: 8,800 XP
      // Level 20: 18,700 XP
      return Math.floor(60 * Math.pow(level, 2.1));
    }

    function calcEnemiesForWave(w) {
      if (w === 1) return 5;
      if (w === 2) return 7;
      if (w === 3) return 9;
      if (w === 4) return 11;
      if (w === 5) return 15;
      
      // After wave 5, MUCH more aggressive scaling
      // Wave 6: 20, Wave 10: 35, Wave 15: 55, Wave 20: 80
      const base = 15;
      const increment = (w - 5) * 3; // 3 enemies per wave
      const waveBonus = Math.floor(w / 5) * 5; // Bonus every 5 waves
      return base + increment + waveBonus;
    }

    function getEnemyHP(wave, isBoss = false, isMiniBoss = false) {
      // MUCH MORE AGGRESSIVE HP scaling!
      // Wave 1: 50 HP
      // Wave 5: 150 HP
      // Wave 10: 400 HP
      // Wave 20: 1,500 HP
      // Wave 30: 4,000 HP
      // Wave 50: 15,000 HP
      const baseHP = 50;
      const linearGrowth = wave * 15; // Increased from 8 to 15
      const exponentialGrowth = Math.pow(wave, 2.0) * 1.2; // Increased exponent and multiplier
      let hp = baseHP + linearGrowth + exponentialGrowth;
      
      if (isBoss) hp *= 12; // Bosses even more tanky (was 10)
      else if (isMiniBoss) hp *= 5; // Mini-bosses more tanky (was 4)
      
      return Math.floor(hp);
    }

    // SPAWNING
    function handleSpawning(dt) {
      if (enemiesToSpawn <= 0) return;
      
      spawnTimer += dt;
      
      // Spawn rate increases dramatically with waves
      // Wave 1: 2.0s, Wave 10: 1.2s, Wave 20: 0.6s, Wave 30: 0.3s
      let spawnInterval = 2.0 - (wave * 0.05);
      spawnInterval = Math.max(spawnInterval, 0.2); // Minimum 0.2s between spawns

      if (spawnTimer >= spawnInterval) {
        spawnTimer = 0;
        enemiesToSpawn--;
        spawnEnemy();
        
        // Start wave timer when last enemy spawns (30s until next wave)
        if (enemiesToSpawn === 0) {
          waveTimer = 30;
          waveTimerActive = true;
          addFloatingText(canvas.width / 2, 100, "30s until next wave!", "#ffff00");
        }
      }
    }

    function spawnEnemy(isBoss = false, isMiniBoss = false) {
      let size, hp, speed, color, glowColor, type, damage, hasShield, isRanged, pattern;

      if (isBoss) {
        // Get boss pattern based on wave
        const patternIndex = Math.floor((wave - 1) / 10) % BOSS_PATTERNS.length;
        const bossPattern = BOSS_PATTERNS[patternIndex];
        
        size = 80;
        hp = getEnemyHP(wave, true, false);
        speed = bossPattern.speed;
        color = bossPattern.color;
        glowColor = bossPattern.color;
        type = "boss";
        
        // Boss damage - first boss deals 50, scales up
        // Wave 10: 50, Wave 20: 70, Wave 30: 90, Wave 40: 110
        damage = 30 + (wave * 2);
        hasShield = bossPattern.pattern === "tank";
        isRanged = bossPattern.pattern === "ranged";
        pattern = bossPattern;
        
      } else if (isMiniBoss) {
        size = 55;
        hp = getEnemyHP(wave, false, true);
        speed = 1.2 + (wave * 0.02); // Mini-bosses get faster
        color = "#ff8800";
        glowColor = "#ff8800";
        type = "miniboss";
        
        // Mini-boss damage - more reasonable scaling
        // Wave 5: 35, Wave 10: 40, Wave 20: 50, Wave 30: 60
        damage = 30 + Math.floor(wave / 5) * 5;
        hasShield = Math.random() < 0.4; // More likely to have shields
        isRanged = Math.random() < 0.3; // More likely to be ranged
        pattern = null;
      } else {
        size = 32 + Math.random() * 16;
        hp = getEnemyHP(wave);
        
        // Speed scales with waves
        const baseSpeed = 1.2 + (wave * 0.03);
        speed = baseSpeed + Math.random() * 0.4;
        
        const rand = Math.random();
        if (rand < 0.12) {
          // TRIANGLE - Extremely fast
          color = "#ffff00";
          glowColor = "#ffaa00";
          type = "triangle";
          hasShield = false;
          isRanged = false;
          speed *= 2.5; // Extremely fast!
          hp *= 0.5; // Low HP
          size = 28;
        } else if (rand < 0.24) {
          // CIRCLE - Heals over time
          color = "#00ff88";
          glowColor = "#00ffaa";
          type = "circle";
          hasShield = false;
          isRanged = false;
          speed *= 0.6; // Slow
          hp *= 1.5; // More HP
          size = 36;
        } else if (rand < 0.36) {
          // JUMPER - Jumps ahead periodically
          color = "#ff00ff";
          glowColor = "#ff88ff";
          type = "jumper";
          hasShield = false;
          isRanged = false;
          speed *= 0.8;
          size = 32;
        } else if (rand < 0.45) {
          // KAMIKAZE - Fastest, explodes on contact
          color = "#ff8800";
          glowColor = "#ffaa00";
          type = "kamikaze";
          hasShield = false;
          isRanged = false;
          speed *= 3.0; // Fastest!
          hp *= 0.3; // Very low HP
          size = 24;
        } else if (rand < 0.60) {
          // SHIELDED - Blue with shield
          color = "#4444ff";
          glowColor = "#4444ff";
          type = "shielded";
          hasShield = true;
          isRanged = false;
          hp *= 0.8;
        } else if (rand < 0.75) {
          // SHOOTER - Ranged attacker
          color = "#ff4444";
          glowColor = "#ffaa00";
          type = "shooter";
          hasShield = false;
          isRanged = true;
          speed *= 0.7;
        } else {
          // GRUNT - Basic enemy
          color = "#ff4444";
          glowColor = "#ff0000";
          type = "grunt";
          hasShield = false;
          isRanged = false;
        }
        
        // Damage scales reasonably
        damage = 20 + Math.floor(wave / 5) * 4;
        
        // Kamikaze does massive explosion damage
        if (type === "kamikaze") {
          damage = 50 + wave * 5; // Much higher damage
        }
        
        pattern = null;
      }
      
      const enemy = {
        x: canvas.width + 30,
        y: GROUND_Y - size,
        vx: -speed,
        w: size,
        h: size,
        maxHP: hp,
        hp: hp,
        color: color,
        glowColor: glowColor,
        type: type,
        isBoss: isBoss,
        isMiniBoss: isMiniBoss,
        baseSpeed: speed,
        damage: damage,
        hasShield: hasShield,
        shieldHP: hasShield ? (isBoss ? 200 + wave * 20 : isMiniBoss ? 80 + wave * 4 : 40 + wave * 2) : 0,
        maxShieldHP: hasShield ? (isBoss ? 200 + wave * 20 : isMiniBoss ? 80 + wave * 4 : 40 + wave * 2) : 0,
        isRanged: isRanged,
        shootTimer: 0,
        shootCooldown: 2.5 + Math.random(),
        attackTimer: 0,
        attackCooldown: 1.5,
        isRetreating: false,
        retreatTimer: 0,
        pattern: pattern,
        patternTimer: 0,
        animFrame: 0,
        // Special properties for new enemy types
        healTimer: 0,
        healCooldown: 2, // Circle heals every 2 seconds
        jumpTimer: 0,
        jumpCooldown: 3 + Math.random() * 2, // Jumper jumps every 3-5 seconds
        shape: type === "triangle" ? "triangle" : type === "circle" ? "circle" : "square"
      };
      
      enemies.push(enemy);
    }

    // CURRENCY SYSTEM
    function dropCurrency(x, y, coins, gems) {
      if (coins > 0) {
        currencyDrops.push({
          x: x,
          y: y,
          type: "coin",
          amount: coins,
          vy: -3,
          life: 5
        });
      }
      if (gems > 0) {
        currencyDrops.push({
          x: x,
          y: y + 20,
          type: "gem",
          amount: gems,
          vy: -2.5,
          life: 5
        });
      }
    }

    function updateCurrencyDrops(dt) {
      for (let i = currencyDrops.length - 1; i >= 0; i--) {
        const drop = currencyDrops[i];
        
        drop.vy += 0.3; // Gravity
        drop.y += drop.vy;
        drop.x += (PLAYER_X + player.w / 2 - drop.x) * 0.05; // Move toward player
        
        drop.life -= dt;
        
        // Collect if close to player
        const dx = drop.x - (player.x + player.w / 2);
        const dy = drop.y - (player.y + player.h / 2);
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < 50) {
          if (drop.type === "coin") {
            sessionCoins += drop.amount;
            gameData.totalCoins += drop.amount;
            addFloatingText(drop.x, drop.y, `+${drop.amount} üí∞`, "#ffff00");
          } else {
            sessionGems += drop.amount;
            gameData.totalGems += drop.amount;
            addFloatingText(drop.x, drop.y, `+${drop.amount} üíé`, "#00ffff");
          }
          saveGameData();
          currencyDrops.splice(i, 1);
          continue;
        }
        
        if (drop.life <= 0 || drop.y > canvas.height) {
          currencyDrops.splice(i, 1);
        }
      }
    }

    // ENEMY UPDATES
    function updateEnemies(dt) {
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        
        // BOSS SPECIAL ABILITIES
        if (e.pattern) {
          e.patternTimer += dt;
          
          if (e.pattern.pattern === "charge" && e.patternTimer > 5) {
            // Speed burst every 5 seconds
            e.vx = -e.baseSpeed * 3;
            setTimeout(() => { e.vx = -e.baseSpeed; }, 1000);
            e.patternTimer = 0;
          } else if (e.pattern.pattern === "summon" && e.patternTimer > 6) {
            // Spawn 2 extra enemies
            for (let j = 0; j < 2; j++) {
              setTimeout(() => spawnEnemy(false, false), j * 500);
            }
            addFloatingText(canvas.width / 2, 200, "Boss summons minions!", "#ff00ff");
            e.patternTimer = 0;
          } else if (e.pattern.pattern === "tank" && e.shieldHP <= 0 && e.hp < e.maxHP * 0.5 && e.patternTimer > 8) {
            // Regenerate shield at 50% HP
            e.shieldHP = e.maxShieldHP;
            addFloatingText(e.x + e.w / 2, e.y - 30, "SHIELD REGEN!", "#00aaff");
            e.patternTimer = 0;
          } else if (e.pattern.pattern === "berserk") {
            // Speed increases as HP lowers
            const hpPercent = e.hp / e.maxHP;
            e.vx = -e.baseSpeed * (2 - hpPercent);
          } else if (e.pattern.pattern === "headthrow" && e.patternTimer > 3) {
            // Throws head as projectile every 3 seconds
            const ex = e.x + e.w / 2;
            const ey = e.y + e.h / 4; // Head position (top quarter)
            const px = player.x + player.w / 2;
            const py = player.y + player.h / 2;
            
            let dx = px - ex;
            let dy = py - ey;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            dx /= dist;
            dy /= dist;
            
            // Throw spinning head
            projectiles.push({
              x: ex, y: ey,
              vx: dx * 10, vy: dy * 10,
              radius: 20, // Large head projectile
              damage: e.damage * 1.5, // Massive damage
              color: "#8B0000",
              glowColor: "#ff0000",
              life: 5,
              trail: [],
              isEnemyProjectile: true,
              isHeadProjectile: true, // Special flag for visual
              rotation: 0
            });
            
            addFloatingText(e.x + e.w / 2, e.y - 40, "üíÄ HEAD THROW!", "#ff0000");
            spawnExplosion(ex, ey, "#8B0000", 12);
            screenShake += 10;
            e.patternTimer = 0;
          }
        }
        
        // SPECIAL ENEMY TYPE BEHAVIORS
        if (e.type === "circle") {
          // Circle heals over time
          e.healTimer += dt;
          if (e.healTimer >= e.healCooldown) {
            e.hp = Math.min(e.hp + e.maxHP * 0.05, e.maxHP); // Heal 5% max HP
            addFloatingText(e.x + e.w / 2, e.y - 20, "+HP", "#00ff00", 0.5);
            e.healTimer = 0;
          }
        } else if (e.type === "jumper") {
          // Jumper teleports forward periodically
          e.jumpTimer += dt;
          if (e.jumpTimer >= e.jumpCooldown) {
            e.x -= 200; // Jump forward 200 pixels
            addFloatingText(e.x + e.w / 2, e.y - 20, "JUMP!", "#ff00ff", 0.5);
            // Visual effect
            spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, "#ff00ff", 8);
            e.jumpTimer = 0;
          }
        } else if (e.type === "kamikaze" && e.x + e.w < player.x + player.w) {
          // Kamikaze explodes when it reaches player
          screenShake += 15;
          spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, "#ff8800", 20);
          addFloatingText(e.x + e.w / 2, e.y - 30, "üí• BOOM! üí•", "#ff8800");
          
          // Damage player
          const damageDealt = damagePlayer(e.damage);
          if (damageDealt > 0) {
            addFloatingText(player.x + player.w / 2, player.y - 30, `-${damageDealt} HP`, "#ff0000");
          }
          
          // Remove kamikaze (it died)
          enemies.splice(i, 1);
          continue;
        }
        
        // Ranged enemies shoot
        if (e.isRanged && player.alive) {
          e.shootTimer += dt;
          const distToPlayer = Math.abs(e.x - player.x);
          
          // Shooters need to get within 300 pixels to shoot
          if (distToPlayer <= 300) {
            // In range - stop and shoot
            e.vx = 0;
            
            if (e.shootTimer >= e.shootCooldown) {
              e.shootTimer = 0;
              e.shootCooldown = 2 + Math.random() * 1.5;
              
              // Boss triple shot
              const shots = (e.pattern && e.pattern.pattern === "ranged") ? 3 : 1;
              
              for (let s = 0; s < shots; s++) {
                setTimeout(() => {
                  const ex = e.x + e.w / 2;
                  const ey = e.y + e.h / 2;
                  const px = player.x + player.w / 2;
                  const py = player.y + player.h / 2;
                  
                  let dx = px - ex;
                  let dy = py - ey;
                  const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                  dx /= dist;
                  dy /= dist;
                  
                  // Add spread for triple shot
                  if (shots > 1) {
                    const angle = Math.atan2(dy, dx) + (s - 1) * 0.3;
                    dx = Math.cos(angle);
                    dy = Math.sin(angle);
                  }
                  
                  projectiles.push({
                    x: ex, y: ey,
                    vx: dx * 7, vy: dy * 7, // Faster projectiles
                    radius: 8,
                    damage: e.damage * 0.6,
                    color: "#ff4444",
                    glowColor: "#ff0000",
                    life: 3,
                    trail: [],
                    isEnemyProjectile: true
                  });
                }, s * 200);
              }
              
              spawnHitParticles(e.x + e.w / 2, e.y + e.h / 2, "#ff8800", 6);
            }
          } else {
            // Not in range - move closer actively
            e.vx = -e.baseSpeed * 0.9; // Move toward player at 90% speed
          }
        }
        
        // Retreat after attacking
        if (e.isRetreating) {
          e.retreatTimer += dt;
          e.vx = e.baseSpeed * 1.5;
          
          if (e.retreatTimer >= 0.8) {
            e.isRetreating = false;
            e.retreatTimer = 0;
          }
        }
        
        if (e.attackTimer > 0) {
          e.attackTimer -= dt;
        }
        
        // Frozen enemies don't move
        if (!e.frozen) {
          e.x += e.vx;
        }
        e.animFrame = ((e.animFrame || 0) + dt * 10) % 1;

        // Collision with player
        if (
          player.alive &&
          e.x < player.x + player.w &&
          e.x + e.w > player.x &&
          e.y < player.y + player.h &&
          e.y + e.h > player.y &&
          !e.isRetreating &&
          e.attackTimer <= 0
        ) {
          let damage = e.damage || 20;
          
          if (player.shield > 0) {
            if (player.shield >= damage) {
              player.shield -= damage;
              damage = 0;
            } else {
              damage -= player.shield;
              player.shield = 0;
            }
          }
          
          player.hp -= damage;
          screenShake += 2;
          
          addFloatingText(player.x + player.w / 2, player.y - 10, "-" + Math.floor(damage), "#ff0000");
          spawnHitParticles(player.x + player.w / 2, player.y + player.h / 2, "#ff0000", 8);
          
          e.isRetreating = true;
          e.retreatTimer = 0;
          e.attackTimer = e.attackCooldown;
          
          if (player.hp <= 0) {
            player.hp = 0;
            player.alive = false;
            endGame();
          }
        }
        
        // Aura damage
        if (player.aura && player.alive) {
          const dx = (e.x + e.w / 2) - (player.x + player.w / 2);
          const dy = (e.y + e.h / 2) - (player.y + player.h / 2);
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < player.aura.radius) {
            if (e.hasShield && e.shieldHP > 0) {
              e.shieldHP -= player.aura.damage * dt;
            } else {
              e.hp -= player.aura.damage * dt;
            }
          }
        }

        // Check death
        if (e.hp <= 0) {
          // Hive Mind: Kill all linked enemies
          if (hiveMindActive && e.hiveMindLinked) {
            enemies.forEach(enemy => {
              if (enemy.hiveMindLinked && enemy !== e) {
                enemy.hp = 0;
              }
            });
            floatingText("üëÅÔ∏è HIVE MIND TRIGGERED!", canvas.width / 2, 150, "#ff0000", 2);
            screenShake += 15;
          }
          
          // Track kill for abilities
          onEnemyKilled(e);
          
          let xpGain = 18 + 7 * wave;
          let coinDrop;
          let gemDrop = 0;
          
          // Regular enemies: coin drops based on size
          if (!e.isMiniBoss && !e.isBoss) {
            if (e.w < 40) {
              // Small enemies
              coinDrop = 4;
            } else if (e.w < 50) {
              // Medium enemies
              coinDrop = 11;
            } else {
              // Large enemies
              coinDrop = 15;
            }
          }
          
          if (e.isMiniBoss) {
            xpGain *= 3;
            coinDrop = 20 + wave * 5;
            gemDrop = 1 + Math.floor(wave / 10);
          }
          if (e.isBoss) {
            xpGain *= 8;
            coinDrop = 50 + wave * 10;
            gemDrop = 3 + Math.floor(wave / 5);
          }
          
          // DROP CURRENCY FIRST (before clearing enemies!)
          giveXP(xpGain);
          dropCurrency(e.x + e.w / 2, e.y + e.h / 2, coinDrop, gemDrop);
          spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, e.color, 15);
          
          // Show drops as floating text
          if (coinDrop > 0) {
            addFloatingText(e.x + e.w / 2, e.y - 20, `+${coinDrop} üí∞`, "#ffff00");
          }
          if (gemDrop > 0) {
            addFloatingText(e.x + e.w / 2, e.y - 40, `+${gemDrop} üíé`, "#00ffff");
          }
          
          // THEN handle boss wave completion
          if (e.isBoss) {
            // BOSS DEATH = START WAVE TIMER!
            enemiesToSpawn = 0;
            // Clear all remaining enemies
            for (let j = enemies.length - 1; j >= 0; j--) {
              if (enemies[j] !== e) {
                spawnExplosion(enemies[j].x + enemies[j].w / 2, enemies[j].y + enemies[j].h / 2, enemies[j].color, 10);
              }
            }
            enemies.length = 0; // Clear all
            
            addFloatingText(canvas.width / 2, 250, "üéâ BOSS DEFEATED! üéâ", "#ff00ff");
            addFloatingText(canvas.width / 2, 280, "Next wave in 30s!", "#ffff00");
            screenShake += 25;
            
            // Start 30-second timer for next wave
            waveTimer = 30;
            waveTimerActive = true;
          }
          
          // Necromancer: Spawn skeleton minion
          if (player.spawnSkeletonsOnKill && Math.random() < 0.3) {
            spawnMinion();
            addFloatingText(player.x + player.w / 2, player.y - 40, "Skeleton Raised!", "#9933ff");
          }
          
          combo++;
          comboTimer = 2.0;
          if (combo > maxCombo) maxCombo = combo;
          
          enemiesKilled++; // Track kills for stats
          
          if (!e.isBoss) { // Boss already cleared enemies array above
            enemies.splice(i, 1);
          }
          continue;
        }

        if (e.x + e.w < -50) {
          enemies.splice(i, 1);
        }
      }
    }

    // SHOOTING
    function handleShooting(dt) {
      shootTimer += dt;
      const target = getTargetEnemy();
      
      if (!autoShoot || !target) return;

      if (shootTimer >= player.fireRate) {
        shootTimer = 0;
        shootProjectile(target);
        
        // Multishot: Fire additional shots at the same target in rapid succession
        if (player.multiShot > 0) {
          for (let i = 0; i < player.multiShot; i++) {
            setTimeout(() => {
              const currentTarget = getTargetEnemy();
              if (currentTarget) {
                // Fire at same spot, no angle offset
                shootProjectile(currentTarget, 0);
              }
            }, (i + 1) * 50); // 50ms delay between each shot for rapid fire effect
          }
        }
      }
    }

    function getTargetEnemy() {
      if (enemies.length === 0) return null;
      
      // Overwatch: Target highest HP enemy
      if (overwatchActive) {
        let highestHP = null;
        let maxHP = 0;
        
        for (const e of enemies) {
          const dx = (e.x + e.w / 2) - (player.x + player.w / 2);
          const dy = (e.y + e.h / 2) - (player.y + player.h / 2);
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < player.range && e.hp > maxHP) {
            maxHP = e.hp;
            highestHP = e;
          }
        }
        
        return highestHP;
      }
      
      if (!autoAim) {
        return enemies.find(e => 
          Math.abs((e.x + e.w / 2) - (player.x + player.w / 2)) < player.range
        ) || null;
      }
      
      let closestInRange = null;
      let closestDist = player.range;
      
      for (const e of enemies) {
        const dx = (e.x + e.w / 2) - (player.x + player.w / 2);
        const dy = (e.y + e.h / 2) - (player.y + player.h / 2);
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < closestDist) {
          closestDist = dist;
          closestInRange = e;
        }
      }
      
      return closestInRange;
    }

    function shootProjectile(target, angleOffset = 0) {
      const px = player.x + player.w / 2;
      const py = player.y + player.h / 2;
      const tx = target.x + target.w / 2;
      const ty = target.y + target.h / 2;

      let dx = tx - px;
      let dy = ty - py;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      dx /= dist;
      dy /= dist;

      if (angleOffset !== 0) {
        const angle = Math.atan2(dy, dx) + (angleOffset * Math.PI / 180);
        dx = Math.cos(angle);
        dy = Math.sin(angle);
      }

      let isCrit = false;
      if (player.critChance && Math.random() < player.critChance) {
        isCrit = true;
      }
      
      // Headhunter: Guaranteed 5x crits
      if (headhunterShots > 0) {
        isCrit = true;
        headhunterShots--;
      }
      
      // Chain Reaction: Double explosion radius
      let explosiveRadius = player.explosive ? 60 : 0;
      if (chainReactionShots > 0) {
        explosiveRadius = 120;
        chainReactionShots--;
      }
      
      // Calculate potion damage bonus
      const totalPotions = potions.heal + potions.shield + potions.crit + potions.damage + potions.speed + potions.dragon;
      const potionDamageBonus = totalPotions * gameData.potionUpgrades.potionDamage * 2;
      const finalDamage = player.damage + potionDamageBonus;
      
      let critMultiplier = player.critMultiplier || 1.0;
      if (headhunterShots >= 0 && isCrit) {
        critMultiplier = 5.0; // Headhunter 5x crits
      }

      projectiles.push({
        x: px, y: py,
        vx: dx * player.projectileSpeed,
        vy: dy * player.projectileSpeed,
        radius: 5,
        damage: finalDamage,
        color: isCrit ? "#ff0000" : player.bulletColor,
        glowColor: isCrit ? "#ff0000" : player.glowColor,
        life: 3.5,
        trail: [],
        pierce: player.pierce,
        pierceCount: 0,
        explosive: player.explosive || explosiveRadius > 0,
        explosionRadius: explosiveRadius,
        isCrit: isCrit,
        critMultiplier: critMultiplier,
        chainLightning: player.chainLightning || 0,
        poison: player.poison, // Necromancer poison
        isEnemyProjectile: false
      });
    }

    // PROJECTILE UPDATES
    function updateProjectiles(dt) {
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        
        if (p.trail.length > 8) p.trail.shift();
        p.trail.push({ x: p.x, y: p.y });
        
        p.x += p.vx;
        p.y += p.vy;
        p.life -= dt;

        if (p.life <= 0 || p.x < -50 || p.x > canvas.width + 50 || p.y < -50 || p.y > canvas.height + 50) {
          projectiles.splice(i, 1);
          continue;
        }

        // Enemy projectile hitting player
        if (p.isEnemyProjectile && player.alive) {
          if (p.x > player.x && p.x < player.x + player.w && p.y > player.y && p.y < player.y + player.h) {
            let damage = p.damage;
            
            if (player.shield > 0) {
              if (player.shield >= damage) {
                player.shield -= damage;
                damage = 0;
              } else {
                damage -= player.shield;
                player.shield = 0;
              }
            }
            
            player.hp -= damage;
            addFloatingText(p.x, p.y - 20, "-" + Math.floor(damage), "#ff0000"); // Show damage taken!
            spawnHitParticles(p.x, p.y, "#ff0000", 8);
            screenShake += 2;
            projectiles.splice(i, 1);
            
            if (player.hp <= 0) {
              player.hp = 0;
              player.alive = false;
              endGame();
            }
            continue;
          }
        }

        // Player projectile hitting enemies
        if (!p.isEnemyProjectile) {
          for (let j = enemies.length - 1; j >= 0; j--) {
            const e = enemies[j];
            if (p.x > e.x && p.x < e.x + e.w && p.y > e.y && p.y < e.y + e.h) {
              let actualDamage = p.damage;
              if (p.isCrit) {
                actualDamage *= p.critMultiplier;
                addFloatingText(e.x + e.w / 2, e.y - 30, "CRIT!", "#ff0000");
              }
              
              // Damage shield first
              if (e.hasShield && e.shieldHP > 0) {
                if (e.shieldHP >= actualDamage) {
                  e.shieldHP -= actualDamage;
                  actualDamage = 0;
                  addFloatingText(e.x + e.w / 2, e.y - 10, "SHIELD", "#00aaff");
                } else {
                  actualDamage -= e.shieldHP;
                  e.shieldHP = 0;
                  addFloatingText(e.x + e.w / 2, e.y - 10, "SHIELD BROKEN!", "#ffaa00");
                }
              }
              
              e.hp -= actualDamage;
              spawnHitParticles(p.x, p.y, p.color, p.isCrit ? 12 : 6);
              screenShake += p.isCrit ? 4 : 2;
              
              // Lifesteal
              if (player.lifesteal > 0) {
                const heal = actualDamage * player.lifesteal;
                if (player.shield < player.maxShield) {
                  player.shield = Math.min(player.shield + heal, player.maxShield);
                } else {
                  player.hp = Math.min(player.hp + heal, player.maxHP);
                }
              }
              
              // Upside Down lifesteal (50%)
              if (upsideDownActive) {
                const heal = actualDamage * 0.5;
                player.hp = Math.min(player.hp + heal, player.maxHP);
              }
              
              // Soul Harvest healing from poison
              if (soulHarvestActive && e.poisoned) {
                const heal = (e.poisonDamage || 5) * dt * 10;
                player.hp = Math.min(player.hp + heal, player.maxHP);
              }
              
              // Explosion
              if (p.explosive) {
                const explosionRadius = p.explosionRadius || 60;
                for (const otherEnemy of enemies) {
                  if (otherEnemy === e) continue;
                  const dx = (otherEnemy.x + otherEnemy.w / 2) - p.x;
                  const dy = (otherEnemy.y + otherEnemy.h / 2) - p.y;
                  const dist = Math.sqrt(dx * dx + dy * dy);
                  if (dist < explosionRadius) {
                    otherEnemy.hp -= actualDamage * 0.5;
                  }
                }
                spawnExplosion(p.x, p.y, "#ff8800", Math.min(15 + explosionRadius / 10, 30));
                screenShake += 6;
              }
              
              // Apply poison (Necromancer)
              if (p.poison && !e.poisonStacks) {
                e.poisonStacks = [];
              }
              if (p.poison) {
                e.poisonStacks.push({
                  damage: p.poison.damage,
                  duration: p.poison.duration
                });
              }
              
              // Chain lightning
              if (p.chainLightning > 0 && !p.hasChained) {
                p.hasChained = true;
                let chainsLeft = p.chainLightning;
                let lastTarget = e;
                
                while (chainsLeft > 0) {
                  let nearestDist = 150;
                  let nearestEnemy = null;
                  
                  for (const otherEnemy of enemies) {
                    if (otherEnemy === lastTarget) continue;
                    const dx = (otherEnemy.x + otherEnemy.w / 2) - (lastTarget.x + lastTarget.w / 2);
                    const dy = (otherEnemy.y + otherEnemy.h / 2) - (lastTarget.y + lastTarget.h / 2);
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < nearestDist) {
                      nearestDist = dist;
                      nearestEnemy = otherEnemy;
                    }
                  }
                  
                  if (nearestEnemy) {
                    nearestEnemy.hp -= actualDamage * 0.6;
                    spawnHitParticles(nearestEnemy.x + nearestEnemy.w / 2, nearestEnemy.y + nearestEnemy.h / 2, "#00ffff", 6);
                    lastTarget = nearestEnemy;
                    chainsLeft--;
                  } else {
                    break;
                  }
                }
              }
              
              if (p.pierce && p.pierceCount < 3) {
                p.pierceCount++;
              } else {
                projectiles.splice(i, 1);
              }
              
              if (!p.pierce) break;
            }
          }
        }
      }
    }

    // MINIONS (Summoner class)
    function spawnMinion() {
      minions.push({
        angle: Math.random() * Math.PI * 2,
        distance: 50 + Math.random() * 20,
        spinSpeed: 2 + Math.random(),
        tickTimer: 0
      });
    }

    function updateMinions(dt) {
      if (!player || player.className !== "Summoner") return;

      const px = player.x + player.w / 2;
      const py = player.y + player.h / 2 - 15;

      for (const m of minions) {
        m.angle += dt * m.spinSpeed;
        m.tickTimer += dt;

        if (m.tickTimer >= 0.3) {
          m.tickTimer = 0;
          const target = getTargetEnemy();
          if (target) {
            const mx = px + Math.cos(m.angle) * m.distance;
            const my = py + Math.sin(m.angle) * m.distance;

            let dx = target.x + target.w / 2 - mx;
            let dy = target.y + target.h / 2 - my;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            dx /= dist;
            dy /= dist;

            projectiles.push({
              x: mx, y: my,
              vx: dx * 6, vy: dy * 6,
              radius: 4,
              damage: player.damage * 0.5,
              color: "#88ff88",
              glowColor: "#88ff88",
              life: 2.5,
              trail: []
            });
          }
        }

        m.drawX = px + Math.cos(m.angle) * m.distance;
        m.drawY = py + Math.sin(m.angle) * m.distance;
      }
    }

    // XP & LEVELING
    function giveXP(amount) {
      player.xp += amount;
      if (player.xp >= player.xpToNext) {
        player.level++;
        player.xp -= player.xpToNext;
        player.xpToNext = xpForLevel(player.level);
        showUpgradeScreen();
      }
    }

    let currentUpgradeOptions = []; // Store current options for shuffling

    function showUpgradeScreen() {
      gameState = "upgrading";
      upgradeScreen.classList.add("active");
      upgradeSubtitle.textContent = `Level ${player.level} - Choose Your Power-Up`;
      
      generateUpgradeOptions();
      
      // Update shuffle button
      shuffleCount.textContent = shufflesRemaining;
      if (shufflesRemaining > 0) {
        shuffleBtn.style.opacity = "1";
        shuffleBtn.style.cursor = "pointer";
        shuffleBtn.disabled = false;
      } else {
        shuffleBtn.style.opacity = "0.5";
        shuffleBtn.style.cursor = "not-allowed";
        shuffleBtn.disabled = true;
      }
    }

    function generateUpgradeOptions() {
      const availableUpgrades = Object.keys(UPGRADE_TYPES);
      const shuffled = availableUpgrades.sort(() => Math.random() - 0.5);
      currentUpgradeOptions = shuffled.slice(0, 3);
      
      upgradeOptions.innerHTML = "";
      currentUpgradeOptions.forEach(key => {
        const upgrade = UPGRADE_TYPES[key];
        const card = document.createElement("div");
        card.className = "upgrade-card";
        card.innerHTML = `
          <div class="upgrade-card-icon">${upgrade.icon}</div>
          <div class="upgrade-card-title">${upgrade.name}</div>
          <div class="upgrade-card-desc">${upgrade.desc}</div>
        `;
        card.onclick = () => selectUpgrade(key);
        upgradeOptions.appendChild(card);
      });
    }

    function selectUpgrade(upgradeKey) {
      const upgrade = UPGRADE_TYPES[upgradeKey];
      upgrade.apply(player);
      
      upgradeScreen.classList.remove("active");
      gameState = "playing";
      
      addFloatingText(player.x + player.w / 2, player.y - 30, upgrade.name + "!", "#ffff00");
      spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, player.glowColor, 20);
    }

    // Shuffle button listener
    shuffleBtn.addEventListener("click", () => {
      if (shufflesRemaining > 0) {
        shufflesRemaining--;
        generateUpgradeOptions();
        shuffleCount.textContent = shufflesRemaining;
        
        if (shufflesRemaining === 0) {
          shuffleBtn.style.opacity = "0.5";
          shuffleBtn.style.cursor = "not-allowed";
          shuffleBtn.disabled = true;
        }
      }
    });

    // COMBO SYSTEM
    function updateCombo(dt) {
      if (combo > 0) {
        comboTimer -= dt;
        if (comboTimer <= 0) {
          combo = 0;
        }
      }
    }

    // PARTICLES & EFFECTS
    function spawnHitParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 4,
          vy: (Math.random() - 0.5) * 4,
          life: 0.5,
          color
        });
      }
    }

    function spawnExplosion(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 8,
          vy: (Math.random() - 0.5) * 8,
          life: 0.8,
          color
        });
      }
    }

    function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= dt;
        if (p.life <= 0) {
          particles.splice(i, 1);
        }
      }
    }

    function addFloatingText(x, y, text, color) {
      floatingTexts.push({ x, y, text, color, life: 1.5, vy: -1.5 });
    }
    
    function floatingText(text, x, y, color, life = 1.5) {
      floatingTexts.push({ x, y, text, color, life, vy: -1.5 });
    }

    function updateFloatingTexts(dt) {
      for (let i = floatingTexts.length - 1; i >= 0; i--) {
        const t = floatingTexts[i];
        t.y += t.vy;
        t.life -= dt;
        if (t.life <= 0) {
          floatingTexts.splice(i, 1);
        }
      }
    }

    // ROUND BREAKS
    function startRoundBreak() {
      gameState = "roundBreak";
      roundBreakTimer = ROUND_BREAK_TIME;
      roundBreakScreen.classList.add("active");
      
      if (wave % 10 === 0) {
        breakTitle.textContent = "üî• BOSS WAVE INCOMING! üî•";
        breakInfo.innerHTML = `
          Prepare yourself!<br>
          A mighty boss approaches...<br>
          <br>Press SPACE to start immediately
        `;
      } else if (wave % 5 === 0) {
        breakTitle.textContent = "‚ö° MINI-BOSS WAVE! ‚ö°";
        breakInfo.innerHTML = `
          Get ready!<br>
          A powerful enemy is coming...<br>
          <br>Press SPACE to start immediately
        `;
      } else {
        breakTitle.textContent = `üéØ WAVE ${wave} COMPLETE! üéØ`;
        breakInfo.innerHTML = `
          Prepare for the next wave!<br>
          <br>Press SPACE to start immediately
        `;
      }
    }

    function endRoundBreak() {
      gameState = "playing";
      roundBreakScreen.classList.remove("active");
      enemiesToSpawn = calcEnemiesForWave(wave);
      spawnTimer = 0;
      
      if (wave % 10 === 0) {
        spawnEnemy(true, false);
      } else if (wave % 5 === 0) {
        spawnEnemy(false, true);
      }
    }

    // GAME END
    function endGame() {
      gameRunning = false; // Stop game loop
      spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, player.color, 30);
      
      // Update highest wave
      let newClassUnlocked = false;
      if (wave > gameData.highestWave) {
        gameData.highestWave = wave;
        
        // Unlock classes
        Object.entries(CLASSES).forEach(([name, data]) => {
          if (!data.purchasable && wave >= data.unlockWave && !gameData.unlockedClasses.includes(name)) {
            gameData.unlockedClasses.push(name);
            newClassUnlocked = true;
          }
        });
      }
      
      saveGameData();
      
      // Hide give up button
      giveUpBtn.style.display = "none";
      
      // Show game over screen with stats
      finalWave.textContent = wave;
      finalLevel.textContent = player.level;
      finalKills.textContent = enemiesKilled;
      finalCombo.textContent = maxCombo + "x";
      earnedCoins.textContent = sessionCoins;
      earnedGems.textContent = sessionGems;
      totalCoinsNow.textContent = gameData.totalCoins;
      totalGemsNow.textContent = gameData.totalGems;
      
      gameOverScreen.classList.add("active");
      
      // Show class unlock notification if any
      if (newClassUnlocked) {
        setTimeout(() => {
          alert("üîì NEW CLASS UNLOCKED! Check the class selection!");
        }, 500);
      }
    }
    
    // Continue button handler
    continueBtn.addEventListener("click", () => {
      // Hide all screens
      gameOverScreen.classList.remove("active");
      classSelection.classList.remove("active");
      shopScreen.classList.remove("active");
      upgradeScreen.classList.remove("active");
      roundBreakScreen.classList.remove("active");
      
      // Show title screen with updated stats
      titleScreen.classList.remove("hidden");
      updateTitleScreen();
    });
    
    // Give up button handler
    giveUpBtn.addEventListener("click", function(e) {
      e.preventDefault();
      e.stopPropagation();
      
      if (confirm("Are you sure you want to give up? You'll keep all coins/gems earned so far.")) {
        // Stop game immediately
        gameRunning = false;
        player.alive = false;
        player.hp = 0;
        
        // Clear all timers and intervals
        waveTimerActive = false;
        waveTimer = 0;
        
        // End the game
        endGame();
      }
    });

    // MAIN UPDATE LOOP
    function update(dt) {
      if (!player || !player.alive) return;

      if (gameState === "roundBreak") {
        roundBreakTimer -= dt;
        breakTimer.textContent = Math.ceil(roundBreakTimer);
        
        if (roundBreakTimer <= 0) {
          endRoundBreak();
        }
        
        updateParticles(dt);
        updateFloatingTexts(dt);
        updateCurrencyDrops(dt);
        screenShake *= 0.9;
        return;
      }

      if (gameState === "upgrading") {
        updateParticles(dt);
        updateFloatingTexts(dt);
        updateCurrencyDrops(dt);
        return;
      }

      handleShooting(dt);
      handleSpawning(dt);
      updateProjectiles(dt);
      updateEnemies(dt);
      updateMinions(dt);
      updateParticles(dt);
      updateFloatingTexts(dt);
      updateCombo(dt);
      updateCurrencyDrops(dt);
      updatePotionEffects(dt);
      updatePotionCooldownDisplay();
      updateAbilities(dt);
      updateFireZones(dt);
      
      // Regeneration
      if (player.regen > 0) {
        player.hp = Math.min(player.hp + player.regen * dt, player.maxHP);
      }
      
      screenShake *= 0.9;
      if (screenShake < 0.1) screenShake = 0;

      // Check if wave is complete (all enemies spawned AND all enemies killed)
      // Start next wave IMMEDIATELY regardless of timer
      if (enemiesToSpawn === 0 && enemies.length === 0) {
        // Cancel wave timer if active
        if (waveTimerActive) {
          waveTimerActive = false;
          waveTimer = 0;
        }
        
        // Check if node is complete (wave 20)
        if (wave === 20) {
          // NODE COMPLETED!
          gameRunning = false;
          
          // Complete the current node
          if (OVERWORLD_MAP.currentNode) {
            completeNode(OVERWORLD_MAP.currentNode);
          }
          
          // Show victory message
          addFloatingText(canvas.width / 2, 200, "üéâ NODE COMPLETE! üéâ", "#ffff00", 2.5);
          addFloatingText(canvas.width / 2, 240, "Returning to Overworld...", "#00ffff", 1.5);
          
          // Hide game UI, return to overworld after delay
          setTimeout(() => {
            giveUpBtn.style.display = "none";
            document.getElementById('overworldScreen').classList.add('active');
            document.getElementById('nodeInfoPanel').classList.remove('active');
          }, 3000);
          
          return; // Don't start next wave
        }
        
        // Wave complete! Start next wave immediately
        wave++;
        
        // Check for map progression (every 20 waves)
        if (wave % 20 === 1 && wave > 1) {
          currentMap++;
          mapsCompleted++;
          shufflesRemaining = 4;
          addFloatingText(canvas.width / 2, 200, `üó∫Ô∏è MAP ${currentMap} üó∫Ô∏è`, "#ff00ff");
          addFloatingText(canvas.width / 2, 230, "SHUFFLES RESET!", "#00ffff");
          screenShake += 15;
        }
        
        // Give wave bonus XP
        const waveBonus = 50 + wave * 10;
        giveXP(waveBonus);
        addFloatingText(canvas.width / 2, 150, "WAVE " + wave + " COMPLETE!", "#00ff00");
        addFloatingText(canvas.width / 2, 180, "Starting Wave " + wave, "#00ffff");
        
        // Potions DO NOT reset - Summoner ability only!
        
        // Reset Last Stand for new wave
        lastStandUsed = false;
        
        // Start next wave immediately
        enemiesToSpawn = calcEnemiesForWave(wave);
        spawnTimer = 0;
        
        // Spawn boss/mini-boss immediately if applicable
        // Mini-boss every 5 waves
        if (wave % 5 === 0 && wave % 10 !== 0) {
          spawnEnemy(false, true);
          enemiesToSpawn--;
        }
        // Boss every 10 waves
        if (wave % 10 === 0) {
          spawnEnemy(true, false);
          enemiesToSpawn--;
        }
      }

      // Wave timer system (30s after last enemy spawns)
      if (waveTimerActive) {
        waveTimer -= dt;
        
        // Check if wave timer expired
        if (waveTimer <= 0) {
          // Auto-start if enabled, otherwise wait for player to press Space
          if (!autoStartWave) {
            // Show message and wait - but don't return, let game continue
            // Player can press Space to start manually
          } else {
            // Auto-start enabled, start wave automatically
            wave++;
            waveTimerActive = false;
            
            // Check for map progression (every 20 waves)
            if (wave % 20 === 1 && wave > 1) {
              currentMap++;
              mapsCompleted++;
              shufflesRemaining = 4; // Reset shuffles on new map!
              
              addFloatingText(canvas.width / 2, 200, `üó∫Ô∏è MAP ${currentMap} üó∫Ô∏è`, "#ff00ff");
              addFloatingText(canvas.width / 2, 230, "SHUFFLES RESET!", "#00ffff");
              screenShake += 15;
            }
            
            // Give wave bonus XP
            const waveBonus = 50 + wave * 10;
            giveXP(waveBonus);
            addFloatingText(canvas.width / 2, 150, "WAVE " + wave + " START!", "#00ffff");
            
            // Potions DO NOT reset - Summoner ability only!
            
            // Reset Last Stand for new wave
            lastStandUsed = false;
            
            // Start next wave
            enemiesToSpawn = calcEnemiesForWave(wave);
            spawnTimer = 0;
            
            // Spawn boss/mini-boss immediately if applicable
            if (wave % 10 === 0) {
              spawnEnemy(true, false);
              enemiesToSpawn--; // Boss counts as one of the enemies
            } else if (wave % 5 === 0) {
              spawnEnemy(false, true);
              enemiesToSpawn--; // Mini-boss counts as one
            }
          }
        }
      }
    }

    // DRAWING
    function drawBackground() {
      ctx.fillStyle = "#0a0015";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Stars
      const time = Date.now() * 0.0001;
      for (let i = 0; i < 50; i++) {
        const x = (i * 123.456 % canvas.width);
        const y = ((i * 78.9 + time * 20) % canvas.height);
        const brightness = (Math.sin(i + time * 3) + 1) * 0.5;
        ctx.fillStyle = `rgba(255, 255, 255, ${brightness * 0.5})`;
        ctx.fillRect(x, y, 2, 2);
      }
    }

    function drawGround() {
      ctx.fillStyle = "#2a1a3a";
      ctx.fillRect(0, GROUND_Y, canvas.width, canvas.height - GROUND_Y);
      ctx.strokeStyle = "#00ffff";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, GROUND_Y);
      ctx.lineTo(canvas.width, GROUND_Y);
      ctx.stroke();
    }

    function drawPlayer() {
      if (!player) return;
      
      const x = player.x;
      const y = player.y;
      const w = player.w;
      const h = player.h;

      ctx.shadowColor = player.glowColor;
      ctx.shadowBlur = 15;
      ctx.fillStyle = player.color;
      ctx.fillRect(x, y, w, h);

      ctx.shadowBlur = 0;
      ctx.fillStyle = player.accent;
      ctx.fillRect(x + 4, y + 4, w - 8, h - 8);

      ctx.fillStyle = "#ffd4a3";
      ctx.fillRect(x + w * 0.25, y - h * 0.3, w * 0.5, h * 0.3);

      ctx.fillStyle = player.glowColor;
      ctx.fillRect(x + w * 0.35, y - h * 0.18, 4, 4);
      ctx.fillRect(x + w * 0.55, y - h * 0.18, 4, 4);

      ctx.shadowBlur = 0;
    }

    function drawEnemies() {
      for (const e of enemies) {
        ctx.shadowColor = e.glowColor;
        ctx.shadowBlur = e.isBoss ? 25 : e.isMiniBoss ? 18 : 12;

        const wobble = Math.sin(e.animFrame * Math.PI * 2) * 2;
        ctx.fillStyle = e.color;
        
        // Draw different shapes based on enemy type
        if (e.shape === "triangle") {
          // Triangle shape
          ctx.beginPath();
          ctx.moveTo(e.x + e.w / 2, e.y + wobble); // Top point
          ctx.lineTo(e.x + e.w, e.y + e.h + wobble); // Bottom right
          ctx.lineTo(e.x, e.y + e.h + wobble); // Bottom left
          ctx.closePath();
          ctx.fill();
        } else if (e.shape === "circle") {
          // Circle shape
          ctx.beginPath();
          ctx.arc(e.x + e.w / 2, e.y + e.h / 2 + wobble, e.w / 2, 0, Math.PI * 2);
          ctx.fill();
        } else {
          // Square shape (default)
          ctx.fillRect(e.x + 2, e.y + wobble, e.w - 4, e.h - 4);
        }

        ctx.shadowBlur = 0;
        
        // Labels
        if (e.pattern) {
          ctx.fillStyle = "#ffffff";
          ctx.font = "bold 12px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText(e.pattern.name.toUpperCase(), e.x + e.w / 2, e.y - 22);
        } else if (e.isBoss) {
          ctx.fillStyle = "#ffffff";
          ctx.font = "bold 12px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText("BOSS", e.x + e.w / 2, e.y - 22);
        } else if (e.isMiniBoss) {
          ctx.fillStyle = "#ffff00";
          ctx.font = "bold 10px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText("MINI-BOSS", e.x + e.w / 2, e.y - 22);
        } else if (e.type === "triangle") {
          ctx.fillStyle = "#ffff00";
          ctx.font = "bold 8px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText("SPEEDY", e.x + e.w / 2, e.y - 22);
        } else if (e.type === "circle") {
          ctx.fillStyle = "#00ff88";
          ctx.font = "bold 8px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText("HEALER", e.x + e.w / 2, e.y - 22);
        } else if (e.type === "jumper") {
          ctx.fillStyle = "#ff00ff";
          ctx.font = "bold 8px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText("JUMPER", e.x + e.w / 2, e.y - 22);
        } else if (e.type === "kamikaze") {
          ctx.fillStyle = "#ff8800";
          ctx.font = "bold 8px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText("BOMBER", e.x + e.w / 2, e.y - 22);
        } else if (e.isRanged) {
          ctx.fillStyle = "#ffaa00";
          ctx.font = "bold 8px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText("SHOOTER", e.x + e.w / 2, e.y - 22);
        } else if (e.hasShield && e.shieldHP > 0) {
          ctx.fillStyle = "#00aaff";
          ctx.font = "bold 8px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText("SHIELDED", e.x + e.w / 2, e.y - 22);
        }
        ctx.textAlign = "left";
        
        // Eyes
        ctx.fillStyle = "#ffff00";
        const eyeSize = e.isBoss ? 8 : e.isMiniBoss ? 6 : 5;
        ctx.fillRect(e.x + e.w * 0.25, e.y + e.h * 0.2, eyeSize, eyeSize);
        ctx.fillRect(e.x + e.w * 0.65, e.y + e.h * 0.2, eyeSize, eyeSize);

        // Shield bar
        if (e.hasShield && e.maxShieldHP > 0) {
          const shieldRatio = e.shieldHP / e.maxShieldHP;
          const barWidth = e.w;
          ctx.fillStyle = "rgba(0, 40, 80, 0.8)";
          ctx.fillRect(e.x, e.y - 14, barWidth, 4);
          
          ctx.fillStyle = "#00aaff";
          ctx.fillRect(e.x, e.y - 14, barWidth * shieldRatio, 4);
        }

        // HP bar
        const hpRatio = e.hp / e.maxHP;
        const barWidth = e.w;
        const barHeight = e.isBoss ? 8 : e.isMiniBoss ? 6 : 5;
        ctx.fillStyle = "rgba(60, 0, 0, 0.8)";
        ctx.fillRect(e.x, e.y - 8, barWidth, barHeight);
        
        const hpColor = hpRatio > 0.5 ? "#44ff44" : hpRatio > 0.25 ? "#ffaa44" : "#ff4444";
        ctx.fillStyle = hpColor;
        ctx.fillRect(e.x, e.y - 8, barWidth * hpRatio, barHeight);
      }
      ctx.shadowBlur = 0;
    }

    function drawProjectiles() {
      for (const p of projectiles) {
        // Special rendering for dragon beam
        if (p.isDragonBeam) {
          ctx.save();
          
          // Thick glowing laser
          ctx.shadowColor = p.glowColor;
          ctx.shadowBlur = 30;
          ctx.strokeStyle = p.color;
          ctx.lineWidth = p.radius * 2;
          ctx.globalAlpha = 0.8;
          ctx.beginPath();
          ctx.moveTo(0, p.y);
          ctx.lineTo(canvas.width, p.y);
          ctx.stroke();
          
          // Inner bright beam
          ctx.shadowBlur = 20;
          ctx.strokeStyle = "#ffff00";
          ctx.lineWidth = p.radius;
          ctx.beginPath();
          ctx.moveTo(0, p.y);
          ctx.lineTo(canvas.width, p.y);
          ctx.stroke();
          
          ctx.restore();
          continue;
        }
        
        // Normal projectile rendering
        ctx.globalAlpha = 0.3;
        ctx.strokeStyle = p.color;
        ctx.lineWidth = p.radius;
        ctx.beginPath();
        for (let i = 0; i < p.trail.length; i++) {
          const t = p.trail[i];
          if (i === 0) ctx.moveTo(t.x, t.y);
          else ctx.lineTo(t.x, t.y);
        }
        ctx.stroke();
        ctx.globalAlpha = 1.0;

        ctx.shadowColor = p.glowColor;
        ctx.shadowBlur = 15;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }

    function drawMinions() {
      if (!player || player.className !== "Summoner") return;
      
      for (const m of minions) {
        ctx.shadowColor = "#88ff88";
        ctx.shadowBlur = 15;
        ctx.fillStyle = "#88ff88";
        ctx.beginPath();
        ctx.arc(m.drawX, m.drawY, 8, 0, Math.PI * 2);
        ctx.fill();

        ctx.shadowBlur = 0;
        ctx.fillStyle = "#ffffff";
        ctx.beginPath();
        ctx.arc(m.drawX, m.drawY, 4, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;
    }

    function drawParticles() {
      for (const p of particles) {
        ctx.globalAlpha = p.life * 0.8;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
      }
      ctx.globalAlpha = 1.0;
    }
    
    function drawFireZones() {
      fireZones.forEach(zone => {
        ctx.save();
        
        // Pulsing fire effect
        const pulse = Math.sin(Date.now() / 100) * 0.2 + 0.8;
        ctx.globalAlpha = 0.6 * pulse;
        
        // Outer glow
        const gradient = ctx.createRadialGradient(zone.x, zone.y, 0, zone.x, zone.y, zone.radius);
        gradient.addColorStop(0, "#ff8800");
        gradient.addColorStop(0.5, "#ff4400");
        gradient.addColorStop(1, "rgba(255, 68, 0, 0)");
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Inner hot spot
        ctx.globalAlpha = 0.8;
        ctx.fillStyle = "#ffff00";
        ctx.beginPath();
        ctx.arc(zone.x, zone.y, zone.radius * 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Fire particles
        if (Math.random() < 0.3) {
          particles.push({
            x: zone.x + (Math.random() - 0.5) * zone.radius,
            y: zone.y + (Math.random() - 0.5) * zone.radius,
            vx: 0,
            vy: -2,
            radius: 3,
            color: Math.random() < 0.5 ? "#ff4400" : "#ff8800",
            life: 0.5
          });
        }
        
        ctx.restore();
      });
    }

    function drawFloatingTexts() {
      for (const t of floatingTexts) {
        ctx.globalAlpha = t.life;
        ctx.fillStyle = t.color;
        ctx.font = "bold 14px 'Courier New'";
        ctx.textAlign = "center";
        ctx.fillText(t.text, t.x, t.y);
      }
      ctx.globalAlpha = 1.0;
      ctx.textAlign = "left";
    }

    function drawCurrency() {
      for (const drop of currencyDrops) {
        ctx.globalAlpha = Math.min(drop.life, 1.0);
        
        if (drop.type === "coin") {
          ctx.shadowColor = "#ffff00";
          ctx.shadowBlur = 10;
          ctx.fillStyle = "#ffff00";
          ctx.font = "bold 16px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText("üí∞", drop.x, drop.y);
        } else {
          ctx.shadowColor = "#00ffff";
          ctx.shadowBlur = 10;
          ctx.fillStyle = "#00ffff";
          ctx.font = "bold 16px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText("üíé", drop.x, drop.y);
        }
        
        ctx.shadowBlur = 0;
      }
      ctx.globalAlpha = 1.0;
      ctx.textAlign = "left";
    }

    function drawHUD() {
      if (!player) return;

      // Main HUD
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(10, 10, 300, 110);
      
      ctx.strokeStyle = "#00ffff";
      ctx.lineWidth = 2;
      ctx.strokeRect(10, 10, 300, 110);

      ctx.fillStyle = "#00ffff";
      ctx.font = "bold 14px 'Courier New'";
      ctx.fillText("‚öîÔ∏è " + player.className, 20, 30);
      ctx.fillText("üó∫Ô∏è Map: " + currentMap, 20, 50);
      ctx.fillText("üåä Wave: " + wave, 130, 50);
      ctx.fillText("‚≠ê Level: " + player.level, 230, 50);
      
      // Auto-start indicator (top-right)
      ctx.fillStyle = autoStartWave ? "rgba(0, 255, 0, 0.8)" : "rgba(255, 0, 0, 0.8)";
      ctx.fillRect(canvas.width - 160, 10, 150, 30);
      ctx.strokeStyle = autoStartWave ? "#00ff00" : "#ff0000";
      ctx.lineWidth = 2;
      ctx.strokeRect(canvas.width - 160, 10, 150, 30);
      ctx.fillStyle = "#000000";
      ctx.font = "bold 12px 'Courier New'";
      ctx.fillText("‚ö° Auto-Start: " + (autoStartWave ? "ON" : "OFF"), canvas.width - 150, 28);
      ctx.fillStyle = "#ffff00";
      ctx.font = "10px 'Courier New'";
      ctx.fillText("[R] to toggle", canvas.width - 150, 38);
      
      // Game speed indicator
      ctx.fillStyle = gameSpeed === 2 ? "rgba(255, 136, 0, 0.8)" : "rgba(100, 100, 100, 0.8)";
      ctx.fillRect(canvas.width - 160, 45, 150, 30);
      ctx.strokeStyle = gameSpeed === 2 ? "#ff8800" : "#666666";
      ctx.lineWidth = 2;
      ctx.strokeRect(canvas.width - 160, 45, 150, 30);
      ctx.fillStyle = gameSpeed === 2 ? "#ffffff" : "#cccccc";
      ctx.font = "bold 12px 'Courier New'";
      ctx.fillText("‚è© Speed: " + gameSpeed + "x", canvas.width - 150, 63);
      ctx.fillStyle = "#ffff00";
      ctx.font = "10px 'Courier New'";
      ctx.fillText("[F] to toggle", canvas.width - 150, 73);

      // Shield bar
      if (player.maxShield > 0) {
        const shieldRatio = player.shield / player.maxShield;
        ctx.fillText("üõ°Ô∏è Shield", 20, 70);
        ctx.fillStyle = "rgba(0, 40, 80, 0.8)";
        ctx.fillRect(70, 60, 230, 8);
        
        ctx.fillStyle = "#00aaff";
        ctx.fillRect(70, 60, 230 * shieldRatio, 8);
        
        ctx.strokeStyle = "#00ffff";
        ctx.strokeRect(70, 60, 230, 8);
      }

      // HP bar
      const hpRatio = player.hp / player.maxHP;
      ctx.fillStyle = "#00ffff";
      const hpY = player.maxShield > 0 ? 84 : 70;
      const hpBarY = player.maxShield > 0 ? 74 : 60;
      ctx.fillText("‚ù§Ô∏è HP", 20, hpY);
      ctx.fillStyle = "rgba(60, 0, 0, 0.8)";
      ctx.fillRect(70, hpBarY, 230, 12);
      
      ctx.fillStyle = hpRatio > 0.5 ? "#44ff44" : hpRatio > 0.25 ? "#ffaa44" : "#ff4444";
      ctx.fillRect(70, hpBarY, 230 * hpRatio, 12);
      
      ctx.strokeStyle = "#ff4444";
      ctx.strokeRect(70, hpBarY, 230, 12);

      // XP bar
      const xpRatio = player.xp / player.xpToNext;
      ctx.fillStyle = "#00ffff";
      ctx.fillText("‚ú® XP: " + Math.floor(player.xp) + "/" + player.xpToNext, 20, 102);
      ctx.fillStyle = "rgba(0, 50, 80, 0.8)";
      ctx.fillRect(70, 92, 230, 10);
      
      ctx.fillStyle = "#0088ff";
      ctx.fillRect(70, 92, 230 * xpRatio, 10);
      
      ctx.strokeStyle = "#00ffff";
      ctx.strokeRect(70, 92, 230, 10);

      // Currency display
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(canvas.width - 210, 10, 200, 60);
      ctx.strokeStyle = "#00ffff";
      ctx.strokeRect(canvas.width - 210, 10, 200, 60);

      ctx.fillStyle = "#ffff00";
      ctx.font = "bold 14px 'Courier New'";
      ctx.fillText("üí∞ " + sessionCoins + " (+" + gameData.totalCoins + ")", canvas.width - 200, 30);
      ctx.fillStyle = "#00ffff";
      ctx.fillText("üíé " + sessionGems + " (+" + gameData.totalGems + ")", canvas.width - 200, 50);
      
      // Combo
      if (combo > 0) {
        ctx.fillStyle = "#ff8800";
        ctx.font = "bold 16px 'Courier New'";
        ctx.fillText("üî• COMBO: " + combo + "x", canvas.width - 200, 80);
      }
      
      // Wave timer
      if (waveTimerActive) {
        ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
        ctx.fillRect(canvas.width / 2 - 100, 10, 200, 50);
        ctx.strokeStyle = "#ffff00";
        ctx.lineWidth = 3;
        ctx.strokeRect(canvas.width / 2 - 100, 10, 200, 50);
        
        ctx.fillStyle = "#ffff00";
        ctx.font = "bold 18px 'Courier New'";
        ctx.textAlign = "center";
        ctx.fillText("‚è∞ Next Wave In:", canvas.width / 2, 30);
        ctx.font = "bold 24px 'Courier New'";
        ctx.fillStyle = waveTimer <= 5 ? "#ff0000" : "#00ff00";
        ctx.fillText(Math.ceil(waveTimer) + "s", canvas.width / 2, 52);
        ctx.textAlign = "left";
      }
      
      // Active potion effects
      let effectY = canvas.height - 140;
      if (potionEffects.critActive) {
        ctx.fillStyle = "rgba(255, 0, 0, 0.8)";
        ctx.fillRect(10, effectY, 180, 30);
        ctx.strokeStyle = "#ff0000";
        ctx.lineWidth = 2;
        ctx.strokeRect(10, effectY, 180, 30);
        ctx.fillStyle = "#ffff00";
        ctx.font = "bold 14px 'Courier New'";
        ctx.fillText("üí• CRIT BOOST: " + Math.ceil(potionEffects.critTimer) + "s", 20, effectY + 20);
        effectY -= 35;
      }
      
      if (potionEffects.damageActive) {
        ctx.fillStyle = "rgba(255, 136, 0, 0.8)";
        ctx.fillRect(10, effectY, 180, 30);
        ctx.strokeStyle = "#ff8800";
        ctx.lineWidth = 2;
        ctx.strokeRect(10, effectY, 180, 30);
        ctx.fillStyle = "#ffff00";
        ctx.font = "bold 14px 'Courier New'";
        ctx.fillText("‚öîÔ∏è DAMAGE UP: " + Math.ceil(potionEffects.damageTimer) + "s", 20, effectY + 20);
        effectY -= 35;
      }
      
      if (potionEffects.speedActive) {
        ctx.fillStyle = "rgba(255, 255, 0, 0.8)";
        ctx.fillRect(10, effectY, 180, 30);
        ctx.strokeStyle = "#ffff00";
        ctx.lineWidth = 2;
        ctx.strokeRect(10, effectY, 180, 30);
        ctx.fillStyle = "#000000";
        ctx.font = "bold 14px 'Courier New'";
        ctx.fillText("‚ö° SPEED UP: " + Math.ceil(potionEffects.speedTimer) + "s", 20, effectY + 20);
        effectY -= 35;
      }
      
      // Potion inventory display at bottom center
      const potionBarY = canvas.height - 60;
      const potionBarWidth = 480;
      const potionBarX = (canvas.width - potionBarWidth) / 2;
      
      ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
      ctx.fillRect(potionBarX, potionBarY, potionBarWidth, 50);
      ctx.strokeStyle = "#00ffff";
      ctx.lineWidth = 2;
      ctx.strokeRect(potionBarX, potionBarY, potionBarWidth, 50);
      
      const potionSlotWidth = 75;
      const potionsList = [
        { key: '1', icon: '‚ù§Ô∏è', name: 'Heal', count: potions.heal, color: '#ff4444' },
        { key: '2', icon: 'üõ°Ô∏è', name: 'Shield', count: potions.shield, color: '#4444ff' },
        { key: '3', icon: 'üí•', name: 'Crit', count: potions.crit, color: '#ff0000' },
        { key: '4', icon: '‚öîÔ∏è', name: 'Damage', count: potions.damage, color: '#ff8800' },
        { key: '5', icon: '‚ö°', name: 'Speed', count: potions.speed, color: '#ffff00' },
        { key: '6', icon: 'üêâ', name: 'Dragon', count: potions.dragon, color: '#ff00ff' }
      ];
      
      potionsList.forEach((potion, i) => {
        const slotX = potionBarX + 10 + (i * potionSlotWidth);
        const slotY = potionBarY + 5;
        
        // Draw slot
        ctx.fillStyle = potion.count > 0 ? "rgba(0, 50, 50, 0.8)" : "rgba(50, 50, 50, 0.5)";
        ctx.fillRect(slotX, slotY, 70, 40);
        ctx.strokeStyle = potion.count > 0 ? potion.color : "#444444";
        ctx.lineWidth = 2;
        ctx.strokeRect(slotX, slotY, 70, 40);
        
        // Draw icon and count
        ctx.fillStyle = potion.count > 0 ? "#ffffff" : "#666666";
        ctx.font = "20px 'Courier New'";
        ctx.textAlign = "center";
        ctx.fillText(potion.icon, slotX + 20, slotY + 28);
        
        ctx.fillStyle = potion.count > 0 ? "#00ff00" : "#666666";
        ctx.font = "bold 16px 'Courier New'";
        ctx.fillText("√ó" + potion.count, slotX + 50, slotY + 28);
        
        // Draw hotkey
        ctx.fillStyle = "#ffff00";
        ctx.font = "10px 'Courier New'";
        ctx.fillText("[" + potion.key + "]", slotX + 35, slotY + 38);
      });
      
      ctx.textAlign = "left";
    }
    
    function drawAbilityEffects() {
      // Upside Down dimension effect
      if (upsideDownActive) {
        ctx.save();
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = "#8B0000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.globalAlpha = 1;
        ctx.restore();
        
        // Distorted text
        ctx.save();
        ctx.fillStyle = "#ff0000";
        ctx.font = "bold 24px 'Courier New'";
        ctx.textAlign = "center";
        ctx.fillText("üåÄ UPSIDE DOWN üåÄ", canvas.width / 2, 50);
        ctx.fillStyle = "#ffff00";
        ctx.font = "16px 'Courier New'";
        ctx.fillText(`${Math.ceil(upsideDownTimer)}s remaining`, canvas.width / 2, 75);
        ctx.restore();
      }
      
      // Hive Mind links
      if (hiveMindActive) {
        ctx.save();
        ctx.strokeStyle = "#ff0000";
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        
        for (let i = 0; i < enemies.length; i++) {
          for (let j = i + 1; j < enemies.length; j++) {
            if (enemies[i].hiveMindLinked && enemies[j].hiveMindLinked) {
              ctx.beginPath();
              ctx.moveTo(enemies[i].x, enemies[i].y);
              ctx.lineTo(enemies[j].x, enemies[j].y);
              ctx.stroke();
            }
          }
        }
        
        ctx.setLineDash([]);
        ctx.restore();
        
        // Display text
        ctx.save();
        ctx.fillStyle = "#ff0000";
        ctx.font = "bold 24px 'Courier New'";
        ctx.textAlign = "center";
        ctx.fillText("üëÅÔ∏è HIVE MIND ACTIVE üëÅÔ∏è", canvas.width / 2, 50);
        ctx.fillStyle = "#ffff00";
        ctx.font = "16px 'Courier New'";
        ctx.fillText(`${Math.ceil(hiveMindTimer)}s remaining`, canvas.width / 2, 75);
        ctx.restore();
      }
      
      // Blade Storm effect
      if (bladeStormActive && player) {
        ctx.save();
        ctx.strokeStyle = "#9933ff";
        ctx.lineWidth = 3;
        const numBlades = 8;
        const time = Date.now() / 100;
        
        for (let i = 0; i < numBlades; i++) {
          const angle = (Math.PI * 2 / numBlades) * i + time;
          const x1 = player.x + Math.cos(angle) * 100;
          const y1 = player.y + Math.sin(angle) * 100;
          const x2 = player.x + Math.cos(angle + 0.5) * 150;
          const y2 = player.y + Math.sin(angle + 0.5) * 150;
          
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }
        ctx.restore();
      }
      
      // Time Freeze effect
      if (timeFreezeActive) {
        ctx.save();
        ctx.strokeStyle = "#00ffff";
        ctx.lineWidth = 2;
        
        enemies.forEach(e => {
          if (e.frozen) {
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.radius + 5, 0, Math.PI * 2);
            ctx.stroke();
          }
        });
        
        ctx.fillStyle = "#00ffff";
        ctx.font = "bold 24px 'Courier New'";
        ctx.textAlign = "center";
        ctx.fillText("‚ùÑÔ∏è TIME FROZEN ‚ùÑÔ∏è", canvas.width / 2, 50);
        ctx.restore();
      }
      
      // Vecna monsters
      vecnaMonsters.forEach(m => {
        ctx.save();
        ctx.fillStyle = m.color;
        ctx.beginPath();
        ctx.arc(m.x, m.y, m.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // HP bar
        const barWidth = 30;
        const barHeight = 4;
        const hpPercent = m.hp / m.maxHP;
        
        ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
        ctx.fillRect(m.x - barWidth / 2, m.y - m.radius - 10, barWidth, barHeight);
        
        ctx.fillStyle = "#00ff00";
        ctx.fillRect(m.x - barWidth / 2, m.y - m.radius - 10, barWidth * hpPercent, barHeight);
        
        ctx.restore();
      });
    }

    function draw() {
      ctx.save();
      if (screenShake > 0) {
        const shakeX = (Math.random() - 0.5) * screenShake;
        const shakeY = (Math.random() - 0.5) * screenShake;
        ctx.translate(shakeX, shakeY);
      }

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      drawBackground();
      drawGround();
      drawFireZones();
      if (player) drawPlayer();
      drawEnemies();
      drawProjectiles();
      drawMinions();
      drawParticles();
      drawFloatingTexts();
      drawCurrency();
      drawHUD();
      
      // Special ability visual effects
      drawAbilityEffects();

      ctx.restore();
    }

    // OVERWORLD MAP FUNCTIONS
    const overworldCanvas = document.getElementById('overworldCanvas');
    const overworldCtx = overworldCanvas.getContext('2d');
    let selectedNode = null;
    let hoveredNode = null;
    let overworldAnimTime = 0;
    let overworldInitialized = false;

    function drawOverworldMap() {
      overworldCtx.clearRect(0, 0, overworldCanvas.width, overworldCanvas.height);
      
      overworldAnimTime += 0.02;
      
      // Draw connections/paths between nodes
      const nodes = OVERWORLD_MAP.nodes;
      Object.values(nodes).forEach(node => {
        if (node.connections) {
          node.connections.forEach(connId => {
            const targetNode = nodes[connId];
            if (targetNode) {
              const isPathActive = node.completed || node.unlocked;
              
              overworldCtx.strokeStyle = isPathActive ? 
                `rgba(0, 255, 255, ${0.3 + Math.sin(overworldAnimTime) * 0.2})` : 
                'rgba(100, 100, 100, 0.3)';
              overworldCtx.lineWidth = isPathActive ? 4 : 2;
              overworldCtx.beginPath();
              overworldCtx.moveTo(node.x, node.y);
              overworldCtx.lineTo(targetNode.x, targetNode.y);
              overworldCtx.stroke();
            }
          });
        }
      });
      
      // Draw nodes
      Object.values(nodes).forEach(node => {
        const isHovered = hoveredNode === node.id;
        const isSelected = selectedNode === node.id;
        
        overworldCtx.save();
        overworldCtx.translate(node.x, node.y);
        
        // Node appearance based on state
        let nodeColor, nodeSize, nodeIcon;
        
        if (node.completed) {
          nodeColor = '#00ff00';
          nodeSize = 25 + (isHovered ? 5 : 0);
          nodeIcon = '‚úì';
        } else if (node.unlocked) {
          nodeColor = '#ffff00';
          nodeSize = 25 + (isHovered ? 5 : 0);
          nodeIcon = getNodeIcon(node.type);
        } else if (node.hidden) {
          // Skip drawing hidden nodes
          overworldCtx.restore();
          return;
        } else {
          nodeColor = '#666666';
          nodeSize = 20;
          nodeIcon = 'üîí';
        }
        
        // Glow effect for completed/unlocked nodes
        if (node.completed || node.unlocked) {
          overworldCtx.shadowColor = nodeColor;
          overworldCtx.shadowBlur = 15 + Math.sin(overworldAnimTime + node.x) * 5;
        }
        
        // Draw node circle
        overworldCtx.fillStyle = nodeColor;
        overworldCtx.beginPath();
        overworldCtx.arc(0, 0, nodeSize, 0, Math.PI * 2);
        overworldCtx.fill();
        
        if (isSelected) {
          overworldCtx.strokeStyle = '#ffffff';
          overworldCtx.lineWidth = 4;
          overworldCtx.stroke();
        }
        
        // Draw inner circle
        overworldCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        overworldCtx.beginPath();
        overworldCtx.arc(0, 0, nodeSize - 5, 0, Math.PI * 2);
        overworldCtx.fill();
        
        // Draw node icon
        overworldCtx.shadowBlur = 0;
        overworldCtx.font = `${nodeSize}px Arial`;
        overworldCtx.textAlign = 'center';
        overworldCtx.textBaseline = 'middle';
        overworldCtx.fillStyle = '#ffffff';
        overworldCtx.fillText(nodeIcon, 0, 0);
        
        // Draw node name
        overworldCtx.font = '14px Arial';
        overworldCtx.fillStyle = '#ffffff';
        overworldCtx.shadowColor = '#000000';
        overworldCtx.shadowBlur = 3;
        overworldCtx.fillText(node.name, 0, nodeSize + 20);
        
        overworldCtx.restore();
      });
      
      requestAnimationFrame(drawOverworldMap);
    }

    function getNodeIcon(type) {
      switch (type) {
        case 'survival': return '‚öîÔ∏è';
        case 'elite': return 'üíÄ';
        case 'shop': return 'üõí';
        case 'shrine': return '‚õ©Ô∏è';
        case 'secret': return 'üíé';
        case 'boss': return 'üëë';
        case 'gate': return 'üö™';
        case 'final_boss': return 'üèÜ';
        case 'start': return 'üè†';
        default: return '‚ùì';
      }
    }

    function onOverworldClick(event) {
      const rect = overworldCanvas.getBoundingClientRect();
      const x = (event.clientX - rect.left) * (overworldCanvas.width / rect.width);
      const y = (event.clientY - rect.top) * (overworldCanvas.height / rect.height);
      
      // Check if clicked on a node
      Object.values(OVERWORLD_MAP.nodes).forEach(node => {
        const dist = Math.hypot(x - node.x, y - node.y);
        if (dist < 30 && (node.unlocked || node.completed)) {
          selectedNode = node.id;
          showNodeInfo(node);
        }
      });
    }

    function onOverworldMove(event) {
      const rect = overworldCanvas.getBoundingClientRect();
      const x = (event.clientX - rect.left) * (overworldCanvas.width / rect.width);
      const y = (event.clientY - rect.top) * (overworldCanvas.height / rect.height);
      
      hoveredNode = null;
      Object.values(OVERWORLD_MAP.nodes).forEach(node => {
        const dist = Math.hypot(x - node.x, y - node.y);
        if (dist < 30 && (node.unlocked || node.completed)) {
          hoveredNode = node.id;
          overworldCanvas.style.cursor = 'pointer';
        }
      });
      
      if (!hoveredNode) {
        overworldCanvas.style.cursor = 'default';
      }
    }

    function showNodeInfo(node) {
      const panel = document.getElementById('nodeInfoPanel');
      const nameEl = document.getElementById('nodeInfoName');
      const detailsEl = document.getElementById('nodeInfoDetails');
      const rewardsEl = document.getElementById('nodeInfoRewards');
      
      nameEl.textContent = node.name;
      
      let details = '';
      
      // Display lore if available
      if (node.lore) {
        details += `<div style="font-style: italic; color: #FFD700; margin-bottom: 10px;">"${node.lore}"</div>`;
      }
      
      if (node.type === 'survival' || node.type === 'elite' || node.type === 'boss' || node.type === 'final_boss') {
        details += `Type: ${node.type.toUpperCase()}<br>`;
        details += `Waves: ${node.waves}<br>`;
        details += `Mini-Bosses: Waves ${node.miniBossWaves.join(', ')}<br>`;
        details += `Bosses: Waves ${node.bossWaves.join(', ')}<br>`;
        details += `Recommended Power: ${node.recommendedPower}`;
      } else if (node.type === 'shop') {
        details += 'Purchase upgrades, potions, and classes';
      } else if (node.type === 'shrine') {
        details += `Unlock/upgrade ${node.shrineClass}`;
      } else if (node.type === 'secret') {
        details += 'Hidden treasure node!';
      } else if (node.type === 'gate') {
        details += 'Gateway node - pass through to continue';
        if (node.requireAllSeals) {
          details += '<br><br><strong>üîí REQUIRES ALL 5 SEALS:</strong><br>';
          details += OVERWORLD_MAP.collectedSeals.crystalKeystone ? '‚úÖ' : '‚ùå';
          details += ' Crystal Keystone<br>';
          details += OVERWORLD_MAP.collectedSeals.abyssKey ? '‚úÖ' : '‚ùå';
          details += ' Abyss Key<br>';
          details += OVERWORLD_MAP.collectedSeals.frozenFragment ? '‚úÖ' : '‚ùå';
          details += ' Frozen Fragment<br>';
          details += OVERWORLD_MAP.collectedSeals.blazingSeal ? '‚úÖ' : '‚ùå';
          details += ' Blazing Seal<br>';
          details += OVERWORLD_MAP.collectedSeals.tideRune ? '‚úÖ' : '‚ùå';
          details += ' Tide Rune';
        }
      }
      
      // Show unlock requirements
      if (node.requireClass) {
        details += `<br><br>üîí Requires Class: ${node.requireClass}`;
      }
      if (node.requireCode) {
        details += `<br><br>üîí Requires Code: ${node.requireCode}`;
      }
      if (node.requireMaterial) {
        details += `<br><br>üîí Requires Material: ${node.requireMaterial}`;
      }
      
      detailsEl.innerHTML = details;
      
      if (node.rewards) {
        let rewardText = 'üéÅ Rewards: ';
        if (node.rewards.coins) rewardText += `üí∞ ${node.rewards.coins} Coins `;
        if (node.rewards.gems) rewardText += `üíé ${node.rewards.gems} Gems `;
        if (node.rewards.classXP) rewardText += `‚≠ê ${node.rewards.classXP} Class XP `;
        if (node.rewards.seal) rewardText += `‚ú® SEAL: ${node.rewards.seal} `;
        if (node.rewards.material) rewardText += `üéÅ ${node.rewards.material}`;
        if (node.rewards.ending) rewardText += 'üèÜ FINAL VICTORY!';
        rewardsEl.textContent = rewardText;
      } else {
        rewardsEl.textContent = '';
      }
      
      panel.classList.add('active');
      
      const enterBtn = document.getElementById('nodeEnterBtn');
      if (node.type === 'shop') {
        enterBtn.textContent = 'OPEN SHOP';
      } else if (node.type === 'shrine') {
        enterBtn.textContent = 'VISIT SHRINE';
      } else if (node.type === 'gate') {
        enterBtn.textContent = 'PASS THROUGH';
      } else {
        enterBtn.textContent = 'ENTER NODE';
      }
      
      enterBtn.onclick = () => enterNode(node);
    }

    function enterNode(node) {
      if (node.type === 'shop') {
        openShopFromOverworld();
      } else if (node.type === 'shrine') {
        openShrineUpgrades(node.shrineClass);
      } else if (node.type === 'gate') {
        // Gates auto-complete and unlock next nodes
        completeNode(node.id);
        document.getElementById('nodeInfoPanel').classList.remove('active');
      } else if (node.type === 'survival' || node.type === 'elite' || node.type === 'boss' || node.type === 'secret' || node.type === 'final_boss') {
        startNodeLevel(node);
      }
    }

    function startNodeLevel(node) {
      // Store current node
      OVERWORLD_MAP.currentNode = node.id;
      
      // Hide overworld, start game
      document.getElementById('overworldScreen').classList.remove('active');
      document.getElementById('nodeInfoPanel').classList.remove('active');
      
      // Initialize game with node parameters
      wave = 1;
      // Note: Wave system will need to be updated to handle node.miniBossWaves and node.bossWaves
      
      startGame();
    }

    function completeNode(nodeId) {
      const node = OVERWORLD_MAP.nodes[nodeId];
      if (node) {
        node.completed = true;
        
        // Unlock connected nodes
        if (node.connections) {
          node.connections.forEach(connId => {
            const connectedNode = OVERWORLD_MAP.nodes[connId];
            if (connectedNode) {
              // Check unlock requirements
              let canUnlock = true;
              
              // Check seal requirement
              if (connectedNode.requireAllSeals) {
                canUnlock = OVERWORLD_MAP.collectedSeals.crystalKeystone &&
                           OVERWORLD_MAP.collectedSeals.abyssKey &&
                           OVERWORLD_MAP.collectedSeals.frozenFragment &&
                           OVERWORLD_MAP.collectedSeals.blazingSeal &&
                           OVERWORLD_MAP.collectedSeals.tideRune;
              }
              
              // Check class requirement
              if (connectedNode.requireClass) {
                canUnlock = gameData.currentClass === connectedNode.requireClass;
              }
              
              // Check material requirement
              if (connectedNode.requireMaterial) {
                canUnlock = gameData.materials && gameData.materials[connectedNode.requireMaterial];
              }
              
              // Check code requirement
              if (connectedNode.requireCode) {
                canUnlock = gameData.redeemedCodes && gameData.redeemedCodes.includes(connectedNode.requireCode);
              }
              
              if (canUnlock && !connectedNode.hidden) {
                connectedNode.unlocked = true;
              } else if (canUnlock && connectedNode.hidden) {
                // Reveal hidden nodes when requirements are met
                connectedNode.unlocked = true;
              }
            }
          });
        }
        
        // Grant rewards
        if (node.rewards) {
          if (node.rewards.coins) {
            gameData.totalCoins += node.rewards.coins;
            sessionCoins += node.rewards.coins;
          }
          if (node.rewards.gems) {
            gameData.totalGems += node.rewards.gems;
            sessionGems += node.rewards.gems;
          }
          if (node.rewards.classXP) {
            // Add class XP system here
          }
          // Collect seals!
          if (node.rewards.seal) {
            OVERWORLD_MAP.collectedSeals[node.rewards.seal] = true;
            showFloatingText('‚ú® SEAL OBTAINED: ' + node.rewards.seal.toUpperCase() + ' ‚ú®', canvas.width / 2, 100, '#FFD700', 40);
          }
          // Collect materials
          if (node.rewards.material) {
            if (!gameData.materials) gameData.materials = {};
            gameData.materials[node.rewards.material] = true;
          }
          // Check for ending
          if (node.rewards.ending) {
            showVictoryScreen('üèÜ LEGEND COMPLETE! You have reclaimed your name!');
            return;
          }
        }
        
        saveGameData();
        updateOverworldStats();
        
        // Return to overworld
        document.getElementById('overworldScreen').classList.add('active');
      }
    }

    function updateOverworldStats() {
      document.getElementById('overworldCoins').textContent = gameData.totalCoins;
      document.getElementById('overworldGems').textContent = gameData.totalGems;
      
      const totalNodes = Object.keys(OVERWORLD_MAP.nodes).length - 1; // Exclude start
      const completed = Object.values(OVERWORLD_MAP.nodes).filter(n => n.completed && n.id !== 'start').length;
      
      document.getElementById('nodesCompleted').textContent = completed;
      document.getElementById('totalNodes').textContent = totalNodes;
    }

    function openShopFromOverworld() {
      document.getElementById('overworldScreen').classList.remove('active');
      document.getElementById('shopScreen').classList.add('active');
    }

    function openShrineUpgrades(className) {
      // Show class upgrade panel for specific class
      showClassUpgradePanel(className);
    }

    function showClassUpgradePanel(className) {
      // TODO: Build full class upgrade UI
      alert(`Class Upgrade Panel for ${className || 'current class'}\n\nShowing upgrade tree with tier 1-3 upgrades.\n\nThis feature is coming soon!`);
    }

    function showRedeemCodePanel() {
      const code = prompt('Enter Redeem Code:');
      if (code) {
        const upperCode = code.toUpperCase();
        // TODO: Implement proper redeem code system
        alert(`Redeem code system coming soon!\nYou entered: ${upperCode}`);
      }
    }

    function gameLoop(timestamp) {
      const baseDt = Math.min((timestamp - lastTime) / 1000, 0.1);
      const dt = baseDt * gameSpeed; // Apply game speed multiplier
      lastTime = timestamp;

      if (gameRunning) {
        update(dt);
      }
      
      draw();
      requestAnimationFrame(gameLoop);
    }

    // INITIALIZATION AND EVENT LISTENERS
    function initializeOverworld() {
      // Set up overworld canvas event listeners
      overworldCanvas.addEventListener('click', onOverworldClick);
      overworldCanvas.addEventListener('mousemove', onOverworldMove);
      
      // Initialize first node as unlocked
      OVERWORLD_MAP.nodes.start.unlocked = true;
      OVERWORLD_MAP.nodes.start.completed = true;
      OVERWORLD_MAP.nodes.forest_1.unlocked = true;
      OVERWORLD_MAP.nodes.plains_1.unlocked = true;
      
      // Start overworld rendering
      drawOverworldMap();
      updateOverworldStats();
      
      // Set up overworld menu buttons
      document.getElementById('classUpgradesBtn').onclick = () => {
        alert('Class Upgrades - Coming soon!');
      };
      
      document.getElementById('redeemCodeBtn').onclick = () => {
        alert('Redeem Code - Coming soon!');
      };
      
      document.getElementById('overworldShopBtn').onclick = () => {
        openShopFromOverworld();
      };
      
      document.getElementById('changeClassBtn').onclick = () => {
        document.getElementById('overworldScreen').classList.remove('active');
        document.getElementById('classSelection').classList.add('active');
      };
      
      document.getElementById('returnHomeBtn').onclick = () => {
        document.getElementById('overworldScreen').classList.remove('active');
        document.getElementById('titleScreen').classList.remove('hidden');
      };
    }

    // Modify the existing start button to go to overworld instead of class selection
    const originalStartBtn = document.getElementById('startBtn');
    if (originalStartBtn) {
      originalStartBtn.onclick = () => {
        document.getElementById('titleScreen').classList.add('hidden');
        document.getElementById('overworldScreen').classList.add('active');
        initializeOverworld();
      };
    }

    // Initialize on load
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        updateOverworldStats();
      });
    } else {
      updateOverworldStats();
    }

    // Start draw loop
    draw();
  </script>
</body>
</html>