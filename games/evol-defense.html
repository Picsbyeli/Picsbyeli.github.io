<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>EVOL LEGENDS - The Forgotten Warrior</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Press+Start+2P&family=Crimson+Text:ital@0;1&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      font-family: 'Press Start 2P', monospace;
      color: #fff;
      overflow: hidden;
    }
    #gameContainer {
      position: relative;
      width: 1200px;
      height: 700px;
      background: #0a0015;
      box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
      overflow: hidden;
    }
    canvas { display: block; image-rendering: pixelated; }
    
    /* Starfield background */
    .starfield {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: linear-gradient(135deg, #0a0015 0%, #1a0030 50%, #0a0020 100%);
      z-index: -1;
    }
    .star {
      position: absolute;
      background: white;
      border-radius: 50%;
      animation: twinkle 2s infinite;
    }
    @keyframes twinkle {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 1; }
    }
    
    /* Title Screen */
    #titleScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: linear-gradient(135deg, #0a0015 0%, #1a0030 50%, #0a0020 100%);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 200;
      cursor: pointer;
    }
    #titleScreen.hidden { display: none; }
    
    .title-logo {
      font-family: 'Cinzel', serif;
      font-size: 72px;
      font-weight: 700;
      background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3, #54a0ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
      animation: logoGlow 3s ease-in-out infinite;
      margin-bottom: 10px;
    }
    @keyframes logoGlow {
      0%, 100% { filter: drop-shadow(0 0 20px #00ffff); }
      50% { filter: drop-shadow(0 0 40px #ff00ff); }
    }
    
    .title-subtitle {
      font-family: 'Crimson Text', serif;
      font-size: 28px;
      font-style: italic;
      color: #ff00ff;
      text-shadow: 0 0 15px #ff00ff;
      margin-bottom: 30px;
    }
    
    .title-tagline {
      font-family: 'Crimson Text', serif;
      font-size: 18px;
      color: #88ffff;
      margin-bottom: 60px;
    }
    
    .press-start {
      font-family: 'Press Start 2P', monospace;
      font-size: 16px;
      color: #00ffff;
      animation: blink 1.5s infinite;
    }
    @keyframes blink {
      0%, 50%, 100% { opacity: 1; }
      25%, 75% { opacity: 0.3; }
    }
    
    /* Name Entry Screen */
    #nameScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: linear-gradient(135deg, #0a0015 0%, #1a0030 100%);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 190;
    }
    #nameScreen.active { display: flex; }
    
    .name-quote {
      font-family: 'Crimson Text', serif;
      font-style: italic;
      font-size: 18px;
      color: #aaa;
      max-width: 600px;
      text-align: center;
      margin-bottom: 40px;
      line-height: 1.6;
    }
    
    .name-prompt {
      font-size: 24px;
      color: #00ffff;
      margin-bottom: 20px;
    }
    
    #warriorNameInput {
      font-family: 'Cinzel', serif;
      font-size: 28px;
      padding: 15px 30px;
      background: rgba(0, 0, 0, 0.8);
      border: 3px solid #00ffff;
      border-radius: 10px;
      color: #ffff00;
      text-align: center;
      width: 400px;
      outline: none;
    }
    #warriorNameInput:focus {
      box-shadow: 0 0 20px #00ffff;
    }
    
    .name-confirm-btn {
      margin-top: 30px;
      padding: 15px 50px;
      font-family: 'Press Start 2P', monospace;
      font-size: 14px;
      background: linear-gradient(135deg, #00ff88 0%, #00ffff 100%);
      color: #000;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
    }
    .name-confirm-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 0 30px #00ffff;
    }
    
    /* Main Menu */
    #mainMenu {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: linear-gradient(135deg, #0a0015 0%, #1a0030 100%);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 180;
    }
    #mainMenu.active { display: flex; }
    
    .menu-title {
      font-family: 'Cinzel', serif;
      font-size: 48px;
      color: #00ffff;
      text-shadow: 0 0 20px #00ffff;
      margin-bottom: 10px;
    }
    
    .menu-warrior-name {
      font-family: 'Crimson Text', serif;
      font-size: 20px;
      color: #ffff00;
      margin-bottom: 30px;
    }
    
    .menu-buttons {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin-bottom: 30px;
    }
    
    .menu-btn {
      padding: 18px 80px;
      font-family: 'Press Start 2P', monospace;
      font-size: 14px;
      background: linear-gradient(135deg, #1a1a3a 0%, #2a1a4a 100%);
      color: #00ffff;
      border: 3px solid #00ffff;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
      min-width: 350px;
    }
    .menu-btn:hover {
      background: linear-gradient(135deg, #00ffff 0%, #ff00ff 100%);
      color: #000;
      transform: scale(1.05);
      box-shadow: 0 0 30px #00ffff;
    }
    .menu-btn.story-btn { border-color: #00ff88; color: #00ff88; }
    .menu-btn.endless-btn { border-color: #ff00ff; color: #ff00ff; }
    .menu-btn.shop-btn { border-color: #ffff00; color: #ffff00; }
    .menu-btn.settings-btn { border-color: #ff8800; color: #ff8800; }
    .menu-btn.redeem-btn { border-color: #ff0088; color: #ff0088; }
    
    .menu-stats {
      display: flex;
      gap: 40px;
      font-size: 12px;
      color: #888;
    }
    .menu-stats span { color: #ffff00; }
    
    /* Overworld Map */
    #overworldMap {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      /* Fallback gradient matching your map's aesthetic */
      background: linear-gradient(
        180deg,
        #0a0a20 0%,
        #1a2a40 15%,
        #2a4a30 30%,
        #4a2a20 50%,
        #1a2a50 70%,
        #0a1a30 100%
      );
      display: none;
      z-index: 170;
      overflow: hidden;
    }
    #overworldMap.active { display: block; }
    
    #mapImage {
      width: 100%;
      height: 100%;
      object-fit: cover;
      filter: brightness(0.9);
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
    }
    
    /* Fog of war overlay */
    .fog-overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 2;
    }
    
    /* Character marker on map */
    .player-marker {
      position: absolute;
      width: 50px;
      height: 50px;
      transform: translate(-50%, -50%);
      z-index: 15;
      pointer-events: none;
      animation: playerBounce 1s ease-in-out infinite;
    }
    .player-marker::before {
      content: "";
      position: absolute;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, rgba(0,255,255,0.4) 0%, transparent 70%);
      border-radius: 50%;
      animation: playerGlow 2s ease-in-out infinite;
    }
    .player-marker::after {
      content: "üìç";
      font-size: 32px;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      filter: drop-shadow(0 0 10px #00ffff);
    }
    @keyframes playerBounce {
      0%, 100% { transform: translate(-50%, -50%); }
      50% { transform: translate(-50%, -60%); }
    }
    @keyframes playerGlow {
      0%, 100% { opacity: 0.5; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.3); }
    }
    
    /* Map connection lines */
    .map-connections {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    
    .map-node {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      z-index: 10;
      transform: translate(-50%, -50%);
    }
    .map-node.locked {
      background: rgba(50, 50, 50, 0.7);
      border: 3px dashed #444;
      cursor: not-allowed;
      opacity: 0.5;
    }
    .map-node.hidden {
      display: none !important;
    }
    .map-node.unlocked {
      background: rgba(0, 255, 255, 0.4);
      border: 3px solid #00ffff;
      animation: nodePulse 2s infinite;
    }
    .map-node.current {
      background: rgba(255, 255, 0, 0.5);
      border: 4px solid #ffff00;
      animation: currentPulse 1s infinite;
      box-shadow: 0 0 30px #ffff00;
    }
    @keyframes currentPulse {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.15); }
    }
    .map-node.completed {
      background: rgba(0, 255, 0, 0.4);
      border: 3px solid #00ff00;
    }
    .map-node.boss {
      width: 55px;
      height: 55px;
      font-size: 28px;
      border-width: 4px;
    }
    .map-node.boss.unlocked {
      border-color: #ff0000;
      background: rgba(255, 0, 0, 0.4);
      animation: bossPulse 1.5s infinite;
    }
    @keyframes bossPulse {
      0%, 100% { box-shadow: 0 0 20px #ff0000; }
      50% { box-shadow: 0 0 40px #ff0000, 0 0 60px #ff4400; }
    }
    .map-node:hover:not(.locked):not(.hidden) {
      transform: translate(-50%, -50%) scale(1.3);
      box-shadow: 0 0 30px #00ffff;
      z-index: 20;
    }
    .map-node-label {
      position: absolute;
      bottom: -25px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 8px;
      color: #fff;
      text-shadow: 0 0 5px #000, 0 0 10px #000;
      white-space: nowrap;
      pointer-events: none;
    }
    
    /* Mission tracker panel */
    .mission-panel {
      position: absolute;
      top: 80px;
      right: 15px;
      width: 280px;
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid #ff8800;
      border-radius: 10px;
      padding: 15px;
      z-index: 25;
    }
    .mission-title {
      color: #ff8800;
      font-size: 14px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .mission-objective {
      color: #ffff00;
      font-size: 11px;
      margin-bottom: 8px;
      padding-left: 20px;
      position: relative;
    }
    .mission-objective::before {
      content: "‚ñ∂";
      position: absolute;
      left: 0;
      color: #00ffff;
    }
    .mission-hint {
      color: #888;
      font-size: 9px;
      font-style: italic;
      margin-top: 10px;
    }
    
    /* Region name display */
    .region-banner {
      position: absolute;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(90deg, transparent, rgba(0,0,0,0.9) 20%, rgba(0,0,0,0.9) 80%, transparent);
      padding: 15px 60px;
      z-index: 25;
      text-align: center;
    }
    .region-banner .region-name {
      font-size: 20px;
      color: #ffff00;
      text-shadow: 0 0 20px #ff8800;
    }
    .region-banner .region-desc {
      font-size: 10px;
      color: #aaa;
      margin-top: 5px;
    }
    
    @keyframes nodePulse {
      0%, 100% { box-shadow: 0 0 10px #00ffff; }
      50% { box-shadow: 0 0 25px #00ffff, 0 0 40px #00ffff; }
    }
    
    .map-hud {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      pointer-events: none;
      z-index: 30;
    }
    .map-hud > * { pointer-events: auto; }
    
    .map-info {
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid #00ffff;
      border-radius: 10px;
      padding: 15px 20px;
    }
    
    .map-currency {
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid #ffff00;
      border-radius: 10px;
      padding: 15px 20px;
      font-size: 14px;
    }
    
    /* Boss dialogue overlay */
    #bossDialogue {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 300;
    }
    #bossDialogue.active { display: flex; }
    
    .dialogue-box {
      background: linear-gradient(135deg, #1a0030 0%, #300050 100%);
      border: 4px solid #ff0000;
      border-radius: 20px;
      padding: 40px;
      max-width: 800px;
      text-align: center;
      animation: dialogueAppear 0.5s ease-out;
    }
    @keyframes dialogueAppear {
      from { transform: scale(0.8); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }
    .boss-portrait {
      font-size: 100px;
      margin-bottom: 20px;
      animation: bossFloat 2s ease-in-out infinite;
    }
    @keyframes bossFloat {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }
    .boss-name-dialogue {
      font-size: 28px;
      color: #ff0000;
      text-shadow: 0 0 20px #ff0000;
      margin-bottom: 15px;
    }
    .dialogue-text {
      font-family: 'Crimson Text', serif;
      font-size: 20px;
      color: #ffffff;
      line-height: 1.6;
      margin-bottom: 30px;
      font-style: italic;
    }
    .dialogue-continue {
      color: #00ffff;
      font-size: 14px;
      animation: blink 1s infinite;
    }
    
    /* Level Modal */
    #levelModal {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #1a0030 0%, #2a0050 100%);
      border: 4px solid #00ffff;
      border-radius: 20px;
      padding: 30px;
      display: none;
      flex-direction: column;
      align-items: center;
      z-index: 175;
      min-width: 400px;
    }
    #levelModal.active { display: flex; }
    
    /* Class Selection */
    #classSelection {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: linear-gradient(135deg, #0a0015 0%, #1a0030 100%);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 160;
      overflow-y: auto;
      padding: 20px;
    }
    #classSelection.active { display: flex; }
    
    .class-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      max-width: 1000px;
      width: 100%;
    }
    
    .class-card {
      background: linear-gradient(135deg, #1a1a3a 0%, #2a1a3a 100%);
      border: 3px solid #00ffff;
      border-radius: 15px;
      padding: 20px;
      cursor: pointer;
      transition: all 0.3s;
      position: relative;
    }
    .class-card:hover:not(.locked) {
      transform: translateY(-10px);
      box-shadow: 0 10px 30px rgba(0, 255, 255, 0.5);
    }
    .class-card.locked {
      opacity: 0.5;
      cursor: not-allowed;
      border-color: #666;
    }
    .class-card.locked::after {
      content: "üîí";
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 24px;
    }
    .class-icon { font-size: 48px; text-align: center; margin-bottom: 10px; }
    .class-name { font-size: 16px; text-align: center; margin-bottom: 10px; color: #ffff00; }
    .class-stats { font-size: 10px; color: #aaa; line-height: 1.6; }
    .class-unlock { font-size: 10px; color: #ff8800; text-align: center; margin-top: 10px; }
    
    /* Shop Screen */
    #shopScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      flex-direction: column;
      align-items: center;
      z-index: 150;
      overflow-y: auto;
      padding: 20px;
    }
    #shopScreen.active { display: flex; }
    
    .shop-tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }
    .shop-tab {
      padding: 12px 25px;
      font-size: 12px;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #00ffff;
      color: #00ffff;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
    }
    .shop-tab.active {
      background: #00ffff;
      color: #000;
    }
    
    .shop-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
      max-width: 1000px;
      width: 100%;
    }
    
    .shop-item {
      background: linear-gradient(135deg, #2a1a3a 0%, #3a2a4a 100%);
      border: 2px solid #00ffff;
      border-radius: 10px;
      padding: 15px;
      cursor: pointer;
      transition: all 0.3s;
    }
    .shop-item:hover:not(.maxed) {
      transform: scale(1.05);
      box-shadow: 0 5px 20px rgba(0, 255, 255, 0.5);
    }
    .shop-item.maxed {
      opacity: 0.6;
      cursor: not-allowed;
      border-color: #666;
    }
    .shop-item-name { font-size: 14px; color: #ffff00; margin-bottom: 5px; }
    .shop-item-desc { font-size: 10px; color: #aaa; margin-bottom: 10px; }
    .shop-item-cost { font-size: 12px; color: #ff8800; }
    
    /* Settings Screen */
    #settingsScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 150;
    }
    #settingsScreen.active { display: flex; }
    
    .settings-container {
      background: linear-gradient(135deg, #1a0030 0%, #2a0050 100%);
      border: 3px solid #ff8800;
      border-radius: 20px;
      padding: 40px;
      min-width: 500px;
    }
    
    .setting-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 25px;
      padding-bottom: 15px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .setting-label { font-size: 14px; color: #00ffff; }
    
    .setting-slider {
      width: 200px;
      height: 8px;
      -webkit-appearance: none;
      background: #333;
      border-radius: 4px;
      outline: none;
    }
    .setting-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      background: #00ffff;
      border-radius: 50%;
      cursor: pointer;
    }
    
    .setting-toggle {
      width: 60px;
      height: 30px;
      background: #333;
      border-radius: 15px;
      cursor: pointer;
      position: relative;
      transition: all 0.3s;
    }
    .setting-toggle.on { background: #00ff88; }
    .setting-toggle::after {
      content: '';
      position: absolute;
      width: 26px;
      height: 26px;
      background: white;
      border-radius: 50%;
      top: 2px;
      left: 2px;
      transition: all 0.3s;
    }
    .setting-toggle.on::after { left: 32px; }
    
    /* Redeem Code Screen */
    #redeemScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 150;
    }
    #redeemScreen.active { display: flex; }
    
    .redeem-container {
      background: linear-gradient(135deg, #1a0030 0%, #2a0050 100%);
      border: 3px solid #ff0088;
      border-radius: 20px;
      padding: 40px;
      text-align: center;
    }
    
    #redeemInput {
      font-family: 'Press Start 2P', monospace;
      font-size: 16px;
      padding: 15px 30px;
      background: rgba(0, 0, 0, 0.8);
      border: 3px solid #ff0088;
      border-radius: 10px;
      color: #ffff00;
      text-align: center;
      width: 350px;
      margin: 20px 0;
      outline: none;
      text-transform: uppercase;
    }
    
    #redeemMessage {
      font-size: 12px;
      margin-top: 15px;
      min-height: 20px;
    }
    
    /* Tutorial/How to Play Screen */
    #tutorialScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 150;
    }
    #tutorialScreen.active { display: flex; }
    
    .tutorial-container {
      background: linear-gradient(135deg, #1a0030 0%, #2a0050 100%);
      border: 3px solid #00ffff;
      border-radius: 20px;
      padding: 30px 50px;
      max-width: 700px;
      max-height: 80vh;
      overflow-y: auto;
    }
    
    .tutorial-section {
      margin-bottom: 25px;
      padding-bottom: 15px;
      border-bottom: 1px solid rgba(0, 255, 255, 0.3);
    }
    
    .tutorial-section:last-child {
      border-bottom: none;
    }
    
    .tutorial-title {
      font-size: 20px;
      color: #00ffff;
      margin-bottom: 15px;
      text-align: center;
    }
    
    .tutorial-subtitle {
      font-size: 14px;
      color: #ffff00;
      margin-bottom: 10px;
    }
    
    .tutorial-text {
      font-size: 10px;
      color: #aaa;
      line-height: 1.8;
    }
    
    .tutorial-controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    
    .control-item {
      background: rgba(0, 0, 0, 0.4);
      padding: 10px;
      border-radius: 8px;
      font-size: 10px;
    }
    
    .control-key {
      color: #00ff88;
      font-weight: bold;
    }
    
    /* Game Screen (Battle) */
    #gameScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: #0a0015;
      display: none;
      z-index: 140;
    }
    #gameScreen.active { display: block; }
    
    #gameCanvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    
    /* Pause Menu */
    #pauseMenu {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.95);
      border: 4px solid #ffff00;
      border-radius: 20px;
      padding: 40px;
      display: none;
      flex-direction: column;
      align-items: center;
      z-index: 145;
    }
    #pauseMenu.active { display: flex; }
    
    .pause-title {
      font-size: 32px;
      color: #ffff00;
      margin-bottom: 30px;
    }
    
    .pause-btn {
      padding: 15px 40px;
      font-size: 14px;
      margin: 10px;
      background: linear-gradient(135deg, #1a1a3a 0%, #2a1a4a 100%);
      color: #00ffff;
      border: 2px solid #00ffff;
      border-radius: 10px;
      cursor: pointer;
      min-width: 250px;
    }
    .pause-btn:hover {
      background: #00ffff;
      color: #000;
    }
    .pause-btn.quit { border-color: #ff0000; color: #ff0000; }
    .pause-btn.quit:hover { background: #ff0000; color: #fff; }
    
    /* Upgrade Screen */
    #upgradeScreen {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #1a0030 0%, #2a0050 100%);
      border: 4px solid #00ffff;
      border-radius: 20px;
      padding: 30px;
      display: none;
      flex-direction: column;
      align-items: center;
      z-index: 145;
    }
    #upgradeScreen.active { display: flex; }
    
    .upgrade-options {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .upgrade-card {
      background: linear-gradient(135deg, #2a1a3a 0%, #3a2a4a 100%);
      border: 3px solid #00ffff;
      border-radius: 15px;
      padding: 20px;
      width: 180px;
      cursor: pointer;
      transition: all 0.3s;
      text-align: center;
    }
    .upgrade-card:hover {
      transform: translateY(-10px);
      box-shadow: 0 10px 30px rgba(0, 255, 255, 0.5);
      border-color: #ffff00;
    }
    
    /* Game Over Screen */
    #gameOverScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 145;
    }
    #gameOverScreen.active { display: flex; }
    
    /* Boss Defeat Dialogue Modal */
    #bossDefeatDialogue {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 150;
      cursor: pointer;
    }
    #bossDefeatDialogue.active { display: flex; }
    
    .defeat-dialogue-box {
      background: linear-gradient(135deg, #1a0a2e, #16213e);
      border: 4px solid;
      border-radius: 15px;
      padding: 40px;
      max-width: 700px;
      width: 90%;
      box-shadow: 0 0 50px rgba(255, 255, 255, 0.3);
    }
    
    .defeat-dialogue-speaker {
      font-size: 20px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 15px;
    }
    
    .defeat-dialogue-text {
      font-size: 16px;
      line-height: 1.6;
      color: #fff;
      min-height: 60px;
    }
    
    .defeat-dialogue-continue {
      font-size: 12px;
      color: #aaa;
      margin-top: 30px;
      animation: blink 1s infinite;
    }
    
    /* Achievement Popup */
    #achievementPopup {
      position: fixed;
      top: 20px;
      right: -400px;
      width: 350px;
      background: linear-gradient(135deg, #1a0a2e, #2d1f4e);
      border: 3px solid #ffd700;
      border-radius: 15px;
      padding: 20px;
      z-index: 200;
      transition: right 0.5s ease;
      box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
    }
    #achievementPopup.show { right: 20px; }
    
    .achievement-popup-header {
      font-size: 14px;
      color: #ffd700;
      margin-bottom: 10px;
      text-align: center;
    }
    
    .achievement-popup-content {
      display: flex;
      align-items: center;
      gap: 15px;
    }
    
    .achievement-popup-icon {
      font-size: 40px;
      background: rgba(255, 215, 0, 0.2);
      border-radius: 10px;
      padding: 10px;
    }
    
    .achievement-popup-info h3 {
      color: #fff;
      font-size: 14px;
      margin-bottom: 5px;
    }
    
    .achievement-popup-info p {
      color: #aaa;
      font-size: 10px;
    }
    
    .achievement-popup-reward {
      margin-top: 10px;
      font-size: 11px;
      color: #00ff00;
      text-align: center;
    }
    
    /* Achievements Screen */
    #achievementsScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.98);
      display: none;
      flex-direction: column;
      align-items: center;
      z-index: 160;
      overflow-y: auto;
      padding: 30px;
    }
    #achievementsScreen.active { display: flex; }
    
    .achievements-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 15px;
      max-width: 1200px;
      width: 100%;
      margin-top: 20px;
    }
    
    .achievement-card {
      background: rgba(40, 40, 60, 0.8);
      border: 2px solid #444;
      border-radius: 10px;
      padding: 15px;
      display: flex;
      align-items: center;
      gap: 15px;
      transition: all 0.3s;
    }
    
    .achievement-card.unlocked {
      background: rgba(0, 100, 50, 0.3);
      border-color: #00ff00;
    }
    
    .achievement-card.locked {
      opacity: 0.5;
      filter: grayscale(0.8);
    }
    
    .achievement-card-icon {
      font-size: 35px;
      min-width: 50px;
      text-align: center;
    }
    
    .achievement-card-info h3 {
      font-size: 12px;
      color: #fff;
      margin-bottom: 5px;
    }
    
    .achievement-card-info p {
      font-size: 9px;
      color: #aaa;
    }
    
    .achievement-card-reward {
      font-size: 10px;
      color: #ffd700;
      margin-top: 5px;
    }
    
    /* Leaderboard Screen */
    #leaderboardScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.98);
      display: none;
      flex-direction: column;
      align-items: center;
      z-index: 160;
      overflow-y: auto;
      padding: 30px;
    }
    #leaderboardScreen.active { display: flex; }
    
    .leaderboard-container {
      display: flex;
      gap: 30px;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 20px;
      max-width: 1000px;
    }
    
    .leaderboard-section {
      background: linear-gradient(135deg, #1a0a2e, #16213e);
      border: 3px solid #00ffff;
      border-radius: 15px;
      padding: 25px;
      min-width: 350px;
    }
    
    .leaderboard-section h2 {
      font-size: 16px;
      color: #00ffff;
      margin-bottom: 20px;
      text-align: center;
      border-bottom: 2px solid #00ffff;
      padding-bottom: 10px;
    }
    
    .leaderboard-entry {
      display: flex;
      align-items: center;
      padding: 10px;
      margin-bottom: 8px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      border-left: 4px solid #666;
    }
    
    .leaderboard-entry.gold { border-left-color: #ffd700; background: rgba(255, 215, 0, 0.1); }
    .leaderboard-entry.silver { border-left-color: #c0c0c0; background: rgba(192, 192, 192, 0.1); }
    .leaderboard-entry.bronze { border-left-color: #cd7f32; background: rgba(205, 127, 50, 0.1); }
    
    .leaderboard-rank {
      font-size: 16px;
      min-width: 40px;
      color: #fff;
    }
    
    .leaderboard-name {
      flex: 1;
      font-size: 12px;
      color: #fff;
    }
    
    .leaderboard-class {
      font-size: 10px;
      color: #888;
      margin-left: 10px;
    }
    
    .leaderboard-score {
      font-size: 14px;
      color: #ffff00;
      font-weight: bold;
    }
    
    .leaderboard-empty {
      text-align: center;
      color: #666;
      font-size: 12px;
      padding: 20px;
    }
    
    /* Victory Screen */
    #victoryScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 145;
    }
    #victoryScreen.active { display: flex; }
    
    /* Potion Bar */
    #potionBar {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      gap: 10px;
      z-index: 143;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px 20px;
      border-radius: 15px;
      border: 3px solid #00ffff;
    }
    #potionBar.active { display: flex; }
    
    .potion-slot {
      width: 60px;
      height: 70px;
      background: rgba(40, 40, 40, 0.9);
      border: 2px solid #666;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    .potion-slot:hover:not(.cooldown) {
      transform: scale(1.1);
      border-color: #00ffff;
    }
    .potion-slot.cooldown { opacity: 0.5; cursor: not-allowed; }
    .potion-icon { font-size: 28px; }
    .potion-count { font-size: 12px; color: #ffff00; }
    .potion-key { position: absolute; top: 2px; left: 4px; font-size: 10px; color: #aaa; }
    
    /* Ability Bar */
    #abilityBar {
      position: absolute;
      bottom: 110px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      gap: 15px;
      z-index: 143;
      background: rgba(20, 0, 40, 0.9);
      padding: 12px 25px;
      border-radius: 15px;
      border: 3px solid #ff00ff;
      box-shadow: 0 0 20px rgba(255, 0, 255, 0.4);
    }
    #abilityBar.active { display: flex; }
    
    .ability-slot {
      width: 70px;
      height: 80px;
      background: linear-gradient(180deg, rgba(60, 0, 80, 0.9) 0%, rgba(30, 0, 50, 0.9) 100%);
      border: 2px solid #8800ff;
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    .ability-slot:hover {
      transform: scale(1.1);
      border-color: #ff00ff;
      box-shadow: 0 0 15px rgba(255, 0, 255, 0.6);
    }
    .ability-slot.cooldown { opacity: 0.5; cursor: not-allowed; }
    .ability-icon { font-size: 32px; }
    .ability-name { font-size: 8px; color: #ff88ff; margin-top: 4px; }
    .ability-key { position: absolute; top: 2px; left: 6px; font-size: 10px; color: #ff88ff; }
    
    /* Back Button */
    .back-btn {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #00ffff;
      color: #00ffff;
      font-size: 24px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s;
      z-index: 100;
    }
    .back-btn:hover {
      background: #00ffff;
      color: #000;
    }
    
    /* Generic button styles */
    .btn-primary {
      padding: 15px 40px;
      font-family: 'Press Start 2P', monospace;
      font-size: 12px;
      background: linear-gradient(135deg, #00ff88 0%, #00ffff 100%);
      color: #000;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
    }
    .btn-primary:hover {
      transform: scale(1.05);
      box-shadow: 0 0 20px #00ffff;
    }
    
    .btn-danger {
      padding: 15px 40px;
      font-family: 'Press Start 2P', monospace;
      font-size: 12px;
      background: linear-gradient(135deg, #ff4444 0%, #ff0000 100%);
      color: #fff;
      border: none;
      border-radius: 10px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <!-- Title Screen -->
    <div id="titleScreen">
      <div class="starfield" id="starfield"></div>
      <div class="title-logo">EVOL LEGENDS</div>
      <div class="title-subtitle">The Forgotten Warrior</div>
      <div class="title-tagline">A tale of memory, destiny, and eternal combat</div>
      <div class="press-start">‚Äî PRESS ANY KEY OR CLICK TO BEGIN ‚Äî</div>
    </div>
    
    <!-- Name Entry Screen -->
    <div id="nameScreen">
      <div class="name-quote">
        "In the realm where memories fade and legends are born,<br>
        a warrior awakens without name or past...<br>
        What shall you be called, brave soul?"
      </div>
      <div class="name-prompt">Enter Your Warrior Name</div>
      <input type="text" id="warriorNameInput" placeholder="Your Name" maxlength="20">
      <button class="name-confirm-btn" id="nameConfirmBtn">BEGIN YOUR LEGEND</button>
    </div>
    
    <!-- Main Menu -->
    <div id="mainMenu">
      <div class="menu-title">EVOL LEGENDS</div>
      <div class="menu-warrior-name">Welcome, <span id="menuWarriorName">Warrior</span></div>
      <div class="menu-buttons">
        <button class="menu-btn story-btn" id="storyModeBtn">üó∫Ô∏è STORY MODE</button>
        <button class="menu-btn endless-btn" id="endlessModeBtn">‚ôæÔ∏è ENDLESS MODE</button>
        <button class="menu-btn shop-btn" id="shopBtn">üõí SHOP</button>
        <button class="menu-btn" id="achievementsBtn" style="border-color: #ffd700; color: #ffd700;">üèÜ ACHIEVEMENTS</button>
        <button class="menu-btn" id="leaderboardBtn" style="border-color: #00ffff; color: #00ffff;">üèÖ LEADERBOARD</button>
        <button class="menu-btn settings-btn" id="settingsBtn">‚öôÔ∏è SETTINGS</button>
        <button class="menu-btn redeem-btn" id="redeemBtn">üéÅ REDEEM CODE</button>
        <button class="menu-btn" id="tutorialBtn" style="border-color: #00ffff; color: #00ffff;">üìñ HOW TO PLAY</button>
      </div>
      <div class="menu-stats">
        <div>üí∞ Coins: <span id="menuCoins">0</span></div>
        <div>üíé Gems: <span id="menuGems">0</span></div>
        <div>üèÜ Highest Wave: <span id="menuHighWave">1</span></div>
        <div>üìä Progress: <span id="menuProgress">0</span>%</div>
      </div>
    </div>
    
    <!-- Overworld Map -->
    <div id="overworldMap">
      <!-- IMPORTANT: Place your map image in games/story-map.png or update the src below -->
      <img id="mapImage" src="story-map.png" alt="Overworld Map" onerror="this.style.display='none'">
      <canvas id="fogCanvas" class="fog-overlay"></canvas>
      <svg class="map-connections" id="mapConnections"></svg>
      <div class="player-marker" id="playerMarker"></div>
      <div class="map-hud">
        <div class="map-info">
          <div style="color: #ffff00; font-size: 14px; margin-bottom: 5px;">üìç <span id="mapRegion">Beginner Village</span></div>
          <div style="color: #aaa; font-size: 10px;">üó∫Ô∏è Story Progress: <span id="mapProgress">0</span>%</div>
        </div>
        <div class="map-currency">
          <div>üí∞ <span id="mapCoins">0</span></div>
          <div>üíé <span id="mapGems">0</span></div>
        </div>
      </div>
      <div class="mission-panel" id="missionPanel">
        <div class="mission-title">üìã CURRENT MISSION</div>
        <div class="mission-objective" id="missionObjective">Defeat the Shadow Beast</div>
        <div class="mission-hint" id="missionHint">Tip: Follow the glowing path to your next objective!</div>
      </div>
      <div class="region-banner" id="regionBanner">
        <div class="region-name" id="regionName">Beginner Village</div>
        <div class="region-desc" id="regionDesc">Where every legend begins...</div>
      </div>
      <button class="back-btn" id="mapBackBtn">‚Üê</button>
      <div id="mapNodes"></div>
    </div>
    
    <!-- Boss Dialogue -->
    <div id="bossDialogue">
      <div class="dialogue-box">
        <div class="boss-portrait" id="bossPortrait">üëπ</div>
        <div class="boss-name-dialogue" id="bossNameDialogue">Unknown Boss</div>
        <div class="dialogue-text" id="dialogueText">"Prepare yourself, warrior..."</div>
        <div class="dialogue-continue">[ Press SPACE or Click to Continue ]</div>
      </div>
    </div>
    
    <!-- Level Modal -->
    <div id="levelModal">
      <div style="font-size: 24px; color: #00ffff; margin-bottom: 10px;" id="levelName">Forest Path</div>
      <div style="font-size: 14px; color: #888; margin-bottom: 15px;" id="levelDesc">A peaceful path through the forest...</div>
      <div style="color: #ffff00; margin-bottom: 10px;">‚≠ê Difficulty: <span id="levelDifficulty">1</span>/10</div>
      <div style="color: #00ff88; margin-bottom: 20px;">üí∞ Rewards: <span id="levelRewards">50 coins</span></div>
      <div style="display: flex; gap: 15px;">
        <button class="btn-primary" id="enterLevelBtn">‚öîÔ∏è ENTER BATTLE</button>
        <button class="btn-danger" id="cancelLevelBtn">CANCEL</button>
      </div>
    </div>
    
    <!-- Class Selection -->
    <div id="classSelection">
      <button class="back-btn" id="classBackBtn">‚Üê</button>
      <div style="font-size: 28px; color: #00ffff; margin-bottom: 10px;">SELECT YOUR LEGEND</div>
      <div style="font-size: 12px; color: #ffff00; margin-bottom: 30px;" id="classSubtitle">Choose your class to begin!</div>
      <div class="class-grid" id="classGrid"></div>
    </div>
    
    <!-- Shop Screen -->
    <div id="shopScreen">
      <button class="back-btn" id="shopBackBtn">‚Üê</button>
      <div style="font-size: 28px; color: #ffff00; margin-bottom: 10px;">üõí MERCHANT'S GUILD</div>
      <div style="font-size: 14px; color: #00ffff; margin-bottom: 20px;">
        üí∞ <span id="shopCoins">0</span> Coins | üíé <span id="shopGems">0</span> Gems
      </div>
      <div class="shop-tabs">
        <button class="shop-tab active" data-tab="upgrades">‚¨ÜÔ∏è Upgrades</button>
        <button class="shop-tab" data-tab="potions">üß™ Potions</button>
        <button class="shop-tab" data-tab="classes">üé≠ Classes</button>
        <button class="shop-tab" data-tab="cosmetics">‚ú® Cosmetics</button>
      </div>
      <div class="shop-grid" id="shopGrid"></div>
    </div>
    
    <!-- Settings Screen -->
    <div id="settingsScreen">
      <button class="back-btn" id="settingsBackBtn">‚Üê</button>
      <div class="settings-container">
        <div style="font-size: 24px; color: #ff8800; text-align: center; margin-bottom: 30px;">‚öôÔ∏è SETTINGS</div>
        
        <div class="setting-row">
          <span class="setting-label">üîä Music Volume</span>
          <input type="range" class="setting-slider" id="musicVolume" min="0" max="100" value="70">
        </div>
        
        <div class="setting-row">
          <span class="setting-label">üîà SFX Volume</span>
          <input type="range" class="setting-slider" id="sfxVolume" min="0" max="100" value="80">
        </div>
        
        <div class="setting-row">
          <span class="setting-label">üéØ Auto-Shoot</span>
          <div class="setting-toggle on" id="autoShootToggle"></div>
        </div>
        
        <div class="setting-row">
          <span class="setting-label">üéØ Auto-Aim</span>
          <div class="setting-toggle on" id="autoAimToggle"></div>
        </div>
        
        <div class="setting-row">
          <span class="setting-label">üì∫ Screen Shake</span>
          <div class="setting-toggle on" id="screenShakeToggle"></div>
        </div>
        
        <div class="setting-row">
          <span class="setting-label">‚ö° Show Damage Numbers</span>
          <div class="setting-toggle on" id="damageNumbersToggle"></div>
        </div>
        
        <div style="text-align: center; margin-top: 20px;">
          <button class="btn-danger" id="resetDataBtn">üóëÔ∏è RESET ALL DATA</button>
        </div>
      </div>
    </div>
    
    <!-- Redeem Code Screen -->
    <div id="redeemScreen">
      <button class="back-btn" id="redeemBackBtn">‚Üê</button>
      <div class="redeem-container">
        <div style="font-size: 24px; color: #ff0088; margin-bottom: 20px;">üéÅ REDEEM CODE</div>
        <div style="font-size: 12px; color: #aaa; margin-bottom: 20px;">Enter a valid code to receive rewards!</div>
        <input type="text" id="redeemInput" placeholder="ENTER CODE">
        <br>
        <button class="btn-primary" id="redeemSubmitBtn">REDEEM</button>
        <div id="redeemMessage"></div>
      </div>
    </div>
    
    <!-- Tutorial/How to Play Screen -->
    <div id="tutorialScreen">
      <button class="back-btn" id="tutorialBackBtn">‚Üê</button>
      <div class="tutorial-container">
        <div class="tutorial-title">üìñ HOW TO PLAY</div>
        
        <div class="tutorial-section">
          <div class="tutorial-subtitle">üéÆ CONTROLS</div>
          <div class="tutorial-controls">
            <div class="control-item"><span class="control-key">WASD / Arrow Keys</span> - Move your character</div>
            <div class="control-item"><span class="control-key">Mouse</span> - Aim (with Auto-Aim off)</div>
            <div class="control-item"><span class="control-key">Q / E</span> - Use Ultimate Abilities</div>
            <div class="control-item"><span class="control-key">1-6</span> - Use Potions</div>
            <div class="control-item"><span class="control-key">R</span> - Toggle Auto-Start Waves</div>
            <div class="control-item"><span class="control-key">F</span> - Toggle Game Speed (1x/2x)</div>
            <div class="control-item"><span class="control-key">ESC</span> - Pause Game</div>
            <div class="control-item"><span class="control-key">G</span> - Give Up (End Run)</div>
          </div>
        </div>
        
        <div class="tutorial-section">
          <div class="tutorial-subtitle">‚öîÔ∏è GAMEPLAY</div>
          <div class="tutorial-text">
            ‚Ä¢ Survive waves of enemies in Story Mode or Endless Mode<br>
            ‚Ä¢ Defeat enemies to gain XP and level up<br>
            ‚Ä¢ Choose upgrades when you level up to get stronger<br>
            ‚Ä¢ Use potions strategically - they have cooldowns!<br>
            ‚Ä¢ Unlock new classes by progressing through the story<br>
            ‚Ä¢ Purchase upgrades and cosmetics from the shop
          </div>
        </div>
        
        <div class="tutorial-section">
          <div class="tutorial-subtitle">üß™ POTIONS</div>
          <div class="tutorial-text">
            [1] ‚ù§Ô∏è Heal - Restore HP<br>
            [2] üõ°Ô∏è Shield - Gain temporary shield<br>
            [3] üí• Crit - 100% crit chance for 5s<br>
            [4] ‚öîÔ∏è Damage - Double damage for 5s<br>
            [5] ‚ö° Speed - Double attack speed for 5s<br>
            [6] üêâ Dragon - Powerful fire breath attack
          </div>
        </div>
        
        <div class="tutorial-section">
          <div class="tutorial-subtitle">üé≠ CLASSES</div>
          <div class="tutorial-text">
            Each class has unique stats and two Ultimate Abilities.<br>
            Unlock more classes by completing Story Mode levels!<br>
            Some classes can be purchased from the shop.
          </div>
        </div>
        
        <button class="btn-primary" id="tutorialCloseBtn">GOT IT!</button>
      </div>
    </div>
    
    <!-- Game Screen -->
    <div id="gameScreen">
      <canvas id="gameCanvas" width="1200" height="700"></canvas>
    </div>
    
    <!-- Pause Menu -->
    <div id="pauseMenu">
      <div class="pause-title">‚è∏Ô∏è PAUSED</div>
      <button class="pause-btn" id="resumeBtn">‚ñ∂Ô∏è RESUME</button>
      <button class="pause-btn" id="restartBtn">üîÑ RESTART</button>
      <button class="pause-btn quit" id="quitBtn">üö™ QUIT TO MENU</button>
    </div>
    
    <!-- Upgrade Screen -->
    <div id="upgradeScreen">
      <div style="font-size: 24px; color: #ffff00; margin-bottom: 10px;">üéâ LEVEL UP!</div>
      <div style="font-size: 12px; color: #00ffff; margin-bottom: 20px;">Choose Your Power-Up</div>
      <div class="upgrade-options" id="upgradeOptions"></div>
      <button id="shuffleUpgradesBtn" style="margin-top: 15px; padding: 10px 20px; font-family: 'Press Start 2P', monospace; font-size: 10px; background: rgba(255, 136, 0, 0.8); color: #fff; border: 2px solid #ff8800; border-radius: 8px; cursor: pointer;">üîÄ SHUFFLE (<span id="shufflesCount">4</span> left)</button>
    </div>
    
    <!-- Game Over Screen -->
    <div id="gameOverScreen">
      <div style="font-size: 48px; color: #ff0000; margin-bottom: 30px;">üíÄ GAME OVER üíÄ</div>
      <div style="background: rgba(20, 20, 20, 0.8); border: 3px solid #00ffff; border-radius: 15px; padding: 30px; margin-bottom: 20px;">
        <div style="font-size: 16px; margin-bottom: 15px;">üåä Wave Reached: <span id="finalWave" style="color: #ffff00;">1</span></div>
        <div style="font-size: 16px; margin-bottom: 15px;">‚≠ê Level Reached: <span id="finalLevel" style="color: #ffff00;">1</span></div>
        <div style="font-size: 16px; margin-bottom: 15px;">üíÄ Enemies Killed: <span id="finalKills" style="color: #ffff00;">0</span></div>
      </div>
      <div style="background: rgba(255, 215, 0, 0.1); border: 3px solid #ffff00; border-radius: 15px; padding: 20px; margin-bottom: 20px;">
        <div style="font-size: 14px; margin-bottom: 10px;">üí∞ Coins Earned: <span id="earnedCoins" style="color: #ffff00;">0</span></div>
        <div style="font-size: 14px;">üíé Gems Earned: <span id="earnedGems" style="color: #00ffff;">0</span></div>
      </div>
      <button class="btn-primary" id="gameOverContinueBtn">RETURN TO MENU</button>
    </div>
    
    <!-- Victory Screen -->
    <div id="victoryScreen">
      <div style="font-size: 48px; color: #00ff00; margin-bottom: 30px;">üéâ VICTORY! üéâ</div>
      <div style="font-size: 16px; color: #ffff00; margin-bottom: 30px;" id="victoryMessage">Level Complete!</div>
      <div style="background: rgba(0, 255, 0, 0.1); border: 3px solid #00ff00; border-radius: 15px; padding: 20px; margin-bottom: 20px;">
        <div style="font-size: 14px; margin-bottom: 10px;">üí∞ Coins Earned: <span id="victoryCoins" style="color: #ffff00;">0</span></div>
        <div style="font-size: 14px;">üíé Gems Earned: <span id="victoryGems" style="color: #00ffff;">0</span></div>
      </div>
      <button class="btn-primary" id="victoryContinueBtn">CONTINUE</button>
    </div>
    
    <!-- Boss Defeat Dialogue Modal -->
    <div id="bossDefeatDialogue">
      <div class="defeat-dialogue-box" id="defeatDialogueBox">
        <div class="defeat-dialogue-speaker" id="defeatDialogueSpeaker">
          <span id="defeatDialogueIcon"></span>
          <span id="defeatDialogueName"></span>
        </div>
        <div class="defeat-dialogue-text" id="defeatDialogueText"></div>
        <div class="defeat-dialogue-continue">‚ñ∂ Click or press any key to continue...</div>
      </div>
    </div>
    
    <!-- Achievement Popup -->
    <div id="achievementPopup">
      <div class="achievement-popup-header">üèÜ ACHIEVEMENT UNLOCKED!</div>
      <div class="achievement-popup-content">
        <div class="achievement-popup-icon" id="achievementPopupIcon"></div>
        <div class="achievement-popup-info">
          <h3 id="achievementPopupName"></h3>
          <p id="achievementPopupDesc"></p>
        </div>
      </div>
      <div class="achievement-popup-reward" id="achievementPopupReward"></div>
    </div>
    
    <!-- Achievements Screen -->
    <div id="achievementsScreen">
      <div style="font-size: 32px; color: #ffd700; margin-bottom: 10px;">üèÜ ACHIEVEMENTS üèÜ</div>
      <div style="font-size: 12px; color: #aaa; margin-bottom: 20px;" id="achievementsProgress">0 / 0 Unlocked</div>
      <div class="achievements-grid" id="achievementsGrid"></div>
      <button class="btn-primary" style="margin-top: 30px;" id="achievementsCloseBtn">CLOSE</button>
    </div>
    
    <!-- Leaderboard Screen -->
    <div id="leaderboardScreen">
      <div style="font-size: 32px; color: #00ffff; margin-bottom: 10px;">üèÖ LEADERBOARD üèÖ</div>
      <div style="font-size: 12px; color: #aaa; margin-bottom: 20px;">Local Rankings - No Bots Allowed!</div>
      <div class="leaderboard-container">
        <div class="leaderboard-section">
          <h2>üåä HIGHEST WAVE</h2>
          <div id="leaderboardWaves"></div>
        </div>
        <div class="leaderboard-section">
          <h2>üíÄ MOST KILLS</h2>
          <div id="leaderboardKills"></div>
        </div>
      </div>
      <button class="btn-primary" style="margin-top: 30px;" id="leaderboardCloseBtn">CLOSE</button>
    </div>
    
    <!-- Potion Bar -->
    <div id="potionBar">
      <div class="potion-slot" data-type="heal">
        <div class="potion-key">[1]</div>
        <div class="potion-icon">‚ù§Ô∏è</div>
        <div class="potion-count" id="potionHealCount">3</div>
      </div>
      <div class="potion-slot" data-type="shield">
        <div class="potion-key">[2]</div>
        <div class="potion-icon">üõ°Ô∏è</div>
        <div class="potion-count" id="potionShieldCount">2</div>
      </div>
      <div class="potion-slot" data-type="crit">
        <div class="potion-key">[3]</div>
        <div class="potion-icon">üí•</div>
        <div class="potion-count" id="potionCritCount">1</div>
      </div>
      <div class="potion-slot" data-type="damage">
        <div class="potion-key">[4]</div>
        <div class="potion-icon">‚öîÔ∏è</div>
        <div class="potion-count" id="potionDamageCount">1</div>
      </div>
      <div class="potion-slot" data-type="speed">
        <div class="potion-key">[5]</div>
        <div class="potion-icon">‚ö°</div>
        <div class="potion-count" id="potionSpeedCount">1</div>
      </div>
      <div class="potion-slot" data-type="dragon">
        <div class="potion-key">[6]</div>
        <div class="potion-icon">üêâ</div>
        <div class="potion-count" id="potionDragonCount">1</div>
      </div>
    </div>
    
    <!-- Ability Bar -->
    <div id="abilityBar">
      <div class="ability-slot" onclick="useAbility('ult1')">
        <div class="ability-key">[Q]</div>
        <div class="ability-icon" id="ability1">üèπ</div>
        <div class="ability-name" id="ability1Name">Ultimate 1</div>
      </div>
      <div class="ability-slot" onclick="useAbility('ult2')">
        <div class="ability-key">[E]</div>
        <div class="ability-icon" id="ability2">üéØ</div>
        <div class="ability-name" id="ability2Name">Ultimate 2</div>
      </div>
    </div>
  </div>

<script>
// ==================== GAME DATA ====================
const DEFAULT_GAME_DATA = {
  warriorName: "",
  selectedClass: "Hunter",
  totalCoins: 0,
  totalGems: 0,
  storyProgress: 0,
  completedNodes: [],
  unlockedNodes: ["start"],
  currentRegion: "Beginner Village",
  playerPosition: "start",
  keyShards: { water: false, fire: false },
  unlockedClasses: ["Hunter", "Knight", "Assassin"], // STARTERS: Hunter, Knight, Assassin
  purchasedClasses: [],
  highestWave: 1,
  // Achievement Stats Tracking
  totalKills: 0,
  totalCoinsEarned: 0,
  bossKills: 0,
  storyNodesCompleted: 0,
  defeatedBosses: [],
  classesUnlocked: 3,
  highestCombo: 0,
  unlockedAchievements: [],
  permanentUpgrades: {
    damage: 0, health: 0, fireRate: 0, critChance: 0, coinMultiplier: 0, xpMultiplier: 0
  },
  potionUpgrades: {
    healStrength: 0, shieldStrength: 0, startingHeals: 0, startingShields: 0, potionGen: 0
  },
  potionInventory: {
    heal: 5, shield: 3, crit: 2, damage: 2, speed: 2, dragon: 1
  },
  cosmetics: {
    playerSkin: "default",
    attackEffect: "default",
    unlockedSkins: ["default"],
    unlockedEffects: ["default"]
  },
  redeemedCodes: [],
  settings: {
    musicVolume: 70,
    sfxVolume: 80,
    autoShoot: true,
    autoAim: true,
    screenShake: true,
    damageNumbers: true
  }
};

let gameData = JSON.parse(JSON.stringify(DEFAULT_GAME_DATA));

// ==================== CLASSES ====================
const CLASSES = {
  // STARTER CLASSES
  Hunter: {
    icon: "üèπ", color: "#00ff88", unlockWave: 0, purchasable: false,
    stats: { maxHP: 100, damage: 10, fireRate: 0.8, range: 650, projectileSpeed: 8 },
    description: "Balanced starter class. The classic choice."
  },
  Knight: {
    icon: "‚öîÔ∏è", color: "#4488ff", unlockWave: 0, purchasable: false,
    stats: { maxHP: 140, damage: 14, fireRate: 1.111, range: 400, projectileSpeed: 6.5 },
    description: "Durable frontline fighter with slower heavy shots."
  },
  Assassin: {
    icon: "üó°Ô∏è", color: "#ff00ff", unlockWave: 0, purchasable: false,
    stats: { maxHP: 95, damage: 9, fireRate: 0.357, range: 400, projectileSpeed: 9.5 },
    description: "Ultra-fast glass cannon. Speed kills!"
  },
  Rookie: {
    icon: "üéØ", color: "#cccccc", unlockWave: 0, purchasable: false,
    stats: { maxHP: 80, damage: 6, fireRate: 1.25, range: 350, projectileSpeed: 6, xpMultiplier: 1.5, powerUpMultiplier: 1.2 },
    description: "Beginner class that levels up 50% faster and gets 20% better upgrades."
  },
  
  // UNLOCKABLE BY WAVE
  Thief: {
    icon: "ü•∑", color: "#4a0080", unlockWave: 15, purchasable: false,
    stats: { maxHP: 85, damage: 8, fireRate: 0.455, range: 350, projectileSpeed: 8, coinMultiplier: 5, gemMultiplier: 5 },
    description: "Fast dagger-throwing class! Earns 5x coins and gems!"
  },
  Archer: {
    icon: "üéØ", color: "#228b22", unlockWave: 20, purchasable: false,
    stats: { maxHP: 90, damage: 12, fireRate: 0.556, range: 700, projectileSpeed: 10, pierce: true },
    description: "Rapid-firing ranged attacker with piercing shots."
  },
  Engineer: {
    icon: "üîß", color: "#FF8C00", unlockWave: 25, purchasable: false,
    stats: { maxHP: 95, damage: 7, fireRate: 1.0, range: 450, projectileSpeed: 7, turretClass: true, maxTurrets: 3 },
    description: "Deploys defensive turrets with specialized abilities."
  },
  Ranger: {
    icon: "üèπ", color: "#2F4F2F", unlockWave: 25, purchasable: false,
    stats: { maxHP: 95, damage: 20, fireRate: 0.769, range: 750, projectileSpeed: 11, pierce: true, trackingShots: true },
    description: "Forest tracker with piercing long-range arrows."
  },
  Mage: {
    icon: "üßô", color: "#9932cc", unlockWave: 30, purchasable: false,
    stats: { maxHP: 90, damage: 32, fireRate: 1.667, range: 600, projectileSpeed: 6, magicMissiles: true },
    description: "Basic wizard with high-damage magic missiles."
  },
  Berserk: {
    icon: "ü™ì", color: "#8B0000", unlockWave: 40, purchasable: false,
    stats: { maxHP: 150, damage: 25, fireRate: 0.667, range: 350, projectileSpeed: 9, rageMode: true },
    description: "Wild berserker - stronger when damaged!"
  },
  Pyromancer: {
    icon: "üî•", color: "#ff4500", unlockWave: 45, purchasable: false,
    stats: { maxHP: 90, damage: 22, fireRate: 0.909, range: 550, projectileSpeed: 7, burnDamage: true },
    description: "Burns enemies over time with flame shots."
  },
  Samurai: {
    icon: "‚öîÔ∏è", color: "#C0C0C0", unlockWave: 50, purchasable: false,
    stats: { maxHP: 110, damage: 28, fireRate: 0.909, range: 450, projectileSpeed: 10, critBonus: 1.0 },
    description: "Honor-bound warrior with devastating crits."
  },
  Druid: {
    icon: "üåø", color: "#228B22", unlockWave: 60, purchasable: false,
    stats: { maxHP: 120, damage: 18, fireRate: 1.0, range: 500, projectileSpeed: 7, summonSpirits: true, healOverTime: 1 },
    description: "Nature caster with spirits and healing."
  },
  Summoner: {
    icon: "‚ú®", color: "#88ff88", unlockWave: 65, purchasable: false,
    stats: { maxHP: 110, damage: 12, fireRate: 1.0, range: 500, projectileSpeed: 7 },
    description: "Summons spirit helpers to assist with damage."
  },
  LightningRanger: {
    icon: "‚ö°", color: "#ffd700", unlockWave: 75, purchasable: false,
    stats: { maxHP: 105, damage: 28, fireRate: 1.176, range: 600, projectileSpeed: 9, chainLightning: 3 },
    description: "Electric shots chain between enemies."
  },
  ShadowMonk: {
    icon: "ü•ã", color: "#2f4f4f", unlockWave: 85, purchasable: false,
    stats: { maxHP: 110, damage: 20, fireRate: 0.714, range: 300, projectileSpeed: 8, knockback: 40, critBonus: 0.5 },
    description: "Crit-focused martial artist with knockback."
  },
  DarkMagician: {
    icon: "üîÆ", color: "#8800ff", unlockWave: 95, purchasable: false,
    stats: { maxHP: 85, damage: 35, fireRate: 1.818, range: 550, projectileSpeed: 5.5, explosive: true },
    description: "Slow but extremely powerful caster."
  },
  TrickshotRogue: {
    icon: "üé≤", color: "#ff1493", unlockWave: 100, purchasable: false,
    stats: { maxHP: 80, damage: 35, fireRate: 1.0, range: 600, projectileSpeed: 9, ricochetShots: 2 },
    description: "Ricocheting shots with burst potential."
  },
  AstralGolem: {
    icon: "üóø", color: "#708090", unlockWave: 120, purchasable: false,
    stats: { maxHP: 400, damage: 22, fireRate: 1.818, range: 500, projectileSpeed: 5, damageReduction: 0.30 },
    description: "Massive tank with heavy star projectiles."
  },
  
  // PURCHASABLE CLASSES
  Bomber: {
    icon: "üí£", color: "#ff8800", unlockWave: 0, purchasable: true,
    cost: { coins: 500, gems: 2 },
    stats: { maxHP: 130, damage: 30, fireRate: 1.2, range: 500, projectileSpeed: 6, explosive: true, explosionRadius: 120 },
    description: "Massive AOE explosions! 3x direct hit, 3x AOE blast damage!"
  },
  Shadowblade: {
    icon: "‚öîÔ∏è", color: "#000000", unlockWave: 0, purchasable: true,
    cost: { coins: 5000, gems: 0 },
    stats: { maxHP: 100, damage: 12, fireRate: 0.526, range: 400, projectileSpeed: 8, curseOnHit: true, critBonus: 0.75 },
    description: "Curses enemies and deals bonus crit damage."
  },
  Sniper: {
    icon: "üî≠", color: "#00ffff", unlockWave: 0, purchasable: true,
    cost: { coins: 15000, gems: 150 },
    stats: { maxHP: 100, damage: 45, fireRate: 2.222, range: 900, projectileSpeed: 12, alwaysCrit: true },
    description: "Highest single-hit damage. Very slow fire rate."
  },
  PlagueDoctor: {
    icon: "ü¶†", color: "#32cd32", unlockWave: 0, purchasable: true,
    cost: { coins: 20000, gems: 200 },
    stats: { maxHP: 100, damage: 16, fireRate: 0.833, range: 500, projectileSpeed: 7, stackingPoison: true, poisonSpread: true },
    description: "Applies stacking poison that spreads."
  },
  Necromancer: {
    icon: "üíÄ", color: "#9933ff", unlockWave: 0, purchasable: true,
    cost: { coins: 25000, gems: 250 },
    stats: { maxHP: 105, damage: 15, fireRate: 1.111, range: 550, projectileSpeed: 7, poison: true, spawnSkeletonsOnKill: true },
    description: "Poisons enemies and raises skeletons."
  },
  Gunslinger: {
    icon: "ü§†", color: "#8B4513", unlockWave: 0, purchasable: true,
    cost: { coins: 30000, gems: 300 },
    stats: { maxHP: 100, damage: 15, fireRate: 0.333, range: 550, projectileSpeed: 12, dualWield: true, ricochetChance: 0.3 },
    description: "Western shooter with dual pistols and ricochets."
  },
  CrystalGuardian: {
    icon: "üíé", color: "#9370db", unlockWave: 0, purchasable: true,
    cost: { coins: 40000, gems: 350 },
    stats: { maxHP: 160, damage: 12, fireRate: 1.25, range: 500, projectileSpeed: 6, startingShield: 250, reflectDamage: 0.15 },
    description: "Crystal energy bolts and reflect defense."
  },
  Warlock: {
    icon: "üëπ", color: "#4B0082", unlockWave: 0, purchasable: true,
    cost: { coins: 50000, gems: 500 },
    stats: { maxHP: 95, damage: 20, fireRate: 1.111, range: 550, projectileSpeed: 7, curseShots: true, lifesteal: 0.2 },
    description: "Dark sorcerer with curses and life drain."
  },
  Illusionist: {
    icon: "üé≠", color: "#9370DB", unlockWave: 0, purchasable: true,
    cost: { coins: 75000, gems: 750 },
    stats: { maxHP: 110, damage: 12, fireRate: 0.909, range: 550, projectileSpeed: 7.5, createClone: true },
    description: "Master of illusions - creates a fighting clone."
  },
  DrEclipse: {
    icon: "üåô", color: "#2C1E4A", unlockWave: 0, purchasable: true,
    cost: { coins: 100000, gems: 1000 },
    stats: { maxHP: 115, damage: 18, fireRate: 1.111, range: 600, projectileSpeed: 7, knockback: 25, moonControl: true },
    description: "Controls a moon that lifts enemies and slams them."
  },
  Vecna: {
    icon: "üëÅÔ∏è", color: "#8B0000", unlockWave: 0, purchasable: true,
    cost: { coins: 10000000, gems: 10000 },
    stats: { maxHP: 110, damage: 18, fireRate: 1.333, range: 600, projectileSpeed: 7.5, summonMonsters: true, enemyConversion: 0.2 },
    description: "Converts enemies, summons monsters. Ultimate power.",
    special: "monsters"
  },
  
  // ACHIEVEMENT/CHALLENGE UNLOCKS
  CryoSentinel: {
    icon: "‚ùÑÔ∏è", color: "#00bfff", unlockWave: 0, purchasable: false,
    achievementUnlock: "freeze100",
    stats: { maxHP: 120, damage: 14, fireRate: 1.053, range: 500, projectileSpeed: 6.5, slowOnHit: 0.5, freezeChance: 0.1 },
    description: "Ice shots slow enemies. Unlock: Freeze 100 enemies."
  },
  BloodReaver: {
    icon: "ü©∏", color: "#8b0000", unlockWave: 0, purchasable: false,
    achievementUnlock: "defeat3Elites",
    stats: { maxHP: 140, damage: 18, fireRate: 1.0, range: 450, projectileSpeed: 7, lifesteal: 0.15, bleedDamage: true },
    description: "Lifesteal and bleed. Unlock: Defeat 3 elite enemies."
  },
  ArcWarden: {
    icon: "‚ö°", color: "#4169e1", unlockWave: 0, purchasable: false,
    achievementUnlock: "collect5ArcCores",
    stats: { maxHP: 95, damage: 30, fireRate: 1.429, range: 550, projectileSpeed: 7.5, stunChance: 0.15 },
    description: "Electric cannon with stun. Unlock: Collect 5 Arc Cores."
  },
  HolyCleric: {
    icon: "‚úùÔ∏è", color: "#ffd700", unlockWave: 0, purchasable: false,
    achievementUnlock: "heal1000HP",
    stats: { maxHP: 150, damage: 10, fireRate: 0.909, range: 500, projectileSpeed: 6.5, healOnHit: 2 },
    description: "Heals on hit. Unlock: Heal 1000 total HP."
  },
  Starcaller: {
    icon: "üåü", color: "#9400d3", unlockWave: 0, purchasable: false,
    achievementUnlock: "fallingStarDrop",
    stats: { maxHP: 115, damage: 18, fireRate: 1.0, range: 550, projectileSpeed: 7, gravityPull: true },
    description: "Cosmic caster with gravity. Unlock: Rare drop."
  },
  VoidAssassin: {
    icon: "üåë", color: "#191970", unlockWave: 0, purchasable: false,
    achievementUnlock: "kill100In10Sec",
    stats: { maxHP: 90, damage: 40, fireRate: 1.111, range: 450, projectileSpeed: 8.5, voidStrike: true, invulnFrames: 0.5 },
    description: "High crit void strikes. Unlock: Kill 100 in 10 sec."
  },
  GuardianTank: {
    icon: "üõ°Ô∏è", color: "#4169e1", unlockWave: 0, purchasable: false,
    achievementUnlock: "5ShieldUpgradesHP200",
    stats: { maxHP: 180, damage: 35, fireRate: 2.0, range: 500, projectileSpeed: 4.5, knockback: 80, projectileSize: 24 },
    description: "Throws massive shields. Unlock: 5 shield upgrades + HP > 200."
  },
  TheForsakenOne: {
    icon: "üíÄ", color: "#4B0082", unlockWave: 0, purchasable: false,
    challengeUnlock: "rejectAllPowerups",
    stats: { maxHP: 115, damage: 17, fireRate: 0.741, range: 500, projectileSpeed: 7.5, knockback: 1.5, cursedFlux: true },
    description: "Chaos power! Unlock: Reject all powerups, survive wave 11."
  },
  DrSunshine: {
    icon: "‚òÄÔ∏è", color: "#FFD700", unlockWave: 0, purchasable: false,
    challengeUnlock: "wave18Restart7Times",
    stats: { maxHP: 120, damage: 15, fireRate: 1.0, range: 600, projectileSpeed: 7, miniSun: true, sunDamage: 25 },
    description: "Controls a mini sun. Unlock: Restart at wave 18, 7 times."
  },
  EvolLegend: {
    icon: "üåå", color: "#000000", unlockWave: 0, purchasable: false,
    codeUnlock: "ZVBLUE",
    stats: { maxHP: 130, damage: 100, fireRate: 3.0, range: 700, projectileSpeed: 6, blackHoleShots: true },
    description: "Legendary cosmic being with black hole shots. Code: ZVBLUE."
  }
};

// ==================== SKILL TREES (ULTIMATES) ====================
const SKILL_TREES = {
  // STARTER CLASSES
  Hunter: {
    ult1: { name: "Rapid Barrage", icon: "üèπ", desc: "Fire 8 shots in rapid succession", cooldown: 12, type: "active" },
    ult2: { name: "Hunters Mark", icon: "üéØ", desc: "Mark target for 200% damage for 5 sec", cooldown: 15, type: "active" }
  },
  Knight: {
    ult1: { name: "Shield Wall", icon: "üõ°Ô∏è", desc: "Block all damage for 4 seconds", cooldown: 18, type: "active" },
    ult2: { name: "Whirlwind", icon: "‚öîÔ∏è", desc: "Spin attack dealing 300% damage to nearby enemies", cooldown: 15, type: "active" }
  },
  Assassin: {
    ult1: { name: "Shadow Step", icon: "üë§", desc: "Teleport to enemy and deal 500% crit damage", cooldown: 10, type: "active" },
    ult2: { name: "Blade Dance", icon: "üó°Ô∏è", desc: "Throw 12 daggers in all directions", cooldown: 14, type: "active" }
  },
  Rookie: {
    ult1: { name: "Quick Learn", icon: "üìö", desc: "Gain 500 bonus XP instantly", cooldown: 20, type: "active" },
    ult2: { name: "Beginner Luck", icon: "üçÄ", desc: "Next 5 shots are guaranteed crits", cooldown: 25, type: "active" }
  },
  
  // WAVE UNLOCK CLASSES
  Thief: {
    ult1: { name: "Coin Storm", icon: "üí∞", desc: "Enemies drop 10x coins for 10 sec", cooldown: 30, type: "active" },
    ult2: { name: "Smoke Bomb", icon: "üí®", desc: "Become invisible for 5 sec, +100% crit", cooldown: 20, type: "active" }
  },
  Archer: {
    ult1: { name: "Rain of Arrows", icon: "üåßÔ∏è", desc: "Rain arrows on area dealing massive damage", cooldown: 20, type: "active" },
    ult2: { name: "Cupids Bow", icon: "üíï", desc: "Charm enemies to fight for you for 6 sec", cooldown: 25, type: "active" }
  },
  Engineer: {
    ult1: { name: "Mega Turret", icon: "üîß", desc: "Deploy a mega turret with 3x damage", cooldown: 25, type: "active" },
    ult2: { name: "Repair All", icon: "üî©", desc: "Fully repair all turrets and heal player 50%", cooldown: 30, type: "active" }
  },
  Ranger: {
    ult1: { name: "Tracking Arrow", icon: "üèπ", desc: "Homing arrow that hits all enemies", cooldown: 18, type: "active" },
    ult2: { name: "Camouflage", icon: "üå≤", desc: "Invisible for 8 sec, +50% damage", cooldown: 25, type: "active" }
  },
  Mage: {
    ult1: { name: "Arcane Blast", icon: "üí´", desc: "Massive magic explosion in all directions", cooldown: 20, type: "active" },
    ult2: { name: "Mana Shield", icon: "üîÆ", desc: "Convert damage to mana for 5 sec", cooldown: 22, type: "active" }
  },
  Berserk: {
    ult1: { name: "Blood Rage", icon: "ü™ì", desc: "Lose 30% HP, gain 200% damage for 8 sec", cooldown: 15, type: "active" },
    ult2: { name: "Unstoppable", icon: "üí¢", desc: "Cannot die for 5 sec, heal 50% after", cooldown: 40, type: "active" }
  },
  Pyromancer: {
    ult1: { name: "Inferno", icon: "üî•", desc: "Create fire zone dealing burn damage", cooldown: 18, type: "active" },
    ult2: { name: "Phoenix Flame", icon: "üê¶‚Äçüî•", desc: "Revive with fire explosion on death", cooldown: 60, type: "passive" }
  },
  Samurai: {
    ult1: { name: "Blade Storm", icon: "‚öîÔ∏è", desc: "Slash all enemies in range for 400% damage", cooldown: 16, type: "active" },
    ult2: { name: "Honor Guard", icon: "üèØ", desc: "Block next 3 attacks completely", cooldown: 20, type: "active" }
  },
  Druid: {
    ult1: { name: "Nature's Wrath", icon: "üåø", desc: "Summon vines that trap all enemies", cooldown: 22, type: "active" },
    ult2: { name: "Rejuvenation", icon: "üå∏", desc: "Heal 5% HP per second for 10 sec", cooldown: 30, type: "active" }
  },
  Summoner: {
    ult1: { name: "Army of Light", icon: "‚ú®", desc: "Summon 5 spirit warriors", cooldown: 20, type: "active" },
    ult2: { name: "Phoenix Rising", icon: "üî•", desc: "Revive with full HP when killed", cooldown: 60, type: "passive" }
  },
  LightningRanger: {
    ult1: { name: "Chain Lightning", icon: "‚ö°", desc: "Lightning chains to all enemies", cooldown: 18, type: "active" },
    ult2: { name: "Thunder Strike", icon: "üå©Ô∏è", desc: "Call down lightning on all enemies", cooldown: 25, type: "active" }
  },
  ShadowMonk: {
    ult1: { name: "Shadow Fist", icon: "ü•ã", desc: "Rapid punch combo hitting 20 times", cooldown: 15, type: "active" },
    ult2: { name: "Inner Peace", icon: "‚òØÔ∏è", desc: "Heal 50% and gain 100% crit for 5 sec", cooldown: 25, type: "active" }
  },
  DarkMagician: {
    ult1: { name: "Meteor Shower", icon: "‚òÑÔ∏è", desc: "Call down meteors on all enemies", cooldown: 25, type: "active" },
    ult2: { name: "Time Freeze", icon: "‚è∞", desc: "Stop time for 4 seconds", cooldown: 30, type: "active" }
  },
  TrickshotRogue: {
    ult1: { name: "Lucky Shot", icon: "üé≤", desc: "Random powerful effect on enemies", cooldown: 12, type: "active" },
    ult2: { name: "Ricochet Frenzy", icon: "üéØ", desc: "All shots ricochet 5 times for 10 sec", cooldown: 20, type: "active" }
  },
  AstralGolem: {
    ult1: { name: "Stone Skin", icon: "üóø", desc: "Take 90% less damage for 6 sec", cooldown: 25, type: "active" },
    ult2: { name: "Gravity Slam", icon: "üí´", desc: "Pull and crush all enemies together", cooldown: 30, type: "active" }
  },
  
  // PURCHASABLE CLASSES
  Bomber: {
    ult1: { name: "Carpet Bomb", icon: "üí£", desc: "Drop 10 bombs across the field", cooldown: 18, type: "active" },
    ult2: { name: "Nuclear Option", icon: "‚ò¢Ô∏è", desc: "Massive explosion dealing 1000% damage", cooldown: 45, type: "active" }
  },
  Shadowblade: {
    ult1: { name: "Dark Slash", icon: "‚öîÔ∏è", desc: "Teleport slash through all enemies", cooldown: 14, type: "active" },
    ult2: { name: "Curse Wave", icon: "üåë", desc: "Curse all enemies for 50% more damage taken", cooldown: 20, type: "active" }
  },
  Sniper: {
    ult1: { name: "Headshot", icon: "üéØ", desc: "Guaranteed crit dealing 500% damage", cooldown: 15, type: "active" },
    ult2: { name: "Piercing Round", icon: "üî≠", desc: "Shot pierces ALL enemies for 10 seconds", cooldown: 20, type: "active" }
  },
  PlagueDoctor: {
    ult1: { name: "Pandemic", icon: "ü¶†", desc: "All enemies get max poison stacks", cooldown: 22, type: "active" },
    ult2: { name: "Cure All", icon: "üíâ", desc: "Heal to full, cure all debuffs", cooldown: 30, type: "active" }
  },
  Necromancer: {
    ult1: { name: "Army of Dead", icon: "üíÄ", desc: "Raise 5 skeleton warriors", cooldown: 22, type: "active" },
    ult2: { name: "Death Aura", icon: "‚ò†Ô∏è", desc: "Enemies near you take poison damage", cooldown: 20, type: "active" }
  },
  Gunslinger: {
    ult1: { name: "Fan the Hammer", icon: "ü§†", desc: "Fire 12 shots in rapid succession", cooldown: 12, type: "active" },
    ult2: { name: "High Noon", icon: "üåÖ", desc: "Mark and instant-kill up to 5 enemies", cooldown: 35, type: "active" }
  },
  CrystalGuardian: {
    ult1: { name: "Crystal Shield", icon: "üíé", desc: "Gain 500 shield and reflect all damage", cooldown: 25, type: "active" },
    ult2: { name: "Shatter", icon: "‚ú®", desc: "Explode shield for massive damage", cooldown: 20, type: "active" }
  },
  Warlock: {
    ult1: { name: "Soul Drain", icon: "üëπ", desc: "Drain HP from all enemies", cooldown: 20, type: "active" },
    ult2: { name: "Dark Pact", icon: "üìú", desc: "Double damage but take 20% max HP", cooldown: 25, type: "active" }
  },
  Illusionist: {
    ult1: { name: "Mirror Image", icon: "üé≠", desc: "Create 3 clones that attack", cooldown: 22, type: "active" },
    ult2: { name: "Confusion", icon: "üòµ", desc: "Enemies attack each other for 6 sec", cooldown: 28, type: "active" }
  },
  DrEclipse: {
    ult1: { name: "Lunar Gravity", icon: "üåô", desc: "Moon pulls all enemies and slams them", cooldown: 20, type: "active" },
    ult2: { name: "Eclipse", icon: "üåë", desc: "Darkness blinds enemies for 8 sec", cooldown: 25, type: "active" }
  },
  Vecna: {
    ult1: { name: "Hive Mind", icon: "üß†", desc: "Convert all enemies to fight for you", cooldown: 40, type: "active" },
    ult2: { name: "Upside Down", icon: "üåÄ", desc: "Teleport to shadow dimension - invincible", cooldown: 35, type: "active" }
  },
  
  // ACHIEVEMENT UNLOCK CLASSES
  CryoSentinel: {
    ult1: { name: "Absolute Zero", icon: "‚ùÑÔ∏è", desc: "Freeze all enemies for 5 sec", cooldown: 25, type: "active" },
    ult2: { name: "Ice Age", icon: "üßä", desc: "Slow all enemies by 80% for 10 sec", cooldown: 20, type: "active" }
  },
  BloodReaver: {
    ult1: { name: "Blood Boil", icon: "ü©∏", desc: "Enemies bleed 10% HP per sec", cooldown: 20, type: "active" },
    ult2: { name: "Vampiric Feast", icon: "üßõ", desc: "Heal 100% of damage dealt for 8 sec", cooldown: 25, type: "active" }
  },
  ArcWarden: {
    ult1: { name: "Static Field", icon: "‚ö°", desc: "Stun all enemies for 3 sec", cooldown: 22, type: "active" },
    ult2: { name: "Overcharge", icon: "üîã", desc: "Triple attack speed for 6 sec", cooldown: 20, type: "active" }
  },
  HolyCleric: {
    ult1: { name: "Divine Light", icon: "‚úùÔ∏è", desc: "Heal to full and damage all enemies", cooldown: 30, type: "active" },
    ult2: { name: "Guardian Angel", icon: "üëº", desc: "Auto-revive once when killed", cooldown: 60, type: "passive" }
  },
  Starcaller: {
    ult1: { name: "Supernova", icon: "üåü", desc: "Massive explosion hitting all enemies", cooldown: 25, type: "active" },
    ult2: { name: "Black Hole", icon: "üï≥Ô∏è", desc: "Pull all enemies to center", cooldown: 22, type: "active" }
  },
  VoidAssassin: {
    ult1: { name: "Void Strike", icon: "üåë", desc: "Instant kill any non-boss enemy", cooldown: 15, type: "active" },
    ult2: { name: "Phase Shift", icon: "üëª", desc: "Invincible for 4 sec, +200% damage", cooldown: 25, type: "active" }
  },
  GuardianTank: {
    ult1: { name: "Fortress", icon: "üõ°Ô∏è", desc: "Become immovable, reflect all damage", cooldown: 20, type: "active" },
    ult2: { name: "Shield Bash", icon: "üí•", desc: "Stun and push back all enemies", cooldown: 18, type: "active" }
  },
  TheForsakenOne: {
    ult1: { name: "Chaotic Power", icon: "üíÄ", desc: "Random powerful buff activates", cooldown: 15, type: "active" },
    ult2: { name: "Forsaken Fury", icon: "üòà", desc: "All stats doubled for 10 sec", cooldown: 35, type: "active" }
  },
  DrSunshine: {
    ult1: { name: "Solar Flare", icon: "‚òÄÔ∏è", desc: "Sun explodes dealing massive damage", cooldown: 20, type: "active" },
    ult2: { name: "Sunbeam", icon: "üåû", desc: "Continuous beam burns enemies", cooldown: 22, type: "active" }
  },
  EvolLegend: {
    ult1: { name: "Event Horizon", icon: "üåå", desc: "Black hole kills all normal enemies", cooldown: 30, type: "active" },
    ult2: { name: "Cosmic Power", icon: "‚ú®", desc: "Become god-like for 10 seconds", cooldown: 45, type: "active" }
  }
};

// ==================== BOSS PATTERNS ====================
const BOSS_PATTERNS = {
  // MAJOR BOSSES (Every 10 waves) - 20 unique bosses
  Charger: { 
    name: "The Charger", icon: "üêÇ", color: "#ff0000", 
    hpMult: 10, speedMult: 0.6, size: 80,
    attacks: [
      { type: "charge", damage: 40, duration: 2, cooldown: 4 },
      { type: "stomp", damage: 30, cooldown: 6 }
    ],
    desc: "Charges at player with devastating force"
  },
  Sniper: { 
    name: "The Marksman", icon: "üéØ", color: "#00ff00", 
    hpMult: 8, speedMult: 0.4, size: 75,
    attacks: [
      { type: "ranged", damage: 35, duration: 3, cooldown: 2 },
      { type: "laser", damage: 50, duration: 2, cooldown: 8 }
    ],
    desc: "Deadly accurate long-range shooter"
  },
  Tank: { 
    name: "The Juggernaut", icon: "üõ°Ô∏è", color: "#0088ff", 
    hpMult: 20, speedMult: 0.3, size: 100,
    attacks: [
      { type: "shield", duration: 5, cooldown: 10 },
      { type: "stomp", damage: 50, cooldown: 5 }
    ],
    desc: "Nearly indestructible fortress"
  },
  Summoner: { 
    name: "The Hive Queen", icon: "üëë", color: "#ff00ff", 
    hpMult: 7, speedMult: 0.5, size: 85,
    attacks: [
      { type: "summon", count: 4, cooldown: 8 },
      { type: "ranged", damage: 20, duration: 2, cooldown: 3 }
    ],
    desc: "Calls forth endless minions"
  },
  Berserker: { 
    name: "The Berserker", icon: "ü™ì", color: "#ff8800", 
    hpMult: 9, speedMult: 0.7, size: 78,
    attacks: [
      { type: "spin", damage: 25, duration: 2, cooldown: 5 },
      { type: "charge", damage: 35, duration: 1.5, cooldown: 4 },
      { type: "enrage", cooldown: 0 } // Activates at low HP
    ],
    desc: "Enrages at low HP, becomes deadly"
  },
  Headless: { 
    name: "The Headless Knight", icon: "üíÄ", color: "#880088", 
    hpMult: 8, speedMult: 0.6, size: 82,
    attacks: [
      { type: "ranged", damage: 30, duration: 2, cooldown: 3 },
      { type: "teleport", cooldown: 5 },
      { type: "charge", damage: 40, duration: 1, cooldown: 6 }
    ],
    desc: "Throws its flaming head"
  },
  FrostLord: { 
    name: "Frost Lord", icon: "‚ùÑÔ∏è", color: "#00ffff", 
    hpMult: 10, speedMult: 0.5, size: 85,
    attacks: [
      { type: "ranged", damage: 25, duration: 3, cooldown: 2 },
      { type: "stomp", damage: 35, cooldown: 6 }
    ],
    desc: "Freezes everything in its path"
  },
  FlameWarden: { 
    name: "Flame Warden", icon: "üî•", color: "#ff4400", 
    hpMult: 9, speedMult: 0.6, size: 80,
    attacks: [
      { type: "ranged", damage: 30, duration: 3, cooldown: 2 },
      { type: "poison", damage: 15, cooldown: 8 }
    ],
    desc: "Leaves fire trails everywhere"
  },
  ShadowLord: { 
    name: "Shadow Lord", icon: "üåë", color: "#2a0040", 
    hpMult: 8, speedMult: 0.8, size: 75,
    attacks: [
      { type: "teleport", cooldown: 4 },
      { type: "ranged", damage: 35, duration: 2, cooldown: 3 },
      { type: "charge", damage: 30, duration: 1, cooldown: 5 }
    ],
    desc: "Teleports and strikes from shadows"
  },
  StormBringer: { 
    name: "Storm Bringer", icon: "‚ö°", color: "#ffff00", 
    hpMult: 9, speedMult: 0.55, size: 82,
    attacks: [
      { type: "ranged", damage: 40, duration: 2, cooldown: 2 },
      { type: "stomp", damage: 45, cooldown: 5 }
    ],
    desc: "Commands devastating lightning"
  },
  PlagueBearer: { 
    name: "Plague Bearer", icon: "ü¶†", color: "#00ff44", 
    hpMult: 7, speedMult: 0.7, size: 78,
    attacks: [
      { type: "poison", damage: 25, cooldown: 6 },
      { type: "ranged", damage: 20, duration: 3, cooldown: 3 }
    ],
    desc: "Spreads deadly poison"
  },
  NecroKing: { 
    name: "Necro King", icon: "üíÄ", color: "#9933ff", 
    hpMult: 12, speedMult: 0.4, size: 90,
    attacks: [
      { type: "summon", count: 5, cooldown: 10 },
      { type: "laser", damage: 40, duration: 3, cooldown: 8 },
      { type: "ranged", damage: 30, duration: 2, cooldown: 3 }
    ],
    desc: "Raises the dead to fight"
  },
  Goliath: { 
    name: "The Goliath", icon: "üóø", color: "#8b4513", 
    hpMult: 25, speedMult: 0.2, size: 120,
    attacks: [
      { type: "stomp", damage: 60, cooldown: 4 },
      { type: "ranged", damage: 45, duration: 2, cooldown: 5 }
    ],
    desc: "Massive and nearly unstoppable"
  },
  SpiderQueen: { 
    name: "Spider Queen", icon: "üï∑Ô∏è", color: "#4a0080", 
    hpMult: 8, speedMult: 0.65, size: 85,
    attacks: [
      { type: "summon", count: 3, cooldown: 7 },
      { type: "poison", damage: 20, cooldown: 5 },
      { type: "leap", cooldown: 6 }
    ],
    desc: "Traps and poisons victims"
  },
  DragonLord: { 
    name: "Elder Dragon", icon: "üêâ", color: "#ff6600", 
    hpMult: 15, speedMult: 0.5, size: 110,
    attacks: [
      { type: "laser", damage: 50, duration: 3, cooldown: 6 },
      { type: "stomp", damage: 40, cooldown: 5 },
      { type: "ranged", damage: 35, duration: 2, cooldown: 3 }
    ],
    desc: "Ancient dragon of destruction"
  },
  VoidTitan: { 
    name: "Void Titan", icon: "üåÄ", color: "#1a0033", 
    hpMult: 14, speedMult: 0.35, size: 105,
    attacks: [
      { type: "teleport", cooldown: 3 },
      { type: "stomp", damage: 50, cooldown: 6 },
      { type: "laser", damage: 45, duration: 2, cooldown: 8 }
    ],
    desc: "Pulls enemies into the void"
  },
  CrystalGuardian: { 
    name: "Crystal Guardian", icon: "üíé", color: "#88ffff", 
    hpMult: 11, speedMult: 0.45, size: 88,
    attacks: [
      { type: "shield", duration: 4, cooldown: 10 },
      { type: "ranged", damage: 35, duration: 3, cooldown: 3 }
    ],
    desc: "Reflects damage with crystals"
  },
  DeathKnight: { 
    name: "Death Knight", icon: "‚öîÔ∏è", color: "#4a0000", 
    hpMult: 10, speedMult: 0.6, size: 85,
    attacks: [
      { type: "charge", damage: 45, duration: 2, cooldown: 5 },
      { type: "spin", damage: 30, duration: 2, cooldown: 6 },
      { type: "enrage", cooldown: 0 }
    ],
    desc: "Drains life with every strike"
  },
  Leviathan: { 
    name: "The Leviathan", icon: "üêô", color: "#003366", 
    hpMult: 13, speedMult: 0.4, size: 100,
    attacks: [
      { type: "stomp", damage: 40, cooldown: 4 },
      { type: "summon", count: 4, cooldown: 9 },
      { type: "poison", damage: 20, cooldown: 7 }
    ],
    desc: "Sea monster with many arms"
  },
  Apocalypse: { 
    name: "Apocalypse", icon: "‚ò†Ô∏è", color: "#330000", 
    hpMult: 20, speedMult: 0.5, size: 100,
    attacks: [
      { type: "laser", damage: 60, duration: 3, cooldown: 6 },
      { type: "stomp", damage: 70, cooldown: 5 },
      { type: "summon", count: 5, cooldown: 8 },
      { type: "enrage", cooldown: 0 }
    ],
    desc: "The ultimate destroyer"
  }
};

// MINI-BOSS PATTERNS (Every 5 waves) - 30 unique mini-bosses
const MINIBOSS_PATTERNS = {
  // Warriors
  BladeDancer: { name: "Blade Dancer", icon: "üó°Ô∏è", color: "#ff4488", hpMult: 4, speedMult: 1.5, size: 55, attacks: [{ type: "spin", damage: 15, duration: 1, cooldown: 4 }, { type: "charge", damage: 20, duration: 1, cooldown: 5 }] },
  AxeThrower: { name: "Axe Thrower", icon: "ü™ì", color: "#8b4513", hpMult: 5, speedMult: 0.9, size: 58, attacks: [{ type: "ranged", damage: 25, duration: 2, cooldown: 3 }] },
  Gladiator: { name: "Gladiator", icon: "‚öîÔ∏è", color: "#cd7f32", hpMult: 5, speedMult: 0.8, size: 60, attacks: [{ type: "shield", duration: 3, cooldown: 8 }, { type: "charge", damage: 25, duration: 1, cooldown: 4 }] },
  DualBlade: { name: "Dual Blade", icon: "üî™", color: "#c0c0c0", hpMult: 3.5, speedMult: 1.8, size: 50, attacks: [{ type: "spin", damage: 12, duration: 1.5, cooldown: 3 }] },
  WarHammer: { name: "War Hammer", icon: "üî®", color: "#696969", hpMult: 6, speedMult: 0.6, size: 62, attacks: [{ type: "stomp", damage: 35, cooldown: 4 }] },
  
  // Mages
  FireMage: { name: "Fire Mage", icon: "üî•", color: "#ff6600", hpMult: 3, speedMult: 0.7, size: 52, attacks: [{ type: "ranged", damage: 25, duration: 2, cooldown: 2 }] },
  IceMage: { name: "Ice Mage", icon: "‚ùÑÔ∏è", color: "#88ddff", hpMult: 3, speedMult: 0.7, size: 52, attacks: [{ type: "ranged", damage: 20, duration: 2, cooldown: 2 }] },
  LightningMage: { name: "Lightning Mage", icon: "‚ö°", color: "#ffff44", hpMult: 3, speedMult: 0.8, size: 52, attacks: [{ type: "ranged", damage: 30, duration: 1.5, cooldown: 2 }] },
  DarkMage: { name: "Dark Mage", icon: "üîÆ", color: "#660099", hpMult: 3.5, speedMult: 0.6, size: 54, attacks: [{ type: "ranged", damage: 20, duration: 2, cooldown: 2 }, { type: "teleport", cooldown: 6 }] },
  Warlock: { name: "Warlock", icon: "üëπ", color: "#4a0066", hpMult: 4, speedMult: 0.65, size: 55, attacks: [{ type: "summon", count: 2, cooldown: 10 }, { type: "ranged", damage: 20, duration: 2, cooldown: 3 }] },
  
  // Ranged
  CrossbowElite: { name: "Crossbow Elite", icon: "üèπ", color: "#8b0000", hpMult: 3, speedMult: 0.8, size: 50, attacks: [{ type: "ranged", damage: 30, duration: 2, cooldown: 2 }] },
  Gunner: { name: "Gunner", icon: "üî´", color: "#444444", hpMult: 3.5, speedMult: 0.7, size: 52, attacks: [{ type: "ranged", damage: 15, duration: 3, cooldown: 1.5 }] },
  PoisonArcher: { name: "Poison Archer", icon: "‚ò†Ô∏è", color: "#00aa00", hpMult: 3, speedMult: 0.9, size: 50, attacks: [{ type: "ranged", damage: 15, duration: 2, cooldown: 2 }, { type: "poison", damage: 15, cooldown: 6 }] },
  Bombardier: { name: "Bombardier", icon: "üí£", color: "#ff4400", hpMult: 4, speedMult: 0.5, size: 55, attacks: [{ type: "stomp", damage: 40, cooldown: 4 }] },
  SniperElite: { name: "Sniper Elite", icon: "üéØ", color: "#005500", hpMult: 2.5, speedMult: 0.5, size: 48, attacks: [{ type: "ranged", damage: 45, duration: 1, cooldown: 4 }] },
  
  // Monsters
  Werewolf: { name: "Werewolf", icon: "üê∫", color: "#555555", hpMult: 4, speedMult: 1.6, size: 55, attacks: [{ type: "leap", cooldown: 5 }, { type: "charge", damage: 25, duration: 1, cooldown: 4 }] },
  Minotaur: { name: "Minotaur", icon: "üêÇ", color: "#8b4513", hpMult: 5, speedMult: 0.9, size: 60, attacks: [{ type: "charge", damage: 35, duration: 2, cooldown: 4 }] },
  Gargoyle: { name: "Gargoyle", icon: "üóø", color: "#708090", hpMult: 4.5, speedMult: 1.0, size: 55, attacks: [{ type: "leap", cooldown: 4 }, { type: "shield", duration: 3, cooldown: 8 }] },
  Basilisk: { name: "Basilisk", icon: "üêç", color: "#228b22", hpMult: 4, speedMult: 1.1, size: 55, attacks: [{ type: "ranged", damage: 20, duration: 2, cooldown: 2 }, { type: "poison", damage: 20, cooldown: 6 }] },
  Harpy: { name: "Harpy", icon: "ü¶Ö", color: "#dda0dd", hpMult: 3, speedMult: 1.8, size: 48, attacks: [{ type: "leap", cooldown: 3 }, { type: "ranged", damage: 15, duration: 1, cooldown: 2 }] },
  
  // Undead
  Wraith: { name: "Wraith", icon: "üëª", color: "#88aaff", hpMult: 3, speedMult: 1.2, size: 50, attacks: [{ type: "teleport", cooldown: 4 }, { type: "ranged", damage: 20, duration: 2, cooldown: 3 }] },
  SkeletonChamp: { name: "Skeleton Champion", icon: "üíÄ", color: "#fffff0", hpMult: 4, speedMult: 1.0, size: 54, attacks: [{ type: "ranged", damage: 20, duration: 2, cooldown: 3 }, { type: "charge", damage: 25, duration: 1, cooldown: 5 }] },
  ZombieHulk: { name: "Zombie Hulk", icon: "üßü", color: "#556b2f", hpMult: 6, speedMult: 0.5, size: 65, attacks: [{ type: "poison", damage: 15, cooldown: 5 }, { type: "stomp", damage: 30, cooldown: 5 }] },
  VampireLord: { name: "Vampire Lord", icon: "üßõ", color: "#8b0000", hpMult: 4, speedMult: 1.3, size: 55, attacks: [{ type: "teleport", cooldown: 5 }, { type: "charge", damage: 20, duration: 1, cooldown: 4 }] },
  Lich: { name: "Lich", icon: "‚ò†Ô∏è", color: "#4a0080", hpMult: 4.5, speedMult: 0.6, size: 58, attacks: [{ type: "summon", count: 2, cooldown: 8 }, { type: "ranged", damage: 25, duration: 2, cooldown: 2 }] },
  
  // Elementals
  FireElemental: { name: "Fire Elemental", icon: "üî•", color: "#ff4500", hpMult: 3.5, speedMult: 1.0, size: 52, attacks: [{ type: "ranged", damage: 25, duration: 2, cooldown: 2 }, { type: "spin", damage: 15, duration: 2, cooldown: 5 }] },
  IceElemental: { name: "Ice Elemental", icon: "üßä", color: "#00bfff", hpMult: 3.5, speedMult: 0.8, size: 52, attacks: [{ type: "ranged", damage: 20, duration: 2, cooldown: 2 }, { type: "stomp", damage: 25, cooldown: 6 }] },
  StormElemental: { name: "Storm Elemental", icon: "üå™Ô∏è", color: "#a0a0a0", hpMult: 3.5, speedMult: 1.2, size: 52, attacks: [{ type: "spin", damage: 20, duration: 2, cooldown: 4 }, { type: "ranged", damage: 25, duration: 1, cooldown: 2 }] },
  EarthElemental: { name: "Earth Elemental", icon: "ü™®", color: "#8b4513", hpMult: 6, speedMult: 0.5, size: 65, attacks: [{ type: "stomp", damage: 40, cooldown: 4 }, { type: "shield", duration: 4, cooldown: 10 }] },
  VoidElemental: { name: "Void Elemental", icon: "üåë", color: "#1a1a2e", hpMult: 4, speedMult: 0.9, size: 55, attacks: [{ type: "teleport", cooldown: 4 }, { type: "ranged", damage: 30, duration: 2, cooldown: 3 }] }
};

// Boss attack implementations
let bossAttackTimer = 0;
let bossSpecialTimer = 0;

// ==================== SHOP ITEMS ====================
const SHOP_UPGRADES = {
  damage: { name: "üí• Base Damage", desc: "+3 damage per level", maxLevel: 10, getBonus: l => l * 3, getCost: l => ({ coins: 100 + l * 50, gems: 0 }) },
  health: { name: "‚ù§Ô∏è Base Health", desc: "+15 HP per level", maxLevel: 10, getBonus: l => l * 15, getCost: l => ({ coins: 80 + l * 40, gems: 0 }) },
  fireRate: { name: "‚ö° Fire Rate", desc: "+5% attack speed", maxLevel: 5, getBonus: l => l * 0.05, getCost: l => ({ coins: 200 + l * 100, gems: l * 5 }) },
  critChance: { name: "üí¢ Crit Chance", desc: "+5% crit per level", maxLevel: 5, getBonus: l => l * 0.05, getCost: l => ({ coins: 300 + l * 150, gems: l * 8 }) },
  coinMultiplier: { name: "üí∞ Coin Bonus", desc: "+10% coins per level", maxLevel: 5, getBonus: l => l * 0.1, getCost: l => ({ coins: 500 + l * 250, gems: l * 10 }) },
  xpMultiplier: { name: "‚ú® XP Bonus", desc: "+10% XP per level", maxLevel: 5, getBonus: l => l * 0.1, getCost: l => ({ coins: 400 + l * 200, gems: l * 8 }) }
};

const SHOP_POTIONS = {
  healPack: { name: "‚ù§Ô∏è Heal Potion Pack", desc: "+5 heal potions", gives: { heal: 5 }, cost: { coins: 200, gems: 0 } },
  shieldPack: { name: "üõ°Ô∏è Shield Potion Pack", desc: "+3 shield potions", gives: { shield: 3 }, cost: { coins: 300, gems: 0 } },
  critPack: { name: "üí• Crit Potion Pack", desc: "+2 crit potions", gives: { crit: 2 }, cost: { coins: 500, gems: 5 } },
  damagePack: { name: "‚öîÔ∏è Damage Potion Pack", desc: "+2 damage potions", gives: { damage: 2 }, cost: { coins: 600, gems: 5 } },
  speedPack: { name: "‚ö° Speed Potion Pack", desc: "+2 speed potions", gives: { speed: 2 }, cost: { coins: 700, gems: 8 } },
  dragonPack: { name: "üêâ Dragon Potion", desc: "+1 dragon beam", gives: { dragon: 1 }, cost: { coins: 2000, gems: 20 } },
  megaPack: { name: "üéÅ Mega Potion Bundle", desc: "All potions +3!", gives: { heal: 3, shield: 3, crit: 3, damage: 3, speed: 3, dragon: 1 }, cost: { coins: 5000, gems: 50 } }
};

const SHOP_COSMETICS = {
  // Player Skins
  skinFire: { type: "skin", name: "üî• Fire Warrior", desc: "Flaming aura around player", id: "fire", cost: { coins: 3000, gems: 30 } },
  skinIce: { type: "skin", name: "‚ùÑÔ∏è Ice Warrior", desc: "Frozen crystal appearance", id: "ice", cost: { coins: 3000, gems: 30 } },
  skinShadow: { type: "skin", name: "üë§ Shadow Warrior", desc: "Dark mysterious form", id: "shadow", cost: { coins: 5000, gems: 50 } },
  skinGold: { type: "skin", name: "üëë Golden Warrior", desc: "Gleaming gold armor", id: "gold", cost: { coins: 10000, gems: 100 } },
  skinRainbow: { type: "skin", name: "üåà Rainbow Warrior", desc: "Color-shifting appearance", id: "rainbow", cost: { coins: 15000, gems: 150 } },
  skinVoid: { type: "skin", name: "üï≥Ô∏è Void Warrior", desc: "Darkness incarnate", id: "void", cost: { coins: 25000, gems: 250 } },
  
  // Attack Effects
  effectSpark: { type: "effect", name: "‚ö° Spark Shots", desc: "Electric projectiles", id: "spark", cost: { coins: 2000, gems: 20 } },
  effectFlame: { type: "effect", name: "üî• Flame Shots", desc: "Fiery projectiles", id: "flame", cost: { coins: 2000, gems: 20 } },
  effectPoison: { type: "effect", name: "‚ò†Ô∏è Poison Shots", desc: "Toxic green projectiles", id: "poison", cost: { coins: 3000, gems: 30 } },
  effectStar: { type: "effect", name: "‚≠ê Star Shots", desc: "Sparkling star projectiles", id: "star", cost: { coins: 5000, gems: 50 } },
  effectLaser: { type: "effect", name: "üí´ Laser Beam", desc: "Continuous laser attack", id: "laser", cost: { coins: 10000, gems: 100 } },
  effectDragon: { type: "effect", name: "üê≤ Dragon Breath", desc: "Dragon-shaped projectiles", id: "dragon", cost: { coins: 20000, gems: 200 } }
};

// ==================== REDEEM CODES ====================
const REDEEM_CODES = {
  "EVOLSTART": { coins: 500, gems: 10, message: "Welcome to EVOL LEGENDS!" },
  "LEGENDARY": { coins: 2000, gems: 50, message: "You're a true legend!" },
  "FORGOTTEN": { coins: 1000, gems: 25, classUnlock: "Necromancer", message: "The darkness welcomes you..." },
  "WARRIOR2025": { coins: 3000, gems: 100, message: "Happy 2025!" },
  "BOBBO": { coins: 777, gems: 77, skinUnlock: "rainbow", message: "Bobbo says hi! üîµ" },
  "STORMY": { coins: 888, gems: 88, effectUnlock: "flame", message: "Stormy brings fire! üî¥" },
  "FREEGEMS": { coins: 0, gems: 200, message: "Free gems for you!" },
  "POWERUP": { coins: 5000, gems: 0, message: "POWER OVERWHELMING!" }
};

// ==================== MAP NODES - MATCHES PROVIDED MAP IMAGE ====================
// Coordinates are percentages matching the pixel-art map with branching paths
const MAP_NODES = [
  // ==================== BEGINNER VILLAGE (Green Area - Top Left) ====================
  { id: "start", name: "Village Gate", region: "Beginner Village", type: "start", x: 11, y: 34, waves: 5, difficulty: 1, rewards: { coins: 50 }, 
    unlocks: ["path1a", "path1b"], description: "Your journey begins at the village gate. Prove your worth!", 
    revealed: true, noEnemySpawns: true },
  
  { id: "path1a", name: "Forest Path", region: "Beginner Village", type: "normal", x: 17, y: 26, waves: 6, difficulty: 1, rewards: { coins: 75 }, 
    unlocks: ["path2a"], requiredNodes: ["start"], description: "A winding path through ancient trees." },
  
  { id: "path1b", name: "Meadow Road", region: "Beginner Village", type: "normal", x: 17, y: 42, waves: 6, difficulty: 1, rewards: { coins: 75 }, 
    unlocks: ["path2b"], requiredNodes: ["start"], description: "Peaceful meadows... for now." },
  
  { id: "path2a", name: "Deep Woods", region: "Beginner Village", type: "normal", x: 23, y: 18, waves: 7, difficulty: 2, rewards: { coins: 100 }, 
    unlocks: ["path3a", "village_shop"], requiredNodes: ["path1a"], description: "The forest grows darker here." },
  
  { id: "path2b", name: "Old Bridge", region: "Beginner Village", type: "normal", x: 23, y: 38, waves: 7, difficulty: 2, rewards: { coins: 100 }, 
    unlocks: ["path3b", "village_shop"], requiredNodes: ["path1b"], description: "A rickety bridge over rushing waters." },
  
  { id: "village_shop", name: "Village Market", region: "Beginner Village", type: "shop", x: 28, y: 28, waves: 0, difficulty: 0, rewards: {}, 
    unlocks: [], requiredNodes: ["path2a", "path2b"], description: "Stock up on supplies before the boss!" },
  
  { id: "path3a", name: "Forest Edge", region: "Beginner Village", type: "elite", x: 30, y: 12, waves: 8, difficulty: 3, rewards: { coins: 150, gems: 5 }, 
    unlocks: ["boss1"], requiredNodes: ["path2a"], description: "Elite enemies guard the path ahead." },
  
  { id: "path3b", name: "Hidden Grove", region: "Beginner Village", type: "elite", x: 30, y: 44, waves: 8, difficulty: 3, rewards: { coins: 150, gems: 5 }, 
    unlocks: ["boss1"], requiredNodes: ["path2b"], description: "Something lurks in the shadows..." },
  
  { id: "boss1", name: "Shadow Beast Lair", region: "Beginner Village", type: "boss", x: 38, y: 10, waves: 12, difficulty: 4, 
    rewards: { coins: 500, gems: 25, classUnlock: "Archer" }, unlocks: ["crimson_gate"], requiredNodes: ["path3a", "path3b"], 
    bossName: "Shadow Beast", bossIcon: "üê∫", noEnemySpawns: true,
    description: "The Shadow Beast awaits. Defeat it to unlock the Crimson Forest!" },
  
  // ==================== CRIMSON FOREST (Red Area - Center) ====================
  { id: "crimson_gate", name: "Crimson Gate", region: "Crimson Forest", type: "normal", x: 43, y: 26, waves: 10, difficulty: 4, rewards: { coins: 200 }, 
    unlocks: ["crimson_path1", "crimson_path2"], requiredNodes: ["boss1"], description: "The forest bleeds red..." },
  
  { id: "crimson_path1", name: "Blood Grove", region: "Crimson Forest", type: "normal", x: 48, y: 18, waves: 11, difficulty: 5, rewards: { coins: 250 }, 
    unlocks: ["crimson_elite1"], requiredNodes: ["crimson_gate"], description: "Trees drip with crimson sap." },
  
  { id: "crimson_path2", name: "Thorned Path", region: "Crimson Forest", type: "normal", x: 48, y: 36, waves: 11, difficulty: 5, rewards: { coins: 250 }, 
    unlocks: ["crimson_elite2"], requiredNodes: ["crimson_gate"], description: "Deadly thorns block the way." },
  
  { id: "crimson_elite1", name: "Ancient Shrine", region: "Crimson Forest", type: "shrine", x: 55, y: 12, waves: 12, difficulty: 5, rewards: { gems: 30 }, 
    unlocks: ["boss2"], requiredNodes: ["crimson_path1"], description: "A forgotten shrine of power." },
  
  { id: "crimson_shop", name: "Forest Bazaar", region: "Crimson Forest", type: "shop", x: 55, y: 26, waves: 0, difficulty: 0, rewards: {}, 
    unlocks: [], requiredNodes: ["crimson_gate"], description: "A mysterious merchant awaits." },
  
  { id: "crimson_elite2", name: "Burning Clearing", region: "Crimson Forest", type: "elite", x: 55, y: 42, waves: 14, difficulty: 6, rewards: { coins: 350, gems: 15 }, 
    unlocks: ["boss2"], requiredNodes: ["crimson_path2"], description: "The ground smolders with ancient fire." },
  
  { id: "boss2", name: "Bloodwood Heart", region: "Crimson Forest", type: "boss", x: 65, y: 24, waves: 15, difficulty: 6, 
    rewards: { coins: 1000, gems: 50, classUnlock: "Wizard" }, unlocks: ["mountain_pass", "cave_entrance"], requiredNodes: ["crimson_elite1", "crimson_elite2"], 
    bossName: "Bloodwood Guardian", bossIcon: "üå≤", noEnemySpawns: true,
    description: "The heart of the corrupted forest beats with malice." },
  
  // ==================== UNDERWATER CAVE (Blue Area - Left Side) ====================
  { id: "cave_entrance", name: "Cave Entrance", region: "Underwater Cave", type: "normal", x: 15, y: 52, waves: 12, difficulty: 5, rewards: { coins: 280 }, 
    unlocks: ["cave_depths"], requiredNodes: ["boss2"], description: "Crystal formations light the way." },
  
  { id: "cave_depths", name: "Crystal Caverns", region: "Underwater Cave", type: "normal", x: 18, y: 64, waves: 14, difficulty: 6, rewards: { coins: 320, gems: 10 }, 
    unlocks: ["cave_lake", "cave_shrine"], requiredNodes: ["cave_entrance"], description: "Glittering gems surround you." },
  
  { id: "cave_shrine", name: "Underwater Shrine", region: "Underwater Cave", type: "shrine", x: 12, y: 75, waves: 10, difficulty: 4, rewards: { gems: 40 }, 
    unlocks: ["cave_boss"], requiredNodes: ["cave_depths"], description: "An ancient altar beneath the waves." },
  
  { id: "cave_lake", name: "Submerged Lake", region: "Underwater Cave", type: "elite", x: 22, y: 78, waves: 16, difficulty: 7, rewards: { coins: 400, gems: 20 }, 
    unlocks: ["cave_boss"], requiredNodes: ["cave_depths"], description: "The lake glows with bioluminescence." },
  
  { id: "cave_boss", name: "Leviathan's Rest", region: "Underwater Cave", type: "boss", x: 16, y: 88, waves: 18, difficulty: 7, 
    rewards: { coins: 1500, gems: 75, keyShard: "water" }, unlocks: ["forgotten_gate"], requiredNodes: ["cave_shrine", "cave_lake"], 
    bossName: "Crystal Leviathan", bossIcon: "üêô", noEnemySpawns: true,
    description: "The Leviathan guards the water key shard." },
  
  // ==================== MOUNTAIN PEAKS (Top Right Area) ====================  
  { id: "mountain_pass", name: "Mountain Pass", region: "Mountain Peaks", type: "normal", x: 72, y: 14, waves: 14, difficulty: 6, rewards: { coins: 350 }, 
    unlocks: ["mountain_path1", "mountain_path2"], requiredNodes: ["boss2"], description: "The air grows thin and cold." },
  
  { id: "mountain_path1", name: "Frozen Trail", region: "Mountain Peaks", type: "normal", x: 78, y: 8, waves: 15, difficulty: 7, rewards: { coins: 400 }, 
    unlocks: ["mountain_shrine"], requiredNodes: ["mountain_pass"], description: "Ice covers every surface." },
  
  { id: "mountain_path2", name: "Rocky Ascent", region: "Mountain Peaks", type: "elite", x: 78, y: 22, waves: 16, difficulty: 7, rewards: { coins: 450, gems: 25 }, 
    unlocks: ["mountain_boss"], requiredNodes: ["mountain_pass"], description: "Treacherous cliffs and fierce winds." },
  
  { id: "mountain_shrine", name: "Summit Temple", region: "Mountain Peaks", type: "shrine", x: 85, y: 6, waves: 12, difficulty: 5, rewards: { gems: 50, classUnlock: "Paladin" }, 
    unlocks: ["mountain_boss"], requiredNodes: ["mountain_path1"], description: "A temple at the peak of the world." },
  
  { id: "mountain_boss", name: "Dragon's Perch", region: "Mountain Peaks", type: "boss", x: 88, y: 16, waves: 20, difficulty: 8, 
    rewards: { coins: 2000, gems: 100, keyShard: "fire" }, unlocks: ["forgotten_gate"], requiredNodes: ["mountain_path2", "mountain_shrine"], 
    bossName: "Elder Frost Dragon", bossIcon: "üêâ", noEnemySpawns: true,
    description: "The ancient dragon guards the fire key shard." },
  
  // ==================== FORGOTTEN CITY (Bottom Center - Final Area) ====================
  { id: "forgotten_gate", name: "Forgotten Gates", region: "Forgotten City", type: "locked", x: 55, y: 72, waves: 22, difficulty: 8, rewards: { coins: 2500, gems: 120 }, 
    unlocks: ["forgotten_path"], requiredNodes: ["cave_boss", "mountain_boss"], requiredKeys: ["water", "fire"], 
    description: "The gates require two key shards to open..." },
  
  { id: "forgotten_path", name: "Ruined Streets", region: "Forgotten City", type: "elite", x: 60, y: 82, waves: 25, difficulty: 9, rewards: { coins: 3000, gems: 150 }, 
    unlocks: ["forgotten_plaza"], requiredNodes: ["forgotten_gate"], description: "Echoes of a lost civilization." },
  
  { id: "forgotten_plaza", name: "Central Plaza", region: "Forgotten City", type: "elite", x: 68, y: 88, waves: 28, difficulty: 9, rewards: { coins: 3500, gems: 175 }, 
    unlocks: ["final_boss"], requiredNodes: ["forgotten_path"], description: "The heart of the ancient city." },
  
  { id: "final_boss", name: "Throne of Memories", region: "Forgotten City", type: "boss", x: 75, y: 92, waves: 35, difficulty: 10, 
    rewards: { coins: 10000, gems: 500, classUnlock: "Vecna" }, unlocks: [], requiredNodes: ["forgotten_plaza"], 
    bossName: "Memory Devourer", bossIcon: "‚ò†Ô∏è", noEnemySpawns: true,
    description: "The final battle. Reclaim your memories and end this nightmare!" }
];

// ==================== REGION DEFINITIONS ====================
const REGIONS = {
  "Beginner Village": { color: "#88ff88", desc: "Where every legend begins...", bgMusic: "village" },
  "Crimson Forest": { color: "#ff4444", desc: "Blood-red trees and ancient evil...", bgMusic: "crimson" },
  "Underwater Cave": { color: "#4488ff", desc: "Crystal caverns beneath the waves...", bgMusic: "cave" },
  "Mountain Peaks": { color: "#aaddff", desc: "Frozen heights and dragon's breath...", bgMusic: "mountain" },
  "Forgotten City": { color: "#ff8800", desc: "Ruins of a forgotten age...", bgMusic: "forgotten" }
};

// ==================== BOSS DIALOGUES ====================
const BOSS_DIALOGUES = {
  "Shadow Beast": {
    icon: "üê∫",
    color: "#8844aa",
    dialogues: [
      { speaker: "boss", text: "Another fool stumbles into my lair... How delightful." },
      { speaker: "boss", text: "The shadows have whispered of your coming, little warrior." },
      { speaker: "boss", text: "But shadows also consume... as you will soon discover!" },
      { speaker: "player", text: "I will not fall to darkness!" }
    ]
  },
  "Bloodwood Guardian": {
    icon: "üå≤",
    color: "#aa0000",
    dialogues: [
      { speaker: "boss", text: "You dare tread upon sacred ground?" },
      { speaker: "boss", text: "This forest has stood for millennia... fed by the blood of intruders." },
      { speaker: "boss", text: "Your essence will nourish my roots for centuries to come!" },
      { speaker: "player", text: "Your corruption ends today, monster!" }
    ]
  },
  "Crystal Leviathan": {
    icon: "üêô",
    color: "#0088ff",
    dialogues: [
      { speaker: "boss", text: "The depths welcome you, surface dweller..." },
      { speaker: "boss", text: "None who enter my domain ever leave." },
      { speaker: "boss", text: "The crystals will preserve your bones... forever!" },
      { speaker: "player", text: "I need that key shard - nothing will stop me!" }
    ]
  },
  "Elder Frost Dragon": {
    icon: "üêâ",
    color: "#00ddff",
    dialogues: [
      { speaker: "boss", text: "A mortal dares climb to MY peak?" },
      { speaker: "boss", text: "I have seen empires rise and fall. You are but a fleeting moment." },
      { speaker: "boss", text: "Your frozen corpse will decorate my hoard!" },
      { speaker: "player", text: "Even legends can fall, dragon!" }
    ]
  },
  "Memory Devourer": {
    icon: "‚ò†Ô∏è",
    color: "#ff4400",
    dialogues: [
      { speaker: "boss", text: "At last... you have come to remember." },
      { speaker: "boss", text: "I am the one who stole your past. Your identity. Your very self." },
      { speaker: "boss", text: "And now I will consume what remains!" },
      { speaker: "player", text: "My memories... they're coming back. You took EVERYTHING from me!" },
      { speaker: "boss", text: "Then come, forgotten warrior. Let us end this tale together!" }
    ]
  }
};

// ==================== STORY MISSIONS ====================
const STORY_MISSIONS = {
  "start": { objective: "Begin your journey at the Village Gate", hint: "Click on the glowing node to start!" },
  "boss1": { objective: "Defeat the Shadow Beast", hint: "Complete both paths to unlock the boss!" },
  "boss2": { objective: "Purify the Bloodwood Guardian", hint: "The Crimson Forest hides dark secrets..." },
  "cave_boss": { objective: "Obtain the Water Key Shard", hint: "Explore the underwater caves to find it." },
  "mountain_boss": { objective: "Obtain the Fire Key Shard", hint: "Brave the frozen peaks to claim it." },
  "forgotten_gate": { objective: "Open the Forgotten Gates", hint: "You need both key shards!" },
  "final_boss": { objective: "Confront the Memory Devourer", hint: "Your destiny awaits..." }
};

// ==================== BOSS DEFEAT DIALOGUES ====================
const BOSS_DEFEAT_DIALOGUES = {
  "Shadow Beast": {
    icon: "üê∫",
    color: "#8844aa",
    dialogues: [
      { speaker: "boss", text: "Impossible... the shadows... they fade..." },
      { speaker: "boss", text: "You are stronger than I foresaw, warrior..." },
      { speaker: "player", text: "The light always conquers darkness!" },
      { speaker: "boss", text: "Perhaps... but darker things await in the Crimson Forest... beware..." }
    ]
  },
  "Bloodwood Guardian": {
    icon: "üå≤",
    color: "#aa0000",
    dialogues: [
      { speaker: "boss", text: "The forest... it screams..." },
      { speaker: "boss", text: "You have broken the cycle... the corruption fades..." },
      { speaker: "player", text: "Rest now. Your watch is over." },
      { speaker: "boss", text: "Thank... you... warrior... take this knowledge... two paths lie ahead..." }
    ]
  },
  "Crystal Leviathan": {
    icon: "üêô",
    color: "#0088ff",
    dialogues: [
      { speaker: "boss", text: "The depths... release me at last..." },
      { speaker: "boss", text: "Take the Water Shard... you have earned it..." },
      { speaker: "player", text: "One shard down. One more to go." },
      { speaker: "boss", text: "The dragon guards the other... may the tides guide you..." }
    ]
  },
  "Elder Frost Dragon": {
    icon: "üêâ",
    color: "#00ddff",
    dialogues: [
      { speaker: "boss", text: "In all my centuries... none have bested me..." },
      { speaker: "boss", text: "You are worthy, mortal. Take the Fire Shard." },
      { speaker: "player", text: "Now I can open the Forgotten Gates!" },
      { speaker: "boss", text: "The Memory Devourer awaits... reclaim what was stolen... remember who you are..." }
    ]
  },
  "Memory Devourer": {
    icon: "‚ò†Ô∏è",
    color: "#ff4400",
    dialogues: [
      { speaker: "boss", text: "NO! The memories... they're returning to you!" },
      { speaker: "player", text: "I remember everything now... I was a guardian of this realm!" },
      { speaker: "boss", text: "You were the GREATEST guardian... that's why I had to erase you!" },
      { speaker: "player", text: "And now I've reclaimed my destiny. This realm is protected once more!" },
      { speaker: "boss", text: "Perhaps... but I am eternal... we will meet again... forgotten warrior..." }
    ]
  }
};

// ==================== ACHIEVEMENTS SYSTEM ====================
const ACHIEVEMENTS = {
  // Kill Achievements
  firstBlood: { id: "firstBlood", name: "First Blood", desc: "Kill your first enemy", icon: "üó°Ô∏è", reward: { coins: 50 }, check: (stats) => stats.totalKills >= 1 },
  slayer100: { id: "slayer100", name: "Slayer", desc: "Kill 100 enemies", icon: "‚öîÔ∏è", reward: { coins: 200 }, check: (stats) => stats.totalKills >= 100 },
  slayer500: { id: "slayer500", name: "Executioner", desc: "Kill 500 enemies", icon: "üî™", reward: { coins: 500, gems: 10 }, check: (stats) => stats.totalKills >= 500 },
  slayer1000: { id: "slayer1000", name: "Annihilator", desc: "Kill 1000 enemies", icon: "üíÄ", reward: { coins: 1000, gems: 25 }, check: (stats) => stats.totalKills >= 1000 },
  slayer5000: { id: "slayer5000", name: "Genocide", desc: "Kill 5000 enemies", icon: "‚ò†Ô∏è", reward: { coins: 2500, gems: 50 }, check: (stats) => stats.totalKills >= 5000 },
  
  // Wave Achievements
  wave10: { id: "wave10", name: "Survivor", desc: "Reach wave 10", icon: "üåä", reward: { coins: 100 }, check: (stats) => stats.highestWave >= 10 },
  wave25: { id: "wave25", name: "Veteran", desc: "Reach wave 25", icon: "üèÖ", reward: { coins: 300, gems: 15 }, check: (stats) => stats.highestWave >= 25 },
  wave50: { id: "wave50", name: "Champion", desc: "Reach wave 50", icon: "üèÜ", reward: { coins: 750, gems: 35 }, check: (stats) => stats.highestWave >= 50 },
  wave100: { id: "wave100", name: "Legend", desc: "Reach wave 100", icon: "üëë", reward: { coins: 2000, gems: 100 }, check: (stats) => stats.highestWave >= 100 },
  
  // Boss Achievements
  bossSlayer: { id: "bossSlayer", name: "Boss Slayer", desc: "Defeat your first boss", icon: "üê∫", reward: { coins: 250 }, check: (stats) => stats.bossKills >= 1 },
  bossHunter: { id: "bossHunter", name: "Boss Hunter", desc: "Defeat 10 bosses", icon: "üêâ", reward: { coins: 500, gems: 20 }, check: (stats) => stats.bossKills >= 10 },
  bossmaster: { id: "bossmaster", name: "Bossmaster", desc: "Defeat 50 bosses", icon: "üëπ", reward: { coins: 1500, gems: 75 }, check: (stats) => stats.bossKills >= 50 },
  
  // Story Achievements
  storyStart: { id: "storyStart", name: "The Journey Begins", desc: "Complete your first story node", icon: "üöÄ", reward: { coins: 100 }, check: (stats) => stats.storyNodesCompleted >= 1 },
  shadowSlayer: { id: "shadowSlayer", name: "Shadow Slayer", desc: "Defeat the Shadow Beast", icon: "üê∫", reward: { coins: 500, gems: 25 }, check: (stats) => stats.defeatedBosses && stats.defeatedBosses.includes("Shadow Beast") },
  forestPurifier: { id: "forestPurifier", name: "Forest Purifier", desc: "Defeat the Bloodwood Guardian", icon: "üå≤", reward: { coins: 750, gems: 35 }, check: (stats) => stats.defeatedBosses && stats.defeatedBosses.includes("Bloodwood Guardian") },
  depthExplorer: { id: "depthExplorer", name: "Depth Explorer", desc: "Defeat the Crystal Leviathan", icon: "üêô", reward: { coins: 1000, gems: 50 }, check: (stats) => stats.defeatedBosses && stats.defeatedBosses.includes("Crystal Leviathan") },
  dragonSlayer: { id: "dragonSlayer", name: "Dragon Slayer", desc: "Defeat the Elder Frost Dragon", icon: "üêâ", reward: { coins: 1500, gems: 75 }, check: (stats) => stats.defeatedBosses && stats.defeatedBosses.includes("Elder Frost Dragon") },
  memoryRestored: { id: "memoryRestored", name: "Memory Restored", desc: "Defeat the Memory Devourer", icon: "‚ò†Ô∏è", reward: { coins: 5000, gems: 250, classUnlock: "Vecna" }, check: (stats) => stats.defeatedBosses && stats.defeatedBosses.includes("Memory Devourer") },
  
  // Class Achievements
  classCollector: { id: "classCollector", name: "Class Collector", desc: "Unlock 5 classes", icon: "üé≠", reward: { gems: 50 }, check: (stats) => stats.classesUnlocked >= 5 },
  classMaster: { id: "classMaster", name: "Class Master", desc: "Unlock all classes", icon: "üåü", reward: { gems: 200 }, check: (stats) => stats.classesUnlocked >= 10 },
  
  // Combo Achievements
  combo10: { id: "combo10", name: "Combo Starter", desc: "Get a 10x combo", icon: "üî•", reward: { coins: 100 }, check: (stats) => stats.highestCombo >= 10 },
  combo50: { id: "combo50", name: "Combo King", desc: "Get a 50x combo", icon: "üí•", reward: { coins: 500, gems: 25 }, check: (stats) => stats.highestCombo >= 50 },
  combo100: { id: "combo100", name: "Combo God", desc: "Get a 100x combo", icon: "‚ö°", reward: { coins: 1000, gems: 50 }, check: (stats) => stats.highestCombo >= 100 },
  
  // Wealth Achievements
  rich: { id: "rich", name: "Getting Rich", desc: "Earn 10,000 total coins", icon: "üí∞", reward: { gems: 20 }, check: (stats) => stats.totalCoinsEarned >= 10000 },
  wealthy: { id: "wealthy", name: "Wealthy", desc: "Earn 100,000 total coins", icon: "üíé", reward: { gems: 100 }, check: (stats) => stats.totalCoinsEarned >= 100000 }
};

// ==================== LEADERBOARD SYSTEM ====================
// Note: This is local-only leaderboard. No bots - only real player entries.
const LEADERBOARD_STORAGE_KEY = "evolLegendsLeaderboard";

function getLeaderboard() {
  const saved = localStorage.getItem(LEADERBOARD_STORAGE_KEY);
  if (saved) {
    return JSON.parse(saved);
  }
  return { highestWave: [], mostKills: [] };
}

function saveLeaderboard(leaderboard) {
  localStorage.setItem(LEADERBOARD_STORAGE_KEY, JSON.stringify(leaderboard));
}

function submitToLeaderboard(playerName, wave, kills, className) {
  if (!playerName || playerName.trim() === "") return;
  
  const leaderboard = getLeaderboard();
  const timestamp = Date.now();
  
  // Add to highest wave
  leaderboard.highestWave.push({
    name: playerName,
    score: wave,
    class: className,
    timestamp: timestamp
  });
  
  // Add to most kills
  leaderboard.mostKills.push({
    name: playerName,
    score: kills,
    class: className,
    timestamp: timestamp
  });
  
  // Sort and keep top 10
  leaderboard.highestWave.sort((a, b) => b.score - a.score);
  leaderboard.mostKills.sort((a, b) => b.score - a.score);
  
  leaderboard.highestWave = leaderboard.highestWave.slice(0, 10);
  leaderboard.mostKills = leaderboard.mostKills.slice(0, 10);
  
  saveLeaderboard(leaderboard);
  
  return leaderboard;
}

// ==================== BACKGROUND MUSIC SYSTEM ====================
let bgMusicOscillators = [];
let bgMusicPlaying = false;
let currentBgMusic = null;

function playBackgroundMusic(type) {
  if (!gameData?.settings?.musicVolume || currentBgMusic === type) return;
  
  stopBackgroundMusic();
  currentBgMusic = type;
  bgMusicPlaying = true;
  
  const volume = (gameData.settings.musicVolume || 30) / 100 * 0.15;
  
  // Create ambient music based on region
  const musicPatterns = {
    village: { baseFreq: 220, type: "sine", tempo: 0.5 },
    crimson: { baseFreq: 165, type: "triangle", tempo: 0.7 },
    cave: { baseFreq: 147, type: "sine", tempo: 0.4 },
    mountain: { baseFreq: 196, type: "triangle", tempo: 0.6 },
    forgotten: { baseFreq: 130, type: "sawtooth", tempo: 0.8 },
    battle: { baseFreq: 110, type: "sawtooth", tempo: 1.2 },
    boss: { baseFreq: 82, type: "sawtooth", tempo: 1.5 }
  };
  
  const pattern = musicPatterns[type] || musicPatterns.village;
  
  // Create continuous ambient drone
  function createDrone() {
    if (!bgMusicPlaying) return;
    
    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();
    osc.connect(gain);
    gain.connect(audioContext.destination);
    
    osc.type = pattern.type;
    osc.frequency.setValueAtTime(pattern.baseFreq, audioContext.currentTime);
    gain.gain.setValueAtTime(volume * 0.3, audioContext.currentTime);
    
    // Slow frequency modulation for ambience
    osc.frequency.linearRampToValueAtTime(pattern.baseFreq * 1.02, audioContext.currentTime + 2);
    osc.frequency.linearRampToValueAtTime(pattern.baseFreq * 0.98, audioContext.currentTime + 4);
    osc.frequency.linearRampToValueAtTime(pattern.baseFreq, audioContext.currentTime + 6);
    
    osc.start();
    osc.stop(audioContext.currentTime + 6);
    bgMusicOscillators.push(osc);
    
    setTimeout(createDrone, 5500);
  }
  
  // Create melodic notes
  function playMelody() {
    if (!bgMusicPlaying) return;
    
    const notes = [1, 1.25, 1.5, 1.33, 1.125, 1];
    const noteIndex = Math.floor(Math.random() * notes.length);
    
    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();
    osc.connect(gain);
    gain.connect(audioContext.destination);
    
    osc.type = "sine";
    osc.frequency.setValueAtTime(pattern.baseFreq * 2 * notes[noteIndex], audioContext.currentTime);
    gain.gain.setValueAtTime(0, audioContext.currentTime);
    gain.gain.linearRampToValueAtTime(volume * 0.2, audioContext.currentTime + 0.1);
    gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 1);
    
    osc.start();
    osc.stop(audioContext.currentTime + 1);
    bgMusicOscillators.push(osc);
    
    setTimeout(playMelody, (2000 + Math.random() * 3000) / pattern.tempo);
  }
  
  createDrone();
  setTimeout(playMelody, 1000);
}

function stopBackgroundMusic() {
  bgMusicPlaying = false;
  currentBgMusic = null;
  bgMusicOscillators.forEach(osc => {
    try { osc.stop(); } catch(e) {}
  });
  bgMusicOscillators = [];
}

// ==================== UPGRADE TYPES (In-Game) ====================
const UPGRADE_TYPES = {
  damage: { icon: "‚öîÔ∏è", name: "Power Strike", desc: "+25% damage", apply: p => { p.damage *= 1.25; } },
  fireRate: { icon: "‚ö°", name: "Rapid Fire", desc: "+20% attack speed", apply: p => { p.fireRate *= 0.8; } },
  hp: { icon: "‚ù§Ô∏è", name: "Vitality", desc: "+30 Max HP & heal", apply: p => { p.maxHP += 30; p.hp = p.maxHP; } },
  range: { icon: "üéØ", name: "Extended Range", desc: "+30% range", apply: p => { p.range *= 1.3; } },
  speed: { icon: "üöÄ", name: "Bullet Speed", desc: "+30% projectile speed", apply: p => { p.projectileSpeed *= 1.3; } },
  multiShot: { icon: "üåü", name: "Multi-Shot", desc: "+2 projectiles", apply: p => { p.multiShot = (p.multiShot || 0) + 2; } },
  pierce: { icon: "üî±", name: "Piercing", desc: "Shots pierce enemies", apply: p => { p.pierce = true; } },
  lifesteal: { icon: "ü©∏", name: "Life Drain", desc: "Heal 15% of damage", apply: p => { p.lifesteal = (p.lifesteal || 0) + 0.15; } },
  explosive: { icon: "üí•", name: "Explosive", desc: "Shots explode", apply: p => { p.explosive = true; } },
  crit: { icon: "üí¢", name: "Critical", desc: "+20% crit chance", apply: p => { p.critChance = (p.critChance || 0) + 0.2; } },
  shield: { icon: "üõ°Ô∏è", name: "Shield", desc: "+50 shield", apply: p => { p.shield = (p.shield || 0) + 50; p.maxShield = (p.maxShield || 0) + 50; } },
  regen: { icon: "üíö", name: "Regeneration", desc: "+2 HP per second", apply: p => { p.regen = (p.regen || 0) + 2; } }
};

// ==================== GAME STATE ====================
let currentScreen = "title";
let gameMode = "story"; // "story" or "endless"
let selectedNode = null;
let selectedClass = "Hunter";

// Battle state
let player = null;
let enemies = [];
let projectiles = [];
let particles = [];
let floatingTexts = [];
let minions = [];
let fireZones = [];
let charmedEnemies = []; // Enemies fighting for player
let vecnaMonsters = []; // Vecna's special monsters

let wave = 1;
let maxWaves = 20;
let enemiesToSpawn = 0;
let spawnTimer = 0;
let shootTimer = 0;
let screenShake = 0;
let gameRunning = false;
let gamePaused = false;
let lastTime = 0;
let gameSpeed = 1;

// Wave management
let autoStartWaves = false;
let waveTimer = 0;
let waveTimerActive = false;
let waveTimerMax = 30; // 30 seconds between waves
let shufflesRemaining = 4; // Shuffle button uses

let sessionCoins = 0;
let sessionGems = 0;
let enemiesKilled = 0;
let combo = 0;
let comboTimer = 0;
let maxCombo = 0;

// Ability state
let abilityCooldowns = { ult1: 0, ult2: 0 };
let abilityEffects = {
  huntersMark: null, // Target enemy for bonus damage
  shieldWall: false, shieldWallTimer: 0,
  timeFreezeActive: false, timeFreezeTimer: 0,
  piercingRoundActive: false, piercingRoundTimer: 0,
  deathAuraActive: false, deathAuraTimer: 0,
  hiveMindActive: false, hiveMindTimer: 0,
  upsideDownActive: false, upsideDownTimer: 0,
  phoenixReady: true // Phoenix Rising passive
};

let potions = { heal: 3, shield: 2, crit: 1, damage: 1, speed: 1, dragon: 1 };
let potionCooldowns = { heal: 0, shield: 0, crit: 0, damage: 0, speed: 0, dragon: 0 };
let potionEffects = { critActive: false, critTimer: 0, damageActive: false, damageTimer: 0, speedActive: false, speedTimer: 0 };

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const GROUND_Y = 580;

// ==================== SOUND SYSTEM ====================
const audioContext = new (window.AudioContext || window.webkitAudioContext)();
const soundEnabled = true;

function playSound(type) {
  if (!soundEnabled || !gameData?.settings?.sfxVolume) return;
  
  const volume = (gameData.settings.sfxVolume || 50) / 100;
  const oscillator = audioContext.createOscillator();
  const gainNode = audioContext.createGain();
  
  oscillator.connect(gainNode);
  gainNode.connect(audioContext.destination);
  
  switch (type) {
    case "shoot":
      oscillator.type = "square";
      oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.1);
      gainNode.gain.setValueAtTime(volume * 0.15, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
      oscillator.start();
      oscillator.stop(audioContext.currentTime + 0.1);
      break;
      
    case "hit":
      oscillator.type = "triangle";
      oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.08);
      gainNode.gain.setValueAtTime(volume * 0.2, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.08);
      oscillator.start();
      oscillator.stop(audioContext.currentTime + 0.08);
      break;
      
    case "kill":
      oscillator.type = "sawtooth";
      oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.2);
      gainNode.gain.setValueAtTime(volume * 0.25, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
      oscillator.start();
      oscillator.stop(audioContext.currentTime + 0.2);
      break;
      
    case "potion":
      oscillator.type = "sine";
      oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.15);
      gainNode.gain.setValueAtTime(volume * 0.2, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
      oscillator.start();
      oscillator.stop(audioContext.currentTime + 0.15);
      break;
      
    case "ability":
      oscillator.type = "sine";
      oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.25);
      gainNode.gain.setValueAtTime(volume * 0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.25);
      oscillator.start();
      oscillator.stop(audioContext.currentTime + 0.25);
      
      // Second tone for epic feel
      setTimeout(() => {
        const osc2 = audioContext.createOscillator();
        const gain2 = audioContext.createGain();
        osc2.connect(gain2);
        gain2.connect(audioContext.destination);
        osc2.type = "triangle";
        osc2.frequency.setValueAtTime(600, audioContext.currentTime);
        osc2.frequency.exponentialRampToValueAtTime(1500, audioContext.currentTime + 0.2);
        gain2.gain.setValueAtTime(volume * 0.2, audioContext.currentTime);
        gain2.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
        osc2.start();
        osc2.stop(audioContext.currentTime + 0.2);
      }, 100);
      break;
      
    case "wave":
      oscillator.type = "sine";
      oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(600, audioContext.currentTime + 0.1);
      oscillator.frequency.setValueAtTime(500, audioContext.currentTime + 0.1);
      oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.2);
      gainNode.gain.setValueAtTime(volume * 0.25, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
      oscillator.start();
      oscillator.stop(audioContext.currentTime + 0.3);
      break;
      
    case "levelUp":
      oscillator.type = "sine";
      oscillator.frequency.setValueAtTime(500, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(1000, audioContext.currentTime + 0.2);
      oscillator.frequency.setValueAtTime(800, audioContext.currentTime + 0.2);
      oscillator.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.4);
      gainNode.gain.setValueAtTime(volume * 0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
      oscillator.start();
      oscillator.stop(audioContext.currentTime + 0.4);
      break;
      
    case "victory":
      // Happy ascending notes
      const notes = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6
      notes.forEach((freq, i) => {
        setTimeout(() => {
          const osc = audioContext.createOscillator();
          const gain = audioContext.createGain();
          osc.connect(gain);
          gain.connect(audioContext.destination);
          osc.type = "sine";
          osc.frequency.setValueAtTime(freq, audioContext.currentTime);
          gain.gain.setValueAtTime(volume * 0.3, audioContext.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
          osc.start();
          osc.stop(audioContext.currentTime + 0.3);
        }, i * 150);
      });
      return;
      
    case "gameOver":
      oscillator.type = "sawtooth";
      oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(80, audioContext.currentTime + 0.8);
      gainNode.gain.setValueAtTime(volume * 0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.8);
      oscillator.start();
      oscillator.stop(audioContext.currentTime + 0.8);
      break;
    
    case "playerDefeat":
      // Sad descending notes for player death
      const sadNotes = [392, 349.23, 293.66, 220]; // G4, F4, D4, A3
      sadNotes.forEach((freq, i) => {
        setTimeout(() => {
          const osc = audioContext.createOscillator();
          const gain = audioContext.createGain();
          osc.connect(gain);
          gain.connect(audioContext.destination);
          osc.type = "sine";
          osc.frequency.setValueAtTime(freq, audioContext.currentTime);
          gain.gain.setValueAtTime(volume * 0.3, audioContext.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
          osc.start();
          osc.stop(audioContext.currentTime + 0.4);
        }, i * 200);
      });
      return;
    
    case "bossDefeat":
      // Epic triumphant fanfare for boss death
      const epicNotes = [523.25, 659.25, 783.99, 1046.50, 1318.51, 1046.50]; // C5, E5, G5, C6, E6, C6
      epicNotes.forEach((freq, i) => {
        setTimeout(() => {
          const osc = audioContext.createOscillator();
          const gain = audioContext.createGain();
          osc.connect(gain);
          gain.connect(audioContext.destination);
          osc.type = i < 4 ? "sine" : "triangle";
          osc.frequency.setValueAtTime(freq, audioContext.currentTime);
          gain.gain.setValueAtTime(volume * 0.35, audioContext.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
          osc.start();
          osc.stop(audioContext.currentTime + 0.4);
        }, i * 120);
      });
      return;
      
    case "boss":
      oscillator.type = "sawtooth";
      oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(80, audioContext.currentTime + 0.3);
      gainNode.gain.setValueAtTime(volume * 0.35, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
      oscillator.start();
      oscillator.stop(audioContext.currentTime + 0.3);
      
      // Ominous second tone
      setTimeout(() => {
        const osc2 = audioContext.createOscillator();
        const gain2 = audioContext.createGain();
        osc2.connect(gain2);
        gain2.connect(audioContext.destination);
        osc2.type = "sine";
        osc2.frequency.setValueAtTime(100, audioContext.currentTime);
        gain2.gain.setValueAtTime(volume * 0.25, audioContext.currentTime);
        gain2.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
        osc2.start();
        osc2.stop(audioContext.currentTime + 0.5);
      }, 200);
      break;
      
    case "explosion":
      // White noise for explosion
      const bufferSize = audioContext.sampleRate * 0.2;
      const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
      const output = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        output[i] = Math.random() * 2 - 1;
      }
      const noise = audioContext.createBufferSource();
      noise.buffer = buffer;
      const noiseGain = audioContext.createGain();
      noise.connect(noiseGain);
      noiseGain.connect(audioContext.destination);
      noiseGain.gain.setValueAtTime(volume * 0.3, audioContext.currentTime);
      noiseGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
      noise.start();
      noise.stop(audioContext.currentTime + 0.2);
      return;
  }
}

// ==================== INITIALIZATION ====================
function init() {
  loadGameData();
  createStarfield();
  setupEventListeners();
  updateAllDisplays();
  
  // Start animation loop
  requestAnimationFrame(mainLoop);
}

function loadGameData() {
  const saved = localStorage.getItem("evolLegendsData");
  if (saved) {
    const parsed = JSON.parse(saved);
    gameData = { ...DEFAULT_GAME_DATA, ...parsed };
    // Ensure nested objects exist
    gameData.permanentUpgrades = { ...DEFAULT_GAME_DATA.permanentUpgrades, ...parsed.permanentUpgrades };
    gameData.potionUpgrades = { ...DEFAULT_GAME_DATA.potionUpgrades, ...parsed.potionUpgrades };
    gameData.potionInventory = { ...DEFAULT_GAME_DATA.potionInventory, ...parsed.potionInventory };
    gameData.cosmetics = { ...DEFAULT_GAME_DATA.cosmetics, ...parsed.cosmetics };
    gameData.settings = { ...DEFAULT_GAME_DATA.settings, ...parsed.settings };
    
    // Ensure starter classes are always unlocked
    if (!gameData.unlockedClasses.includes("Hunter")) gameData.unlockedClasses.push("Hunter");
    if (!gameData.unlockedClasses.includes("Knight")) gameData.unlockedClasses.push("Knight");
    if (!gameData.unlockedClasses.includes("Assassin")) gameData.unlockedClasses.push("Assassin");
  }
}

function saveGameData() {
  localStorage.setItem("evolLegendsData", JSON.stringify(gameData));
  updateAllDisplays();
}

function updateAllDisplays() {
  // Menu displays
  document.getElementById("menuCoins").textContent = gameData.totalCoins;
  document.getElementById("menuGems").textContent = gameData.totalGems;
  document.getElementById("menuHighWave").textContent = gameData.highestWave;
  document.getElementById("menuProgress").textContent = Math.floor(gameData.storyProgress);
  document.getElementById("menuWarriorName").textContent = gameData.warriorName || "Warrior";
  
  // Shop displays
  document.getElementById("shopCoins").textContent = gameData.totalCoins;
  document.getElementById("shopGems").textContent = gameData.totalGems;
  
  // Map displays
  document.getElementById("mapCoins").textContent = gameData.totalCoins;
  document.getElementById("mapGems").textContent = gameData.totalGems;
  document.getElementById("mapProgress").textContent = Math.floor(gameData.storyProgress);
  
  // Settings
  document.getElementById("musicVolume").value = gameData.settings.musicVolume;
  document.getElementById("sfxVolume").value = gameData.settings.sfxVolume;
  updateToggle("autoShootToggle", gameData.settings.autoShoot);
  updateToggle("autoAimToggle", gameData.settings.autoAim);
  updateToggle("screenShakeToggle", gameData.settings.screenShake);
  updateToggle("damageNumbersToggle", gameData.settings.damageNumbers);
}

function updateToggle(id, value) {
  const el = document.getElementById(id);
  if (el) {
    el.classList.toggle("on", value);
  }
}

// ==================== ACHIEVEMENT FUNCTIONS ====================
function checkAchievements() {
  const stats = {
    totalKills: gameData.totalKills || 0,
    highestWave: gameData.highestWave || 1,
    bossKills: gameData.bossKills || 0,
    storyNodesCompleted: gameData.storyNodesCompleted || 0,
    defeatedBosses: gameData.defeatedBosses || [],
    classesUnlocked: (gameData.unlockedClasses || []).length,
    highestCombo: gameData.highestCombo || 0,
    totalCoinsEarned: gameData.totalCoinsEarned || 0
  };
  
  for (const [id, achievement] of Object.entries(ACHIEVEMENTS)) {
    if (gameData.unlockedAchievements && gameData.unlockedAchievements.includes(id)) continue;
    
    if (achievement.check(stats)) {
      unlockAchievement(id);
    }
  }
}

function unlockAchievement(achievementId) {
  const achievement = ACHIEVEMENTS[achievementId];
  if (!achievement) return;
  
  // Initialize array if needed
  if (!gameData.unlockedAchievements) gameData.unlockedAchievements = [];
  
  // Already unlocked
  if (gameData.unlockedAchievements.includes(achievementId)) return;
  
  // Unlock
  gameData.unlockedAchievements.push(achievementId);
  
  // Give rewards
  if (achievement.reward) {
    if (achievement.reward.coins) {
      gameData.totalCoins += achievement.reward.coins;
    }
    if (achievement.reward.gems) {
      gameData.totalGems += achievement.reward.gems;
    }
    if (achievement.reward.classUnlock && !gameData.unlockedClasses.includes(achievement.reward.classUnlock)) {
      gameData.unlockedClasses.push(achievement.reward.classUnlock);
    }
  }
  
  saveGameData();
  showAchievementPopup(achievement);
}

function showAchievementPopup(achievement) {
  const popup = document.getElementById("achievementPopup");
  document.getElementById("achievementPopupIcon").textContent = achievement.icon;
  document.getElementById("achievementPopupName").textContent = achievement.name;
  document.getElementById("achievementPopupDesc").textContent = achievement.desc;
  
  let rewardText = "";
  if (achievement.reward) {
    const parts = [];
    if (achievement.reward.coins) parts.push(`üí∞ +${achievement.reward.coins}`);
    if (achievement.reward.gems) parts.push(`üíé +${achievement.reward.gems}`);
    if (achievement.reward.classUnlock) parts.push(`üé≠ Unlocked: ${achievement.reward.classUnlock}`);
    rewardText = parts.join(" | ");
  }
  document.getElementById("achievementPopupReward").textContent = rewardText;
  
  popup.classList.add("show");
  playSound("levelUp");
  
  setTimeout(() => {
    popup.classList.remove("show");
  }, 4000);
}

function showAchievementsScreen() {
  const grid = document.getElementById("achievementsGrid");
  grid.innerHTML = "";
  
  let unlocked = 0;
  const total = Object.keys(ACHIEVEMENTS).length;
  
  for (const [id, achievement] of Object.entries(ACHIEVEMENTS)) {
    const isUnlocked = gameData.unlockedAchievements && gameData.unlockedAchievements.includes(id);
    if (isUnlocked) unlocked++;
    
    const card = document.createElement("div");
    card.className = `achievement-card ${isUnlocked ? 'unlocked' : 'locked'}`;
    
    let rewardText = "";
    if (achievement.reward) {
      const parts = [];
      if (achievement.reward.coins) parts.push(`üí∞ ${achievement.reward.coins}`);
      if (achievement.reward.gems) parts.push(`üíé ${achievement.reward.gems}`);
      parts.join(" ");
      rewardText = parts.join(" ");
    }
    
    card.innerHTML = `
      <div class="achievement-card-icon">${isUnlocked ? achievement.icon : 'üîí'}</div>
      <div class="achievement-card-info">
        <h3>${isUnlocked ? achievement.name : '???'}</h3>
        <p>${isUnlocked ? achievement.desc : 'Keep playing to unlock!'}</p>
        <div class="achievement-card-reward">${rewardText}</div>
      </div>
    `;
    
    grid.appendChild(card);
  }
  
  document.getElementById("achievementsProgress").textContent = `${unlocked} / ${total} Unlocked`;
  document.getElementById("achievementsScreen").classList.add("active");
}

function hideAchievementsScreen() {
  document.getElementById("achievementsScreen").classList.remove("active");
}

// ==================== LEADERBOARD FUNCTIONS ====================
function showLeaderboardScreen() {
  const leaderboard = getLeaderboard();
  
  // Render highest wave
  const waveContainer = document.getElementById("leaderboardWaves");
  waveContainer.innerHTML = "";
  
  if (leaderboard.highestWave.length === 0) {
    waveContainer.innerHTML = '<div class="leaderboard-empty">No entries yet. Play to be the first!</div>';
  } else {
    leaderboard.highestWave.forEach((entry, index) => {
      const rankClass = index === 0 ? 'gold' : index === 1 ? 'silver' : index === 2 ? 'bronze' : '';
      const rankIcon = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `#${index + 1}`;
      
      const div = document.createElement("div");
      div.className = `leaderboard-entry ${rankClass}`;
      div.innerHTML = `
        <span class="leaderboard-rank">${rankIcon}</span>
        <span class="leaderboard-name">${entry.name}</span>
        <span class="leaderboard-class">${entry.class || 'Unknown'}</span>
        <span class="leaderboard-score">Wave ${entry.score}</span>
      `;
      waveContainer.appendChild(div);
    });
  }
  
  // Render most kills
  const killsContainer = document.getElementById("leaderboardKills");
  killsContainer.innerHTML = "";
  
  if (leaderboard.mostKills.length === 0) {
    killsContainer.innerHTML = '<div class="leaderboard-empty">No entries yet. Play to be the first!</div>';
  } else {
    leaderboard.mostKills.forEach((entry, index) => {
      const rankClass = index === 0 ? 'gold' : index === 1 ? 'silver' : index === 2 ? 'bronze' : '';
      const rankIcon = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `#${index + 1}`;
      
      const div = document.createElement("div");
      div.className = `leaderboard-entry ${rankClass}`;
      div.innerHTML = `
        <span class="leaderboard-rank">${rankIcon}</span>
        <span class="leaderboard-name">${entry.name}</span>
        <span class="leaderboard-class">${entry.class || 'Unknown'}</span>
        <span class="leaderboard-score">${entry.score} kills</span>
      `;
      killsContainer.appendChild(div);
    });
  }
  
  document.getElementById("leaderboardScreen").classList.add("active");
}

function hideLeaderboardScreen() {
  document.getElementById("leaderboardScreen").classList.remove("active");
}

// ==================== BOSS DEFEAT DIALOGUE ====================
let defeatDialogueState = {
  active: false,
  dialogues: [],
  currentIndex: 0,
  bossColor: "#ff0000",
  bossIcon: "üëπ",
  onComplete: null
};

function showBossDefeatDialogue(bossName, onComplete) {
  const dialogueData = BOSS_DEFEAT_DIALOGUES[bossName];
  if (!dialogueData) {
    // No dialogue for this boss, just complete
    if (onComplete) onComplete();
    return;
  }
  
  defeatDialogueState = {
    active: true,
    dialogues: dialogueData.dialogues,
    currentIndex: 0,
    bossColor: dialogueData.color,
    bossIcon: dialogueData.icon,
    onComplete: onComplete
  };
  
  // Play boss defeat sound
  playSound("bossDefeat");
  
  document.getElementById("defeatDialogueBox").style.borderColor = dialogueData.color;
  document.getElementById("bossDefeatDialogue").classList.add("active");
  
  showNextDefeatDialogue();
}

function showNextDefeatDialogue() {
  if (defeatDialogueState.currentIndex >= defeatDialogueState.dialogues.length) {
    // Dialogue complete
    document.getElementById("bossDefeatDialogue").classList.remove("active");
    defeatDialogueState.active = false;
    if (defeatDialogueState.onComplete) {
      defeatDialogueState.onComplete();
    }
    return;
  }
  
  const dialogue = defeatDialogueState.dialogues[defeatDialogueState.currentIndex];
  const isBoss = dialogue.speaker === "boss";
  
  document.getElementById("defeatDialogueIcon").textContent = isBoss ? defeatDialogueState.bossIcon : "‚öîÔ∏è";
  document.getElementById("defeatDialogueName").textContent = isBoss ? "BOSS" : "YOU";
  document.getElementById("defeatDialogueName").style.color = isBoss ? defeatDialogueState.bossColor : "#00ff00";
  document.getElementById("defeatDialogueText").textContent = dialogue.text;
  
  defeatDialogueState.currentIndex++;
}

function handleDefeatDialogueClick() {
  if (defeatDialogueState.active) {
    showNextDefeatDialogue();
    playSound("hit");
  }
}

// Event listeners for defeat dialogue
document.getElementById("bossDefeatDialogue").addEventListener("click", handleDefeatDialogueClick);
document.addEventListener("keydown", (e) => {
  if (defeatDialogueState.active) {
    handleDefeatDialogueClick();
    e.preventDefault();
  }
});

function createStarfield() {
  const starfield = document.getElementById("starfield");
  for (let i = 0; i < 100; i++) {
    const star = document.createElement("div");
    star.className = "star";
    star.style.left = Math.random() * 100 + "%";
    star.style.top = Math.random() * 100 + "%";
    star.style.width = (Math.random() * 3 + 1) + "px";
    star.style.height = star.style.width;
    star.style.animationDelay = Math.random() * 2 + "s";
    starfield.appendChild(star);
  }
}

// ==================== EVENT LISTENERS ====================
function setupEventListeners() {
  // Title screen - click OR key
  const titleScreen = document.getElementById("titleScreen");
  titleScreen.addEventListener("click", goToNameEntry);
  document.addEventListener("keydown", function titleKeyHandler(e) {
    if (currentScreen === "title") {
      goToNameEntry();
    }
  });
  
  // Name entry
  document.getElementById("nameConfirmBtn").addEventListener("click", confirmName);
  document.getElementById("warriorNameInput").addEventListener("keypress", (e) => {
    if (e.key === "Enter") confirmName();
  });
  
  // Main menu buttons
  document.getElementById("storyModeBtn").addEventListener("click", () => startMode("story"));
  document.getElementById("endlessModeBtn").addEventListener("click", () => startMode("endless"));
  document.getElementById("shopBtn").addEventListener("click", showShop);
  document.getElementById("settingsBtn").addEventListener("click", showSettings);
  document.getElementById("redeemBtn").addEventListener("click", showRedeem);
  document.getElementById("tutorialBtn").addEventListener("click", () => showScreen("tutorialScreen"));
  document.getElementById("achievementsBtn").addEventListener("click", showAchievementsScreen);
  document.getElementById("leaderboardBtn").addEventListener("click", showLeaderboardScreen);
  
  // Back buttons
  document.getElementById("mapBackBtn").addEventListener("click", () => showScreen("mainMenu"));
  document.getElementById("classBackBtn").addEventListener("click", handleClassBack);
  document.getElementById("shopBackBtn").addEventListener("click", () => showScreen("mainMenu"));
  document.getElementById("settingsBackBtn").addEventListener("click", () => showScreen("mainMenu"));
  document.getElementById("redeemBackBtn").addEventListener("click", () => showScreen("mainMenu"));
  document.getElementById("tutorialBackBtn").addEventListener("click", () => showScreen("mainMenu"));
  document.getElementById("tutorialCloseBtn").addEventListener("click", () => showScreen("mainMenu"));
  document.getElementById("achievementsCloseBtn").addEventListener("click", hideAchievementsScreen);
  document.getElementById("leaderboardCloseBtn").addEventListener("click", hideLeaderboardScreen);
  
  // Level modal
  document.getElementById("enterLevelBtn").addEventListener("click", enterLevel);
  document.getElementById("cancelLevelBtn").addEventListener("click", () => {
    document.getElementById("levelModal").classList.remove("active");
  });
  
  // Shop tabs
  document.querySelectorAll(".shop-tab").forEach(tab => {
    tab.addEventListener("click", () => {
      document.querySelectorAll(".shop-tab").forEach(t => t.classList.remove("active"));
      tab.classList.add("active");
      renderShopTab(tab.dataset.tab);
    });
  });
  
  // Settings toggles
  document.querySelectorAll(".setting-toggle").forEach(toggle => {
    toggle.addEventListener("click", () => {
      toggle.classList.toggle("on");
      const settingId = toggle.id.replace("Toggle", "");
      const settingMap = {
        autoShoot: "autoShoot",
        autoAim: "autoAim",
        screenShake: "screenShake",
        damageNumbers: "damageNumbers"
      };
      if (settingMap[settingId]) {
        gameData.settings[settingMap[settingId]] = toggle.classList.contains("on");
        saveGameData();
      }
    });
  });
  
  // Volume sliders
  document.getElementById("musicVolume").addEventListener("input", (e) => {
    gameData.settings.musicVolume = parseInt(e.target.value);
    saveGameData();
  });
  document.getElementById("sfxVolume").addEventListener("input", (e) => {
    gameData.settings.sfxVolume = parseInt(e.target.value);
    saveGameData();
  });
  
  // Reset data
  document.getElementById("resetDataBtn").addEventListener("click", () => {
    if (confirm("Are you sure you want to reset ALL data? This cannot be undone!")) {
      localStorage.removeItem("evolLegendsData");
      gameData = JSON.parse(JSON.stringify(DEFAULT_GAME_DATA));
      saveGameData();
      showScreen("title");
      alert("All data has been reset!");
    }
  });
  
  // Redeem code
  document.getElementById("redeemSubmitBtn").addEventListener("click", redeemCode);
  document.getElementById("redeemInput").addEventListener("keypress", (e) => {
    if (e.key === "Enter") redeemCode();
  });
  
  // Pause menu
  document.getElementById("resumeBtn").addEventListener("click", resumeGame);
  document.getElementById("restartBtn").addEventListener("click", restartGame);
  document.getElementById("quitBtn").addEventListener("click", quitToMenu);
  
  // Game over / Victory
  document.getElementById("gameOverContinueBtn").addEventListener("click", returnToMenu);
  document.getElementById("victoryContinueBtn").addEventListener("click", handleVictoryContinue);
  
  // Shuffle upgrades button
  document.getElementById("shuffleUpgradesBtn").addEventListener("click", shuffleUpgrades);
  
  // Potion slots
  document.querySelectorAll(".potion-slot").forEach(slot => {
    slot.addEventListener("click", () => usePotion(slot.dataset.type));
  });
  
  // Keyboard controls
  document.addEventListener("keydown", handleKeyDown);
}

// ==================== SCREEN MANAGEMENT ====================
function showScreen(screenId) {
  // Hide all screens
  document.getElementById("titleScreen").classList.add("hidden");
  document.getElementById("nameScreen").classList.remove("active");
  document.getElementById("mainMenu").classList.remove("active");
  document.getElementById("overworldMap").classList.remove("active");
  document.getElementById("classSelection").classList.remove("active");
  document.getElementById("shopScreen").classList.remove("active");
  document.getElementById("settingsScreen").classList.remove("active");
  document.getElementById("redeemScreen").classList.remove("active");
  document.getElementById("tutorialScreen").classList.remove("active");
  document.getElementById("gameScreen").classList.remove("active");
  document.getElementById("levelModal").classList.remove("active");
  document.getElementById("pauseMenu").classList.remove("active");
  document.getElementById("upgradeScreen").classList.remove("active");
  document.getElementById("gameOverScreen").classList.remove("active");
  document.getElementById("victoryScreen").classList.remove("active");
  document.getElementById("potionBar").classList.remove("active");
  
  // Show requested screen
  const screen = document.getElementById(screenId);
  if (screen) {
    if (screenId === "titleScreen") {
      screen.classList.remove("hidden");
    } else {
      screen.classList.add("active");
    }
  }
  
  currentScreen = screenId;
}

function goToNameEntry() {
  if (gameData.warriorName) {
    // Already has a name, go to menu
    showScreen("mainMenu");
  } else {
    showScreen("nameScreen");
  }
}

function confirmName() {
  const name = document.getElementById("warriorNameInput").value.trim();
  if (name.length < 1) {
    alert("Please enter a name!");
    return;
  }
  gameData.warriorName = name;
  saveGameData();
  showScreen("mainMenu");
}

function startMode(mode) {
  gameMode = mode;
  if (mode === "story") {
    showOverworldMap();
  } else {
    // Endless mode - go directly to class selection
    document.getElementById("classSubtitle").textContent = "Choose your class for Endless Mode!";
    showClassSelection();
  }
}

function showOverworldMap() {
  showScreen("overworldMap");
  renderMapNodes();
}

function showClassSelection() {
  showScreen("classSelection");
  renderClassCards();
}

function handleClassBack() {
  if (gameMode === "story") {
    showOverworldMap();
  } else {
    showScreen("mainMenu");
  }
}

function showShop() {
  showScreen("shopScreen");
  renderShopTab("upgrades");
}

function showSettings() {
  showScreen("settingsScreen");
}

function showRedeem() {
  showScreen("redeemScreen");
  document.getElementById("redeemInput").value = "";
  document.getElementById("redeemMessage").textContent = "";
}

// ==================== MAP RENDERING ====================
let playerPosition = "start"; // Current player position on map

function renderMapNodes() {
  const container = document.getElementById("mapNodes");
  container.innerHTML = "";
  
  // Determine current player position (last completed or first unlocked)
  updatePlayerPosition();
  
  // Render connections between nodes
  renderMapConnections();
  
  // Render fog of war
  renderFogOfWar();
  
  // Update mission panel
  updateMissionPanel();
  
  // Update region banner
  updateRegionBanner();
  
  MAP_NODES.forEach(node => {
    const div = document.createElement("div");
    div.className = "map-node";
    
    // Determine node state
    let state = "locked";
    const isRevealed = isNodeRevealed(node);
    
    if (!isRevealed) {
      state = "hidden";
    } else if (gameData.completedNodes.includes(node.id)) {
      state = "completed";
    } else if (gameData.unlockedNodes.includes(node.id)) {
      // Check if keys are required
      if (node.requiredKeys) {
        const hasAllKeys = node.requiredKeys.every(key => gameData.keyShards && gameData.keyShards[key]);
        state = hasAllKeys ? "unlocked" : "locked";
      } else {
        state = "unlocked";
      }
    }
    
    // Check if this is current position
    const isCurrent = node.id === playerPosition;
    
    div.classList.add(state);
    if (node.type === "boss") div.classList.add("boss");
    if (isCurrent && state !== "hidden") div.classList.add("current");
    
    // Position (using transform for centering)
    div.style.left = node.x + "%";
    div.style.top = node.y + "%";
    
    // Icon based on type
    const icons = {
      start: "üè†",
      normal: "‚öîÔ∏è",
      elite: "‚≠ê",
      boss: node.bossIcon || "üëë",
      shop: "üõí",
      shrine: "üèõÔ∏è",
      locked: "üîí"
    };
    
    if (state === "completed") {
      div.textContent = "‚úÖ";
    } else if (state === "locked" && node.requiredKeys) {
      div.textContent = "üîê";
    } else {
      div.textContent = icons[node.type] || "‚öîÔ∏è";
    }
    
    // Add node label
    if (state !== "hidden") {
      const label = document.createElement("div");
      label.className = "map-node-label";
      label.textContent = node.name;
      div.appendChild(label);
    }
    
    // Click handler
    if (state === "unlocked" || (state === "completed" && node.type === "shop")) {
      div.addEventListener("click", () => selectNode(node));
    }
    
    // Tooltip on hover
    div.title = state === "hidden" ? "???" : `${node.name} - ${state}`;
    
    container.appendChild(div);
  });
  
  // Position player marker
  positionPlayerMarker();
  
  // Update currency display
  document.getElementById("mapCoins").textContent = gameData.totalCoins;
  document.getElementById("mapGems").textContent = gameData.totalGems;
}

function updatePlayerPosition() {
  // Find the furthest completed node or first unlocked
  const completedNodes = gameData.completedNodes || [];
  
  if (completedNodes.length === 0) {
    playerPosition = "start";
    return;
  }
  
  // Find last completed node that has unlocked children
  for (let i = MAP_NODES.length - 1; i >= 0; i--) {
    const node = MAP_NODES[i];
    if (completedNodes.includes(node.id)) {
      // Check if there are unlocked children
      const unlockedChildren = node.unlocks.filter(id => 
        gameData.unlockedNodes.includes(id) && !completedNodes.includes(id)
      );
      if (unlockedChildren.length > 0) {
        playerPosition = unlockedChildren[0];
        return;
      }
    }
  }
  
  // Default to last completed
  playerPosition = completedNodes[completedNodes.length - 1];
}

function positionPlayerMarker() {
  const marker = document.getElementById("playerMarker");
  const node = MAP_NODES.find(n => n.id === playerPosition);
  
  if (node && marker) {
    marker.style.left = node.x + "%";
    marker.style.top = node.y + "%";
    marker.style.display = "block";
  }
}

function renderMapConnections() {
  const svg = document.getElementById("mapConnections");
  svg.innerHTML = "";
  
  MAP_NODES.forEach(node => {
    if (!node.unlocks) return;
    
    const nodeRevealed = isNodeRevealed(node);
    
    node.unlocks.forEach(targetId => {
      const target = MAP_NODES.find(n => n.id === targetId);
      if (!target) return;
      
      const targetRevealed = isNodeRevealed(target);
      if (!nodeRevealed && !targetRevealed) return;
      
      // Determine line color based on state
      let color = "#333"; // Hidden
      let dasharray = "5,5";
      
      if (gameData.completedNodes.includes(node.id) && gameData.unlockedNodes.includes(targetId)) {
        color = "#00ff00";
        dasharray = "none";
      } else if (gameData.unlockedNodes.includes(node.id)) {
        color = "#00ffff";
        dasharray = "none";
      }
      
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("x1", node.x + "%");
      line.setAttribute("y1", node.y + "%");
      line.setAttribute("x2", target.x + "%");
      line.setAttribute("y2", target.y + "%");
      line.setAttribute("stroke", color);
      line.setAttribute("stroke-width", "3");
      line.setAttribute("stroke-dasharray", dasharray);
      line.setAttribute("stroke-linecap", "round");
      
      svg.appendChild(line);
    });
  });
}

function renderFogOfWar() {
  const canvas = document.getElementById("fogCanvas");
  const ctx = canvas.getContext("2d");
  
  canvas.width = 1200;
  canvas.height = 700;
  
  // Start with full fog
  ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Clear areas around revealed nodes
  ctx.globalCompositeOperation = "destination-out";
  
  MAP_NODES.forEach(node => {
    if (isNodeRevealed(node)) {
      const x = (node.x / 100) * canvas.width;
      const y = (node.y / 100) * canvas.height;
      const radius = node.type === "boss" ? 120 : 80;
      
      const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
      gradient.addColorStop(0, "rgba(0, 0, 0, 1)");
      gradient.addColorStop(0.7, "rgba(0, 0, 0, 0.8)");
      gradient.addColorStop(1, "rgba(0, 0, 0, 0)");
      
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();
    }
  });
  
  ctx.globalCompositeOperation = "source-over";
}

function isNodeRevealed(node) {
  // Start node is always revealed
  if (node.id === "start" || node.revealed) return true;
  
  // Node is revealed if player has completed a node that unlocks it
  // Or if any required node is completed
  if (node.requiredNodes) {
    for (const reqId of node.requiredNodes) {
      if (gameData.completedNodes.includes(reqId)) return true;
      if (gameData.unlockedNodes.includes(reqId)) return true;
    }
  }
  
  // Or if it's unlocked
  return gameData.unlockedNodes.includes(node.id);
}

function updateMissionPanel() {
  const panel = document.getElementById("missionPanel");
  const objective = document.getElementById("missionObjective");
  const hint = document.getElementById("missionHint");
  
  // Find current mission
  let currentMission = STORY_MISSIONS["start"];
  
  // Check which boss is next
  const bossNodes = MAP_NODES.filter(n => n.type === "boss");
  for (const boss of bossNodes) {
    if (!gameData.completedNodes.includes(boss.id)) {
      if (STORY_MISSIONS[boss.id]) {
        currentMission = STORY_MISSIONS[boss.id];
      } else {
        currentMission = { 
          objective: `Defeat ${boss.bossName || boss.name}`, 
          hint: `Find your way to ${boss.name}!` 
        };
      }
      break;
    }
  }
  
  objective.textContent = currentMission.objective;
  hint.textContent = currentMission.hint;
}

function updateRegionBanner() {
  const node = MAP_NODES.find(n => n.id === playerPosition);
  if (!node) return;
  
  const regionName = document.getElementById("regionName");
  const regionDesc = document.getElementById("regionDesc");
  const mapRegion = document.getElementById("mapRegion");
  
  const region = REGIONS[node.region];
  
  regionName.textContent = node.region;
  regionName.style.color = region ? region.color : "#ffff00";
  regionDesc.textContent = region ? region.desc : "";
  mapRegion.textContent = node.region;
  
  // Play region music
  if (region && region.bgMusic) {
    playBackgroundMusic(region.bgMusic);
  }
}

function selectNode(node) {
  selectedNode = node;
  
  // Play select sound
  playSound("potion");
  
  document.getElementById("levelName").textContent = node.name;
  document.getElementById("levelDesc").textContent = node.description || "A challenging area awaits...";
  document.getElementById("levelDifficulty").textContent = node.difficulty;
  
  let rewardText = "";
  if (node.rewards.coins) rewardText += node.rewards.coins + " coins";
  if (node.rewards.gems) rewardText += (rewardText ? ", " : "") + node.rewards.gems + " gems";
  if (node.rewards.classUnlock) rewardText += (rewardText ? ", " : "") + "üé≠ Unlock: " + node.rewards.classUnlock;
  if (node.rewards.keyShard) rewardText += (rewardText ? ", " : "") + "üîë " + node.rewards.keyShard.toUpperCase() + " Key Shard";
  document.getElementById("levelRewards").textContent = rewardText || "Experience";
  
  document.getElementById("levelModal").classList.add("active");
}

function enterLevel() {
  document.getElementById("levelModal").classList.remove("active");
  
  // Check if this is a boss with dialogue
  if (selectedNode.type === "boss" && selectedNode.bossName && BOSS_DIALOGUES[selectedNode.bossName]) {
    showBossDialogue(selectedNode.bossName, () => {
      proceedToClassSelection();
    });
  } else if (selectedNode.type === "shop") {
    // Go to shop instead of battle
    showShop();
  } else {
    proceedToClassSelection();
  }
}

function proceedToClassSelection() {
  maxWaves = selectedNode.waves || 20;
  
  // Check if boss has no enemy spawns
  if (selectedNode.noEnemySpawns) {
    // Boss fight only - set flag
    window.bossOnlyFight = true;
  } else {
    window.bossOnlyFight = false;
  }
  
  document.getElementById("classSubtitle").textContent = `Select class for: ${selectedNode.name}`;
  
  // Stop map music, prepare for battle music
  stopBackgroundMusic();
  
  showClassSelection();
}

// ==================== BOSS DIALOGUE SYSTEM ====================
let currentDialogue = null;
let dialogueIndex = 0;
let dialogueCallback = null;

function showBossDialogue(bossName, callback) {
  const dialogue = BOSS_DIALOGUES[bossName];
  if (!dialogue) {
    callback();
    return;
  }
  
  currentDialogue = dialogue;
  dialogueIndex = 0;
  dialogueCallback = callback;
  
  // Play boss music
  playBackgroundMusic("boss");
  playSound("boss");
  
  const overlay = document.getElementById("bossDialogue");
  overlay.classList.add("active");
  
  updateDialogueDisplay();
  
  // Add click/key listener
  const advanceDialogue = (e) => {
    if (e.type === "keydown" && e.code !== "Space" && e.code !== "Enter") return;
    
    dialogueIndex++;
    
    if (dialogueIndex >= currentDialogue.dialogues.length) {
      // End dialogue
      overlay.classList.remove("active");
      document.removeEventListener("keydown", advanceDialogue);
      overlay.removeEventListener("click", advanceDialogue);
      
      if (dialogueCallback) dialogueCallback();
    } else {
      updateDialogueDisplay();
    }
  };
  
  document.addEventListener("keydown", advanceDialogue);
  overlay.addEventListener("click", advanceDialogue);
}

function updateDialogueDisplay() {
  if (!currentDialogue) return;
  
  const current = currentDialogue.dialogues[dialogueIndex];
  const portrait = document.getElementById("bossPortrait");
  const name = document.getElementById("bossNameDialogue");
  const text = document.getElementById("dialogueText");
  
  if (current.speaker === "boss") {
    portrait.textContent = currentDialogue.icon;
    name.textContent = Object.keys(BOSS_DIALOGUES).find(k => BOSS_DIALOGUES[k] === currentDialogue);
    name.style.color = currentDialogue.color;
    text.textContent = `"${current.text}"`;
  } else {
    portrait.textContent = "‚öîÔ∏è";
    name.textContent = gameData.warriorName || "Warrior";
    name.style.color = "#00ffff";
    text.textContent = `"${current.text}"`;
  }
}

// ==================== CLASS SELECTION ====================
function renderClassCards() {
  const grid = document.getElementById("classGrid");
  grid.innerHTML = "";
  
  Object.entries(CLASSES).forEach(([name, cls]) => {
    const card = document.createElement("div");
    card.className = "class-card";
    
    // Check if unlocked
    const isUnlocked = gameData.unlockedClasses.includes(name) || 
                       gameData.purchasedClasses.includes(name);
    
    if (!isUnlocked) {
      card.classList.add("locked");
    }
    
    card.innerHTML = `
      <div class="class-icon">${cls.icon}</div>
      <div class="class-name" style="color: ${cls.color}">${name}</div>
      <div class="class-stats">
        HP: ${cls.stats.maxHP} | DMG: ${cls.stats.damage}<br>
        ${cls.description}
      </div>
      ${!isUnlocked ? `<div class="class-unlock">${cls.purchasable ? 'Available in Shop' : 'Wave ' + cls.unlockWave}</div>` : ''}
    `;
    
    if (isUnlocked) {
      card.addEventListener("click", () => selectClass(name));
    }
    
    grid.appendChild(card);
  });
}

function selectClass(className) {
  selectedClass = className;
  gameData.selectedClass = className;
  saveGameData();
  startBattle();
}

// ==================== SHOP ====================
function renderShopTab(tab) {
  const grid = document.getElementById("shopGrid");
  grid.innerHTML = "";
  
  if (tab === "upgrades") {
    Object.entries(SHOP_UPGRADES).forEach(([key, upgrade]) => {
      const level = gameData.permanentUpgrades[key] || 0;
      const isMaxed = level >= upgrade.maxLevel;
      const cost = isMaxed ? null : upgrade.getCost(level);
      
      const item = document.createElement("div");
      item.className = "shop-item" + (isMaxed ? " maxed" : "");
      item.innerHTML = `
        <div class="shop-item-name">${upgrade.name}</div>
        <div class="shop-item-desc">${upgrade.desc}</div>
        <div style="color: #00ff00; font-size: 11px; margin-bottom: 5px;">Level: ${level}/${upgrade.maxLevel}</div>
        <div class="shop-item-cost">${isMaxed ? "‚úÖ MAXED" : `üí∞ ${cost.coins}${cost.gems > 0 ? " | üíé " + cost.gems : ""}`}</div>
      `;
      
      if (!isMaxed) {
        item.addEventListener("click", () => purchaseUpgrade(key));
      }
      
      grid.appendChild(item);
    });
  } else if (tab === "potions") {
    Object.entries(SHOP_POTIONS).forEach(([key, potion]) => {
      const item = document.createElement("div");
      item.className = "shop-item";
      item.innerHTML = `
        <div class="shop-item-name">${potion.name}</div>
        <div class="shop-item-desc">${potion.desc}</div>
        <div class="shop-item-cost">üí∞ ${potion.cost.coins}${potion.cost.gems > 0 ? " | üíé " + potion.cost.gems : ""}</div>
      `;
      item.addEventListener("click", () => purchasePotion(key));
      grid.appendChild(item);
    });
  } else if (tab === "classes") {
    Object.entries(CLASSES).forEach(([name, cls]) => {
      if (!cls.purchasable) return;
      
      const isPurchased = gameData.purchasedClasses.includes(name);
      const item = document.createElement("div");
      item.className = "shop-item" + (isPurchased ? " maxed" : "");
      item.innerHTML = `
        <div class="shop-item-name">${cls.icon} ${name}</div>
        <div class="shop-item-desc">${cls.description}</div>
        <div class="shop-item-cost">${isPurchased ? "‚úÖ OWNED" : `üí∞ ${cls.cost.coins} | üíé ${cls.cost.gems}`}</div>
      `;
      
      if (!isPurchased) {
        item.addEventListener("click", () => purchaseClass(name));
      }
      
      grid.appendChild(item);
    });
  } else if (tab === "cosmetics") {
    Object.entries(SHOP_COSMETICS).forEach(([key, cosmetic]) => {
      const isOwned = cosmetic.type === "skin" 
        ? gameData.cosmetics.unlockedSkins.includes(cosmetic.id)
        : gameData.cosmetics.unlockedEffects.includes(cosmetic.id);
      
      const isEquipped = cosmetic.type === "skin"
        ? gameData.cosmetics.playerSkin === cosmetic.id
        : gameData.cosmetics.attackEffect === cosmetic.id;
      
      const item = document.createElement("div");
      item.className = "shop-item" + (isEquipped ? " maxed" : "");
      item.innerHTML = `
        <div class="shop-item-name">${cosmetic.name}</div>
        <div class="shop-item-desc">${cosmetic.desc}</div>
        <div class="shop-item-cost">${isOwned ? (isEquipped ? "‚úÖ EQUIPPED" : "üëÜ CLICK TO EQUIP") : `üí∞ ${cosmetic.cost.coins} | üíé ${cosmetic.cost.gems}`}</div>
      `;
      
      item.addEventListener("click", () => {
        if (isOwned) {
          equipCosmetic(cosmetic);
        } else {
          purchaseCosmetic(key, cosmetic);
        }
      });
      
      grid.appendChild(item);
    });
  }
}

function purchaseUpgrade(key) {
  const upgrade = SHOP_UPGRADES[key];
  const level = gameData.permanentUpgrades[key] || 0;
  if (level >= upgrade.maxLevel) return;
  
  const cost = upgrade.getCost(level);
  if (gameData.totalCoins >= cost.coins && gameData.totalGems >= cost.gems) {
    gameData.totalCoins -= cost.coins;
    gameData.totalGems -= cost.gems;
    gameData.permanentUpgrades[key] = level + 1;
    saveGameData();
    renderShopTab("upgrades");
    alert(`‚úÖ Upgraded ${upgrade.name} to level ${level + 1}!`);
  } else {
    alert("‚ùå Not enough currency!");
  }
}

function purchasePotion(key) {
  const potion = SHOP_POTIONS[key];
  if (gameData.totalCoins >= potion.cost.coins && gameData.totalGems >= potion.cost.gems) {
    gameData.totalCoins -= potion.cost.coins;
    gameData.totalGems -= potion.cost.gems;
    
    Object.entries(potion.gives).forEach(([type, amount]) => {
      gameData.potionInventory[type] = (gameData.potionInventory[type] || 0) + amount;
    });
    
    saveGameData();
    alert(`‚úÖ Purchased ${potion.name}!`);
  } else {
    alert("‚ùå Not enough currency!");
  }
}

function purchaseClass(name) {
  const cls = CLASSES[name];
  if (gameData.totalCoins >= cls.cost.coins && gameData.totalGems >= cls.cost.gems) {
    gameData.totalCoins -= cls.cost.coins;
    gameData.totalGems -= cls.cost.gems;
    gameData.purchasedClasses.push(name);
    gameData.unlockedClasses.push(name);
    saveGameData();
    renderShopTab("classes");
    alert(`‚úÖ Unlocked ${name}!`);
  } else {
    alert("‚ùå Not enough currency!");
  }
}

function purchaseCosmetic(key, cosmetic) {
  if (gameData.totalCoins >= cosmetic.cost.coins && gameData.totalGems >= cosmetic.cost.gems) {
    gameData.totalCoins -= cosmetic.cost.coins;
    gameData.totalGems -= cosmetic.cost.gems;
    
    if (cosmetic.type === "skin") {
      gameData.cosmetics.unlockedSkins.push(cosmetic.id);
      gameData.cosmetics.playerSkin = cosmetic.id;
    } else {
      gameData.cosmetics.unlockedEffects.push(cosmetic.id);
      gameData.cosmetics.attackEffect = cosmetic.id;
    }
    
    saveGameData();
    renderShopTab("cosmetics");
    alert(`‚úÖ Purchased and equipped ${cosmetic.name}!`);
  } else {
    alert("‚ùå Not enough currency!");
  }
}

function equipCosmetic(cosmetic) {
  if (cosmetic.type === "skin") {
    gameData.cosmetics.playerSkin = cosmetic.id;
  } else {
    gameData.cosmetics.attackEffect = cosmetic.id;
  }
  saveGameData();
  renderShopTab("cosmetics");
}

// ==================== REDEEM CODES ====================
function redeemCode() {
  const input = document.getElementById("redeemInput");
  const message = document.getElementById("redeemMessage");
  const code = input.value.trim().toUpperCase();
  
  if (!code) {
    message.textContent = "‚ùå Please enter a code!";
    message.style.color = "#ff0000";
    return;
  }
  
  if (gameData.redeemedCodes.includes(code)) {
    message.textContent = "‚ùå Code already redeemed!";
    message.style.color = "#ff0000";
    return;
  }
  
  const reward = REDEEM_CODES[code];
  if (!reward) {
    message.textContent = "‚ùå Invalid code!";
    message.style.color = "#ff0000";
    return;
  }
  
  // Apply rewards
  gameData.totalCoins += reward.coins || 0;
  gameData.totalGems += reward.gems || 0;
  
  if (reward.classUnlock && !gameData.unlockedClasses.includes(reward.classUnlock)) {
    gameData.unlockedClasses.push(reward.classUnlock);
  }
  
  if (reward.skinUnlock && !gameData.cosmetics.unlockedSkins.includes(reward.skinUnlock)) {
    gameData.cosmetics.unlockedSkins.push(reward.skinUnlock);
  }
  
  if (reward.effectUnlock && !gameData.cosmetics.unlockedEffects.includes(reward.effectUnlock)) {
    gameData.cosmetics.unlockedEffects.push(reward.effectUnlock);
  }
  
  gameData.redeemedCodes.push(code);
  saveGameData();
  
  let rewardText = reward.message + "\n";
  if (reward.coins) rewardText += `+${reward.coins} coins `;
  if (reward.gems) rewardText += `+${reward.gems} gems `;
  if (reward.classUnlock) rewardText += `Unlocked: ${reward.classUnlock}!`;
  
  message.textContent = "‚úÖ " + rewardText;
  message.style.color = "#00ff00";
  input.value = "";
}

// ==================== BATTLE SYSTEM ====================
function startBattle() {
  showScreen("gameScreen");
  document.getElementById("potionBar").classList.add("active");
  document.getElementById("abilityBar").classList.add("active");
  
  initializePlayer();
  initializePotions();
  initializeAbilities();
  
  enemies = [];
  projectiles = [];
  particles = [];
  floatingTexts = [];
  minions = [];
  fireZones = [];
  charmedEnemies = [];
  vecnaMonsters = [];
  
  wave = 1;
  enemiesToSpawn = calcEnemiesForWave(wave);
  spawnTimer = 0;
  shootTimer = 0;
  screenShake = 0;
  
  sessionCoins = 0;
  sessionGems = 0;
  enemiesKilled = 0;
  combo = 0;
  maxCombo = 0;
  
  // Reset wave management
  waveTimerActive = false;
  waveTimer = 0;
  shufflesRemaining = 4;
  
  gameRunning = true;
  gamePaused = false;
  lastTime = performance.now();
}

function initializeAbilities() {
  abilityCooldowns = { ult1: 0, ult2: 0 };
  abilityEffects = {
    huntersMark: null,
    shieldWall: false, shieldWallTimer: 0,
    timeFreezeActive: false, timeFreezeTimer: 0,
    piercingRoundActive: false, piercingRoundTimer: 0,
    deathAuraActive: false, deathAuraTimer: 0,
    hiveMindActive: false, hiveMindTimer: 0,
    upsideDownActive: false, upsideDownTimer: 0,
    phoenixReady: true
  };
  
  // Update ability bar with class-specific abilities
  const skillTree = SKILL_TREES[selectedClass];
  if (skillTree) {
    const ult1El = document.getElementById("ability1");
    const ult2El = document.getElementById("ability2");
    const name1El = document.getElementById("ability1Name");
    const name2El = document.getElementById("ability2Name");
    
    if (ult1El && skillTree.ult1) {
      ult1El.textContent = skillTree.ult1.icon;
      if (name1El) name1El.textContent = skillTree.ult1.name;
    }
    if (ult2El && skillTree.ult2) {
      ult2El.textContent = skillTree.ult2.icon;
      if (name2El) name2El.textContent = skillTree.ult2.name;
    }
  }
}

function initializePlayer() {
  const cls = CLASSES[selectedClass];
  const upgrades = gameData.permanentUpgrades;
  
  player = {
    x: 100,
    y: GROUND_Y - 44,
    w: 36,
    h: 44,
    maxHP: cls.stats.maxHP + (upgrades.health * 15),
    hp: cls.stats.maxHP + (upgrades.health * 15),
    damage: cls.stats.damage + (upgrades.damage * 3),
    fireRate: cls.stats.fireRate * (1 - upgrades.fireRate * 0.05),
    range: cls.stats.range,
    projectileSpeed: cls.stats.projectileSpeed,
    color: cls.color,
    icon: cls.icon,
    
    level: 1,
    xp: 0,
    xpToNext: 100,
    
    critChance: (upgrades.critChance * 0.05) + (cls.stats.critBonus || 0),
    critMultiplier: 2.0,
    multiShot: 0,
    pierce: cls.stats.pierce || false,
    explosive: cls.stats.explosive || false,
    lifesteal: 0,
    shield: 0,
    maxShield: 0,
    regen: 0,
    poison: cls.stats.poison || false,
    
    alive: true,
    invincible: false
  };
}

function initializePotions() {
  potions = {
    heal: Math.min(gameData.potionInventory.heal, 5),
    shield: Math.min(gameData.potionInventory.shield, 3),
    crit: Math.min(gameData.potionInventory.crit, 2),
    damage: Math.min(gameData.potionInventory.damage, 2),
    speed: Math.min(gameData.potionInventory.speed, 2),
    dragon: Math.min(gameData.potionInventory.dragon, 1)
  };
  
  potionCooldowns = { heal: 0, shield: 0, crit: 0, damage: 0, speed: 0, dragon: 0 };
  potionEffects = { critActive: false, critTimer: 0, damageActive: false, damageTimer: 0, speedActive: false, speedTimer: 0 };
  
  updatePotionDisplay();
}

function updatePotionDisplay() {
  document.getElementById("potionHealCount").textContent = potions.heal;
  document.getElementById("potionShieldCount").textContent = potions.shield;
  document.getElementById("potionCritCount").textContent = potions.crit;
  document.getElementById("potionDamageCount").textContent = potions.damage;
  document.getElementById("potionSpeedCount").textContent = potions.speed;
  document.getElementById("potionDragonCount").textContent = potions.dragon;
}

function calcEnemiesForWave(w) {
  return 5 + w * 2 + Math.floor(w / 5) * 3;
}

function getEnemyHP(w, isBoss = false, isMiniBoss = false) {
  let hp = 50 + w * 15 + Math.pow(w, 1.5) * 2;
  if (isBoss) hp *= 10;
  else if (isMiniBoss) hp *= 4;
  return Math.floor(hp);
}

// ==================== GAME LOOP ====================
function mainLoop(timestamp) {
  const dt = Math.min((timestamp - lastTime) / 1000, 0.1) * gameSpeed;
  lastTime = timestamp;
  
  if (gameRunning && !gamePaused && currentScreen === "gameScreen") {
    update(dt);
  }
  
  if (currentScreen === "gameScreen") {
    draw();
  }
  
  requestAnimationFrame(mainLoop);
}

function update(dt) {
  if (!player || !player.alive) return;
  
  // Shooting
  handleShooting(dt);
  
  // Spawning
  handleSpawning(dt);
  
  // Update entities
  updateProjectiles(dt);
  updateEnemies(dt);
  updateParticles(dt);
  updateFloatingTexts(dt);
  updatePotionEffects(dt);
  updateFireZones(dt);
  updateAbilityEffects(dt);
  
  // Regeneration
  if (player.regen > 0) {
    player.hp = Math.min(player.hp + player.regen * dt, player.maxHP);
  }
  
  // Screen shake decay
  if (gameData.settings.screenShake) {
    screenShake *= 0.9;
    if (screenShake < 0.1) screenShake = 0;
  } else {
    screenShake = 0;
  }
  
  // Combo decay
  if (combo > 0) {
    comboTimer -= dt;
    if (comboTimer <= 0) combo = 0;
  }
  
  // Wave timer logic
  if (enemiesToSpawn === 0 && enemies.length === 0 && !waveTimerActive) {
    // All enemies cleared - start wave timer
    if (gameMode === "endless" || wave < maxWaves) {
      if (autoStartWaves) {
        // Auto-start: begin timer
        waveTimerActive = true;
        waveTimer = waveTimerMax;
      }
      // If not auto-start, player must wait or press to continue
    }
  }
  
  // Count down wave timer
  if (waveTimerActive && waveTimer > 0) {
    waveTimer -= dt;
    if (waveTimer <= 0) {
      waveTimerActive = false;
      nextWave();
    }
  }
  
  // Check wave completion (manual progression if auto-start is off)
  if (enemiesToSpawn === 0 && enemies.length === 0 && !waveTimerActive) {
    if (gameMode === "endless" || wave < maxWaves) {
      if (!autoStartWaves) {
        // Show "Press SPACE for next wave" or auto-continue
        nextWave(); // For now, auto-continue
      }
    } else {
      victory();
    }
  }
}

function handleShooting(dt) {
  if (!gameData.settings.autoShoot) return;
  
  shootTimer += dt;
  const target = getTargetEnemy();
  
  if (target && shootTimer >= player.fireRate) {
    shootTimer = 0;
    shootProjectile(target);
    
    if (player.multiShot > 0) {
      for (let i = 0; i < player.multiShot; i++) {
        setTimeout(() => {
          const t = getTargetEnemy();
          if (t) shootProjectile(t);
        }, (i + 1) * 50);
      }
    }
  }
}

function getTargetEnemy() {
  if (enemies.length === 0) return null;
  
  let closest = null;
  let closestDist = player.range;
  
  for (const e of enemies) {
    const dx = (e.x + e.w / 2) - (player.x + player.w / 2);
    const dy = (e.y + e.h / 2) - (player.y + player.h / 2);
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    if (dist < closestDist) {
      closestDist = dist;
      closest = e;
    }
  }
  
  return closest;
}

function shootProjectile(target) {
  const px = player.x + player.w / 2;
  const py = player.y + player.h / 2;
  const tx = target.x + target.w / 2;
  const ty = target.y + target.h / 2;
  
  let dx = tx - px;
  let dy = ty - py;
  const dist = Math.sqrt(dx * dx + dy * dy) || 1;
  dx /= dist;
  dy /= dist;
  
  const isCrit = Math.random() < player.critChance;
  
  // Sound
  playSound("shoot");
  
  // Get projectile color based on cosmetic
  let projColor = player.color;
  const effect = gameData.cosmetics.attackEffect;
  if (effect === "spark") projColor = "#00ffff";
  else if (effect === "flame") projColor = "#ff4400";
  else if (effect === "poison") projColor = "#00ff00";
  else if (effect === "star") projColor = "#ffff00";
  else if (effect === "laser") projColor = "#ff00ff";
  else if (effect === "dragon") projColor = "#ff8800";
  
  projectiles.push({
    x: px, y: py,
    vx: dx * player.projectileSpeed,
    vy: dy * player.projectileSpeed,
    radius: 5,
    damage: player.damage,
    color: isCrit ? "#ff0000" : projColor,
    life: 3.5,
    trail: [],
    pierce: player.pierce,
    pierceCount: 0,
    explosive: player.explosive,
    isCrit: isCrit,
    critMultiplier: player.critMultiplier,
    poison: player.poison,
    isEnemyProjectile: false
  });
}

function handleSpawning(dt) {
  if (enemiesToSpawn <= 0) return;
  
  spawnTimer += dt;
  const spawnInterval = Math.max(2.0 - wave * 0.05, 0.3);
  
  if (spawnTimer >= spawnInterval) {
    spawnTimer = 0;
    enemiesToSpawn--;
    
    // Check if this is a boss-only fight (story mode boss nodes)
    const isBossOnlyFight = window.bossOnlyFight && selectedNode && selectedNode.noEnemySpawns;
    
    // In boss-only fights, only spawn the boss on the last wave
    if (isBossOnlyFight) {
      // Only spawn boss on final wave
      if (wave === maxWaves && enemiesToSpawn === calcEnemiesForWave(wave) - 1) {
        spawnStoryBoss();
        return;
      }
      // Spawn fewer enemies in boss-only fights
      if (Math.random() < 0.3) return; // 30% chance to skip spawn
    }
    
    const isBoss = wave % 10 === 0 && enemiesToSpawn === calcEnemiesForWave(wave) - 1;
    const isMiniBoss = wave % 5 === 0 && !isBoss && enemiesToSpawn === calcEnemiesForWave(wave) - 1;
    
    spawnEnemy(isBoss, isMiniBoss);
  }
}

// Spawn story mode boss based on selected node
function spawnStoryBoss() {
  if (!selectedNode || !selectedNode.bossName) {
    spawnEnemy(true, false);
    return;
  }
  
  const bossName = selectedNode.bossName;
  let pattern = null;
  
  // Find matching boss pattern
  for (const [key, p] of Object.entries(BOSS_PATTERNS)) {
    if (p.name.includes(bossName) || bossName.includes(key)) {
      pattern = { ...p, key };
      break;
    }
  }
  
  // Story boss stats based on node
  const size = pattern?.size || 90;
  const hp = getEnemyHP(wave, true, false) * (selectedNode.difficulty / 2);
  const speed = 0.6;
  const color = pattern?.color || "#ff00ff";
  
  // Announce story boss
  addFloatingText(canvas.width / 2, 100, "‚ö†Ô∏è BOSS: " + bossName + " ‚ö†Ô∏è", color);
  playSound("boss");
  playBackgroundMusic("boss");
  
  const enemy = {
    x: canvas.width + 30,
    y: GROUND_Y - size,
    w: size,
    h: size,
    maxHP: hp,
    hp: hp,
    vx: -speed,
    baseSpeed: speed,
    color: color,
    type: "boss",
    isBoss: true,
    isMiniBoss: false,
    isStoryBoss: true,
    storyBossName: bossName,
    pattern: pattern,
    damage: 30 + wave * 3,
    shootTimer: 0,
    attackTimer: 0,
    specialTimer: 0,
    chargeTimer: 0,
    summonTimer: 0,
    phaseTimer: 0,
    currentAttack: null,
    attackCooldown: 0,
    isCharging: false,
    isRaging: false,
    poisonTimer: 0,
    poisonDamage: 0,
    frozen: false,
    frozenTimer: 0,
    stoneForm: false,
    stoneTimer: 0
  };
  
  enemies.push(enemy);
}

function spawnEnemy(isBoss = false, isMiniBoss = false) {
  let size, hp, speed, color, type, pattern = null;
  
  if (isBoss) {
    // Select unique boss pattern based on wave
    const bossKeys = Object.keys(BOSS_PATTERNS);
    const bossIndex = Math.floor((wave / 10) - 1) % bossKeys.length;
    const patternKey = bossKeys[bossIndex];
    pattern = { ...BOSS_PATTERNS[patternKey], key: patternKey };
    
    size = pattern.size || 80;
    hp = getEnemyHP(wave, true, false) * (pattern.hpMult / 10);
    speed = 0.8 * (pattern.speedMult || 1);
    color = pattern.color;
    type = "boss";
    
    // Announce boss
    addFloatingText(canvas.width / 2, 100, "‚ö†Ô∏è BOSS: " + pattern.name + " ‚ö†Ô∏è", pattern.color);
    playSound("boss");
    
  } else if (isMiniBoss) {
    // Select unique mini-boss pattern - no repeats within same run
    const miniBossKeys = Object.keys(MINIBOSS_PATTERNS);
    // Use wave number and random seed to ensure variety
    const seed = wave * 7 + Math.floor(Math.random() * 1000);
    const miniBossIndex = seed % miniBossKeys.length;
    const patternKey = miniBossKeys[miniBossIndex];
    pattern = { ...MINIBOSS_PATTERNS[patternKey], key: patternKey };
    
    size = pattern.size || 55;
    hp = getEnemyHP(wave, false, true) * (pattern.hpMult / 5);
    speed = 1.2 * (pattern.speedMult || 1);
    color = pattern.color;
    type = "miniboss";
    
    // Announce mini-boss
    addFloatingText(canvas.width / 2, 120, "‚ö° " + pattern.name + " ‚ö°", pattern.color);
    
  } else {
    size = 32 + Math.random() * 16;
    hp = getEnemyHP(wave);
    speed = 1.2 + wave * 0.03 + Math.random() * 0.4;
    
    const rand = Math.random();
    if (rand < 0.15) {
      color = "#ffff00"; type = "speedy"; speed *= 2; hp *= 0.5;
    } else if (rand < 0.3) {
      color = "#00ff88"; type = "healer"; speed *= 0.6; hp *= 1.5;
    } else if (rand < 0.45) {
      color = "#ff8800"; type = "kamikaze"; speed *= 2.5; hp *= 0.3;
    } else if (rand < 0.6) {
      color = "#ff4444"; type = "shooter"; speed *= 0.7;
    } else {
      color = "#ff4444"; type = "grunt";
    }
  }
  
  const enemy = {
    x: canvas.width + 30,
    y: GROUND_Y - size,
    w: size,
    h: size,
    maxHP: hp,
    hp: hp,
    vx: -speed,
    baseSpeed: speed,
    color: color,
    type: type,
    isBoss: isBoss,
    isMiniBoss: isMiniBoss,
    pattern: pattern,
    damage: 20 + wave * 2,
    shootTimer: 0,
    attackTimer: 0,
    specialTimer: 0,
    chargeTimer: 0,
    summonTimer: 0,
    phaseTimer: 0,
    currentAttack: null,
    attackCooldown: 0,
    isCharging: false,
    isRaging: false,
    poisonTimer: 0,
    poisonDamage: 0,
    frozen: false,
    frozenTimer: 0,
    stoneForm: false,
    stoneTimer: 0
  };
  
  enemies.push(enemy);
}

function updateEnemies(dt) {
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    
    // Poison damage
    if (e.poisonTimer > 0) {
      e.poisonTimer -= dt;
      e.hp -= e.poisonDamage * dt;
    }
    
    // Frozen status
    if (e.frozenTimer > 0) {
      e.frozenTimer -= dt;
      e.frozen = e.frozenTimer > 0;
    }
    
    // Stone form immunity
    if (e.stoneTimer > 0) {
      e.stoneTimer -= dt;
      e.stoneForm = e.stoneTimer > 0;
    }
    
    // Update boss/miniboss attack cooldowns
    if (e.attackCooldown > 0) e.attackCooldown -= dt;
    if (e.specialTimer > 0) e.specialTimer -= dt;
    if (e.chargeTimer > 0) e.chargeTimer -= dt;
    if (e.summonTimer > 0) e.summonTimer -= dt;
    if (e.phaseTimer > 0) e.phaseTimer -= dt;
    
    // Boss/MiniBoss attack patterns
    if ((e.isBoss || e.isMiniBoss) && e.pattern && player.alive) {
      updateBossAttack(e, dt);
    }
    
    // Movement (skip if frozen or stone form or charging)
    if (!e.frozen && !e.stoneForm && !e.isCharging) {
      e.x += e.vx;
    } else if (e.isCharging) {
      // Charging movement is handled in updateBossAttack
    }
    
    // Shooter behavior
    if (e.type === "shooter" && player.alive) {
      e.shootTimer += dt;
      if (e.shootTimer >= 2.5 && e.x < canvas.width - 100) {
        e.shootTimer = 0;
        shootEnemyProjectile(e);
      }
    }
    
    // Kamikaze explosion
    if (e.type === "kamikaze" && e.x + e.w < player.x + player.w + 20) {
      damagePlayer(e.damage * 2);
      spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, "#ff8800", 20);
      screenShake += 15;
      enemies.splice(i, 1);
      continue;
    }
    
    // Collision with player
    if (player.alive && !player.invincible &&
        e.x < player.x + player.w &&
        e.x + e.w > player.x &&
        e.y < player.y + player.h &&
        e.y + e.h > player.y) {
      
      e.attackTimer += dt;
      if (e.attackTimer >= 1) {
        e.attackTimer = 0;
        damagePlayer(e.damage);
        e.x += 50; // Push back
      }
    }
    
    // Death check
    if (e.hp <= 0) {
      onEnemyKilled(e);
      enemies.splice(i, 1);
      continue;
    }
    
    // Off screen
    if (e.x + e.w < -50) {
      enemies.splice(i, 1);
    }
  }
}

// Boss attack pattern handler
function updateBossAttack(e, dt) {
  if (e.attackCooldown > 0) return;
  
  const pattern = e.pattern;
  const attacks = pattern.attacks;
  
  // Select next attack
  if (!e.currentAttack) {
    const availableAttacks = attacks.filter(a => {
      if (a.type === "enrage" && e.hp > e.maxHP * 0.3) return false;
      return true;
    });
    e.currentAttack = availableAttacks[Math.floor(Math.random() * availableAttacks.length)];
    e.phaseTimer = e.currentAttack.duration || 2;
  }
  
  const attack = e.currentAttack;
  const distToPlayer = Math.abs(e.x - player.x);
  
  // Execute current attack
  switch (attack.type) {
    case "charge":
      if (!e.isCharging && distToPlayer < 500) {
        e.isCharging = true;
        e.chargeTimer = 0.5; // Wind up
        playSound("boss");
      }
      if (e.isCharging) {
        e.chargeTimer -= dt;
        if (e.chargeTimer <= 0 && e.chargeTimer > -attack.duration) {
          // Charge at player
          e.x -= 12 * (e.isBoss ? 1.5 : 1);
          spawnParticle(e.x + e.w, e.y + e.h / 2, e.color);
        } else if (e.chargeTimer <= -attack.duration) {
          e.isCharging = false;
          e.currentAttack = null;
          e.attackCooldown = attack.cooldown;
        }
      }
      break;
      
    case "shoot":
    case "ranged":
      if (e.specialTimer <= 0) {
        // Fire projectile(s)
        const count = e.isBoss ? 5 : 3;
        const spread = e.isBoss ? 0.3 : 0.15;
        for (let j = 0; j < count; j++) {
          const angle = Math.atan2(player.y - e.y, player.x - e.x) + (j - Math.floor(count/2)) * spread;
          shootBossProjectile(e, angle, attack.damage || e.damage * 0.3);
        }
        e.specialTimer = 0.5;
        e.phaseTimer -= 0.5;
        if (e.phaseTimer <= 0) {
          e.currentAttack = null;
          e.attackCooldown = attack.cooldown;
        }
      }
      break;
      
    case "summon":
      if (e.summonTimer <= 0) {
        // Summon minions
        const count = Math.min(3, attack.count || 2);
        for (let j = 0; j < count; j++) {
          spawnMinion(e);
        }
        addFloatingText(e.x + e.w/2, e.y, "SUMMON!", e.color);
        e.summonTimer = attack.cooldown;
        e.currentAttack = null;
        e.attackCooldown = attack.cooldown;
      }
      break;
      
    case "stomp":
    case "groundPound":
      if (e.specialTimer <= 0) {
        // Create shockwave
        spawnShockwave(e.x + e.w/2, GROUND_Y);
        screenShake += 20;
        playSound("explosion");
        e.currentAttack = null;
        e.attackCooldown = attack.cooldown;
      }
      break;
      
    case "shield":
      if (!e.stoneForm) {
        e.stoneForm = true;
        e.stoneTimer = attack.duration;
        addFloatingText(e.x + e.w/2, e.y, "SHIELD!", "#4488ff");
      }
      if (e.stoneTimer <= 0) {
        e.stoneForm = false;
        e.currentAttack = null;
        e.attackCooldown = attack.cooldown;
      }
      break;
      
    case "enrage":
    case "berserk":
      if (!e.isRaging) {
        e.isRaging = true;
        e.vx *= 2;
        e.color = "#ff0000";
        addFloatingText(e.x + e.w/2, e.y, "ENRAGED!", "#ff0000");
        e.currentAttack = null;
        e.attackCooldown = attack.cooldown;
      }
      break;
      
    case "spin":
      if (e.phaseTimer > 0) {
        // Damage nearby during spin
        const spinRange = 100;
        if (Math.abs(player.x - e.x) < spinRange && Math.abs(player.y - e.y) < spinRange) {
          if (!player.invincible) damagePlayer(attack.damage * dt);
        }
        spawnParticle(e.x + Math.random() * e.w, e.y + Math.random() * e.h, e.color);
      } else {
        e.currentAttack = null;
        e.attackCooldown = attack.cooldown;
      }
      break;
      
    case "leap":
    case "pounce":
      if (e.specialTimer <= 0) {
        // Leap toward player
        e.x = Math.max(100, player.x + 100);
        e.y = GROUND_Y - e.h;
        spawnExplosion(e.x + e.w/2, e.y + e.h/2, e.color, 15);
        screenShake += 10;
        e.currentAttack = null;
        e.attackCooldown = attack.cooldown;
      }
      break;
      
    case "laser":
      if (e.phaseTimer > 0) {
        // Draw laser beam
        e.laserActive = true;
        if (player.y > e.y - 30 && player.y < e.y + e.h + 30 && player.x < e.x) {
          if (!player.invincible) damagePlayer(attack.damage * dt * 2);
        }
      } else {
        e.laserActive = false;
        e.currentAttack = null;
        e.attackCooldown = attack.cooldown;
      }
      break;
      
    case "poison":
    case "toxicCloud":
      if (e.specialTimer <= 0) {
        // Create poison cloud
        spawnPoisonCloud(e.x + e.w/2, e.y + e.h/2);
        e.currentAttack = null;
        e.attackCooldown = attack.cooldown;
      }
      break;
      
    case "teleport":
      if (e.specialTimer <= 0) {
        // Teleport behind player
        e.x = player.x + 150 + Math.random() * 100;
        spawnParticle(e.x, e.y, "#8800ff");
        addFloatingText(e.x + e.w/2, e.y, "!", "#8800ff");
        e.currentAttack = null;
        e.attackCooldown = attack.cooldown;
      }
      break;
      
    default:
      e.currentAttack = null;
      e.attackCooldown = 2;
  }
}

// Boss projectile
function shootBossProjectile(enemy, angle, damage) {
  const ex = enemy.x + enemy.w / 2;
  const ey = enemy.y + enemy.h / 2;
  
  projectiles.push({
    x: ex, y: ey,
    vx: Math.cos(angle) * 8,
    vy: Math.sin(angle) * 8,
    radius: enemy.isBoss ? 10 : 7,
    damage: damage,
    color: enemy.color,
    life: 3,
    trail: [],
    isEnemyProjectile: true,
    isBossProjectile: true
  });
  
  playSound("shoot");
}

// Spawn minion for summoner bosses
function spawnMinion(boss) {
  const size = 25;
  const hp = getEnemyHP(wave) * 0.3;
  
  enemies.push({
    x: boss.x + boss.w + 20,
    y: GROUND_Y - size,
    w: size,
    h: size,
    maxHP: hp,
    hp: hp,
    vx: -2,
    baseSpeed: 2,
    color: "#aa00aa",
    type: "minion",
    isBoss: false,
    isMiniBoss: false,
    pattern: null,
    damage: 10 + wave,
    shootTimer: 0,
    attackTimer: 0,
    specialTimer: 0,
    chargeTimer: 0,
    summonTimer: 0,
    phaseTimer: 0,
    currentAttack: null,
    attackCooldown: 0,
    isCharging: false,
    isRaging: false,
    poisonTimer: 0,
    poisonDamage: 0,
    frozen: false,
    frozenTimer: 0,
    stoneForm: false,
    stoneTimer: 0
  });
}

// Spawn shockwave for stomp attacks
function spawnShockwave(x, y) {
  // Damage player if nearby
  if (Math.abs(player.x - x) < 300 && !player.invincible) {
    damagePlayer(30 + wave * 2);
  }
  
  // Visual effect
  for (let i = 0; i < 20; i++) {
    particles.push({
      x: x + (Math.random() - 0.5) * 200,
      y: y,
      vx: (Math.random() - 0.5) * 5,
      vy: -Math.random() * 3,
      color: "#8b4513",
      life: 0.5
    });
  }
}

// Spawn poison cloud
function spawnPoisonCloud(x, y) {
  for (let i = 0; i < 15; i++) {
    particles.push({
      x: x + (Math.random() - 0.5) * 80,
      y: y + (Math.random() - 0.5) * 80,
      vx: (Math.random() - 0.5) * 2,
      vy: -Math.random() * 2,
      color: "#00ff00",
      life: 2
    });
  }
  
  // Damage player if in cloud
  if (Math.abs(player.x - x) < 80 && Math.abs(player.y - y) < 80 && !player.invincible) {
    player.poisonTimer = 3;
    player.poisonDamage = 10;
  }
}

function shootEnemyProjectile(enemy) {
  const ex = enemy.x + enemy.w / 2;
  const ey = enemy.y + enemy.h / 2;
  const px = player.x + player.w / 2;
  const py = player.y + player.h / 2;
  
  let dx = px - ex;
  let dy = py - ey;
  const dist = Math.sqrt(dx * dx + dy * dy) || 1;
  dx /= dist;
  dy /= dist;
  
  projectiles.push({
    x: ex, y: ey,
    vx: dx * 6,
    vy: dy * 6,
    radius: 6,
    damage: enemy.damage * 0.5,
    color: "#ff4444",
    life: 3,
    trail: [],
    isEnemyProjectile: true
  });
}

function updateProjectiles(dt) {
  for (let i = projectiles.length - 1; i >= 0; i--) {
    const p = projectiles[i];
    
    if (p.trail.length > 8) p.trail.shift();
    p.trail.push({ x: p.x, y: p.y });
    
    p.x += p.vx;
    p.y += p.vy;
    p.life -= dt;
    
    if (p.life <= 0 || p.x < -50 || p.x > canvas.width + 50 || p.y < -50 || p.y > canvas.height + 50) {
      projectiles.splice(i, 1);
      continue;
    }
    
    // Enemy projectile hitting player
    if (p.isEnemyProjectile && player.alive && !player.invincible) {
      if (p.x > player.x && p.x < player.x + player.w &&
          p.y > player.y && p.y < player.y + player.h) {
        damagePlayer(p.damage);
        projectiles.splice(i, 1);
        continue;
      }
    }
    
    // Player projectile hitting enemies
    if (!p.isEnemyProjectile) {
      for (let j = enemies.length - 1; j >= 0; j--) {
        const e = enemies[j];
        if (p.x > e.x && p.x < e.x + e.w && p.y > e.y && p.y < e.y + e.h) {
          let damage = p.damage;
          
          // Hunter's Mark bonus damage
          if (abilityEffects.huntersMark && abilityEffects.huntersMark.target === e) {
            damage *= 2;
          }
          
          if (p.isCrit) {
            damage *= p.critMultiplier;
            addFloatingText(e.x + e.w / 2, e.y - 30, "CRIT!", "#ff0000");
          }
          
          playSound("hit");
          e.hp -= damage;
          spawnHitParticles(p.x, p.y, p.color, 6);
          screenShake += p.isCrit ? 4 : 2;
          
          // Lifesteal
          if (player.lifesteal > 0) {
            player.hp = Math.min(player.hp + damage * player.lifesteal, player.maxHP);
          }
          
          // Poison
          if (p.poison) {
            e.poisonTimer = 3;
            e.poisonDamage = damage * 0.2;
          }
          
          // Explosion
          if (p.explosive) {
            playSound("explosion");
            for (const other of enemies) {
              if (other === e) continue;
              const dx = (other.x + other.w / 2) - p.x;
              const dy = (other.y + other.h / 2) - p.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist < 60) {
                other.hp -= damage * 0.5;
              }
            }
            spawnExplosion(p.x, p.y, "#ff8800", 15);
            screenShake += 5;
          }
          
          if (p.pierce && p.pierceCount < 3) {
            p.pierceCount++;
          } else {
            projectiles.splice(i, 1);
          }
          
          break;
        }
      }
    }
  }
}

function damagePlayer(amount) {
  if (player.invincible) return;
  
  let damage = amount;
  
  if (player.shield > 0) {
    if (player.shield >= damage) {
      player.shield -= damage;
      damage = 0;
    } else {
      damage -= player.shield;
      player.shield = 0;
    }
  }
  
  player.hp -= damage;
  
  if (gameData.settings.damageNumbers && damage > 0) {
    addFloatingText(player.x + player.w / 2, player.y - 10, "-" + Math.floor(damage), "#ff0000");
  }
  
  spawnHitParticles(player.x + player.w / 2, player.y + player.h / 2, "#ff0000", 8);
  screenShake += 5;
  
  if (player.hp <= 0) {
    player.hp = 0;
    player.alive = false;
    gameOver();
  }
}

function onEnemyKilled(enemy) {
  // Sound
  playSound("kill");
  if (enemy.isBoss) {
    playSound("boss");
  }
  
  // Track stats for achievements
  gameData.totalKills = (gameData.totalKills || 0) + 1;
  if (enemy.isBoss || enemy.isMiniBoss) {
    gameData.bossKills = (gameData.bossKills || 0) + 1;
  }
  
  // Track combo for achievements
  combo++;
  comboTimer = 2;
  if (combo > maxCombo) maxCombo = combo;
  if (combo > (gameData.highestCombo || 0)) {
    gameData.highestCombo = combo;
  }
  
  // XP
  let xpGain = 20 + wave * 5;
  if (enemy.isBoss) xpGain *= 5;
  else if (enemy.isMiniBoss) xpGain *= 2;
  
  xpGain *= (1 + gameData.permanentUpgrades.xpMultiplier * 0.1);
  giveXP(Math.floor(xpGain));
  
  // Currency
  let coinDrop = 5 + wave;
  let gemDrop = 0;
  
  if (enemy.isBoss) {
    coinDrop = 50 + wave * 10;
    gemDrop = 3 + Math.floor(wave / 5);
  } else if (enemy.isMiniBoss) {
    coinDrop = 20 + wave * 5;
    gemDrop = 1;
  }
  
  coinDrop = Math.floor(coinDrop * (1 + gameData.permanentUpgrades.coinMultiplier * 0.1));
  
  sessionCoins += coinDrop;
  sessionGems += gemDrop;
  gameData.totalCoins += coinDrop;
  gameData.totalGems += gemDrop;
  gameData.totalCoinsEarned = (gameData.totalCoinsEarned || 0) + coinDrop;
  
  if (gameData.settings.damageNumbers) {
    addFloatingText(enemy.x + enemy.w / 2, enemy.y - 20, "+" + coinDrop + "üí∞", "#ffff00");
  }
  
  // Effects
  spawnExplosion(enemy.x + enemy.w / 2, enemy.y + enemy.h / 2, enemy.color, 15);
  
  enemiesKilled++;
  
  // Check for boss defeat dialogue (story mode bosses)
  if (enemy.isBoss && enemy.name && BOSS_DEFEAT_DIALOGUES[enemy.name]) {
    // Track defeated boss
    if (!gameData.defeatedBosses) gameData.defeatedBosses = [];
    if (!gameData.defeatedBosses.includes(enemy.name)) {
      gameData.defeatedBosses.push(enemy.name);
    }
    
    // Pause game and show defeat dialogue
    gamePaused = true;
    showBossDefeatDialogue(enemy.name, () => {
      gamePaused = false;
      // Check achievements after boss defeat
      checkAchievements();
    });
  } else {
    // Check achievements periodically
    if (gameData.totalKills % 10 === 0) {
      checkAchievements();
    }
  }
  
  saveGameData();
}

function giveXP(amount) {
  player.xp += amount;
  
  while (player.xp >= player.xpToNext) {
    player.xp -= player.xpToNext;
    player.level++;
    player.xpToNext = Math.floor(100 * Math.pow(player.level, 1.8));
    playSound("levelUp");
    showUpgradeScreen();
  }
}

function showUpgradeScreen() {
  gamePaused = true;
  document.getElementById("upgradeScreen").classList.add("active");
  
  // Update shuffle count display
  document.getElementById("shufflesCount").textContent = shufflesRemaining;
  const shuffleBtn = document.getElementById("shuffleUpgradesBtn");
  shuffleBtn.style.opacity = shufflesRemaining > 0 ? "1" : "0.5";
  shuffleBtn.style.cursor = shufflesRemaining > 0 ? "pointer" : "not-allowed";
  
  renderUpgradeOptions();
}

function renderUpgradeOptions() {
  const container = document.getElementById("upgradeOptions");
  container.innerHTML = "";
  
  const keys = Object.keys(UPGRADE_TYPES);
  const shuffled = keys.sort(() => Math.random() - 0.5).slice(0, 3);
  
  shuffled.forEach(key => {
    const upgrade = UPGRADE_TYPES[key];
    const card = document.createElement("div");
    card.className = "upgrade-card";
    card.innerHTML = `
      <div style="font-size: 40px; margin-bottom: 10px;">${upgrade.icon}</div>
      <div style="font-size: 14px; color: #ffff00; margin-bottom: 5px;">${upgrade.name}</div>
      <div style="font-size: 11px; color: #aaa;">${upgrade.desc}</div>
    `;
    card.addEventListener("click", () => selectUpgrade(key));
    container.appendChild(card);
  });
}

function shuffleUpgrades() {
  if (shufflesRemaining <= 0) {
    addFloatingText(canvas.width / 2, 200, "No shuffles left!", "#ff4444");
    return;
  }
  
  shufflesRemaining--;
  document.getElementById("shufflesCount").textContent = shufflesRemaining;
  
  const shuffleBtn = document.getElementById("shuffleUpgradesBtn");
  if (shufflesRemaining <= 0) {
    shuffleBtn.style.opacity = "0.5";
    shuffleBtn.style.cursor = "not-allowed";
  }
  
  renderUpgradeOptions();
  playSound("upgrade");
}

function selectUpgrade(key) {
  const upgrade = UPGRADE_TYPES[key];
  upgrade.apply(player);
  
  document.getElementById("upgradeScreen").classList.remove("active");
  gamePaused = false;
  
  addFloatingText(player.x + player.w / 2, player.y - 30, upgrade.name + "!", "#ffff00");
  spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#ffff00", 20);
}

function nextWave() {
  wave++;
  
  // Reset wave timer state
  waveTimerActive = false;
  waveTimer = 0;
  
  playSound("wave");
  
  if (wave > gameData.highestWave) {
    gameData.highestWave = wave;
    saveGameData();
  }
  
  enemiesToSpawn = calcEnemiesForWave(wave);
  spawnTimer = 0;
  
  addFloatingText(canvas.width / 2, 100, "WAVE " + wave, "#00ffff");
  
  // Refill some potions each wave in endless
  if (gameMode === "endless" && wave % 5 === 0) {
    potions.heal = Math.min(potions.heal + 1, 5);
    potions.shield = Math.min(potions.shield + 1, 3);
    updatePotionDisplay();
  }
}

function victory() {
  gameRunning = false;
  document.getElementById("potionBar").classList.remove("active");
  document.getElementById("abilityBar").classList.remove("active");
  
  playSound("victory");
  playSound("bossDefeat"); // Epic victory sound
  
  // Mark node as completed in story mode
  if (gameMode === "story" && selectedNode) {
    if (!gameData.completedNodes.includes(selectedNode.id)) {
      gameData.completedNodes.push(selectedNode.id);
      gameData.storyNodesCompleted = (gameData.storyNodesCompleted || 0) + 1;
    }
    
    // Unlock next nodes
    if (selectedNode.unlocks) {
      selectedNode.unlocks.forEach(nodeId => {
        if (!gameData.unlockedNodes.includes(nodeId)) {
          gameData.unlockedNodes.push(nodeId);
        }
      });
    }
    
    // Apply rewards
    if (selectedNode.rewards.classUnlock) {
      if (!gameData.unlockedClasses.includes(selectedNode.rewards.classUnlock)) {
        gameData.unlockedClasses.push(selectedNode.rewards.classUnlock);
      }
    }
    
    if (selectedNode.rewards.keyShard) {
      gameData.keyShards[selectedNode.rewards.keyShard] = true;
    }
    
    // Update story progress
    gameData.storyProgress = (gameData.completedNodes.length / MAP_NODES.length) * 100;
  }
  
  // Update highest wave
  if (wave > gameData.highestWave) {
    gameData.highestWave = wave;
  }
  
  // Submit to leaderboard (no bots - only real player data)
  const playerName = gameData.warriorName || "Unknown Warrior";
  submitToLeaderboard(playerName, wave, enemiesKilled, selectedClass);
  
  // Check achievements
  checkAchievements();
  
  saveGameData();
  
  document.getElementById("victoryCoins").textContent = sessionCoins;
  document.getElementById("victoryGems").textContent = sessionGems;
  document.getElementById("victoryMessage").textContent = gameMode === "story" 
    ? `${selectedNode.name} Complete!` 
    : `Reached Wave ${wave}!`;
  
  document.getElementById("victoryScreen").classList.add("active");
}

function gameOver() {
  gameRunning = false;
  document.getElementById("potionBar").classList.remove("active");
  document.getElementById("abilityBar").classList.remove("active");
  
  // Play player defeat sound
  playSound("playerDefeat");
  playSound("gameOver");
  
  // Check for Phoenix Rising passive (Summoner)
  if (selectedClass === "Summoner" && abilityEffects.phoenixReady) {
    abilityEffects.phoenixReady = false;
    player.hp = player.maxHP;
    player.alive = true;
    gameRunning = true;
    document.getElementById("potionBar").classList.add("active");
    document.getElementById("abilityBar").classList.add("active");
    
    addFloatingText(player.x + player.w / 2, player.y - 50, "üî• PHOENIX RISING! üî•", "#ff8800");
    spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#ff8800", 40);
    screenShake += 20;
    playSound("ability");
    return;
  }
  
  // Update highest wave
  if (wave > gameData.highestWave) {
    gameData.highestWave = wave;
  }
  
  // Submit to leaderboard (no bots - only real player data)
  const playerName = gameData.warriorName || "Unknown Warrior";
  submitToLeaderboard(playerName, wave, enemiesKilled, selectedClass);
  
  // Check achievements
  checkAchievements();
  
  saveGameData();
  
  document.getElementById("finalWave").textContent = wave;
  document.getElementById("finalLevel").textContent = player.level;
  document.getElementById("finalKills").textContent = enemiesKilled;
  document.getElementById("earnedCoins").textContent = sessionCoins;
  document.getElementById("earnedGems").textContent = sessionGems;
  
  document.getElementById("gameOverScreen").classList.add("active");
}

function handleVictoryContinue() {
  document.getElementById("victoryScreen").classList.remove("active");
  
  if (gameMode === "story") {
    showOverworldMap();
  } else {
    showScreen("mainMenu");
  }
}

function returnToMenu() {
  document.getElementById("gameOverScreen").classList.remove("active");
  showScreen("mainMenu");
}

// ==================== POTIONS ====================
function usePotion(type) {
  if (!player || !player.alive) return;
  if (potions[type] <= 0) return;
  if (potionCooldowns[type] > 0) return;
  
  potions[type]--;
  potionCooldowns[type] = 1;
  
  playSound("potion");
  
  // Deduct from inventory
  if (gameData.potionInventory[type] > 0) {
    gameData.potionInventory[type]--;
    saveGameData();
  }
  
  switch (type) {
    case "heal":
      const healAmount = 50 + (gameData.potionUpgrades.healStrength * 20);
      player.hp = Math.min(player.hp + healAmount, player.maxHP);
      addFloatingText(player.x + player.w / 2, player.y - 30, "+" + healAmount + " HP", "#00ff00");
      break;
      
    case "shield":
      const shieldAmount = 50 + (gameData.potionUpgrades.shieldStrength * 25);
      player.shield = (player.shield || 0) + shieldAmount;
      player.maxShield = Math.max(player.maxShield || 0, player.shield);
      addFloatingText(player.x + player.w / 2, player.y - 30, "+" + shieldAmount + " Shield", "#00aaff");
      break;
      
    case "crit":
      potionEffects.critActive = true;
      potionEffects.critTimer = 10;
      player.critChance += 0.25;
      addFloatingText(player.x + player.w / 2, player.y - 30, "Crit Boost!", "#ff0000");
      break;
      
    case "damage":
      potionEffects.damageActive = true;
      potionEffects.damageTimer = 10;
      player.damage += 10;
      addFloatingText(player.x + player.w / 2, player.y - 30, "Damage Boost!", "#ff8800");
      break;
      
    case "speed":
      potionEffects.speedActive = true;
      potionEffects.speedTimer = 10;
      player.fireRate *= 0.7;
      addFloatingText(player.x + player.w / 2, player.y - 30, "Speed Boost!", "#ffff00");
      break;
      
    case "dragon":
      useDragonBeam();
      break;
  }
  
  spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#ff00ff", 10);
  screenShake += 3;
  updatePotionDisplay();
}

function useDragonBeam() {
  addFloatingText(canvas.width / 2, 200, "üêâ DRAGON BEAM! üêâ", "#ff00ff");
  screenShake += 25;
  
  const damage = player.damage * 5;
  
  // Damage all enemies
  enemies.forEach(e => {
    e.hp -= damage;
    spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, "#ff4400", 10);
  });
  
  // Create fire zones
  for (let i = 0; i < 20; i++) {
    fireZones.push({
      x: player.x + 100 + i * 50,
      y: GROUND_Y - 20,
      radius: 40,
      damage: damage * 0.1,
      life: 5
    });
  }
  
  // Visual effect
  for (let i = 0; i < 50; i++) {
    particles.push({
      x: player.x + player.w / 2,
      y: player.y + player.h / 2,
      vx: Math.random() * 20 + 5,
      vy: Math.random() * 10 - 5,
      radius: Math.random() * 6 + 2,
      color: Math.random() < 0.5 ? "#ff4400" : "#ff8800",
      life: 2
    });
  }
}

function updatePotionEffects(dt) {
  // Update cooldowns
  for (let type in potionCooldowns) {
    if (potionCooldowns[type] > 0) {
      potionCooldowns[type] -= dt;
      if (potionCooldowns[type] < 0) potionCooldowns[type] = 0;
    }
  }
  
  // Crit effect
  if (potionEffects.critActive) {
    potionEffects.critTimer -= dt;
    if (potionEffects.critTimer <= 0) {
      potionEffects.critActive = false;
      player.critChance -= 0.25;
    }
  }
  
  // Damage effect
  if (potionEffects.damageActive) {
    potionEffects.damageTimer -= dt;
    if (potionEffects.damageTimer <= 0) {
      potionEffects.damageActive = false;
      player.damage -= 10;
    }
  }
  
  // Speed effect
  if (potionEffects.speedActive) {
    potionEffects.speedTimer -= dt;
    if (potionEffects.speedTimer <= 0) {
      potionEffects.speedActive = false;
      player.fireRate /= 0.7;
    }
  }
}

function updateFireZones(dt) {
  for (let i = fireZones.length - 1; i >= 0; i--) {
    const zone = fireZones[i];
    zone.life -= dt;
    
    if (zone.life <= 0) {
      fireZones.splice(i, 1);
      continue;
    }
    
    // Damage enemies in zone
    enemies.forEach(e => {
      const dx = (e.x + e.w / 2) - zone.x;
      const dy = (e.y + e.h / 2) - zone.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist < zone.radius) {
        e.hp -= zone.damage * dt;
      }
    });
  }
}

// ==================== ABILITY SYSTEM ====================
function useAbility(slot) {
  if (!player || !player.alive) return;
  if (abilityCooldowns[slot] > 0) return;
  
  const skillTree = SKILL_TREES[selectedClass];
  if (!skillTree) return;
  
  const ability = skillTree[slot];
  if (!ability) return;
  
  abilityCooldowns[slot] = ability.cooldown;
  playSound("ability");
  
  // Execute ability based on class
  switch (selectedClass) {
    case "Hunter":
      if (slot === "ult1") activateRapidBarrage();
      else activateHuntersMark();
      break;
    case "Knight":
      if (slot === "ult1") activateShieldWall();
      else activateWhirlwind();
      break;
    case "Assassin":
      if (slot === "ult1") activateShadowStep();
      else activateBladeDance();
      break;
    case "Archer":
      if (slot === "ult1") activateRainOfArrows();
      else activateCupidsBow();
      break;
    case "Wizard":
      if (slot === "ult1") activateMeteorShower();
      else activateTimeFreeze();
      break;
    case "Summoner":
      if (slot === "ult1") activateArmyOfLight();
      // Phoenix Rising is passive
      break;
    case "Bomber":
      if (slot === "ult1") activateCarpetBomb();
      else activateNuclearOption();
      break;
    case "Sniper":
      if (slot === "ult1") activateHeadshot();
      else activatePiercingRound();
      break;
    case "Necromancer":
      if (slot === "ult1") activateArmyOfDead();
      else activateDeathAura();
      break;
    case "Vecna":
      if (slot === "ult1") activateHiveMind();
      else activateUpsideDown();
      break;
  }
  
  updateAbilityDisplay();
}

// Hunter Abilities
function activateRapidBarrage() {
  addFloatingText(player.x + player.w / 2, player.y - 50, "üèπ RAPID BARRAGE!", "#00ff88");
  
  for (let i = 0; i < 8; i++) {
    setTimeout(() => {
      const target = getTargetEnemy();
      if (target) {
        shootProjectile(target);
        spawnHitParticles(player.x + player.w, player.y + player.h / 2, player.color, 3);
      }
    }, i * 100);
  }
}

function activateHuntersMark() {
  const target = getTargetEnemy();
  if (target) {
    abilityEffects.huntersMark = { target: target, timer: 5 };
    addFloatingText(target.x + target.w / 2, target.y - 30, "üéØ MARKED!", "#ff0000");
    spawnExplosion(target.x + target.w / 2, target.y + target.h / 2, "#ff0000", 15);
  }
}

// Knight Abilities
function activateShieldWall() {
  abilityEffects.shieldWall = true;
  abilityEffects.shieldWallTimer = 4;
  player.invincible = true;
  addFloatingText(player.x + player.w / 2, player.y - 50, "üõ°Ô∏è SHIELD WALL!", "#4488ff");
  spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#4488ff", 25);
}

function activateWhirlwind() {
  addFloatingText(player.x + player.w / 2, player.y - 50, "‚öîÔ∏è WHIRLWIND!", "#4488ff");
  
  const damage = player.damage * 3;
  enemies.forEach(e => {
    const dx = (e.x + e.w / 2) - (player.x + player.w / 2);
    const dy = (e.y + e.h / 2) - (player.y + player.h / 2);
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    if (dist < 200) {
      e.hp -= damage;
      spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, "#4488ff", 8);
    }
  });
  
  // Visual spin effect
  for (let i = 0; i < 20; i++) {
    const angle = (i / 20) * Math.PI * 2;
    particles.push({
      x: player.x + player.w / 2,
      y: player.y + player.h / 2,
      vx: Math.cos(angle) * 6,
      vy: Math.sin(angle) * 6,
      radius: 5,
      color: "#4488ff",
      life: 1
    });
  }
  screenShake += 15;
}

// Assassin Abilities
function activateShadowStep() {
  const target = getTargetEnemy();
  if (target) {
    addFloatingText(player.x + player.w / 2, player.y - 50, "üë§ SHADOW STEP!", "#ff00ff");
    
    // Teleport effect
    spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#ff00ff", 15);
    
    // Deal massive crit damage
    const damage = player.damage * 5;
    target.hp -= damage;
    
    addFloatingText(target.x + target.w / 2, target.y - 30, "CRIT! " + Math.floor(damage), "#ff0000");
    spawnExplosion(target.x + target.w / 2, target.y + target.h / 2, "#ff00ff", 20);
    screenShake += 10;
  }
}

function activateBladeDance() {
  addFloatingText(player.x + player.w / 2, player.y - 50, "üó°Ô∏è BLADE DANCE!", "#ff00ff");
  
  for (let i = 0; i < 12; i++) {
    const angle = (i / 12) * Math.PI * 2;
    projectiles.push({
      x: player.x + player.w / 2,
      y: player.y + player.h / 2,
      vx: Math.cos(angle) * 8,
      vy: Math.sin(angle) * 8,
      radius: 6,
      damage: player.damage * 1.5,
      color: "#ff00ff",
      life: 2,
      trail: [],
      pierce: true,
      pierceCount: 0,
      isEnemyProjectile: false
    });
  }
  screenShake += 8;
}

// Archer Abilities
function activateRainOfArrows() {
  addFloatingText(canvas.width / 2, 150, "üåßÔ∏è RAIN OF ARROWS!", "#228b22");
  
  for (let i = 0; i < 30; i++) {
    setTimeout(() => {
      const x = Math.random() * (canvas.width - 200) + 100;
      projectiles.push({
        x: x,
        y: 0,
        vx: 0,
        vy: 10,
        radius: 5,
        damage: player.damage * 0.8,
        color: "#228b22",
        life: 2,
        trail: [],
        isEnemyProjectile: false
      });
    }, i * 50);
  }
}

function activateCupidsBow() {
  addFloatingText(player.x + player.w / 2, player.y - 50, "üíï CUPIDS BOW!", "#ff69b4");
  
  // Charm enemies for 6 seconds
  enemies.forEach(e => {
    if (!e.isBoss) {
      e.charmed = true;
      e.charmTimer = 6;
      e.vx = Math.abs(e.vx); // Move away from player
      spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, "#ff69b4", 8);
    }
  });
}

// Wizard Abilities
function activateMeteorShower() {
  addFloatingText(canvas.width / 2, 150, "‚òÑÔ∏è METEOR SHOWER!", "#8800ff");
  
  for (let i = 0; i < 10; i++) {
    setTimeout(() => {
      if (enemies.length > 0) {
        const target = enemies[Math.floor(Math.random() * enemies.length)];
        spawnMeteor(target.x + target.w / 2, player.damage * 3);
      } else {
        spawnMeteor(Math.random() * canvas.width, player.damage * 3);
      }
    }, i * 200);
  }
}

function spawnMeteor(targetX, damage) {
  // Meteor visual
  const meteor = {
    x: targetX + (Math.random() - 0.5) * 100,
    y: 0,
    targetX: targetX,
    damage: damage
  };
  
  // Animate meteor falling
  let y = 0;
  const interval = setInterval(() => {
    y += 20;
    if (y >= GROUND_Y - 30) {
      clearInterval(interval);
      
      // Impact explosion
      spawnExplosion(targetX, GROUND_Y - 30, "#ff4400", 25);
      screenShake += 10;
      
      // Damage enemies in blast radius
      enemies.forEach(e => {
        const dx = (e.x + e.w / 2) - targetX;
        const dist = Math.abs(dx);
        if (dist < 80) {
          e.hp -= damage * (1 - dist / 80);
        }
      });
      
      // Create fire zone
      fireZones.push({
        x: targetX,
        y: GROUND_Y - 20,
        radius: 60,
        damage: damage * 0.05,
        life: 3
      });
    }
  }, 30);
}

function activateTimeFreeze() {
  abilityEffects.timeFreezeActive = true;
  abilityEffects.timeFreezeTimer = 4;
  addFloatingText(canvas.width / 2, 200, "‚è∞ TIME FREEZE!", "#8800ff");
  
  // Freeze all enemies
  enemies.forEach(e => {
    e.frozen = true;
    e.originalSpeed = e.vx;
    e.vx = 0;
  });
  
  screenShake += 15;
}

// Summoner Abilities
function activateArmyOfLight() {
  addFloatingText(player.x + player.w / 2, player.y - 50, "‚ú® ARMY OF LIGHT!", "#88ff88");
  
  for (let i = 0; i < 5; i++) {
    minions.push({
      x: player.x + 50 + i * 40,
      y: GROUND_Y - 30,
      w: 25,
      h: 30,
      hp: 50 + wave * 5,
      maxHP: 50 + wave * 5,
      damage: player.damage * 0.5,
      fireRate: 1,
      shootTimer: Math.random(),
      color: "#88ff88",
      type: "spirit",
      life: 15
    });
    
    spawnExplosion(player.x + 50 + i * 40, GROUND_Y - 30, "#88ff88", 10);
  }
}

// Bomber Abilities
function activateCarpetBomb() {
  addFloatingText(canvas.width / 2, 150, "üí£ CARPET BOMB!", "#ff8800");
  
  for (let i = 0; i < 10; i++) {
    setTimeout(() => {
      const x = player.x + 100 + i * 80;
      spawnExplosion(x, GROUND_Y - 50, "#ff8800", 20);
      screenShake += 5;
      
      // Damage enemies
      enemies.forEach(e => {
        const dx = (e.x + e.w / 2) - x;
        if (Math.abs(dx) < 60) {
          e.hp -= player.damage * 2;
        }
      });
      
      // Fire zone
      fireZones.push({
        x: x,
        y: GROUND_Y - 20,
        radius: 50,
        damage: player.damage * 0.1,
        life: 4
      });
    }, i * 150);
  }
}

function activateNuclearOption() {
  addFloatingText(canvas.width / 2, 200, "‚ò¢Ô∏è NUCLEAR OPTION! ‚ò¢Ô∏è", "#ff0000");
  screenShake += 50;
  
  // Massive damage to all enemies
  const damage = player.damage * 10;
  enemies.forEach(e => {
    e.hp -= damage;
    spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, "#ffff00", 15);
  });
  
  // Giant explosion at center
  for (let i = 0; i < 100; i++) {
    particles.push({
      x: canvas.width / 2,
      y: GROUND_Y / 2,
      vx: (Math.random() - 0.5) * 20,
      vy: (Math.random() - 0.5) * 20,
      radius: Math.random() * 10 + 3,
      color: Math.random() < 0.5 ? "#ff4400" : "#ffff00",
      life: 2
    });
  }
  
  // Screen flash effect
  setTimeout(() => screenShake += 30, 100);
}

// Sniper Abilities
function activateHeadshot() {
  const target = getTargetEnemy();
  if (target) {
    addFloatingText(player.x + player.w / 2, player.y - 50, "üéØ HEADSHOT!", "#00ffff");
    
    const damage = player.damage * 5;
    target.hp -= damage;
    
    // Laser beam visual
    projectiles.push({
      x: player.x + player.w,
      y: player.y + player.h / 2,
      vx: 30,
      vy: 0,
      radius: 8,
      damage: 0,
      color: "#00ffff",
      life: 0.5,
      trail: [],
      isEnemyProjectile: false
    });
    
    addFloatingText(target.x + target.w / 2, target.y - 30, "üíÄ " + Math.floor(damage), "#ff0000");
    spawnExplosion(target.x + target.w / 2, target.y + target.h / 2, "#00ffff", 20);
    screenShake += 12;
  }
}

function activatePiercingRound() {
  abilityEffects.piercingRoundActive = true;
  abilityEffects.piercingRoundTimer = 10;
  player.pierce = true;
  addFloatingText(player.x + player.w / 2, player.y - 50, "üî≠ PIERCING ROUNDS!", "#00ffff");
  spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#00ffff", 15);
}

// Necromancer Abilities
function activateArmyOfDead() {
  addFloatingText(player.x + player.w / 2, player.y - 50, "üíÄ ARMY OF THE DEAD!", "#9933ff");
  
  for (let i = 0; i < 5; i++) {
    minions.push({
      x: player.x + 50 + i * 50,
      y: GROUND_Y - 35,
      w: 30,
      h: 35,
      hp: 80 + wave * 8,
      maxHP: 80 + wave * 8,
      damage: player.damage * 0.6,
      fireRate: 1.2,
      shootTimer: Math.random(),
      color: "#9933ff",
      type: "skeleton",
      life: 20
    });
    
    spawnExplosion(player.x + 50 + i * 50, GROUND_Y - 35, "#9933ff", 10);
  }
}

function activateDeathAura() {
  abilityEffects.deathAuraActive = true;
  abilityEffects.deathAuraTimer = 8;
  addFloatingText(player.x + player.w / 2, player.y - 50, "‚ò†Ô∏è DEATH AURA!", "#9933ff");
}

// Vecna Abilities
function activateHiveMind() {
  addFloatingText(canvas.width / 2, 200, "üß† HIVE MIND CONTROL!", "#8B0000");
  
  abilityEffects.hiveMindActive = true;
  abilityEffects.hiveMindTimer = 8;
  
  enemies.forEach(e => {
    if (!e.isBoss) {
      e.controlled = true;
      e.vx = Math.abs(e.vx); // Move right (away from player)
      spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, "#8B0000", 8);
    }
  });
  
  screenShake += 20;
}

function activateUpsideDown() {
  abilityEffects.upsideDownActive = true;
  abilityEffects.upsideDownTimer = 6;
  player.invincible = true;
  
  addFloatingText(canvas.width / 2, 200, "üåÄ UPSIDE DOWN!", "#8B0000");
  
  // Spawn Vecna monsters
  for (let i = 0; i < 3; i++) {
    vecnaMonsters.push({
      x: player.x + 80 + i * 60,
      y: GROUND_Y - 50,
      w: 40,
      h: 50,
      damage: player.damage * 0.8,
      speed: 2,
      life: 6,
      color: "#4a0000"
    });
    spawnExplosion(player.x + 80 + i * 60, GROUND_Y - 50, "#8B0000", 15);
  }
  
  screenShake += 25;
}

function updateAbilityEffects(dt) {
  // Update cooldowns
  for (let slot in abilityCooldowns) {
    if (abilityCooldowns[slot] > 0) {
      abilityCooldowns[slot] -= dt;
      if (abilityCooldowns[slot] < 0) abilityCooldowns[slot] = 0;
    }
  }
  
  // Shield Wall
  if (abilityEffects.shieldWall) {
    abilityEffects.shieldWallTimer -= dt;
    if (abilityEffects.shieldWallTimer <= 0) {
      abilityEffects.shieldWall = false;
      player.invincible = false;
    }
  }
  
  // Hunter's Mark
  if (abilityEffects.huntersMark) {
    abilityEffects.huntersMark.timer -= dt;
    if (abilityEffects.huntersMark.timer <= 0 || !enemies.includes(abilityEffects.huntersMark.target)) {
      abilityEffects.huntersMark = null;
    }
  }
  
  // Time Freeze
  if (abilityEffects.timeFreezeActive) {
    abilityEffects.timeFreezeTimer -= dt;
    if (abilityEffects.timeFreezeTimer <= 0) {
      abilityEffects.timeFreezeActive = false;
      enemies.forEach(e => {
        if (e.frozen) {
          e.frozen = false;
          e.vx = e.originalSpeed || -1;
        }
      });
    }
  }
  
  // Piercing Round
  if (abilityEffects.piercingRoundActive) {
    abilityEffects.piercingRoundTimer -= dt;
    if (abilityEffects.piercingRoundTimer <= 0) {
      abilityEffects.piercingRoundActive = false;
      // Only remove pierce if it wasn't a class trait
      const cls = CLASSES[selectedClass];
      if (!cls.stats.pierce) player.pierce = false;
    }
  }
  
  // Death Aura (Necromancer)
  if (abilityEffects.deathAuraActive) {
    abilityEffects.deathAuraTimer -= dt;
    
    // Damage nearby enemies
    enemies.forEach(e => {
      const dx = (e.x + e.w / 2) - (player.x + player.w / 2);
      const dy = (e.y + e.h / 2) - (player.y + player.h / 2);
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist < 150) {
        e.hp -= player.damage * 0.5 * dt;
        e.poisonTimer = 2;
        e.poisonDamage = player.damage * 0.1;
      }
    });
    
    if (abilityEffects.deathAuraTimer <= 0) {
      abilityEffects.deathAuraActive = false;
    }
  }
  
  // Hive Mind (Vecna)
  if (abilityEffects.hiveMindActive) {
    abilityEffects.hiveMindTimer -= dt;
    
    // Controlled enemies fight each other
    enemies.forEach(e => {
      if (e.controlled) {
        // Attack other non-controlled enemies
        enemies.forEach(other => {
          if (other !== e && !other.controlled && !other.isBoss) {
            const dx = (other.x + other.w / 2) - (e.x + e.w / 2);
            const dy = (other.y + other.h / 2) - (e.y + e.h / 2);
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 50) {
              other.hp -= e.damage * 0.3 * dt;
            }
          }
        });
      }
    });
    
    if (abilityEffects.hiveMindTimer <= 0) {
      abilityEffects.hiveMindActive = false;
      enemies.forEach(e => {
        if (e.controlled) {
          e.controlled = false;
          e.vx = -Math.abs(e.vx);
        }
      });
    }
  }
  
  // Upside Down (Vecna)
  if (abilityEffects.upsideDownActive) {
    abilityEffects.upsideDownTimer -= dt;
    if (abilityEffects.upsideDownTimer <= 0) {
      abilityEffects.upsideDownActive = false;
      player.invincible = false;
    }
  }
  
  // Update Vecna monsters
  updateVecnaMonsters(dt);
  
  // Update charmed enemies
  updateCharmedEnemies(dt);
  
  // Update minions
  updateMinions(dt);
}

function updateVecnaMonsters(dt) {
  for (let i = vecnaMonsters.length - 1; i >= 0; i--) {
    const m = vecnaMonsters[i];
    m.life -= dt;
    m.x += m.speed;
    
    if (m.life <= 0 || m.x > canvas.width) {
      vecnaMonsters.splice(i, 1);
      continue;
    }
    
    // Attack enemies
    enemies.forEach(e => {
      if (m.x < e.x + e.w && m.x + m.w > e.x && m.y < e.y + e.h && m.y + m.h > e.y) {
        e.hp -= m.damage * dt * 2;
      }
    });
  }
}

function updateCharmedEnemies(dt) {
  enemies.forEach(e => {
    if (e.charmed) {
      e.charmTimer -= dt;
      if (e.charmTimer <= 0) {
        e.charmed = false;
        e.vx = -Math.abs(e.vx);
      }
    }
  });
}

function updateMinions(dt) {
  for (let i = minions.length - 1; i >= 0; i--) {
    const m = minions[i];
    m.life -= dt;
    m.shootTimer += dt;
    
    if (m.life <= 0 || m.hp <= 0) {
      spawnExplosion(m.x + m.w / 2, m.y + m.h / 2, m.color, 10);
      minions.splice(i, 1);
      continue;
    }
    
    // Shoot at enemies
    if (m.shootTimer >= m.fireRate && enemies.length > 0) {
      m.shootTimer = 0;
      const target = enemies[Math.floor(Math.random() * enemies.length)];
      
      const dx = (target.x + target.w / 2) - (m.x + m.w / 2);
      const dy = (target.y + target.h / 2) - (m.y + m.h / 2);
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      
      projectiles.push({
        x: m.x + m.w / 2,
        y: m.y + m.h / 2,
        vx: (dx / dist) * 7,
        vy: (dy / dist) * 7,
        radius: 4,
        damage: m.damage,
        color: m.color,
        life: 2,
        trail: [],
        isEnemyProjectile: false
      });
    }
  }
}

function updateAbilityDisplay() {
  const bar = document.getElementById("abilityBar");
  if (!bar) return;
  
  const skillTree = SKILL_TREES[selectedClass];
  if (!skillTree) return;
  
  // Update ability 1
  const ult1 = document.getElementById("ability1");
  if (ult1 && skillTree.ult1) {
    const cd = abilityCooldowns.ult1;
    ult1.textContent = cd > 0 ? Math.ceil(cd) : skillTree.ult1.icon;
    ult1.style.opacity = cd > 0 ? "0.5" : "1";
  }
  
  // Update ability 2
  const ult2 = document.getElementById("ability2");
  if (ult2 && skillTree.ult2) {
    const cd = abilityCooldowns.ult2;
    ult2.textContent = cd > 0 ? Math.ceil(cd) : skillTree.ult2.icon;
    ult2.style.opacity = cd > 0 ? "0.5" : "1";
  }
}

// ==================== PARTICLES & EFFECTS ====================
function spawnHitParticles(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 4,
      vy: (Math.random() - 0.5) * 4,
      radius: 3,
      color,
      life: 0.5
    });
  }
}

function spawnExplosion(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 8,
      vy: (Math.random() - 0.5) * 8,
      radius: Math.random() * 4 + 2,
      color,
      life: 0.8
    });
  }
}

function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.life -= dt;
    if (p.life <= 0) {
      particles.splice(i, 1);
    }
  }
}

function addFloatingText(x, y, text, color) {
  floatingTexts.push({ x, y, text, color, life: 1.5, vy: -1.5 });
}

function updateFloatingTexts(dt) {
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const t = floatingTexts[i];
    t.y += t.vy;
    t.life -= dt;
    if (t.life <= 0) {
      floatingTexts.splice(i, 1);
    }
  }
}

// ==================== DRAWING ====================
function draw() {
  ctx.save();
  
  // Screen shake
  if (screenShake > 0) {
    ctx.translate(
      (Math.random() - 0.5) * screenShake,
      (Math.random() - 0.5) * screenShake
    );
  }
  
  // Background - Upside Down effect
  if (abilityEffects.upsideDownActive) {
    ctx.fillStyle = "#1a0010";
  } else {
    ctx.fillStyle = "#0a0015";
  }
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Stars
  drawStars();
  
  // Ground
  if (abilityEffects.upsideDownActive) {
    ctx.fillStyle = "#3a1020";
  } else {
    ctx.fillStyle = "#2a1a3a";
  }
  ctx.fillRect(0, GROUND_Y, canvas.width, canvas.height - GROUND_Y);
  ctx.strokeStyle = abilityEffects.upsideDownActive ? "#ff0044" : "#00ffff";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, GROUND_Y);
  ctx.lineTo(canvas.width, GROUND_Y);
  ctx.stroke();
  
  // Fire zones
  drawFireZones();
  
  // Player
  if (player) drawPlayer();
  
  // Minions
  drawMinions();
  
  // Vecna monsters
  drawVecnaMonsters();
  
  // Enemies
  drawEnemies();
  
  // Projectiles
  drawProjectiles();
  
  // Particles
  drawParticles();
  
  // Floating texts
  drawFloatingTexts();
  
  // Ability effects visuals
  drawAbilityEffects();
  
  // HUD
  drawHUD();
  
  ctx.restore();
}

function drawMinions() {
  for (const m of minions) {
    ctx.shadowColor = m.color;
    ctx.shadowBlur = 12;
    ctx.fillStyle = m.color;
    
    // Body
    ctx.fillRect(m.x, m.y, m.w, m.h);
    ctx.shadowBlur = 0;
    
    // Eyes
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(m.x + m.w * 0.2, m.y + m.h * 0.2, 4, 4);
    ctx.fillRect(m.x + m.w * 0.6, m.y + m.h * 0.2, 4, 4);
    
    // Type indicator
    if (m.type === "skeleton") {
      ctx.fillStyle = "#ffffff";
      ctx.font = "10px 'Press Start 2P'";
      ctx.textAlign = "center";
      ctx.fillText("üíÄ", m.x + m.w / 2, m.y - 5);
    } else if (m.type === "spirit") {
      ctx.fillStyle = "#ffffff";
      ctx.font = "10px 'Press Start 2P'";
      ctx.textAlign = "center";
      ctx.fillText("‚ú®", m.x + m.w / 2, m.y - 5);
    }
    
    // HP bar
    const hpRatio = m.hp / m.maxHP;
    ctx.fillStyle = "rgba(60, 0, 0, 0.8)";
    ctx.fillRect(m.x, m.y - 8, m.w, 4);
    ctx.fillStyle = "#44ff44";
    ctx.fillRect(m.x, m.y - 8, m.w * hpRatio, 4);
  }
  ctx.textAlign = "left";
}

function drawVecnaMonsters() {
  for (const m of vecnaMonsters) {
    ctx.shadowColor = "#8B0000";
    ctx.shadowBlur = 20;
    ctx.fillStyle = m.color;
    
    // Body - tentacle-like shape
    ctx.beginPath();
    ctx.arc(m.x + m.w / 2, m.y + m.h / 2, m.w / 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    
    // Creepy eyes
    ctx.fillStyle = "#ff0000";
    ctx.beginPath();
    ctx.arc(m.x + m.w * 0.3, m.y + m.h * 0.4, 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(m.x + m.w * 0.7, m.y + m.h * 0.4, 5, 0, Math.PI * 2);
    ctx.fill();
    
    // Life indicator
    ctx.globalAlpha = m.life / 6;
    ctx.strokeStyle = "#8B0000";
    ctx.lineWidth = 3;
    ctx.strokeRect(m.x - 2, m.y - 2, m.w + 4, m.h + 4);
    ctx.globalAlpha = 1;
  }
}

function drawAbilityEffects() {
  // Death Aura visual
  if (abilityEffects.deathAuraActive && player) {
    const gradient = ctx.createRadialGradient(
      player.x + player.w / 2, player.y + player.h / 2, 0,
      player.x + player.w / 2, player.y + player.h / 2, 150
    );
    gradient.addColorStop(0, "rgba(153, 51, 255, 0.4)");
    gradient.addColorStop(0.5, "rgba(153, 51, 255, 0.2)");
    gradient.addColorStop(1, "rgba(153, 51, 255, 0)");
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(player.x + player.w / 2, player.y + player.h / 2, 150, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Hunter's Mark visual
  if (abilityEffects.huntersMark && abilityEffects.huntersMark.target) {
    const target = abilityEffects.huntersMark.target;
    ctx.strokeStyle = "#ff0000";
    ctx.lineWidth = 3;
    ctx.setLineDash([5, 5]);
    ctx.strokeRect(target.x - 5, target.y - 5, target.w + 10, target.h + 10);
    ctx.setLineDash([]);
    
    // Target reticle
    ctx.beginPath();
    ctx.arc(target.x + target.w / 2, target.y + target.h / 2, target.w * 0.8, 0, Math.PI * 2);
    ctx.stroke();
  }
  
  // Time Freeze visual
  if (abilityEffects.timeFreezeActive) {
    ctx.fillStyle = "rgba(136, 0, 255, 0.1)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Clock icon
    ctx.fillStyle = "#8800ff";
    ctx.font = "30px 'Press Start 2P'";
    ctx.textAlign = "center";
    ctx.fillText("‚è∞", canvas.width - 50, 150);
    ctx.font = "12px 'Press Start 2P'";
    ctx.fillText(Math.ceil(abilityEffects.timeFreezeTimer) + "s", canvas.width - 50, 175);
    ctx.textAlign = "left";
  }
  
  // Shield Wall visual
  if (abilityEffects.shieldWall && player) {
    ctx.strokeStyle = "#4488ff";
    ctx.lineWidth = 5;
    ctx.globalAlpha = 0.6 + Math.sin(Date.now() / 100) * 0.3;
    ctx.strokeRect(player.x - 15, player.y - 15, player.w + 30, player.h + 30);
    ctx.globalAlpha = 1;
  }
  
  // Hive Mind visual
  if (abilityEffects.hiveMindActive) {
    // Draw lines from player to controlled enemies
    enemies.forEach(e => {
      if (e.controlled) {
        ctx.strokeStyle = "rgba(139, 0, 0, 0.5)";
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(player.x + player.w / 2, player.y + player.h / 2);
        ctx.lineTo(e.x + e.w / 2, e.y + e.h / 2);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Mind control indicator
        ctx.fillStyle = "#8B0000";
        ctx.font = "12px 'Press Start 2P'";
        ctx.textAlign = "center";
        ctx.fillText("üß†", e.x + e.w / 2, e.y - 15);
      }
    });
    ctx.textAlign = "left";
  }
}

function drawStars() {
  const time = Date.now() * 0.0001;
  for (let i = 0; i < 30; i++) {
    const x = (i * 123.456) % canvas.width;
    const y = ((i * 78.9 + time * 20) % (GROUND_Y - 50));
    const brightness = (Math.sin(i + time * 3) + 1) * 0.5;
    ctx.fillStyle = `rgba(255, 255, 255, ${brightness * 0.5})`;
    ctx.fillRect(x, y, 2, 2);
  }
}

function drawPlayer() {
  const skin = gameData.cosmetics.playerSkin;
  
  // Glow based on skin
  ctx.shadowColor = player.color;
  ctx.shadowBlur = 15;
  
  if (skin === "fire") {
    ctx.shadowColor = "#ff4400";
    ctx.fillStyle = "#ff6600";
  } else if (skin === "ice") {
    ctx.shadowColor = "#00ffff";
    ctx.fillStyle = "#88ffff";
  } else if (skin === "shadow") {
    ctx.shadowColor = "#000000";
    ctx.fillStyle = "#333333";
  } else if (skin === "gold") {
    ctx.shadowColor = "#ffdd00";
    ctx.fillStyle = "#ffd700";
  } else if (skin === "rainbow") {
    const hue = (Date.now() / 20) % 360;
    ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;
    ctx.fillStyle = `hsl(${hue}, 100%, 60%)`;
  } else if (skin === "void") {
    ctx.shadowColor = "#8B0000";
    ctx.fillStyle = "#2a0000";
  } else {
    ctx.fillStyle = player.color;
  }
  
  // Body
  ctx.fillRect(player.x, player.y, player.w, player.h);
  ctx.shadowBlur = 0;
  
  // Head
  ctx.fillStyle = "#ffd4a3";
  ctx.fillRect(player.x + player.w * 0.25, player.y - player.h * 0.3, player.w * 0.5, player.h * 0.3);
  
  // Eyes
  ctx.fillStyle = "#00ffff";
  ctx.fillRect(player.x + player.w * 0.35, player.y - player.h * 0.18, 4, 4);
  ctx.fillRect(player.x + player.w * 0.55, player.y - player.h * 0.18, 4, 4);
  
  // Shield visual
  if (player.shield > 0) {
    ctx.strokeStyle = "#00aaff";
    ctx.lineWidth = 3;
    ctx.globalAlpha = 0.5;
    ctx.strokeRect(player.x - 5, player.y - 5, player.w + 10, player.h + 10);
    ctx.globalAlpha = 1;
  }
  
  // Invincibility visual
  if (player.invincible) {
    ctx.strokeStyle = "#ffff00";
    ctx.lineWidth = 3;
    ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 100) * 0.3;
    ctx.strokeRect(player.x - 8, player.y - 8, player.w + 16, player.h + 16);
    ctx.globalAlpha = 1;
  }
}

function drawEnemies() {
  for (const e of enemies) {
    ctx.shadowColor = e.color;
    ctx.shadowBlur = e.isBoss ? 25 : e.isMiniBoss ? 18 : 10;
    
    // Stone form visual
    if (e.stoneForm) {
      ctx.fillStyle = "#666666";
    } else if (e.isRaging) {
      ctx.fillStyle = "#ff0000";
    } else if (e.frozen) {
      ctx.fillStyle = "#88ccff";
    } else {
      ctx.fillStyle = e.color;
    }
    
    const wobble = e.isCharging ? 0 : Math.sin(Date.now() / 200) * 2;
    ctx.fillRect(e.x + 2, e.y + wobble, e.w - 4, e.h - 4);
    
    ctx.shadowBlur = 0;
    
    // Eyes
    ctx.fillStyle = e.isRaging ? "#ffff00" : e.frozen ? "#aaddff" : "#ffff00";
    const eyeSize = e.isBoss ? 8 : e.isMiniBoss ? 6 : 5;
    ctx.fillRect(e.x + e.w * 0.25, e.y + e.h * 0.2 + wobble, eyeSize, eyeSize);
    ctx.fillRect(e.x + e.w * 0.65, e.y + e.h * 0.2 + wobble, eyeSize, eyeSize);
    
    // Charging indicator
    if (e.isCharging && e.chargeTimer > 0) {
      ctx.strokeStyle = "#ff0000";
      ctx.lineWidth = 3;
      ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 50) * 0.5;
      ctx.beginPath();
      ctx.moveTo(e.x, e.y + e.h / 2);
      ctx.lineTo(e.x - 100, e.y + e.h / 2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }
    
    // Laser beam
    if (e.laserActive) {
      ctx.strokeStyle = e.color;
      ctx.lineWidth = 8 + Math.sin(Date.now() / 30) * 3;
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.moveTo(e.x + e.w / 2, e.y + e.h / 2);
      ctx.lineTo(0, e.y + e.h / 2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }
    
    // Stone form aura
    if (e.stoneForm) {
      ctx.strokeStyle = "#4488ff";
      ctx.lineWidth = 3;
      ctx.globalAlpha = 0.6 + Math.sin(Date.now() / 100) * 0.3;
      ctx.strokeRect(e.x - 5, e.y - 5, e.w + 10, e.h + 10);
      ctx.globalAlpha = 1;
    }
    
    // Rage aura
    if (e.isRaging) {
      for (let i = 0; i < 3; i++) {
        if (Math.random() < 0.3) {
          particles.push({
            x: e.x + Math.random() * e.w,
            y: e.y + e.h,
            vx: (Math.random() - 0.5) * 2,
            vy: -Math.random() * 3 - 1,
            color: "#ff4400",
            life: 0.5,
            radius: 4
          });
        }
      }
    }
    
    // Labels with boss name
    if (e.isBoss) {
      ctx.fillStyle = "#ffffff";
      ctx.font = "bold 12px 'Press Start 2P'";
      ctx.textAlign = "center";
      const bossName = e.pattern ? e.pattern.name : "BOSS";
      ctx.fillText(bossName, e.x + e.w / 2, e.y - 25);
      
      // Show current attack
      if (e.currentAttack) {
        ctx.fillStyle = "#ffff00";
        ctx.font = "bold 8px 'Press Start 2P'";
        ctx.fillText(e.currentAttack.type.toUpperCase(), e.x + e.w / 2, e.y - 12);
      }
    } else if (e.isMiniBoss) {
      ctx.fillStyle = "#ffff00";
      ctx.font = "bold 10px 'Press Start 2P'";
      ctx.textAlign = "center";
      const miniBossName = e.pattern ? e.pattern.name : "ELITE";
      ctx.fillText(miniBossName, e.x + e.w / 2, e.y - 20);
    }
    
    // HP bar
    const hpRatio = e.hp / e.maxHP;
    ctx.fillStyle = "rgba(60, 0, 0, 0.8)";
    ctx.fillRect(e.x, e.y - 8, e.w, 5);
    ctx.fillStyle = hpRatio > 0.5 ? "#44ff44" : hpRatio > 0.25 ? "#ffaa44" : "#ff4444";
    ctx.fillRect(e.x, e.y - 8, e.w * hpRatio, 5);
    
    ctx.textAlign = "left";
  }
}

function drawProjectiles() {
  for (const p of projectiles) {
    // Trail
    ctx.globalAlpha = 0.3;
    ctx.strokeStyle = p.color;
    ctx.lineWidth = p.radius;
    ctx.beginPath();
    for (let i = 0; i < p.trail.length; i++) {
      const t = p.trail[i];
      if (i === 0) ctx.moveTo(t.x, t.y);
      else ctx.lineTo(t.x, t.y);
    }
    ctx.stroke();
    ctx.globalAlpha = 1;
    
    // Bullet
    ctx.shadowColor = p.color;
    ctx.shadowBlur = 10;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

function drawFireZones() {
  fireZones.forEach(zone => {
    const gradient = ctx.createRadialGradient(zone.x, zone.y, 0, zone.x, zone.y, zone.radius);
    gradient.addColorStop(0, "rgba(255, 136, 0, 0.6)");
    gradient.addColorStop(0.5, "rgba(255, 68, 0, 0.3)");
    gradient.addColorStop(1, "rgba(255, 68, 0, 0)");
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
    ctx.fill();
  });
}

function drawParticles() {
  for (const p of particles) {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.radius || 3, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function drawFloatingTexts() {
  for (const t of floatingTexts) {
    ctx.globalAlpha = t.life;
    ctx.fillStyle = t.color;
    ctx.font = "bold 14px 'Press Start 2P'";
    ctx.textAlign = "center";
    ctx.fillText(t.text, t.x, t.y);
  }
  ctx.globalAlpha = 1;
  ctx.textAlign = "left";
}

function drawHUD() {
  // Info panel
  ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
  ctx.fillRect(10, 10, 300, 90);
  ctx.strokeStyle = "#00ffff";
  ctx.lineWidth = 2;
  ctx.strokeRect(10, 10, 300, 90);
  
  ctx.fillStyle = "#00ffff";
  ctx.font = "12px 'Press Start 2P'";
  ctx.fillText("‚öîÔ∏è " + selectedClass, 20, 30);
  ctx.fillText("üåä Wave: " + wave + (gameMode === "story" ? "/" + maxWaves : ""), 20, 50);
  ctx.fillText("‚≠ê Level: " + (player?.level || 1), 170, 50);
  
  // HP bar
  if (player) {
    const hpRatio = player.hp / player.maxHP;
    ctx.fillStyle = "rgba(60, 0, 0, 0.8)";
    ctx.fillRect(20, 65, 280, 12);
    ctx.fillStyle = hpRatio > 0.5 ? "#44ff44" : hpRatio > 0.25 ? "#ffaa44" : "#ff4444";
    ctx.fillRect(20, 65, 280 * hpRatio, 12);
    ctx.strokeStyle = "#ff4444";
    ctx.strokeRect(20, 65, 280, 12);
    ctx.fillStyle = "#ffffff";
    ctx.font = "10px 'Press Start 2P'";
    ctx.fillText(Math.floor(player.hp) + "/" + player.maxHP, 25, 75);
    
    // XP bar
    const xpRatio = player.xp / player.xpToNext;
    ctx.fillStyle = "rgba(0, 50, 80, 0.8)";
    ctx.fillRect(20, 82, 280, 8);
    ctx.fillStyle = "#0088ff";
    ctx.fillRect(20, 82, 280 * xpRatio, 8);
  }
  
  // Currency
  ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
  ctx.fillRect(canvas.width - 160, 10, 150, 50);
  ctx.strokeStyle = "#ffff00";
  ctx.strokeRect(canvas.width - 160, 10, 150, 50);
  ctx.fillStyle = "#ffff00";
  ctx.font = "12px 'Press Start 2P'";
  ctx.fillText("üí∞ " + sessionCoins, canvas.width - 150, 30);
  ctx.fillStyle = "#00ffff";
  ctx.fillText("üíé " + sessionGems, canvas.width - 150, 50);
  
  // Combo
  if (combo > 1) {
    ctx.fillStyle = "#ff8800";
    ctx.font = "bold 16px 'Press Start 2P'";
    ctx.fillText("üî• COMBO: " + combo + "x", canvas.width - 200, 80);
  }
  
  // Wave Timer (when no enemies and waiting for next wave)
  if (waveTimerActive && waveTimer > 0) {
    ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
    ctx.fillRect(canvas.width / 2 - 100, 10, 200, 40);
    ctx.strokeStyle = "#ff8800";
    ctx.strokeRect(canvas.width / 2 - 100, 10, 200, 40);
    ctx.fillStyle = "#ffff00";
    ctx.font = "14px 'Press Start 2P'";
    ctx.textAlign = "center";
    ctx.fillText("Next Wave: " + Math.ceil(waveTimer) + "s", canvas.width / 2, 35);
    ctx.textAlign = "left";
  }
  
  // Status indicators (bottom left)
  ctx.fillStyle = "#888";
  ctx.font = "10px 'Press Start 2P'";
  let statusY = canvas.height - 50;
  ctx.fillText("[R] Auto: " + (autoStartWaves ? "ON" : "OFF"), 20, statusY);
  ctx.fillText("[F] Speed: " + gameSpeed + "x", 20, statusY + 15);
  ctx.fillText("[G] Give Up", 150, statusY);
  
  // Pause button hint
  ctx.fillStyle = "#888";
  ctx.font = "10px 'Press Start 2P'";
  ctx.fillText("[ESC] Pause", canvas.width - 120, canvas.height - 20);
}

// ==================== KEYBOARD CONTROLS ====================
function handleKeyDown(e) {
  // Pause
  if (e.key === "Escape" && currentScreen === "gameScreen" && gameRunning) {
    if (gamePaused) {
      resumeGame();
    } else {
      pauseGame();
    }
    return;
  }
  
  // Skip title with any key
  if (currentScreen === "title") {
    goToNameEntry();
    return;
  }
  
  // Potions and Abilities (during gameplay)
  if (currentScreen === "gameScreen" && gameRunning && !gamePaused) {
    if (e.key === "1") usePotion("heal");
    if (e.key === "2") usePotion("shield");
    if (e.key === "3") usePotion("crit");
    if (e.key === "4") usePotion("damage");
    if (e.key === "5") usePotion("speed");
    if (e.key === "6") usePotion("dragon");
    
    // Abilities
    if (e.key === "q" || e.key === "Q") useAbility("ult1");
    if (e.key === "e" || e.key === "E") useAbility("ult2");
    
    // Speed toggle
    if (e.key === "f" || e.key === "F") {
      gameSpeed = gameSpeed === 1 ? 2 : 1;
      addFloatingText(canvas.width / 2, 150, "Speed: " + gameSpeed + "x", gameSpeed === 2 ? "#ff8800" : "#ffffff");
    }
    
    // Auto-start waves toggle
    if (e.key === "r" || e.key === "R") {
      autoStartWaves = !autoStartWaves;
      addFloatingText(canvas.width / 2, 180, "Auto-Start: " + (autoStartWaves ? "ON" : "OFF"), autoStartWaves ? "#00ff88" : "#ff4444");
    }
    
    // Give up (end run)
    if (e.key === "g" || e.key === "G") {
      if (confirm("Are you sure you want to give up?")) {
        gameOver();
      }
    }
  }
}

function pauseGame() {
  gamePaused = true;
  document.getElementById("pauseMenu").classList.add("active");
}

function resumeGame() {
  gamePaused = false;
  document.getElementById("pauseMenu").classList.remove("active");
  document.getElementById("upgradeScreen").classList.remove("active");
}

function restartGame() {
  document.getElementById("pauseMenu").classList.remove("active");
  startBattle();
}

function quitToMenu() {
  gameRunning = false;
  document.getElementById("pauseMenu").classList.remove("active");
  document.getElementById("potionBar").classList.remove("active");
  document.getElementById("abilityBar").classList.remove("active");
  showScreen("mainMenu");
}

// ==================== START ====================
init();
</script>
</body>
</html>