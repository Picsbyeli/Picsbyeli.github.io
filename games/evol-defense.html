<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>EVOL LEGENDS - The Forgotten Warrior</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Press+Start+2P&family=Crimson+Text:ital@0;1&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      font-family: 'Press Start 2P', monospace;
      color: #fff;
      overflow: hidden;
    }
    #gameContainer {
      position: relative;
      width: 1200px;
      height: 700px;
      background: #0a0015;
      box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
      overflow: hidden;
    }
    canvas { display: block; image-rendering: pixelated; }
    
    /* Starfield background */
    .starfield {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: linear-gradient(135deg, #0a0015 0%, #1a0030 50%, #0a0020 100%);
      z-index: -1;
    }
    .star {
      position: absolute;
      background: white;
      border-radius: 50%;
      animation: twinkle 2s infinite;
    }
    @keyframes twinkle {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 1; }
    }
    
    /* Title Screen */
    #titleScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: linear-gradient(135deg, #0a0015 0%, #1a0030 50%, #0a0020 100%);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 200;
      cursor: pointer;
    }
    #titleScreen.hidden { display: none; }
    
    .title-logo {
      font-family: 'Cinzel', serif;
      font-size: 72px;
      font-weight: 700;
      background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3, #54a0ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
      animation: logoGlow 3s ease-in-out infinite;
      margin-bottom: 10px;
    }
    @keyframes logoGlow {
      0%, 100% { filter: drop-shadow(0 0 20px #00ffff); }
      50% { filter: drop-shadow(0 0 40px #ff00ff); }
    }
    
    .title-subtitle {
      font-family: 'Crimson Text', serif;
      font-size: 28px;
      font-style: italic;
      color: #ff00ff;
      text-shadow: 0 0 15px #ff00ff;
      margin-bottom: 30px;
    }
    
    .title-tagline {
      font-family: 'Crimson Text', serif;
      font-size: 18px;
      color: #88ffff;
      margin-bottom: 60px;
    }
    
    .press-start {
      font-family: 'Press Start 2P', monospace;
      font-size: 16px;
      color: #00ffff;
      animation: blink 1.5s infinite;
    }
    @keyframes blink {
      0%, 50%, 100% { opacity: 1; }
      25%, 75% { opacity: 0.3; }
    }
    
    /* Name Entry Screen */
    #nameScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: linear-gradient(135deg, #0a0015 0%, #1a0030 100%);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 190;
    }
    #nameScreen.active { display: flex; }
    
    .name-quote {
      font-family: 'Crimson Text', serif;
      font-style: italic;
      font-size: 18px;
      color: #aaa;
      max-width: 600px;
      text-align: center;
      margin-bottom: 40px;
      line-height: 1.6;
    }
    
    .name-prompt {
      font-size: 24px;
      color: #00ffff;
      margin-bottom: 20px;
    }
    
    #warriorNameInput {
      font-family: 'Cinzel', serif;
      font-size: 28px;
      padding: 15px 30px;
      background: rgba(0, 0, 0, 0.8);
      border: 3px solid #00ffff;
      border-radius: 10px;
      color: #ffff00;
      text-align: center;
      width: 400px;
      outline: none;
    }
    #warriorNameInput:focus {
      box-shadow: 0 0 20px #00ffff;
    }
    
    .name-confirm-btn {
      margin-top: 30px;
      padding: 15px 50px;
      font-family: 'Press Start 2P', monospace;
      font-size: 14px;
      background: linear-gradient(135deg, #00ff88 0%, #00ffff 100%);
      color: #000;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
    }
    .name-confirm-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 0 30px #00ffff;
    }
    
    /* Main Menu */
    #mainMenu {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: linear-gradient(135deg, #0a0015 0%, #1a0030 100%);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 180;
    }
    #mainMenu.active { display: flex; }
    
    .menu-title {
      font-family: 'Cinzel', serif;
      font-size: 48px;
      color: #00ffff;
      text-shadow: 0 0 20px #00ffff;
      margin-bottom: 10px;
    }
    
    .menu-warrior-name {
      font-family: 'Crimson Text', serif;
      font-size: 20px;
      color: #ffff00;
      margin-bottom: 30px;
    }
    
    .menu-buttons {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin-bottom: 30px;
    }
    
    .menu-btn {
      padding: 18px 80px;
      font-family: 'Press Start 2P', monospace;
      font-size: 14px;
      background: linear-gradient(135deg, #1a1a3a 0%, #2a1a4a 100%);
      color: #00ffff;
      border: 3px solid #00ffff;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
      min-width: 350px;
    }
    .menu-btn:hover {
      background: linear-gradient(135deg, #00ffff 0%, #ff00ff 100%);
      color: #000;
      transform: scale(1.05);
      box-shadow: 0 0 30px #00ffff;
    }
    .menu-btn.story-btn { border-color: #00ff88; color: #00ff88; }
    .menu-btn.endless-btn { border-color: #ff00ff; color: #ff00ff; }
    .menu-btn.shop-btn { border-color: #ffff00; color: #ffff00; }
    .menu-btn.settings-btn { border-color: #ff8800; color: #ff8800; }
    .menu-btn.redeem-btn { border-color: #ff0088; color: #ff0088; }
    
    .menu-stats {
      display: flex;
      gap: 40px;
      font-size: 12px;
      color: #888;
    }
    .menu-stats span { color: #ffff00; }
    
    /* Overworld Map */
    #overworldMap {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: #000;
      display: none;
      z-index: 170;
    }
    #overworldMap.active { display: block; }
    
    #mapImage {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .map-node {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
    }
    .map-node.locked {
      background: rgba(100, 100, 100, 0.5);
      border: 3px dashed #666;
      cursor: not-allowed;
    }
    .map-node.unlocked {
      background: rgba(0, 255, 255, 0.3);
      border: 3px solid #00ffff;
      animation: nodePulse 2s infinite;
    }
    .map-node.completed {
      background: rgba(0, 255, 0, 0.3);
      border: 3px solid #00ff00;
    }
    .map-node.boss {
      width: 60px;
      height: 60px;
      font-size: 30px;
    }
    .map-node:hover:not(.locked) {
      transform: scale(1.3);
      box-shadow: 0 0 30px #00ffff;
    }
    @keyframes nodePulse {
      0%, 100% { box-shadow: 0 0 10px #00ffff; }
      50% { box-shadow: 0 0 25px #00ffff, 0 0 40px #00ffff; }
    }
    
    .map-hud {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      pointer-events: none;
    }
    .map-hud > * { pointer-events: auto; }
    
    .map-info {
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid #00ffff;
      border-radius: 10px;
      padding: 15px 20px;
    }
    
    .map-currency {
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid #ffff00;
      border-radius: 10px;
      padding: 15px 20px;
      font-size: 14px;
    }
    
    /* Level Modal */
    #levelModal {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #1a0030 0%, #2a0050 100%);
      border: 4px solid #00ffff;
      border-radius: 20px;
      padding: 30px;
      display: none;
      flex-direction: column;
      align-items: center;
      z-index: 175;
      min-width: 400px;
    }
    #levelModal.active { display: flex; }
    
    /* Class Selection */
    #classSelection {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: linear-gradient(135deg, #0a0015 0%, #1a0030 100%);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 160;
      overflow-y: auto;
      padding: 20px;
    }
    #classSelection.active { display: flex; }
    
    .class-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      max-width: 1000px;
      width: 100%;
    }
    
    .class-card {
      background: linear-gradient(135deg, #1a1a3a 0%, #2a1a3a 100%);
      border: 3px solid #00ffff;
      border-radius: 15px;
      padding: 20px;
      cursor: pointer;
      transition: all 0.3s;
      position: relative;
    }
    .class-card:hover:not(.locked) {
      transform: translateY(-10px);
      box-shadow: 0 10px 30px rgba(0, 255, 255, 0.5);
    }
    .class-card.locked {
      opacity: 0.5;
      cursor: not-allowed;
      border-color: #666;
    }
    .class-card.locked::after {
      content: "üîí";
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 24px;
    }
    .class-icon { font-size: 48px; text-align: center; margin-bottom: 10px; }
    .class-name { font-size: 16px; text-align: center; margin-bottom: 10px; color: #ffff00; }
    .class-stats { font-size: 10px; color: #aaa; line-height: 1.6; }
    .class-unlock { font-size: 10px; color: #ff8800; text-align: center; margin-top: 10px; }
    
    /* Shop Screen */
    #shopScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      flex-direction: column;
      align-items: center;
      z-index: 150;
      overflow-y: auto;
      padding: 20px;
    }
    #shopScreen.active { display: flex; }
    
    .shop-tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }
    .shop-tab {
      padding: 12px 25px;
      font-size: 12px;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #00ffff;
      color: #00ffff;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
    }
    .shop-tab.active {
      background: #00ffff;
      color: #000;
    }
    
    .shop-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
      max-width: 1000px;
      width: 100%;
    }
    
    .shop-item {
      background: linear-gradient(135deg, #2a1a3a 0%, #3a2a4a 100%);
      border: 2px solid #00ffff;
      border-radius: 10px;
      padding: 15px;
      cursor: pointer;
      transition: all 0.3s;
    }
    .shop-item:hover:not(.maxed) {
      transform: scale(1.05);
      box-shadow: 0 5px 20px rgba(0, 255, 255, 0.5);
    }
    .shop-item.maxed {
      opacity: 0.6;
      cursor: not-allowed;
      border-color: #666;
    }
    .shop-item-name { font-size: 14px; color: #ffff00; margin-bottom: 5px; }
    .shop-item-desc { font-size: 10px; color: #aaa; margin-bottom: 10px; }
    .shop-item-cost { font-size: 12px; color: #ff8800; }
    
    /* Settings Screen */
    #settingsScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 150;
    }
    #settingsScreen.active { display: flex; }
    
    .settings-container {
      background: linear-gradient(135deg, #1a0030 0%, #2a0050 100%);
      border: 3px solid #ff8800;
      border-radius: 20px;
      padding: 40px;
      min-width: 500px;
    }
    
    .setting-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 25px;
      padding-bottom: 15px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .setting-label { font-size: 14px; color: #00ffff; }
    
    .setting-slider {
      width: 200px;
      height: 8px;
      -webkit-appearance: none;
      background: #333;
      border-radius: 4px;
      outline: none;
    }
    .setting-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      background: #00ffff;
      border-radius: 50%;
      cursor: pointer;
    }
    
    .setting-toggle {
      width: 60px;
      height: 30px;
      background: #333;
      border-radius: 15px;
      cursor: pointer;
      position: relative;
      transition: all 0.3s;
    }
    .setting-toggle.on { background: #00ff88; }
    .setting-toggle::after {
      content: '';
      position: absolute;
      width: 26px;
      height: 26px;
      background: white;
      border-radius: 50%;
      top: 2px;
      left: 2px;
      transition: all 0.3s;
    }
    .setting-toggle.on::after { left: 32px; }
    
    /* Redeem Code Screen */
    #redeemScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 150;
    }
    #redeemScreen.active { display: flex; }
    
    .redeem-container {
      background: linear-gradient(135deg, #1a0030 0%, #2a0050 100%);
      border: 3px solid #ff0088;
      border-radius: 20px;
      padding: 40px;
      text-align: center;
    }
    
    #redeemInput {
      font-family: 'Press Start 2P', monospace;
      font-size: 16px;
      padding: 15px 30px;
      background: rgba(0, 0, 0, 0.8);
      border: 3px solid #ff0088;
      border-radius: 10px;
      color: #ffff00;
      text-align: center;
      width: 350px;
      margin: 20px 0;
      outline: none;
      text-transform: uppercase;
    }
    
    #redeemMessage {
      font-size: 12px;
      margin-top: 15px;
      min-height: 20px;
    }
    
    /* Game Screen (Battle) */
    #gameScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: #0a0015;
      display: none;
      z-index: 140;
    }
    #gameScreen.active { display: block; }
    
    #gameCanvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    
    /* Pause Menu */
    #pauseMenu {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.95);
      border: 4px solid #ffff00;
      border-radius: 20px;
      padding: 40px;
      display: none;
      flex-direction: column;
      align-items: center;
      z-index: 145;
    }
    #pauseMenu.active { display: flex; }
    
    .pause-title {
      font-size: 32px;
      color: #ffff00;
      margin-bottom: 30px;
    }
    
    .pause-btn {
      padding: 15px 40px;
      font-size: 14px;
      margin: 10px;
      background: linear-gradient(135deg, #1a1a3a 0%, #2a1a4a 100%);
      color: #00ffff;
      border: 2px solid #00ffff;
      border-radius: 10px;
      cursor: pointer;
      min-width: 250px;
    }
    .pause-btn:hover {
      background: #00ffff;
      color: #000;
    }
    .pause-btn.quit { border-color: #ff0000; color: #ff0000; }
    .pause-btn.quit:hover { background: #ff0000; color: #fff; }
    
    /* Upgrade Screen */
    #upgradeScreen {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #1a0030 0%, #2a0050 100%);
      border: 4px solid #00ffff;
      border-radius: 20px;
      padding: 30px;
      display: none;
      flex-direction: column;
      align-items: center;
      z-index: 145;
    }
    #upgradeScreen.active { display: flex; }
    
    .upgrade-options {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .upgrade-card {
      background: linear-gradient(135deg, #2a1a3a 0%, #3a2a4a 100%);
      border: 3px solid #00ffff;
      border-radius: 15px;
      padding: 20px;
      width: 180px;
      cursor: pointer;
      transition: all 0.3s;
      text-align: center;
    }
    .upgrade-card:hover {
      transform: translateY(-10px);
      box-shadow: 0 10px 30px rgba(0, 255, 255, 0.5);
      border-color: #ffff00;
    }
    
    /* Game Over Screen */
    #gameOverScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 145;
    }
    #gameOverScreen.active { display: flex; }
    
    /* Victory Screen */
    #victoryScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 145;
    }
    #victoryScreen.active { display: flex; }
    
    /* Potion Bar */
    #potionBar {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      gap: 10px;
      z-index: 143;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px 20px;
      border-radius: 15px;
      border: 3px solid #00ffff;
    }
    #potionBar.active { display: flex; }
    
    .potion-slot {
      width: 60px;
      height: 70px;
      background: rgba(40, 40, 40, 0.9);
      border: 2px solid #666;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    .potion-slot:hover:not(.cooldown) {
      transform: scale(1.1);
      border-color: #00ffff;
    }
    .potion-slot.cooldown { opacity: 0.5; cursor: not-allowed; }
    .potion-icon { font-size: 28px; }
    .potion-count { font-size: 12px; color: #ffff00; }
    .potion-key { position: absolute; top: 2px; left: 4px; font-size: 10px; color: #aaa; }
    
    /* Ability Bar */
    #abilityBar {
      position: absolute;
      bottom: 110px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      gap: 15px;
      z-index: 143;
      background: rgba(20, 0, 40, 0.9);
      padding: 12px 25px;
      border-radius: 15px;
      border: 3px solid #ff00ff;
      box-shadow: 0 0 20px rgba(255, 0, 255, 0.4);
    }
    #abilityBar.active { display: flex; }
    
    .ability-slot {
      width: 70px;
      height: 80px;
      background: linear-gradient(180deg, rgba(60, 0, 80, 0.9) 0%, rgba(30, 0, 50, 0.9) 100%);
      border: 2px solid #8800ff;
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    .ability-slot:hover {
      transform: scale(1.1);
      border-color: #ff00ff;
      box-shadow: 0 0 15px rgba(255, 0, 255, 0.6);
    }
    .ability-slot.cooldown { opacity: 0.5; cursor: not-allowed; }
    .ability-icon { font-size: 32px; }
    .ability-name { font-size: 8px; color: #ff88ff; margin-top: 4px; }
    .ability-key { position: absolute; top: 2px; left: 6px; font-size: 10px; color: #ff88ff; }
    
    /* Back Button */
    .back-btn {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #00ffff;
      color: #00ffff;
      font-size: 24px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s;
      z-index: 100;
    }
    .back-btn:hover {
      background: #00ffff;
      color: #000;
    }
    
    /* Generic button styles */
    .btn-primary {
      padding: 15px 40px;
      font-family: 'Press Start 2P', monospace;
      font-size: 12px;
      background: linear-gradient(135deg, #00ff88 0%, #00ffff 100%);
      color: #000;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
    }
    .btn-primary:hover {
      transform: scale(1.05);
      box-shadow: 0 0 20px #00ffff;
    }
    
    .btn-danger {
      padding: 15px 40px;
      font-family: 'Press Start 2P', monospace;
      font-size: 12px;
      background: linear-gradient(135deg, #ff4444 0%, #ff0000 100%);
      color: #fff;
      border: none;
      border-radius: 10px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <!-- Title Screen -->
    <div id="titleScreen">
      <div class="starfield" id="starfield"></div>
      <div class="title-logo">EVOL LEGENDS</div>
      <div class="title-subtitle">The Forgotten Warrior</div>
      <div class="title-tagline">A tale of memory, destiny, and eternal combat</div>
      <div class="press-start">‚Äî PRESS ANY KEY OR CLICK TO BEGIN ‚Äî</div>
    </div>
    
    <!-- Name Entry Screen -->
    <div id="nameScreen">
      <div class="name-quote">
        "In the realm where memories fade and legends are born,<br>
        a warrior awakens without name or past...<br>
        What shall you be called, brave soul?"
      </div>
      <div class="name-prompt">Enter Your Warrior Name</div>
      <input type="text" id="warriorNameInput" placeholder="Your Name" maxlength="20">
      <button class="name-confirm-btn" id="nameConfirmBtn">BEGIN YOUR LEGEND</button>
    </div>
    
    <!-- Main Menu -->
    <div id="mainMenu">
      <div class="menu-title">EVOL LEGENDS</div>
      <div class="menu-warrior-name">Welcome, <span id="menuWarriorName">Warrior</span></div>
      <div class="menu-buttons">
        <button class="menu-btn story-btn" id="storyModeBtn">üó∫Ô∏è STORY MODE</button>
        <button class="menu-btn endless-btn" id="endlessModeBtn">‚ôæÔ∏è ENDLESS MODE</button>
        <button class="menu-btn shop-btn" id="shopBtn">üõí SHOP</button>
        <button class="menu-btn settings-btn" id="settingsBtn">‚öôÔ∏è SETTINGS</button>
        <button class="menu-btn redeem-btn" id="redeemBtn">üéÅ REDEEM CODE</button>
      </div>
      <div class="menu-stats">
        <div>üí∞ Coins: <span id="menuCoins">0</span></div>
        <div>üíé Gems: <span id="menuGems">0</span></div>
        <div>üèÜ Highest Wave: <span id="menuHighWave">1</span></div>
        <div>üìä Progress: <span id="menuProgress">0</span>%</div>
      </div>
    </div>
    
    <!-- Overworld Map -->
    <div id="overworldMap">
      <img id="mapImage" src="evol-map.png" alt="Overworld Map">
      <div class="map-hud">
        <div class="map-info">
          <div style="color: #ffff00; font-size: 14px; margin-bottom: 5px;">üìç <span id="mapRegion">Starter Village</span></div>
          <div style="color: #aaa; font-size: 10px;">üó∫Ô∏è Story Progress: <span id="mapProgress">0</span>%</div>
        </div>
        <div class="map-currency">
          <div>üí∞ <span id="mapCoins">0</span></div>
          <div>üíé <span id="mapGems">0</span></div>
        </div>
      </div>
      <button class="back-btn" id="mapBackBtn">‚Üê</button>
      <div id="mapNodes"></div>
    </div>
    
    <!-- Level Modal -->
    <div id="levelModal">
      <div style="font-size: 24px; color: #00ffff; margin-bottom: 10px;" id="levelName">Forest Path</div>
      <div style="font-size: 14px; color: #888; margin-bottom: 15px;" id="levelDesc">A peaceful path through the forest...</div>
      <div style="color: #ffff00; margin-bottom: 10px;">‚≠ê Difficulty: <span id="levelDifficulty">1</span>/10</div>
      <div style="color: #00ff88; margin-bottom: 20px;">üí∞ Rewards: <span id="levelRewards">50 coins</span></div>
      <div style="display: flex; gap: 15px;">
        <button class="btn-primary" id="enterLevelBtn">‚öîÔ∏è ENTER BATTLE</button>
        <button class="btn-danger" id="cancelLevelBtn">CANCEL</button>
      </div>
    </div>
    
    <!-- Class Selection -->
    <div id="classSelection">
      <button class="back-btn" id="classBackBtn">‚Üê</button>
      <div style="font-size: 28px; color: #00ffff; margin-bottom: 10px;">SELECT YOUR LEGEND</div>
      <div style="font-size: 12px; color: #ffff00; margin-bottom: 30px;" id="classSubtitle">Choose your class to begin!</div>
      <div class="class-grid" id="classGrid"></div>
    </div>
    
    <!-- Shop Screen -->
    <div id="shopScreen">
      <button class="back-btn" id="shopBackBtn">‚Üê</button>
      <div style="font-size: 28px; color: #ffff00; margin-bottom: 10px;">üõí MERCHANT'S GUILD</div>
      <div style="font-size: 14px; color: #00ffff; margin-bottom: 20px;">
        üí∞ <span id="shopCoins">0</span> Coins | üíé <span id="shopGems">0</span> Gems
      </div>
      <div class="shop-tabs">
        <button class="shop-tab active" data-tab="upgrades">‚¨ÜÔ∏è Upgrades</button>
        <button class="shop-tab" data-tab="potions">üß™ Potions</button>
        <button class="shop-tab" data-tab="classes">üé≠ Classes</button>
        <button class="shop-tab" data-tab="cosmetics">‚ú® Cosmetics</button>
      </div>
      <div class="shop-grid" id="shopGrid"></div>
    </div>
    
    <!-- Settings Screen -->
    <div id="settingsScreen">
      <button class="back-btn" id="settingsBackBtn">‚Üê</button>
      <div class="settings-container">
        <div style="font-size: 24px; color: #ff8800; text-align: center; margin-bottom: 30px;">‚öôÔ∏è SETTINGS</div>
        
        <div class="setting-row">
          <span class="setting-label">üîä Music Volume</span>
          <input type="range" class="setting-slider" id="musicVolume" min="0" max="100" value="70">
        </div>
        
        <div class="setting-row">
          <span class="setting-label">üîà SFX Volume</span>
          <input type="range" class="setting-slider" id="sfxVolume" min="0" max="100" value="80">
        </div>
        
        <div class="setting-row">
          <span class="setting-label">üéØ Auto-Shoot</span>
          <div class="setting-toggle on" id="autoShootToggle"></div>
        </div>
        
        <div class="setting-row">
          <span class="setting-label">üéØ Auto-Aim</span>
          <div class="setting-toggle on" id="autoAimToggle"></div>
        </div>
        
        <div class="setting-row">
          <span class="setting-label">üì∫ Screen Shake</span>
          <div class="setting-toggle on" id="screenShakeToggle"></div>
        </div>
        
        <div class="setting-row">
          <span class="setting-label">‚ö° Show Damage Numbers</span>
          <div class="setting-toggle on" id="damageNumbersToggle"></div>
        </div>
        
        <div style="text-align: center; margin-top: 20px;">
          <button class="btn-danger" id="resetDataBtn">üóëÔ∏è RESET ALL DATA</button>
        </div>
      </div>
    </div>
    
    <!-- Redeem Code Screen -->
    <div id="redeemScreen">
      <button class="back-btn" id="redeemBackBtn">‚Üê</button>
      <div class="redeem-container">
        <div style="font-size: 24px; color: #ff0088; margin-bottom: 20px;">üéÅ REDEEM CODE</div>
        <div style="font-size: 12px; color: #aaa; margin-bottom: 20px;">Enter a valid code to receive rewards!</div>
        <input type="text" id="redeemInput" placeholder="ENTER CODE">
        <br>
        <button class="btn-primary" id="redeemSubmitBtn">REDEEM</button>
        <div id="redeemMessage"></div>
      </div>
    </div>
    
    <!-- Game Screen -->
    <div id="gameScreen">
      <canvas id="gameCanvas" width="1200" height="700"></canvas>
    </div>
    
    <!-- Pause Menu -->
    <div id="pauseMenu">
      <div class="pause-title">‚è∏Ô∏è PAUSED</div>
      <button class="pause-btn" id="resumeBtn">‚ñ∂Ô∏è RESUME</button>
      <button class="pause-btn" id="restartBtn">üîÑ RESTART</button>
      <button class="pause-btn quit" id="quitBtn">üö™ QUIT TO MENU</button>
    </div>
    
    <!-- Upgrade Screen -->
    <div id="upgradeScreen">
      <div style="font-size: 24px; color: #ffff00; margin-bottom: 10px;">üéâ LEVEL UP!</div>
      <div style="font-size: 12px; color: #00ffff; margin-bottom: 20px;">Choose Your Power-Up</div>
      <div class="upgrade-options" id="upgradeOptions"></div>
    </div>
    
    <!-- Game Over Screen -->
    <div id="gameOverScreen">
      <div style="font-size: 48px; color: #ff0000; margin-bottom: 30px;">üíÄ GAME OVER üíÄ</div>
      <div style="background: rgba(20, 20, 20, 0.8); border: 3px solid #00ffff; border-radius: 15px; padding: 30px; margin-bottom: 20px;">
        <div style="font-size: 16px; margin-bottom: 15px;">üåä Wave Reached: <span id="finalWave" style="color: #ffff00;">1</span></div>
        <div style="font-size: 16px; margin-bottom: 15px;">‚≠ê Level Reached: <span id="finalLevel" style="color: #ffff00;">1</span></div>
        <div style="font-size: 16px; margin-bottom: 15px;">üíÄ Enemies Killed: <span id="finalKills" style="color: #ffff00;">0</span></div>
      </div>
      <div style="background: rgba(255, 215, 0, 0.1); border: 3px solid #ffff00; border-radius: 15px; padding: 20px; margin-bottom: 20px;">
        <div style="font-size: 14px; margin-bottom: 10px;">üí∞ Coins Earned: <span id="earnedCoins" style="color: #ffff00;">0</span></div>
        <div style="font-size: 14px;">üíé Gems Earned: <span id="earnedGems" style="color: #00ffff;">0</span></div>
      </div>
      <button class="btn-primary" id="gameOverContinueBtn">RETURN TO MENU</button>
    </div>
    
    <!-- Victory Screen -->
    <div id="victoryScreen">
      <div style="font-size: 48px; color: #00ff00; margin-bottom: 30px;">üéâ VICTORY! üéâ</div>
      <div style="font-size: 16px; color: #ffff00; margin-bottom: 30px;" id="victoryMessage">Level Complete!</div>
      <div style="background: rgba(0, 255, 0, 0.1); border: 3px solid #00ff00; border-radius: 15px; padding: 20px; margin-bottom: 20px;">
        <div style="font-size: 14px; margin-bottom: 10px;">üí∞ Coins Earned: <span id="victoryCoins" style="color: #ffff00;">0</span></div>
        <div style="font-size: 14px;">üíé Gems Earned: <span id="victoryGems" style="color: #00ffff;">0</span></div>
      </div>
      <button class="btn-primary" id="victoryContinueBtn">CONTINUE</button>
    </div>
    
    <!-- Potion Bar -->
    <div id="potionBar">
      <div class="potion-slot" data-type="heal">
        <div class="potion-key">[1]</div>
        <div class="potion-icon">‚ù§Ô∏è</div>
        <div class="potion-count" id="potionHealCount">3</div>
      </div>
      <div class="potion-slot" data-type="shield">
        <div class="potion-key">[2]</div>
        <div class="potion-icon">üõ°Ô∏è</div>
        <div class="potion-count" id="potionShieldCount">2</div>
      </div>
      <div class="potion-slot" data-type="crit">
        <div class="potion-key">[3]</div>
        <div class="potion-icon">üí•</div>
        <div class="potion-count" id="potionCritCount">1</div>
      </div>
      <div class="potion-slot" data-type="damage">
        <div class="potion-key">[4]</div>
        <div class="potion-icon">‚öîÔ∏è</div>
        <div class="potion-count" id="potionDamageCount">1</div>
      </div>
      <div class="potion-slot" data-type="speed">
        <div class="potion-key">[5]</div>
        <div class="potion-icon">‚ö°</div>
        <div class="potion-count" id="potionSpeedCount">1</div>
      </div>
      <div class="potion-slot" data-type="dragon">
        <div class="potion-key">[6]</div>
        <div class="potion-icon">üêâ</div>
        <div class="potion-count" id="potionDragonCount">1</div>
      </div>
    </div>
    
    <!-- Ability Bar -->
    <div id="abilityBar">
      <div class="ability-slot" onclick="useAbility('ult1')">
        <div class="ability-key">[Q]</div>
        <div class="ability-icon" id="ability1">üèπ</div>
        <div class="ability-name" id="ability1Name">Ultimate 1</div>
      </div>
      <div class="ability-slot" onclick="useAbility('ult2')">
        <div class="ability-key">[E]</div>
        <div class="ability-icon" id="ability2">üéØ</div>
        <div class="ability-name" id="ability2Name">Ultimate 2</div>
      </div>
    </div>
  </div>

<script>
// ==================== GAME DATA ====================
const DEFAULT_GAME_DATA = {
  warriorName: "",
  selectedClass: "Hunter",
  totalCoins: 0,
  totalGems: 0,
  storyProgress: 0,
  completedNodes: [],
  unlockedNodes: ["start"],
  currentRegion: "beginner",
  keyShards: { crystal: false, abyss: false, frozen: false, blazing: false, tide: false },
  unlockedClasses: ["Hunter", "Knight", "Assassin"], // STARTERS: Hunter, Knight, Assassin
  purchasedClasses: [],
  highestWave: 1,
  permanentUpgrades: {
    damage: 0, health: 0, fireRate: 0, critChance: 0, coinMultiplier: 0, xpMultiplier: 0
  },
  potionUpgrades: {
    healStrength: 0, shieldStrength: 0, startingHeals: 0, startingShields: 0, potionGen: 0
  },
  potionInventory: {
    heal: 5, shield: 3, crit: 2, damage: 2, speed: 2, dragon: 1
  },
  cosmetics: {
    playerSkin: "default",
    attackEffect: "default",
    unlockedSkins: ["default"],
    unlockedEffects: ["default"]
  },
  redeemedCodes: [],
  settings: {
    musicVolume: 70,
    sfxVolume: 80,
    autoShoot: true,
    autoAim: true,
    screenShake: true,
    damageNumbers: true
  }
};

let gameData = JSON.parse(JSON.stringify(DEFAULT_GAME_DATA));

// ==================== CLASSES ====================
const CLASSES = {
  Hunter: {
    icon: "üèπ", color: "#00ff88", unlockWave: 0, purchasable: false,
    stats: { maxHP: 120, damage: 14, fireRate: 0.3, range: 650, projectileSpeed: 8 },
    description: "Balanced ranged fighter. The classic choice."
  },
  Knight: {
    icon: "‚öîÔ∏è", color: "#4488ff", unlockWave: 0, purchasable: false, // STARTER
    stats: { maxHP: 160, damage: 28, fireRate: 0.65, range: 260, projectileSpeed: 6.5 },
    description: "High HP tank with powerful melee strikes."
  },
  Assassin: {
    icon: "üó°Ô∏è", color: "#ff00ff", unlockWave: 0, purchasable: false, // STARTER
    stats: { maxHP: 95, damage: 9, fireRate: 0.15, range: 400, projectileSpeed: 9.5 },
    description: "Ultra-fast glass cannon. Speed kills!"
  },
  Archer: {
    icon: "üéØ", color: "#228b22", unlockWave: 15, purchasable: false,
    stats: { maxHP: 100, damage: 18, fireRate: 0.4, range: 950, projectileSpeed: 10, pierce: true },
    description: "Longest range with piercing shots."
  },
  Wizard: {
    icon: "üîÆ", color: "#8800ff", unlockWave: 25, purchasable: false,
    stats: { maxHP: 85, damage: 35, fireRate: 0.85, range: 550, projectileSpeed: 5.5, explosive: true },
    description: "Powerful explosive magic attacks."
  },
  Summoner: {
    icon: "‚ú®", color: "#88ff88", unlockWave: 35, purchasable: false,
    stats: { maxHP: 110, damage: 12, fireRate: 0.55, range: 450, projectileSpeed: 7 },
    description: "Summons spirit helpers to fight."
  },
  Bomber: {
    icon: "üí£", color: "#ff8800", unlockWave: 0, purchasable: true,
    cost: { coins: 5000, gems: 50 },
    stats: { maxHP: 130, damage: 20, fireRate: 0.75, range: 500, projectileSpeed: 6, explosive: true },
    description: "Every shot explodes! Area damage."
  },
  Sniper: {
    icon: "üî≠", color: "#00ffff", unlockWave: 0, purchasable: true,
    cost: { coins: 15000, gems: 150 },
    stats: { maxHP: 100, damage: 45, fireRate: 1.2, range: 900, projectileSpeed: 12, critBonus: 0.3 },
    description: "Extreme range, high crit chance."
  },
  Necromancer: {
    icon: "üíÄ", color: "#9933ff", unlockWave: 0, purchasable: true,
    cost: { coins: 25000, gems: 250 },
    stats: { maxHP: 105, damage: 15, fireRate: 0.45, range: 550, projectileSpeed: 7, poison: true },
    description: "Poisons enemies, raises minions."
  },
  Vecna: {
    icon: "üëÅÔ∏è", color: "#8B0000", unlockWave: 0, purchasable: true,
    cost: { coins: 1000000, gems: 1000 },
    stats: { maxHP: 150, damage: 25, fireRate: 0.5, range: 600, projectileSpeed: 8 },
    description: "Master of darkness. Ultimate power.",
    special: "monsters"
  }
};

// ==================== SKILL TREES (ULTIMATES) ====================
const SKILL_TREES = {
  Hunter: {
    ult1: { name: "Rapid Barrage", icon: "üèπ", desc: "Fire 8 shots in rapid succession", cooldown: 12, type: "active" },
    ult2: { name: "Hunters Mark", icon: "üéØ", desc: "Mark target for 200% damage for 5 sec", cooldown: 15, type: "active" }
  },
  Knight: {
    ult1: { name: "Shield Wall", icon: "üõ°Ô∏è", desc: "Block all damage for 4 seconds", cooldown: 18, type: "active" },
    ult2: { name: "Whirlwind", icon: "‚öîÔ∏è", desc: "Spin attack dealing 300% damage to nearby enemies", cooldown: 15, type: "active" }
  },
  Assassin: {
    ult1: { name: "Shadow Step", icon: "üë§", desc: "Teleport to enemy and deal 500% crit damage", cooldown: 10, type: "active" },
    ult2: { name: "Blade Dance", icon: "üó°Ô∏è", desc: "Throw 12 daggers in all directions", cooldown: 14, type: "active" }
  },
  Archer: {
    ult1: { name: "Rain of Arrows", icon: "üåßÔ∏è", desc: "Rain arrows on area dealing massive damage", cooldown: 20, type: "active" },
    ult2: { name: "Cupids Bow", icon: "üíï", desc: "Charm enemies to fight for you for 6 sec", cooldown: 25, type: "active" }
  },
  Wizard: {
    ult1: { name: "Meteor Shower", icon: "‚òÑÔ∏è", desc: "Call down meteors on all enemies", cooldown: 25, type: "active" },
    ult2: { name: "Time Freeze", icon: "‚è∞", desc: "Stop time for 4 seconds", cooldown: 30, type: "active" }
  },
  Summoner: {
    ult1: { name: "Army of Light", icon: "‚ú®", desc: "Summon 5 spirit warriors", cooldown: 20, type: "active" },
    ult2: { name: "Phoenix Rising", icon: "üî•", desc: "Revive with full HP when killed (once per battle)", cooldown: 60, type: "passive" }
  },
  Bomber: {
    ult1: { name: "Carpet Bomb", icon: "üí£", desc: "Drop 10 bombs across the field", cooldown: 18, type: "active" },
    ult2: { name: "Nuclear Option", icon: "‚ò¢Ô∏è", desc: "Massive explosion dealing 1000% damage", cooldown: 45, type: "active" }
  },
  Sniper: {
    ult1: { name: "Headshot", icon: "üéØ", desc: "Guaranteed crit dealing 500% damage", cooldown: 15, type: "active" },
    ult2: { name: "Piercing Round", icon: "üî≠", desc: "Shot pierces ALL enemies for 10 seconds", cooldown: 20, type: "active" }
  },
  Necromancer: {
    ult1: { name: "Army of Dead", icon: "üíÄ", desc: "Raise 5 skeleton warriors from killed enemies", cooldown: 22, type: "active" },
    ult2: { name: "Death Aura", icon: "‚ò†Ô∏è", desc: "Enemies near you take poison damage for 8 sec", cooldown: 20, type: "active" }
  },
  Vecna: {
    ult1: { name: "Hive Mind", icon: "üß†", desc: "Convert all enemies to fight for you for 8 sec", cooldown: 40, type: "active" },
    ult2: { name: "Upside Down", icon: "üåÄ", desc: "Teleport to shadow dimension - invincible for 6 sec", cooldown: 35, type: "active" }
  }
};

// ==================== BOSS PATTERNS ====================
const BOSS_PATTERNS = [
  { name: "Charger", color: "#ff0000", behavior: "charge", speedMult: 2.5, desc: "Charges at player rapidly" },
  { name: "Sniper", color: "#00ff00", behavior: "ranged", projectileSpeed: 12, desc: "Fires accurate long-range shots" },
  { name: "Tank", color: "#0088ff", behavior: "slow", hpMult: 3, damageMult: 2, desc: "Extremely durable" },
  { name: "Summoner", color: "#ff00ff", behavior: "summon", summonCount: 3, summonTimer: 5, desc: "Summons minions" },
  { name: "Berserker", color: "#ff8800", behavior: "berserk", rageThreshold: 0.3, desc: "Enrages at low HP" },
  { name: "Headless", color: "#880088", behavior: "headThrow", throwCooldown: 4, desc: "Throws head as projectile" }
];

// ==================== SHOP ITEMS ====================
const SHOP_UPGRADES = {
  damage: { name: "üí• Base Damage", desc: "+3 damage per level", maxLevel: 10, getBonus: l => l * 3, getCost: l => ({ coins: 100 + l * 50, gems: 0 }) },
  health: { name: "‚ù§Ô∏è Base Health", desc: "+15 HP per level", maxLevel: 10, getBonus: l => l * 15, getCost: l => ({ coins: 80 + l * 40, gems: 0 }) },
  fireRate: { name: "‚ö° Fire Rate", desc: "+5% attack speed", maxLevel: 5, getBonus: l => l * 0.05, getCost: l => ({ coins: 200 + l * 100, gems: l * 5 }) },
  critChance: { name: "üí¢ Crit Chance", desc: "+5% crit per level", maxLevel: 5, getBonus: l => l * 0.05, getCost: l => ({ coins: 300 + l * 150, gems: l * 8 }) },
  coinMultiplier: { name: "üí∞ Coin Bonus", desc: "+10% coins per level", maxLevel: 5, getBonus: l => l * 0.1, getCost: l => ({ coins: 500 + l * 250, gems: l * 10 }) },
  xpMultiplier: { name: "‚ú® XP Bonus", desc: "+10% XP per level", maxLevel: 5, getBonus: l => l * 0.1, getCost: l => ({ coins: 400 + l * 200, gems: l * 8 }) }
};

const SHOP_POTIONS = {
  healPack: { name: "‚ù§Ô∏è Heal Potion Pack", desc: "+5 heal potions", gives: { heal: 5 }, cost: { coins: 200, gems: 0 } },
  shieldPack: { name: "üõ°Ô∏è Shield Potion Pack", desc: "+3 shield potions", gives: { shield: 3 }, cost: { coins: 300, gems: 0 } },
  critPack: { name: "üí• Crit Potion Pack", desc: "+2 crit potions", gives: { crit: 2 }, cost: { coins: 500, gems: 5 } },
  damagePack: { name: "‚öîÔ∏è Damage Potion Pack", desc: "+2 damage potions", gives: { damage: 2 }, cost: { coins: 600, gems: 5 } },
  speedPack: { name: "‚ö° Speed Potion Pack", desc: "+2 speed potions", gives: { speed: 2 }, cost: { coins: 700, gems: 8 } },
  dragonPack: { name: "üêâ Dragon Potion", desc: "+1 dragon beam", gives: { dragon: 1 }, cost: { coins: 2000, gems: 20 } },
  megaPack: { name: "üéÅ Mega Potion Bundle", desc: "All potions +3!", gives: { heal: 3, shield: 3, crit: 3, damage: 3, speed: 3, dragon: 1 }, cost: { coins: 5000, gems: 50 } }
};

const SHOP_COSMETICS = {
  // Player Skins
  skinFire: { type: "skin", name: "üî• Fire Warrior", desc: "Flaming aura around player", id: "fire", cost: { coins: 3000, gems: 30 } },
  skinIce: { type: "skin", name: "‚ùÑÔ∏è Ice Warrior", desc: "Frozen crystal appearance", id: "ice", cost: { coins: 3000, gems: 30 } },
  skinShadow: { type: "skin", name: "üë§ Shadow Warrior", desc: "Dark mysterious form", id: "shadow", cost: { coins: 5000, gems: 50 } },
  skinGold: { type: "skin", name: "üëë Golden Warrior", desc: "Gleaming gold armor", id: "gold", cost: { coins: 10000, gems: 100 } },
  skinRainbow: { type: "skin", name: "üåà Rainbow Warrior", desc: "Color-shifting appearance", id: "rainbow", cost: { coins: 15000, gems: 150 } },
  skinVoid: { type: "skin", name: "üï≥Ô∏è Void Warrior", desc: "Darkness incarnate", id: "void", cost: { coins: 25000, gems: 250 } },
  
  // Attack Effects
  effectSpark: { type: "effect", name: "‚ö° Spark Shots", desc: "Electric projectiles", id: "spark", cost: { coins: 2000, gems: 20 } },
  effectFlame: { type: "effect", name: "üî• Flame Shots", desc: "Fiery projectiles", id: "flame", cost: { coins: 2000, gems: 20 } },
  effectPoison: { type: "effect", name: "‚ò†Ô∏è Poison Shots", desc: "Toxic green projectiles", id: "poison", cost: { coins: 3000, gems: 30 } },
  effectStar: { type: "effect", name: "‚≠ê Star Shots", desc: "Sparkling star projectiles", id: "star", cost: { coins: 5000, gems: 50 } },
  effectLaser: { type: "effect", name: "üí´ Laser Beam", desc: "Continuous laser attack", id: "laser", cost: { coins: 10000, gems: 100 } },
  effectDragon: { type: "effect", name: "üê≤ Dragon Breath", desc: "Dragon-shaped projectiles", id: "dragon", cost: { coins: 20000, gems: 200 } }
};

// ==================== REDEEM CODES ====================
const REDEEM_CODES = {
  "EVOLSTART": { coins: 500, gems: 10, message: "Welcome to EVOL LEGENDS!" },
  "LEGENDARY": { coins: 2000, gems: 50, message: "You're a true legend!" },
  "FORGOTTEN": { coins: 1000, gems: 25, classUnlock: "Necromancer", message: "The darkness welcomes you..." },
  "WARRIOR2025": { coins: 3000, gems: 100, message: "Happy 2025!" },
  "BOBBO": { coins: 777, gems: 77, skinUnlock: "rainbow", message: "Bobbo says hi! üîµ" },
  "STORMY": { coins: 888, gems: 88, effectUnlock: "flame", message: "Stormy brings fire! üî¥" },
  "FREEGEMS": { coins: 0, gems: 200, message: "Free gems for you!" },
  "POWERUP": { coins: 5000, gems: 0, message: "POWER OVERWHELMING!" }
};

// ==================== MAP NODES ====================
const MAP_NODES = [
  // Starter Village (6 nodes)
  { id: "start", name: "Village Gate", region: "beginner", type: "normal", x: 12, y: 75, waves: 5, difficulty: 1, rewards: { coins: 50 }, unlocks: ["forest1"], description: "The journey begins here..." },
  { id: "forest1", name: "Forest Path", region: "beginner", type: "normal", x: 18, y: 65, waves: 8, difficulty: 2, rewards: { coins: 80 }, unlocks: ["forest2", "cave1"], requiredNodes: ["start"] },
  { id: "forest2", name: "Deep Woods", region: "beginner", type: "elite", x: 25, y: 55, waves: 10, difficulty: 3, rewards: { coins: 150, gems: 5 }, unlocks: ["boss1"], requiredNodes: ["forest1"] },
  { id: "cave1", name: "Dark Cave", region: "beginner", type: "normal", x: 22, y: 78, waves: 8, difficulty: 2, rewards: { coins: 100 }, unlocks: ["boss1"], requiredNodes: ["forest1"] },
  { id: "shop1", name: "Merchant's Rest", region: "beginner", type: "shop", x: 28, y: 70, waves: 0, difficulty: 0, rewards: {}, unlocks: [], requiredNodes: ["forest1"] },
  { id: "boss1", name: "Shadow Beast Lair", region: "beginner", type: "boss", x: 35, y: 60, waves: 15, difficulty: 5, rewards: { coins: 500, gems: 25, classUnlock: "Archer" }, unlocks: ["crimson1"], requiredNodes: ["forest2", "cave1"], bossName: "Shadow Beast" },
  
  // Crimson Forest (8 nodes)
  { id: "crimson1", name: "Crimson Gate", region: "crimson", type: "normal", x: 42, y: 55, waves: 12, difficulty: 4, rewards: { coins: 200 }, unlocks: ["crimson2", "crimson3"], requiredNodes: ["boss1"] },
  { id: "crimson2", name: "Blood Grove", region: "crimson", type: "elite", x: 48, y: 45, waves: 15, difficulty: 5, rewards: { coins: 300, gems: 10 }, unlocks: ["shrine1"], requiredNodes: ["crimson1"] },
  { id: "crimson3", name: "Thorned Path", region: "crimson", type: "normal", x: 50, y: 65, waves: 12, difficulty: 4, rewards: { coins: 250 }, unlocks: ["crimson4"], requiredNodes: ["crimson1"] },
  { id: "shrine1", name: "Ancient Shrine", region: "crimson", type: "shrine", x: 55, y: 38, waves: 10, difficulty: 3, rewards: { gems: 20 }, unlocks: ["boss2"], requiredNodes: ["crimson2"] },
  { id: "crimson4", name: "Burning Clearing", region: "crimson", type: "elite", x: 58, y: 58, waves: 18, difficulty: 6, rewards: { coins: 400, gems: 15 }, unlocks: ["boss2"], requiredNodes: ["crimson3"] },
  { id: "shop2", name: "Forest Bazaar", region: "crimson", type: "shop", x: 52, y: 52, waves: 0, difficulty: 0, rewards: {}, unlocks: [], requiredNodes: ["crimson1"] },
  { id: "boss2", name: "Bloodwood Heart", region: "crimson", type: "boss", x: 65, y: 48, waves: 20, difficulty: 7, rewards: { coins: 1000, gems: 50, keyShard: "blazing" }, unlocks: ["crystal1"], requiredNodes: ["shrine1", "crimson4"], bossName: "Bloodwood Guardian" },
  
  // Crystal Caves (5 nodes)
  { id: "crystal1", name: "Crystal Entrance", region: "crystal", type: "normal", x: 72, y: 42, waves: 18, difficulty: 6, rewards: { coins: 350 }, unlocks: ["crystal2", "crystal3"], requiredNodes: ["boss2"] },
  { id: "crystal2", name: "Gem Caverns", region: "crystal", type: "elite", x: 78, y: 35, waves: 20, difficulty: 7, rewards: { coins: 500, gems: 30 }, unlocks: ["boss3"], requiredNodes: ["crystal1"] },
  { id: "crystal3", name: "Mirror Lake", region: "crystal", type: "shrine", x: 80, y: 50, waves: 15, difficulty: 5, rewards: { gems: 40, classUnlock: "Wizard" }, unlocks: ["boss3"], requiredNodes: ["crystal1"] },
  { id: "shop3", name: "Crystal Market", region: "crystal", type: "shop", x: 75, y: 55, waves: 0, difficulty: 0, rewards: {}, unlocks: [], requiredNodes: ["crystal1"] },
  { id: "boss3", name: "Crystal Core", region: "crystal", type: "boss", x: 88, y: 40, waves: 25, difficulty: 8, rewards: { coins: 2000, gems: 100, keyShard: "crystal" }, unlocks: ["final1"], requiredNodes: ["crystal2", "crystal3"], bossName: "Crystal Golem" },
  
  // Final Area - Forgotten City (4 nodes)
  { id: "final1", name: "Forgotten Gates", region: "forgotten", type: "locked", x: 45, y: 25, waves: 30, difficulty: 9, rewards: { coins: 3000, gems: 150 }, unlocks: ["final2"], requiredNodes: ["boss3"], requiredKeys: ["crystal", "blazing"] },
  { id: "final2", name: "Ruined Plaza", region: "forgotten", type: "elite", x: 52, y: 18, waves: 35, difficulty: 9, rewards: { coins: 4000, gems: 200 }, unlocks: ["finalboss"], requiredNodes: ["final1"] },
  { id: "finalboss", name: "Throne of Memories", region: "forgotten", type: "boss", x: 60, y: 12, waves: 50, difficulty: 10, rewards: { coins: 10000, gems: 500, classUnlock: "Vecna" }, unlocks: [], requiredNodes: ["final2"], bossName: "Memory Devourer" }
];

// ==================== UPGRADE TYPES (In-Game) ====================
const UPGRADE_TYPES = {
  damage: { icon: "‚öîÔ∏è", name: "Power Strike", desc: "+25% damage", apply: p => { p.damage *= 1.25; } },
  fireRate: { icon: "‚ö°", name: "Rapid Fire", desc: "+20% attack speed", apply: p => { p.fireRate *= 0.8; } },
  hp: { icon: "‚ù§Ô∏è", name: "Vitality", desc: "+30 Max HP & heal", apply: p => { p.maxHP += 30; p.hp = p.maxHP; } },
  range: { icon: "üéØ", name: "Extended Range", desc: "+30% range", apply: p => { p.range *= 1.3; } },
  speed: { icon: "üöÄ", name: "Bullet Speed", desc: "+30% projectile speed", apply: p => { p.projectileSpeed *= 1.3; } },
  multiShot: { icon: "üåü", name: "Multi-Shot", desc: "+2 projectiles", apply: p => { p.multiShot = (p.multiShot || 0) + 2; } },
  pierce: { icon: "üî±", name: "Piercing", desc: "Shots pierce enemies", apply: p => { p.pierce = true; } },
  lifesteal: { icon: "ü©∏", name: "Life Drain", desc: "Heal 15% of damage", apply: p => { p.lifesteal = (p.lifesteal || 0) + 0.15; } },
  explosive: { icon: "üí•", name: "Explosive", desc: "Shots explode", apply: p => { p.explosive = true; } },
  crit: { icon: "üí¢", name: "Critical", desc: "+20% crit chance", apply: p => { p.critChance = (p.critChance || 0) + 0.2; } },
  shield: { icon: "üõ°Ô∏è", name: "Shield", desc: "+50 shield", apply: p => { p.shield = (p.shield || 0) + 50; p.maxShield = (p.maxShield || 0) + 50; } },
  regen: { icon: "üíö", name: "Regeneration", desc: "+2 HP per second", apply: p => { p.regen = (p.regen || 0) + 2; } }
};

// ==================== GAME STATE ====================
let currentScreen = "title";
let gameMode = "story"; // "story" or "endless"
let selectedNode = null;
let selectedClass = "Hunter";

// Battle state
let player = null;
let enemies = [];
let projectiles = [];
let particles = [];
let floatingTexts = [];
let minions = [];
let fireZones = [];
let charmedEnemies = []; // Enemies fighting for player
let vecnaMonsters = []; // Vecna's special monsters

let wave = 1;
let maxWaves = 20;
let enemiesToSpawn = 0;
let spawnTimer = 0;
let shootTimer = 0;
let screenShake = 0;
let gameRunning = false;
let gamePaused = false;
let lastTime = 0;
let gameSpeed = 1;

let sessionCoins = 0;
let sessionGems = 0;
let enemiesKilled = 0;
let combo = 0;
let comboTimer = 0;
let maxCombo = 0;

// Ability state
let abilityCooldowns = { ult1: 0, ult2: 0 };
let abilityEffects = {
  huntersMark: null, // Target enemy for bonus damage
  shieldWall: false, shieldWallTimer: 0,
  timeFreezeActive: false, timeFreezeTimer: 0,
  piercingRoundActive: false, piercingRoundTimer: 0,
  deathAuraActive: false, deathAuraTimer: 0,
  hiveMindActive: false, hiveMindTimer: 0,
  upsideDownActive: false, upsideDownTimer: 0,
  phoenixReady: true // Phoenix Rising passive
};

let potions = { heal: 3, shield: 2, crit: 1, damage: 1, speed: 1, dragon: 1 };
let potionCooldowns = { heal: 0, shield: 0, crit: 0, damage: 0, speed: 0, dragon: 0 };
let potionEffects = { critActive: false, critTimer: 0, damageActive: false, damageTimer: 0, speedActive: false, speedTimer: 0 };

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const GROUND_Y = 580;

// ==================== SOUND SYSTEM ====================
const audioContext = new (window.AudioContext || window.webkitAudioContext)();
const soundEnabled = true;

function playSound(type) {
  if (!soundEnabled || !gameData?.settings?.sfxVolume) return;
  
  const volume = (gameData.settings.sfxVolume || 50) / 100;
  const oscillator = audioContext.createOscillator();
  const gainNode = audioContext.createGain();
  
  oscillator.connect(gainNode);
  gainNode.connect(audioContext.destination);
  
  switch (type) {
    case "shoot":
      oscillator.type = "square";
      oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.1);
      gainNode.gain.setValueAtTime(volume * 0.15, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
      oscillator.start();
      oscillator.stop(audioContext.currentTime + 0.1);
      break;
      
    case "hit":
      oscillator.type = "triangle";
      oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.08);
      gainNode.gain.setValueAtTime(volume * 0.2, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.08);
      oscillator.start();
      oscillator.stop(audioContext.currentTime + 0.08);
      break;
      
    case "kill":
      oscillator.type = "sawtooth";
      oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.2);
      gainNode.gain.setValueAtTime(volume * 0.25, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
      oscillator.start();
      oscillator.stop(audioContext.currentTime + 0.2);
      break;
      
    case "potion":
      oscillator.type = "sine";
      oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.15);
      gainNode.gain.setValueAtTime(volume * 0.2, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
      oscillator.start();
      oscillator.stop(audioContext.currentTime + 0.15);
      break;
      
    case "ability":
      oscillator.type = "sine";
      oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.25);
      gainNode.gain.setValueAtTime(volume * 0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.25);
      oscillator.start();
      oscillator.stop(audioContext.currentTime + 0.25);
      
      // Second tone for epic feel
      setTimeout(() => {
        const osc2 = audioContext.createOscillator();
        const gain2 = audioContext.createGain();
        osc2.connect(gain2);
        gain2.connect(audioContext.destination);
        osc2.type = "triangle";
        osc2.frequency.setValueAtTime(600, audioContext.currentTime);
        osc2.frequency.exponentialRampToValueAtTime(1500, audioContext.currentTime + 0.2);
        gain2.gain.setValueAtTime(volume * 0.2, audioContext.currentTime);
        gain2.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
        osc2.start();
        osc2.stop(audioContext.currentTime + 0.2);
      }, 100);
      break;
      
    case "wave":
      oscillator.type = "sine";
      oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(600, audioContext.currentTime + 0.1);
      oscillator.frequency.setValueAtTime(500, audioContext.currentTime + 0.1);
      oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.2);
      gainNode.gain.setValueAtTime(volume * 0.25, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
      oscillator.start();
      oscillator.stop(audioContext.currentTime + 0.3);
      break;
      
    case "levelUp":
      oscillator.type = "sine";
      oscillator.frequency.setValueAtTime(500, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(1000, audioContext.currentTime + 0.2);
      oscillator.frequency.setValueAtTime(800, audioContext.currentTime + 0.2);
      oscillator.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.4);
      gainNode.gain.setValueAtTime(volume * 0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
      oscillator.start();
      oscillator.stop(audioContext.currentTime + 0.4);
      break;
      
    case "victory":
      // Happy ascending notes
      const notes = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6
      notes.forEach((freq, i) => {
        setTimeout(() => {
          const osc = audioContext.createOscillator();
          const gain = audioContext.createGain();
          osc.connect(gain);
          gain.connect(audioContext.destination);
          osc.type = "sine";
          osc.frequency.setValueAtTime(freq, audioContext.currentTime);
          gain.gain.setValueAtTime(volume * 0.3, audioContext.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
          osc.start();
          osc.stop(audioContext.currentTime + 0.3);
        }, i * 150);
      });
      return;
      
    case "gameOver":
      oscillator.type = "sawtooth";
      oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(80, audioContext.currentTime + 0.8);
      gainNode.gain.setValueAtTime(volume * 0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.8);
      oscillator.start();
      oscillator.stop(audioContext.currentTime + 0.8);
      break;
      
    case "boss":
      oscillator.type = "sawtooth";
      oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(80, audioContext.currentTime + 0.3);
      gainNode.gain.setValueAtTime(volume * 0.35, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
      oscillator.start();
      oscillator.stop(audioContext.currentTime + 0.3);
      
      // Ominous second tone
      setTimeout(() => {
        const osc2 = audioContext.createOscillator();
        const gain2 = audioContext.createGain();
        osc2.connect(gain2);
        gain2.connect(audioContext.destination);
        osc2.type = "sine";
        osc2.frequency.setValueAtTime(100, audioContext.currentTime);
        gain2.gain.setValueAtTime(volume * 0.25, audioContext.currentTime);
        gain2.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
        osc2.start();
        osc2.stop(audioContext.currentTime + 0.5);
      }, 200);
      break;
      
    case "explosion":
      // White noise for explosion
      const bufferSize = audioContext.sampleRate * 0.2;
      const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
      const output = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        output[i] = Math.random() * 2 - 1;
      }
      const noise = audioContext.createBufferSource();
      noise.buffer = buffer;
      const noiseGain = audioContext.createGain();
      noise.connect(noiseGain);
      noiseGain.connect(audioContext.destination);
      noiseGain.gain.setValueAtTime(volume * 0.3, audioContext.currentTime);
      noiseGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
      noise.start();
      noise.stop(audioContext.currentTime + 0.2);
      return;
  }
}

// ==================== INITIALIZATION ====================
function init() {
  loadGameData();
  createStarfield();
  setupEventListeners();
  updateAllDisplays();
  
  // Start animation loop
  requestAnimationFrame(mainLoop);
}

function loadGameData() {
  const saved = localStorage.getItem("evolLegendsData");
  if (saved) {
    const parsed = JSON.parse(saved);
    gameData = { ...DEFAULT_GAME_DATA, ...parsed };
    // Ensure nested objects exist
    gameData.permanentUpgrades = { ...DEFAULT_GAME_DATA.permanentUpgrades, ...parsed.permanentUpgrades };
    gameData.potionUpgrades = { ...DEFAULT_GAME_DATA.potionUpgrades, ...parsed.potionUpgrades };
    gameData.potionInventory = { ...DEFAULT_GAME_DATA.potionInventory, ...parsed.potionInventory };
    gameData.cosmetics = { ...DEFAULT_GAME_DATA.cosmetics, ...parsed.cosmetics };
    gameData.settings = { ...DEFAULT_GAME_DATA.settings, ...parsed.settings };
    
    // Ensure starter classes are always unlocked
    if (!gameData.unlockedClasses.includes("Hunter")) gameData.unlockedClasses.push("Hunter");
    if (!gameData.unlockedClasses.includes("Knight")) gameData.unlockedClasses.push("Knight");
    if (!gameData.unlockedClasses.includes("Assassin")) gameData.unlockedClasses.push("Assassin");
  }
}

function saveGameData() {
  localStorage.setItem("evolLegendsData", JSON.stringify(gameData));
  updateAllDisplays();
}

function updateAllDisplays() {
  // Menu displays
  document.getElementById("menuCoins").textContent = gameData.totalCoins;
  document.getElementById("menuGems").textContent = gameData.totalGems;
  document.getElementById("menuHighWave").textContent = gameData.highestWave;
  document.getElementById("menuProgress").textContent = Math.floor(gameData.storyProgress);
  document.getElementById("menuWarriorName").textContent = gameData.warriorName || "Warrior";
  
  // Shop displays
  document.getElementById("shopCoins").textContent = gameData.totalCoins;
  document.getElementById("shopGems").textContent = gameData.totalGems;
  
  // Map displays
  document.getElementById("mapCoins").textContent = gameData.totalCoins;
  document.getElementById("mapGems").textContent = gameData.totalGems;
  document.getElementById("mapProgress").textContent = Math.floor(gameData.storyProgress);
  
  // Settings
  document.getElementById("musicVolume").value = gameData.settings.musicVolume;
  document.getElementById("sfxVolume").value = gameData.settings.sfxVolume;
  updateToggle("autoShootToggle", gameData.settings.autoShoot);
  updateToggle("autoAimToggle", gameData.settings.autoAim);
  updateToggle("screenShakeToggle", gameData.settings.screenShake);
  updateToggle("damageNumbersToggle", gameData.settings.damageNumbers);
}

function updateToggle(id, value) {
  const el = document.getElementById(id);
  if (el) {
    el.classList.toggle("on", value);
  }
}

function createStarfield() {
  const starfield = document.getElementById("starfield");
  for (let i = 0; i < 100; i++) {
    const star = document.createElement("div");
    star.className = "star";
    star.style.left = Math.random() * 100 + "%";
    star.style.top = Math.random() * 100 + "%";
    star.style.width = (Math.random() * 3 + 1) + "px";
    star.style.height = star.style.width;
    star.style.animationDelay = Math.random() * 2 + "s";
    starfield.appendChild(star);
  }
}

// ==================== EVENT LISTENERS ====================
function setupEventListeners() {
  // Title screen - click OR key
  const titleScreen = document.getElementById("titleScreen");
  titleScreen.addEventListener("click", goToNameEntry);
  document.addEventListener("keydown", function titleKeyHandler(e) {
    if (currentScreen === "title") {
      goToNameEntry();
    }
  });
  
  // Name entry
  document.getElementById("nameConfirmBtn").addEventListener("click", confirmName);
  document.getElementById("warriorNameInput").addEventListener("keypress", (e) => {
    if (e.key === "Enter") confirmName();
  });
  
  // Main menu buttons
  document.getElementById("storyModeBtn").addEventListener("click", () => startMode("story"));
  document.getElementById("endlessModeBtn").addEventListener("click", () => startMode("endless"));
  document.getElementById("shopBtn").addEventListener("click", showShop);
  document.getElementById("settingsBtn").addEventListener("click", showSettings);
  document.getElementById("redeemBtn").addEventListener("click", showRedeem);
  
  // Back buttons
  document.getElementById("mapBackBtn").addEventListener("click", () => showScreen("mainMenu"));
  document.getElementById("classBackBtn").addEventListener("click", handleClassBack);
  document.getElementById("shopBackBtn").addEventListener("click", () => showScreen("mainMenu"));
  document.getElementById("settingsBackBtn").addEventListener("click", () => showScreen("mainMenu"));
  document.getElementById("redeemBackBtn").addEventListener("click", () => showScreen("mainMenu"));
  
  // Level modal
  document.getElementById("enterLevelBtn").addEventListener("click", enterLevel);
  document.getElementById("cancelLevelBtn").addEventListener("click", () => {
    document.getElementById("levelModal").classList.remove("active");
  });
  
  // Shop tabs
  document.querySelectorAll(".shop-tab").forEach(tab => {
    tab.addEventListener("click", () => {
      document.querySelectorAll(".shop-tab").forEach(t => t.classList.remove("active"));
      tab.classList.add("active");
      renderShopTab(tab.dataset.tab);
    });
  });
  
  // Settings toggles
  document.querySelectorAll(".setting-toggle").forEach(toggle => {
    toggle.addEventListener("click", () => {
      toggle.classList.toggle("on");
      const settingId = toggle.id.replace("Toggle", "");
      const settingMap = {
        autoShoot: "autoShoot",
        autoAim: "autoAim",
        screenShake: "screenShake",
        damageNumbers: "damageNumbers"
      };
      if (settingMap[settingId]) {
        gameData.settings[settingMap[settingId]] = toggle.classList.contains("on");
        saveGameData();
      }
    });
  });
  
  // Volume sliders
  document.getElementById("musicVolume").addEventListener("input", (e) => {
    gameData.settings.musicVolume = parseInt(e.target.value);
    saveGameData();
  });
  document.getElementById("sfxVolume").addEventListener("input", (e) => {
    gameData.settings.sfxVolume = parseInt(e.target.value);
    saveGameData();
  });
  
  // Reset data
  document.getElementById("resetDataBtn").addEventListener("click", () => {
    if (confirm("Are you sure you want to reset ALL data? This cannot be undone!")) {
      localStorage.removeItem("evolLegendsData");
      gameData = JSON.parse(JSON.stringify(DEFAULT_GAME_DATA));
      saveGameData();
      showScreen("title");
      alert("All data has been reset!");
    }
  });
  
  // Redeem code
  document.getElementById("redeemSubmitBtn").addEventListener("click", redeemCode);
  document.getElementById("redeemInput").addEventListener("keypress", (e) => {
    if (e.key === "Enter") redeemCode();
  });
  
  // Pause menu
  document.getElementById("resumeBtn").addEventListener("click", resumeGame);
  document.getElementById("restartBtn").addEventListener("click", restartGame);
  document.getElementById("quitBtn").addEventListener("click", quitToMenu);
  
  // Game over / Victory
  document.getElementById("gameOverContinueBtn").addEventListener("click", returnToMenu);
  document.getElementById("victoryContinueBtn").addEventListener("click", handleVictoryContinue);
  
  // Potion slots
  document.querySelectorAll(".potion-slot").forEach(slot => {
    slot.addEventListener("click", () => usePotion(slot.dataset.type));
  });
  
  // Keyboard controls
  document.addEventListener("keydown", handleKeyDown);
}

// ==================== SCREEN MANAGEMENT ====================
function showScreen(screenId) {
  // Hide all screens
  document.getElementById("titleScreen").classList.add("hidden");
  document.getElementById("nameScreen").classList.remove("active");
  document.getElementById("mainMenu").classList.remove("active");
  document.getElementById("overworldMap").classList.remove("active");
  document.getElementById("classSelection").classList.remove("active");
  document.getElementById("shopScreen").classList.remove("active");
  document.getElementById("settingsScreen").classList.remove("active");
  document.getElementById("redeemScreen").classList.remove("active");
  document.getElementById("gameScreen").classList.remove("active");
  document.getElementById("levelModal").classList.remove("active");
  document.getElementById("pauseMenu").classList.remove("active");
  document.getElementById("upgradeScreen").classList.remove("active");
  document.getElementById("gameOverScreen").classList.remove("active");
  document.getElementById("victoryScreen").classList.remove("active");
  document.getElementById("potionBar").classList.remove("active");
  
  // Show requested screen
  const screen = document.getElementById(screenId);
  if (screen) {
    if (screenId === "titleScreen") {
      screen.classList.remove("hidden");
    } else {
      screen.classList.add("active");
    }
  }
  
  currentScreen = screenId;
}

function goToNameEntry() {
  if (gameData.warriorName) {
    // Already has a name, go to menu
    showScreen("mainMenu");
  } else {
    showScreen("nameScreen");
  }
}

function confirmName() {
  const name = document.getElementById("warriorNameInput").value.trim();
  if (name.length < 1) {
    alert("Please enter a name!");
    return;
  }
  gameData.warriorName = name;
  saveGameData();
  showScreen("mainMenu");
}

function startMode(mode) {
  gameMode = mode;
  if (mode === "story") {
    showOverworldMap();
  } else {
    // Endless mode - go directly to class selection
    document.getElementById("classSubtitle").textContent = "Choose your class for Endless Mode!";
    showClassSelection();
  }
}

function showOverworldMap() {
  showScreen("overworldMap");
  renderMapNodes();
}

function showClassSelection() {
  showScreen("classSelection");
  renderClassCards();
}

function handleClassBack() {
  if (gameMode === "story") {
    showOverworldMap();
  } else {
    showScreen("mainMenu");
  }
}

function showShop() {
  showScreen("shopScreen");
  renderShopTab("upgrades");
}

function showSettings() {
  showScreen("settingsScreen");
}

function showRedeem() {
  showScreen("redeemScreen");
  document.getElementById("redeemInput").value = "";
  document.getElementById("redeemMessage").textContent = "";
}

// ==================== MAP RENDERING ====================
function renderMapNodes() {
  const container = document.getElementById("mapNodes");
  container.innerHTML = "";
  
  MAP_NODES.forEach(node => {
    const div = document.createElement("div");
    div.className = "map-node";
    
    // Determine node state
    let state = "locked";
    if (gameData.completedNodes.includes(node.id)) {
      state = "completed";
    } else if (gameData.unlockedNodes.includes(node.id)) {
      // Check if keys are required
      if (node.requiredKeys) {
        const hasAllKeys = node.requiredKeys.every(key => gameData.keyShards[key]);
        state = hasAllKeys ? "unlocked" : "locked";
      } else {
        state = "unlocked";
      }
    }
    
    div.classList.add(state);
    if (node.type === "boss") div.classList.add("boss");
    
    // Position
    div.style.left = node.x + "%";
    div.style.top = node.y + "%";
    
    // Icon
    const icons = {
      normal: "‚öîÔ∏è",
      elite: "‚≠ê",
      boss: "üëë",
      shop: "üõí",
      shrine: "üèõÔ∏è",
      locked: "üîí"
    };
    div.textContent = state === "completed" ? "‚úÖ" : icons[node.type] || "‚öîÔ∏è";
    
    // Click handler
    if (state === "unlocked") {
      div.addEventListener("click", () => selectNode(node));
    }
    
    // Tooltip on hover
    div.title = `${node.name} (${state})`;
    
    container.appendChild(div);
  });
}

function selectNode(node) {
  selectedNode = node;
  
  document.getElementById("levelName").textContent = node.name;
  document.getElementById("levelDesc").textContent = node.description || "A challenging area awaits...";
  document.getElementById("levelDifficulty").textContent = node.difficulty;
  
  let rewardText = "";
  if (node.rewards.coins) rewardText += node.rewards.coins + " coins";
  if (node.rewards.gems) rewardText += (rewardText ? ", " : "") + node.rewards.gems + " gems";
  if (node.rewards.classUnlock) rewardText += (rewardText ? ", " : "") + "Unlock: " + node.rewards.classUnlock;
  document.getElementById("levelRewards").textContent = rewardText || "Experience";
  
  document.getElementById("levelModal").classList.add("active");
}

function enterLevel() {
  document.getElementById("levelModal").classList.remove("active");
  maxWaves = selectedNode.waves || 20;
  document.getElementById("classSubtitle").textContent = `Select class for: ${selectedNode.name}`;
  showClassSelection();
}

// ==================== CLASS SELECTION ====================
function renderClassCards() {
  const grid = document.getElementById("classGrid");
  grid.innerHTML = "";
  
  Object.entries(CLASSES).forEach(([name, cls]) => {
    const card = document.createElement("div");
    card.className = "class-card";
    
    // Check if unlocked
    const isUnlocked = gameData.unlockedClasses.includes(name) || 
                       gameData.purchasedClasses.includes(name);
    
    if (!isUnlocked) {
      card.classList.add("locked");
    }
    
    card.innerHTML = `
      <div class="class-icon">${cls.icon}</div>
      <div class="class-name" style="color: ${cls.color}">${name}</div>
      <div class="class-stats">
        HP: ${cls.stats.maxHP} | DMG: ${cls.stats.damage}<br>
        ${cls.description}
      </div>
      ${!isUnlocked ? `<div class="class-unlock">${cls.purchasable ? 'Available in Shop' : 'Wave ' + cls.unlockWave}</div>` : ''}
    `;
    
    if (isUnlocked) {
      card.addEventListener("click", () => selectClass(name));
    }
    
    grid.appendChild(card);
  });
}

function selectClass(className) {
  selectedClass = className;
  gameData.selectedClass = className;
  saveGameData();
  startBattle();
}

// ==================== SHOP ====================
function renderShopTab(tab) {
  const grid = document.getElementById("shopGrid");
  grid.innerHTML = "";
  
  if (tab === "upgrades") {
    Object.entries(SHOP_UPGRADES).forEach(([key, upgrade]) => {
      const level = gameData.permanentUpgrades[key] || 0;
      const isMaxed = level >= upgrade.maxLevel;
      const cost = isMaxed ? null : upgrade.getCost(level);
      
      const item = document.createElement("div");
      item.className = "shop-item" + (isMaxed ? " maxed" : "");
      item.innerHTML = `
        <div class="shop-item-name">${upgrade.name}</div>
        <div class="shop-item-desc">${upgrade.desc}</div>
        <div style="color: #00ff00; font-size: 11px; margin-bottom: 5px;">Level: ${level}/${upgrade.maxLevel}</div>
        <div class="shop-item-cost">${isMaxed ? "‚úÖ MAXED" : `üí∞ ${cost.coins}${cost.gems > 0 ? " | üíé " + cost.gems : ""}`}</div>
      `;
      
      if (!isMaxed) {
        item.addEventListener("click", () => purchaseUpgrade(key));
      }
      
      grid.appendChild(item);
    });
  } else if (tab === "potions") {
    Object.entries(SHOP_POTIONS).forEach(([key, potion]) => {
      const item = document.createElement("div");
      item.className = "shop-item";
      item.innerHTML = `
        <div class="shop-item-name">${potion.name}</div>
        <div class="shop-item-desc">${potion.desc}</div>
        <div class="shop-item-cost">üí∞ ${potion.cost.coins}${potion.cost.gems > 0 ? " | üíé " + potion.cost.gems : ""}</div>
      `;
      item.addEventListener("click", () => purchasePotion(key));
      grid.appendChild(item);
    });
  } else if (tab === "classes") {
    Object.entries(CLASSES).forEach(([name, cls]) => {
      if (!cls.purchasable) return;
      
      const isPurchased = gameData.purchasedClasses.includes(name);
      const item = document.createElement("div");
      item.className = "shop-item" + (isPurchased ? " maxed" : "");
      item.innerHTML = `
        <div class="shop-item-name">${cls.icon} ${name}</div>
        <div class="shop-item-desc">${cls.description}</div>
        <div class="shop-item-cost">${isPurchased ? "‚úÖ OWNED" : `üí∞ ${cls.cost.coins} | üíé ${cls.cost.gems}`}</div>
      `;
      
      if (!isPurchased) {
        item.addEventListener("click", () => purchaseClass(name));
      }
      
      grid.appendChild(item);
    });
  } else if (tab === "cosmetics") {
    Object.entries(SHOP_COSMETICS).forEach(([key, cosmetic]) => {
      const isOwned = cosmetic.type === "skin" 
        ? gameData.cosmetics.unlockedSkins.includes(cosmetic.id)
        : gameData.cosmetics.unlockedEffects.includes(cosmetic.id);
      
      const isEquipped = cosmetic.type === "skin"
        ? gameData.cosmetics.playerSkin === cosmetic.id
        : gameData.cosmetics.attackEffect === cosmetic.id;
      
      const item = document.createElement("div");
      item.className = "shop-item" + (isEquipped ? " maxed" : "");
      item.innerHTML = `
        <div class="shop-item-name">${cosmetic.name}</div>
        <div class="shop-item-desc">${cosmetic.desc}</div>
        <div class="shop-item-cost">${isOwned ? (isEquipped ? "‚úÖ EQUIPPED" : "üëÜ CLICK TO EQUIP") : `üí∞ ${cosmetic.cost.coins} | üíé ${cosmetic.cost.gems}`}</div>
      `;
      
      item.addEventListener("click", () => {
        if (isOwned) {
          equipCosmetic(cosmetic);
        } else {
          purchaseCosmetic(key, cosmetic);
        }
      });
      
      grid.appendChild(item);
    });
  }
}

function purchaseUpgrade(key) {
  const upgrade = SHOP_UPGRADES[key];
  const level = gameData.permanentUpgrades[key] || 0;
  if (level >= upgrade.maxLevel) return;
  
  const cost = upgrade.getCost(level);
  if (gameData.totalCoins >= cost.coins && gameData.totalGems >= cost.gems) {
    gameData.totalCoins -= cost.coins;
    gameData.totalGems -= cost.gems;
    gameData.permanentUpgrades[key] = level + 1;
    saveGameData();
    renderShopTab("upgrades");
    alert(`‚úÖ Upgraded ${upgrade.name} to level ${level + 1}!`);
  } else {
    alert("‚ùå Not enough currency!");
  }
}

function purchasePotion(key) {
  const potion = SHOP_POTIONS[key];
  if (gameData.totalCoins >= potion.cost.coins && gameData.totalGems >= potion.cost.gems) {
    gameData.totalCoins -= potion.cost.coins;
    gameData.totalGems -= potion.cost.gems;
    
    Object.entries(potion.gives).forEach(([type, amount]) => {
      gameData.potionInventory[type] = (gameData.potionInventory[type] || 0) + amount;
    });
    
    saveGameData();
    alert(`‚úÖ Purchased ${potion.name}!`);
  } else {
    alert("‚ùå Not enough currency!");
  }
}

function purchaseClass(name) {
  const cls = CLASSES[name];
  if (gameData.totalCoins >= cls.cost.coins && gameData.totalGems >= cls.cost.gems) {
    gameData.totalCoins -= cls.cost.coins;
    gameData.totalGems -= cls.cost.gems;
    gameData.purchasedClasses.push(name);
    gameData.unlockedClasses.push(name);
    saveGameData();
    renderShopTab("classes");
    alert(`‚úÖ Unlocked ${name}!`);
  } else {
    alert("‚ùå Not enough currency!");
  }
}

function purchaseCosmetic(key, cosmetic) {
  if (gameData.totalCoins >= cosmetic.cost.coins && gameData.totalGems >= cosmetic.cost.gems) {
    gameData.totalCoins -= cosmetic.cost.coins;
    gameData.totalGems -= cosmetic.cost.gems;
    
    if (cosmetic.type === "skin") {
      gameData.cosmetics.unlockedSkins.push(cosmetic.id);
      gameData.cosmetics.playerSkin = cosmetic.id;
    } else {
      gameData.cosmetics.unlockedEffects.push(cosmetic.id);
      gameData.cosmetics.attackEffect = cosmetic.id;
    }
    
    saveGameData();
    renderShopTab("cosmetics");
    alert(`‚úÖ Purchased and equipped ${cosmetic.name}!`);
  } else {
    alert("‚ùå Not enough currency!");
  }
}

function equipCosmetic(cosmetic) {
  if (cosmetic.type === "skin") {
    gameData.cosmetics.playerSkin = cosmetic.id;
  } else {
    gameData.cosmetics.attackEffect = cosmetic.id;
  }
  saveGameData();
  renderShopTab("cosmetics");
}

// ==================== REDEEM CODES ====================
function redeemCode() {
  const input = document.getElementById("redeemInput");
  const message = document.getElementById("redeemMessage");
  const code = input.value.trim().toUpperCase();
  
  if (!code) {
    message.textContent = "‚ùå Please enter a code!";
    message.style.color = "#ff0000";
    return;
  }
  
  if (gameData.redeemedCodes.includes(code)) {
    message.textContent = "‚ùå Code already redeemed!";
    message.style.color = "#ff0000";
    return;
  }
  
  const reward = REDEEM_CODES[code];
  if (!reward) {
    message.textContent = "‚ùå Invalid code!";
    message.style.color = "#ff0000";
    return;
  }
  
  // Apply rewards
  gameData.totalCoins += reward.coins || 0;
  gameData.totalGems += reward.gems || 0;
  
  if (reward.classUnlock && !gameData.unlockedClasses.includes(reward.classUnlock)) {
    gameData.unlockedClasses.push(reward.classUnlock);
  }
  
  if (reward.skinUnlock && !gameData.cosmetics.unlockedSkins.includes(reward.skinUnlock)) {
    gameData.cosmetics.unlockedSkins.push(reward.skinUnlock);
  }
  
  if (reward.effectUnlock && !gameData.cosmetics.unlockedEffects.includes(reward.effectUnlock)) {
    gameData.cosmetics.unlockedEffects.push(reward.effectUnlock);
  }
  
  gameData.redeemedCodes.push(code);
  saveGameData();
  
  let rewardText = reward.message + "\n";
  if (reward.coins) rewardText += `+${reward.coins} coins `;
  if (reward.gems) rewardText += `+${reward.gems} gems `;
  if (reward.classUnlock) rewardText += `Unlocked: ${reward.classUnlock}!`;
  
  message.textContent = "‚úÖ " + rewardText;
  message.style.color = "#00ff00";
  input.value = "";
}

// ==================== BATTLE SYSTEM ====================
function startBattle() {
  showScreen("gameScreen");
  document.getElementById("potionBar").classList.add("active");
  document.getElementById("abilityBar").classList.add("active");
  
  initializePlayer();
  initializePotions();
  initializeAbilities();
  
  enemies = [];
  projectiles = [];
  particles = [];
  floatingTexts = [];
  minions = [];
  fireZones = [];
  charmedEnemies = [];
  vecnaMonsters = [];
  
  wave = 1;
  enemiesToSpawn = calcEnemiesForWave(wave);
  spawnTimer = 0;
  shootTimer = 0;
  screenShake = 0;
  
  sessionCoins = 0;
  sessionGems = 0;
  enemiesKilled = 0;
  combo = 0;
  maxCombo = 0;
  
  gameRunning = true;
  gamePaused = false;
  lastTime = performance.now();
}

function initializeAbilities() {
  abilityCooldowns = { ult1: 0, ult2: 0 };
  abilityEffects = {
    huntersMark: null,
    shieldWall: false, shieldWallTimer: 0,
    timeFreezeActive: false, timeFreezeTimer: 0,
    piercingRoundActive: false, piercingRoundTimer: 0,
    deathAuraActive: false, deathAuraTimer: 0,
    hiveMindActive: false, hiveMindTimer: 0,
    upsideDownActive: false, upsideDownTimer: 0,
    phoenixReady: true
  };
  
  // Update ability bar with class-specific abilities
  const skillTree = SKILL_TREES[selectedClass];
  if (skillTree) {
    const ult1El = document.getElementById("ability1");
    const ult2El = document.getElementById("ability2");
    const name1El = document.getElementById("ability1Name");
    const name2El = document.getElementById("ability2Name");
    
    if (ult1El && skillTree.ult1) {
      ult1El.textContent = skillTree.ult1.icon;
      if (name1El) name1El.textContent = skillTree.ult1.name;
    }
    if (ult2El && skillTree.ult2) {
      ult2El.textContent = skillTree.ult2.icon;
      if (name2El) name2El.textContent = skillTree.ult2.name;
    }
  }
}

function initializePlayer() {
  const cls = CLASSES[selectedClass];
  const upgrades = gameData.permanentUpgrades;
  
  player = {
    x: 100,
    y: GROUND_Y - 44,
    w: 36,
    h: 44,
    maxHP: cls.stats.maxHP + (upgrades.health * 15),
    hp: cls.stats.maxHP + (upgrades.health * 15),
    damage: cls.stats.damage + (upgrades.damage * 3),
    fireRate: cls.stats.fireRate * (1 - upgrades.fireRate * 0.05),
    range: cls.stats.range,
    projectileSpeed: cls.stats.projectileSpeed,
    color: cls.color,
    icon: cls.icon,
    
    level: 1,
    xp: 0,
    xpToNext: 100,
    
    critChance: (upgrades.critChance * 0.05) + (cls.stats.critBonus || 0),
    critMultiplier: 2.0,
    multiShot: 0,
    pierce: cls.stats.pierce || false,
    explosive: cls.stats.explosive || false,
    lifesteal: 0,
    shield: 0,
    maxShield: 0,
    regen: 0,
    poison: cls.stats.poison || false,
    
    alive: true,
    invincible: false
  };
}

function initializePotions() {
  potions = {
    heal: Math.min(gameData.potionInventory.heal, 5),
    shield: Math.min(gameData.potionInventory.shield, 3),
    crit: Math.min(gameData.potionInventory.crit, 2),
    damage: Math.min(gameData.potionInventory.damage, 2),
    speed: Math.min(gameData.potionInventory.speed, 2),
    dragon: Math.min(gameData.potionInventory.dragon, 1)
  };
  
  potionCooldowns = { heal: 0, shield: 0, crit: 0, damage: 0, speed: 0, dragon: 0 };
  potionEffects = { critActive: false, critTimer: 0, damageActive: false, damageTimer: 0, speedActive: false, speedTimer: 0 };
  
  updatePotionDisplay();
}

function updatePotionDisplay() {
  document.getElementById("potionHealCount").textContent = potions.heal;
  document.getElementById("potionShieldCount").textContent = potions.shield;
  document.getElementById("potionCritCount").textContent = potions.crit;
  document.getElementById("potionDamageCount").textContent = potions.damage;
  document.getElementById("potionSpeedCount").textContent = potions.speed;
  document.getElementById("potionDragonCount").textContent = potions.dragon;
}

function calcEnemiesForWave(w) {
  return 5 + w * 2 + Math.floor(w / 5) * 3;
}

function getEnemyHP(w, isBoss = false, isMiniBoss = false) {
  let hp = 50 + w * 15 + Math.pow(w, 1.5) * 2;
  if (isBoss) hp *= 10;
  else if (isMiniBoss) hp *= 4;
  return Math.floor(hp);
}

// ==================== GAME LOOP ====================
function mainLoop(timestamp) {
  const dt = Math.min((timestamp - lastTime) / 1000, 0.1) * gameSpeed;
  lastTime = timestamp;
  
  if (gameRunning && !gamePaused && currentScreen === "gameScreen") {
    update(dt);
  }
  
  if (currentScreen === "gameScreen") {
    draw();
  }
  
  requestAnimationFrame(mainLoop);
}

function update(dt) {
  if (!player || !player.alive) return;
  
  // Shooting
  handleShooting(dt);
  
  // Spawning
  handleSpawning(dt);
  
  // Update entities
  updateProjectiles(dt);
  updateEnemies(dt);
  updateParticles(dt);
  updateFloatingTexts(dt);
  updatePotionEffects(dt);
  updateFireZones(dt);
  updateAbilityEffects(dt);
  
  // Regeneration
  if (player.regen > 0) {
    player.hp = Math.min(player.hp + player.regen * dt, player.maxHP);
  }
  
  // Screen shake decay
  if (gameData.settings.screenShake) {
    screenShake *= 0.9;
    if (screenShake < 0.1) screenShake = 0;
  } else {
    screenShake = 0;
  }
  
  // Combo decay
  if (combo > 0) {
    comboTimer -= dt;
    if (comboTimer <= 0) combo = 0;
  }
  
  // Check wave completion
  if (enemiesToSpawn === 0 && enemies.length === 0) {
    if (gameMode === "endless" || wave < maxWaves) {
      nextWave();
    } else {
      victory();
    }
  }
}

function handleShooting(dt) {
  if (!gameData.settings.autoShoot) return;
  
  shootTimer += dt;
  const target = getTargetEnemy();
  
  if (target && shootTimer >= player.fireRate) {
    shootTimer = 0;
    shootProjectile(target);
    
    if (player.multiShot > 0) {
      for (let i = 0; i < player.multiShot; i++) {
        setTimeout(() => {
          const t = getTargetEnemy();
          if (t) shootProjectile(t);
        }, (i + 1) * 50);
      }
    }
  }
}

function getTargetEnemy() {
  if (enemies.length === 0) return null;
  
  let closest = null;
  let closestDist = player.range;
  
  for (const e of enemies) {
    const dx = (e.x + e.w / 2) - (player.x + player.w / 2);
    const dy = (e.y + e.h / 2) - (player.y + player.h / 2);
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    if (dist < closestDist) {
      closestDist = dist;
      closest = e;
    }
  }
  
  return closest;
}

function shootProjectile(target) {
  const px = player.x + player.w / 2;
  const py = player.y + player.h / 2;
  const tx = target.x + target.w / 2;
  const ty = target.y + target.h / 2;
  
  let dx = tx - px;
  let dy = ty - py;
  const dist = Math.sqrt(dx * dx + dy * dy) || 1;
  dx /= dist;
  dy /= dist;
  
  const isCrit = Math.random() < player.critChance;
  
  // Sound
  playSound("shoot");
  
  // Get projectile color based on cosmetic
  let projColor = player.color;
  const effect = gameData.cosmetics.attackEffect;
  if (effect === "spark") projColor = "#00ffff";
  else if (effect === "flame") projColor = "#ff4400";
  else if (effect === "poison") projColor = "#00ff00";
  else if (effect === "star") projColor = "#ffff00";
  else if (effect === "laser") projColor = "#ff00ff";
  else if (effect === "dragon") projColor = "#ff8800";
  
  projectiles.push({
    x: px, y: py,
    vx: dx * player.projectileSpeed,
    vy: dy * player.projectileSpeed,
    radius: 5,
    damage: player.damage,
    color: isCrit ? "#ff0000" : projColor,
    life: 3.5,
    trail: [],
    pierce: player.pierce,
    pierceCount: 0,
    explosive: player.explosive,
    isCrit: isCrit,
    critMultiplier: player.critMultiplier,
    poison: player.poison,
    isEnemyProjectile: false
  });
}

function handleSpawning(dt) {
  if (enemiesToSpawn <= 0) return;
  
  spawnTimer += dt;
  const spawnInterval = Math.max(2.0 - wave * 0.05, 0.3);
  
  if (spawnTimer >= spawnInterval) {
    spawnTimer = 0;
    enemiesToSpawn--;
    
    const isBoss = wave % 10 === 0 && enemiesToSpawn === calcEnemiesForWave(wave) - 1;
    const isMiniBoss = wave % 5 === 0 && !isBoss && enemiesToSpawn === calcEnemiesForWave(wave) - 1;
    
    spawnEnemy(isBoss, isMiniBoss);
  }
}

function spawnEnemy(isBoss = false, isMiniBoss = false) {
  let size, hp, speed, color, type;
  
  if (isBoss) {
    size = 80;
    hp = getEnemyHP(wave, true, false);
    speed = 0.8;
    color = "#ff00ff";
    type = "boss";
  } else if (isMiniBoss) {
    size = 55;
    hp = getEnemyHP(wave, false, true);
    speed = 1.2;
    color = "#ff8800";
    type = "miniboss";
  } else {
    size = 32 + Math.random() * 16;
    hp = getEnemyHP(wave);
    speed = 1.2 + wave * 0.03 + Math.random() * 0.4;
    
    const rand = Math.random();
    if (rand < 0.15) {
      color = "#ffff00"; type = "speedy"; speed *= 2; hp *= 0.5;
    } else if (rand < 0.3) {
      color = "#00ff88"; type = "healer"; speed *= 0.6; hp *= 1.5;
    } else if (rand < 0.45) {
      color = "#ff8800"; type = "kamikaze"; speed *= 2.5; hp *= 0.3;
    } else if (rand < 0.6) {
      color = "#ff4444"; type = "shooter"; speed *= 0.7;
    } else {
      color = "#ff4444"; type = "grunt";
    }
  }
  
  enemies.push({
    x: canvas.width + 30,
    y: GROUND_Y - size,
    w: size,
    h: size,
    maxHP: hp,
    hp: hp,
    vx: -speed,
    color: color,
    type: type,
    isBoss: isBoss,
    isMiniBoss: isMiniBoss,
    damage: 20 + wave * 2,
    shootTimer: 0,
    attackTimer: 0,
    poisonTimer: 0,
    poisonDamage: 0
  });
}

function updateEnemies(dt) {
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    
    // Poison damage
    if (e.poisonTimer > 0) {
      e.poisonTimer -= dt;
      e.hp -= e.poisonDamage * dt;
    }
    
    // Movement
    e.x += e.vx;
    
    // Shooter behavior
    if (e.type === "shooter" && player.alive) {
      e.shootTimer += dt;
      if (e.shootTimer >= 2.5 && e.x < canvas.width - 100) {
        e.shootTimer = 0;
        shootEnemyProjectile(e);
      }
    }
    
    // Kamikaze explosion
    if (e.type === "kamikaze" && e.x + e.w < player.x + player.w + 20) {
      damagePlayer(e.damage * 2);
      spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, "#ff8800", 20);
      screenShake += 15;
      enemies.splice(i, 1);
      continue;
    }
    
    // Collision with player
    if (player.alive && !player.invincible &&
        e.x < player.x + player.w &&
        e.x + e.w > player.x &&
        e.y < player.y + player.h &&
        e.y + e.h > player.y) {
      
      e.attackTimer += dt;
      if (e.attackTimer >= 1) {
        e.attackTimer = 0;
        damagePlayer(e.damage);
        e.x += 50; // Push back
      }
    }
    
    // Death check
    if (e.hp <= 0) {
      onEnemyKilled(e);
      enemies.splice(i, 1);
      continue;
    }
    
    // Off screen
    if (e.x + e.w < -50) {
      enemies.splice(i, 1);
    }
  }
}

function shootEnemyProjectile(enemy) {
  const ex = enemy.x + enemy.w / 2;
  const ey = enemy.y + enemy.h / 2;
  const px = player.x + player.w / 2;
  const py = player.y + player.h / 2;
  
  let dx = px - ex;
  let dy = py - ey;
  const dist = Math.sqrt(dx * dx + dy * dy) || 1;
  dx /= dist;
  dy /= dist;
  
  projectiles.push({
    x: ex, y: ey,
    vx: dx * 6,
    vy: dy * 6,
    radius: 6,
    damage: enemy.damage * 0.5,
    color: "#ff4444",
    life: 3,
    trail: [],
    isEnemyProjectile: true
  });
}

function updateProjectiles(dt) {
  for (let i = projectiles.length - 1; i >= 0; i--) {
    const p = projectiles[i];
    
    if (p.trail.length > 8) p.trail.shift();
    p.trail.push({ x: p.x, y: p.y });
    
    p.x += p.vx;
    p.y += p.vy;
    p.life -= dt;
    
    if (p.life <= 0 || p.x < -50 || p.x > canvas.width + 50 || p.y < -50 || p.y > canvas.height + 50) {
      projectiles.splice(i, 1);
      continue;
    }
    
    // Enemy projectile hitting player
    if (p.isEnemyProjectile && player.alive && !player.invincible) {
      if (p.x > player.x && p.x < player.x + player.w &&
          p.y > player.y && p.y < player.y + player.h) {
        damagePlayer(p.damage);
        projectiles.splice(i, 1);
        continue;
      }
    }
    
    // Player projectile hitting enemies
    if (!p.isEnemyProjectile) {
      for (let j = enemies.length - 1; j >= 0; j--) {
        const e = enemies[j];
        if (p.x > e.x && p.x < e.x + e.w && p.y > e.y && p.y < e.y + e.h) {
          let damage = p.damage;
          
          // Hunter's Mark bonus damage
          if (abilityEffects.huntersMark && abilityEffects.huntersMark.target === e) {
            damage *= 2;
          }
          
          if (p.isCrit) {
            damage *= p.critMultiplier;
            addFloatingText(e.x + e.w / 2, e.y - 30, "CRIT!", "#ff0000");
          }
          
          playSound("hit");
          e.hp -= damage;
          spawnHitParticles(p.x, p.y, p.color, 6);
          screenShake += p.isCrit ? 4 : 2;
          
          // Lifesteal
          if (player.lifesteal > 0) {
            player.hp = Math.min(player.hp + damage * player.lifesteal, player.maxHP);
          }
          
          // Poison
          if (p.poison) {
            e.poisonTimer = 3;
            e.poisonDamage = damage * 0.2;
          }
          
          // Explosion
          if (p.explosive) {
            playSound("explosion");
            for (const other of enemies) {
              if (other === e) continue;
              const dx = (other.x + other.w / 2) - p.x;
              const dy = (other.y + other.h / 2) - p.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist < 60) {
                other.hp -= damage * 0.5;
              }
            }
            spawnExplosion(p.x, p.y, "#ff8800", 15);
            screenShake += 5;
          }
          
          if (p.pierce && p.pierceCount < 3) {
            p.pierceCount++;
          } else {
            projectiles.splice(i, 1);
          }
          
          break;
        }
      }
    }
  }
}

function damagePlayer(amount) {
  if (player.invincible) return;
  
  let damage = amount;
  
  if (player.shield > 0) {
    if (player.shield >= damage) {
      player.shield -= damage;
      damage = 0;
    } else {
      damage -= player.shield;
      player.shield = 0;
    }
  }
  
  player.hp -= damage;
  
  if (gameData.settings.damageNumbers && damage > 0) {
    addFloatingText(player.x + player.w / 2, player.y - 10, "-" + Math.floor(damage), "#ff0000");
  }
  
  spawnHitParticles(player.x + player.w / 2, player.y + player.h / 2, "#ff0000", 8);
  screenShake += 5;
  
  if (player.hp <= 0) {
    player.hp = 0;
    player.alive = false;
    gameOver();
  }
}

function onEnemyKilled(enemy) {
  // Sound
  playSound("kill");
  if (enemy.isBoss) playSound("boss");
  
  // XP
  let xpGain = 20 + wave * 5;
  if (enemy.isBoss) xpGain *= 5;
  else if (enemy.isMiniBoss) xpGain *= 2;
  
  xpGain *= (1 + gameData.permanentUpgrades.xpMultiplier * 0.1);
  giveXP(Math.floor(xpGain));
  
  // Currency
  let coinDrop = 5 + wave;
  let gemDrop = 0;
  
  if (enemy.isBoss) {
    coinDrop = 50 + wave * 10;
    gemDrop = 3 + Math.floor(wave / 5);
  } else if (enemy.isMiniBoss) {
    coinDrop = 20 + wave * 5;
    gemDrop = 1;
  }
  
  coinDrop = Math.floor(coinDrop * (1 + gameData.permanentUpgrades.coinMultiplier * 0.1));
  
  sessionCoins += coinDrop;
  sessionGems += gemDrop;
  gameData.totalCoins += coinDrop;
  gameData.totalGems += gemDrop;
  
  if (gameData.settings.damageNumbers) {
    addFloatingText(enemy.x + enemy.w / 2, enemy.y - 20, "+" + coinDrop + "üí∞", "#ffff00");
  }
  
  // Effects
  spawnExplosion(enemy.x + enemy.w / 2, enemy.y + enemy.h / 2, enemy.color, 15);
  
  // Combo
  combo++;
  comboTimer = 2;
  if (combo > maxCombo) maxCombo = combo;
  
  enemiesKilled++;
  saveGameData();
}

function giveXP(amount) {
  player.xp += amount;
  
  while (player.xp >= player.xpToNext) {
    player.xp -= player.xpToNext;
    player.level++;
    player.xpToNext = Math.floor(100 * Math.pow(player.level, 1.8));
    playSound("levelUp");
    showUpgradeScreen();
  }
}

function showUpgradeScreen() {
  gamePaused = true;
  document.getElementById("upgradeScreen").classList.add("active");
  
  const container = document.getElementById("upgradeOptions");
  container.innerHTML = "";
  
  const keys = Object.keys(UPGRADE_TYPES);
  const shuffled = keys.sort(() => Math.random() - 0.5).slice(0, 3);
  
  shuffled.forEach(key => {
    const upgrade = UPGRADE_TYPES[key];
    const card = document.createElement("div");
    card.className = "upgrade-card";
    card.innerHTML = `
      <div style="font-size: 40px; margin-bottom: 10px;">${upgrade.icon}</div>
      <div style="font-size: 14px; color: #ffff00; margin-bottom: 5px;">${upgrade.name}</div>
      <div style="font-size: 11px; color: #aaa;">${upgrade.desc}</div>
    `;
    card.addEventListener("click", () => selectUpgrade(key));
    container.appendChild(card);
  });
}

function selectUpgrade(key) {
  const upgrade = UPGRADE_TYPES[key];
  upgrade.apply(player);
  
  document.getElementById("upgradeScreen").classList.remove("active");
  gamePaused = false;
  
  addFloatingText(player.x + player.w / 2, player.y - 30, upgrade.name + "!", "#ffff00");
  spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#ffff00", 20);
}

function nextWave() {
  wave++;
  
  playSound("wave");
  
  if (wave > gameData.highestWave) {
    gameData.highestWave = wave;
    saveGameData();
  }
  
  enemiesToSpawn = calcEnemiesForWave(wave);
  spawnTimer = 0;
  
  addFloatingText(canvas.width / 2, 100, "WAVE " + wave, "#00ffff");
  
  // Refill some potions each wave in endless
  if (gameMode === "endless" && wave % 5 === 0) {
    potions.heal = Math.min(potions.heal + 1, 5);
    potions.shield = Math.min(potions.shield + 1, 3);
    updatePotionDisplay();
  }
}

function victory() {
  gameRunning = false;
  document.getElementById("potionBar").classList.remove("active");
  document.getElementById("abilityBar").classList.remove("active");
  
  playSound("victory");
  
  // Mark node as completed in story mode
  if (gameMode === "story" && selectedNode) {
    if (!gameData.completedNodes.includes(selectedNode.id)) {
      gameData.completedNodes.push(selectedNode.id);
    }
    
    // Unlock next nodes
    if (selectedNode.unlocks) {
      selectedNode.unlocks.forEach(nodeId => {
        if (!gameData.unlockedNodes.includes(nodeId)) {
          gameData.unlockedNodes.push(nodeId);
        }
      });
    }
    
    // Apply rewards
    if (selectedNode.rewards.classUnlock) {
      if (!gameData.unlockedClasses.includes(selectedNode.rewards.classUnlock)) {
        gameData.unlockedClasses.push(selectedNode.rewards.classUnlock);
      }
    }
    
    if (selectedNode.rewards.keyShard) {
      gameData.keyShards[selectedNode.rewards.keyShard] = true;
    }
    
    // Update story progress
    gameData.storyProgress = (gameData.completedNodes.length / MAP_NODES.length) * 100;
  }
  
  saveGameData();
  
  document.getElementById("victoryCoins").textContent = sessionCoins;
  document.getElementById("victoryGems").textContent = sessionGems;
  document.getElementById("victoryMessage").textContent = gameMode === "story" 
    ? `${selectedNode.name} Complete!` 
    : `Reached Wave ${wave}!`;
  
  document.getElementById("victoryScreen").classList.add("active");
}

function gameOver() {
  gameRunning = false;
  document.getElementById("potionBar").classList.remove("active");
  document.getElementById("abilityBar").classList.remove("active");
  
  playSound("gameOver");
  
  // Check for Phoenix Rising passive (Summoner)
  if (selectedClass === "Summoner" && abilityEffects.phoenixReady) {
    abilityEffects.phoenixReady = false;
    player.hp = player.maxHP;
    player.alive = true;
    gameRunning = true;
    document.getElementById("potionBar").classList.add("active");
    document.getElementById("abilityBar").classList.add("active");
    
    addFloatingText(player.x + player.w / 2, player.y - 50, "üî• PHOENIX RISING! üî•", "#ff8800");
    spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#ff8800", 40);
    screenShake += 20;
    playSound("ability");
    return;
  }
  
  saveGameData();
  
  document.getElementById("finalWave").textContent = wave;
  document.getElementById("finalLevel").textContent = player.level;
  document.getElementById("finalKills").textContent = enemiesKilled;
  document.getElementById("earnedCoins").textContent = sessionCoins;
  document.getElementById("earnedGems").textContent = sessionGems;
  
  document.getElementById("gameOverScreen").classList.add("active");
}

function handleVictoryContinue() {
  document.getElementById("victoryScreen").classList.remove("active");
  
  if (gameMode === "story") {
    showOverworldMap();
  } else {
    showScreen("mainMenu");
  }
}

function returnToMenu() {
  document.getElementById("gameOverScreen").classList.remove("active");
  showScreen("mainMenu");
}

// ==================== POTIONS ====================
function usePotion(type) {
  if (!player || !player.alive) return;
  if (potions[type] <= 0) return;
  if (potionCooldowns[type] > 0) return;
  
  potions[type]--;
  potionCooldowns[type] = 1;
  
  playSound("potion");
  
  // Deduct from inventory
  if (gameData.potionInventory[type] > 0) {
    gameData.potionInventory[type]--;
    saveGameData();
  }
  
  switch (type) {
    case "heal":
      const healAmount = 50 + (gameData.potionUpgrades.healStrength * 20);
      player.hp = Math.min(player.hp + healAmount, player.maxHP);
      addFloatingText(player.x + player.w / 2, player.y - 30, "+" + healAmount + " HP", "#00ff00");
      break;
      
    case "shield":
      const shieldAmount = 50 + (gameData.potionUpgrades.shieldStrength * 25);
      player.shield = (player.shield || 0) + shieldAmount;
      player.maxShield = Math.max(player.maxShield || 0, player.shield);
      addFloatingText(player.x + player.w / 2, player.y - 30, "+" + shieldAmount + " Shield", "#00aaff");
      break;
      
    case "crit":
      potionEffects.critActive = true;
      potionEffects.critTimer = 10;
      player.critChance += 0.25;
      addFloatingText(player.x + player.w / 2, player.y - 30, "Crit Boost!", "#ff0000");
      break;
      
    case "damage":
      potionEffects.damageActive = true;
      potionEffects.damageTimer = 10;
      player.damage += 10;
      addFloatingText(player.x + player.w / 2, player.y - 30, "Damage Boost!", "#ff8800");
      break;
      
    case "speed":
      potionEffects.speedActive = true;
      potionEffects.speedTimer = 10;
      player.fireRate *= 0.7;
      addFloatingText(player.x + player.w / 2, player.y - 30, "Speed Boost!", "#ffff00");
      break;
      
    case "dragon":
      useDragonBeam();
      break;
  }
  
  spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#ff00ff", 10);
  screenShake += 3;
  updatePotionDisplay();
}

function useDragonBeam() {
  addFloatingText(canvas.width / 2, 200, "üêâ DRAGON BEAM! üêâ", "#ff00ff");
  screenShake += 25;
  
  const damage = player.damage * 5;
  
  // Damage all enemies
  enemies.forEach(e => {
    e.hp -= damage;
    spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, "#ff4400", 10);
  });
  
  // Create fire zones
  for (let i = 0; i < 20; i++) {
    fireZones.push({
      x: player.x + 100 + i * 50,
      y: GROUND_Y - 20,
      radius: 40,
      damage: damage * 0.1,
      life: 5
    });
  }
  
  // Visual effect
  for (let i = 0; i < 50; i++) {
    particles.push({
      x: player.x + player.w / 2,
      y: player.y + player.h / 2,
      vx: Math.random() * 20 + 5,
      vy: Math.random() * 10 - 5,
      radius: Math.random() * 6 + 2,
      color: Math.random() < 0.5 ? "#ff4400" : "#ff8800",
      life: 2
    });
  }
}

function updatePotionEffects(dt) {
  // Update cooldowns
  for (let type in potionCooldowns) {
    if (potionCooldowns[type] > 0) {
      potionCooldowns[type] -= dt;
      if (potionCooldowns[type] < 0) potionCooldowns[type] = 0;
    }
  }
  
  // Crit effect
  if (potionEffects.critActive) {
    potionEffects.critTimer -= dt;
    if (potionEffects.critTimer <= 0) {
      potionEffects.critActive = false;
      player.critChance -= 0.25;
    }
  }
  
  // Damage effect
  if (potionEffects.damageActive) {
    potionEffects.damageTimer -= dt;
    if (potionEffects.damageTimer <= 0) {
      potionEffects.damageActive = false;
      player.damage -= 10;
    }
  }
  
  // Speed effect
  if (potionEffects.speedActive) {
    potionEffects.speedTimer -= dt;
    if (potionEffects.speedTimer <= 0) {
      potionEffects.speedActive = false;
      player.fireRate /= 0.7;
    }
  }
}

function updateFireZones(dt) {
  for (let i = fireZones.length - 1; i >= 0; i--) {
    const zone = fireZones[i];
    zone.life -= dt;
    
    if (zone.life <= 0) {
      fireZones.splice(i, 1);
      continue;
    }
    
    // Damage enemies in zone
    enemies.forEach(e => {
      const dx = (e.x + e.w / 2) - zone.x;
      const dy = (e.y + e.h / 2) - zone.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist < zone.radius) {
        e.hp -= zone.damage * dt;
      }
    });
  }
}

// ==================== ABILITY SYSTEM ====================
function useAbility(slot) {
  if (!player || !player.alive) return;
  if (abilityCooldowns[slot] > 0) return;
  
  const skillTree = SKILL_TREES[selectedClass];
  if (!skillTree) return;
  
  const ability = skillTree[slot];
  if (!ability) return;
  
  abilityCooldowns[slot] = ability.cooldown;
  playSound("ability");
  
  // Execute ability based on class
  switch (selectedClass) {
    case "Hunter":
      if (slot === "ult1") activateRapidBarrage();
      else activateHuntersMark();
      break;
    case "Knight":
      if (slot === "ult1") activateShieldWall();
      else activateWhirlwind();
      break;
    case "Assassin":
      if (slot === "ult1") activateShadowStep();
      else activateBladeDance();
      break;
    case "Archer":
      if (slot === "ult1") activateRainOfArrows();
      else activateCupidsBow();
      break;
    case "Wizard":
      if (slot === "ult1") activateMeteorShower();
      else activateTimeFreeze();
      break;
    case "Summoner":
      if (slot === "ult1") activateArmyOfLight();
      // Phoenix Rising is passive
      break;
    case "Bomber":
      if (slot === "ult1") activateCarpetBomb();
      else activateNuclearOption();
      break;
    case "Sniper":
      if (slot === "ult1") activateHeadshot();
      else activatePiercingRound();
      break;
    case "Necromancer":
      if (slot === "ult1") activateArmyOfDead();
      else activateDeathAura();
      break;
    case "Vecna":
      if (slot === "ult1") activateHiveMind();
      else activateUpsideDown();
      break;
  }
  
  updateAbilityDisplay();
}

// Hunter Abilities
function activateRapidBarrage() {
  addFloatingText(player.x + player.w / 2, player.y - 50, "üèπ RAPID BARRAGE!", "#00ff88");
  
  for (let i = 0; i < 8; i++) {
    setTimeout(() => {
      const target = getTargetEnemy();
      if (target) {
        shootProjectile(target);
        spawnHitParticles(player.x + player.w, player.y + player.h / 2, player.color, 3);
      }
    }, i * 100);
  }
}

function activateHuntersMark() {
  const target = getTargetEnemy();
  if (target) {
    abilityEffects.huntersMark = { target: target, timer: 5 };
    addFloatingText(target.x + target.w / 2, target.y - 30, "üéØ MARKED!", "#ff0000");
    spawnExplosion(target.x + target.w / 2, target.y + target.h / 2, "#ff0000", 15);
  }
}

// Knight Abilities
function activateShieldWall() {
  abilityEffects.shieldWall = true;
  abilityEffects.shieldWallTimer = 4;
  player.invincible = true;
  addFloatingText(player.x + player.w / 2, player.y - 50, "üõ°Ô∏è SHIELD WALL!", "#4488ff");
  spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#4488ff", 25);
}

function activateWhirlwind() {
  addFloatingText(player.x + player.w / 2, player.y - 50, "‚öîÔ∏è WHIRLWIND!", "#4488ff");
  
  const damage = player.damage * 3;
  enemies.forEach(e => {
    const dx = (e.x + e.w / 2) - (player.x + player.w / 2);
    const dy = (e.y + e.h / 2) - (player.y + player.h / 2);
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    if (dist < 200) {
      e.hp -= damage;
      spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, "#4488ff", 8);
    }
  });
  
  // Visual spin effect
  for (let i = 0; i < 20; i++) {
    const angle = (i / 20) * Math.PI * 2;
    particles.push({
      x: player.x + player.w / 2,
      y: player.y + player.h / 2,
      vx: Math.cos(angle) * 6,
      vy: Math.sin(angle) * 6,
      radius: 5,
      color: "#4488ff",
      life: 1
    });
  }
  screenShake += 15;
}

// Assassin Abilities
function activateShadowStep() {
  const target = getTargetEnemy();
  if (target) {
    addFloatingText(player.x + player.w / 2, player.y - 50, "üë§ SHADOW STEP!", "#ff00ff");
    
    // Teleport effect
    spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#ff00ff", 15);
    
    // Deal massive crit damage
    const damage = player.damage * 5;
    target.hp -= damage;
    
    addFloatingText(target.x + target.w / 2, target.y - 30, "CRIT! " + Math.floor(damage), "#ff0000");
    spawnExplosion(target.x + target.w / 2, target.y + target.h / 2, "#ff00ff", 20);
    screenShake += 10;
  }
}

function activateBladeDance() {
  addFloatingText(player.x + player.w / 2, player.y - 50, "üó°Ô∏è BLADE DANCE!", "#ff00ff");
  
  for (let i = 0; i < 12; i++) {
    const angle = (i / 12) * Math.PI * 2;
    projectiles.push({
      x: player.x + player.w / 2,
      y: player.y + player.h / 2,
      vx: Math.cos(angle) * 8,
      vy: Math.sin(angle) * 8,
      radius: 6,
      damage: player.damage * 1.5,
      color: "#ff00ff",
      life: 2,
      trail: [],
      pierce: true,
      pierceCount: 0,
      isEnemyProjectile: false
    });
  }
  screenShake += 8;
}

// Archer Abilities
function activateRainOfArrows() {
  addFloatingText(canvas.width / 2, 150, "üåßÔ∏è RAIN OF ARROWS!", "#228b22");
  
  for (let i = 0; i < 30; i++) {
    setTimeout(() => {
      const x = Math.random() * (canvas.width - 200) + 100;
      projectiles.push({
        x: x,
        y: 0,
        vx: 0,
        vy: 10,
        radius: 5,
        damage: player.damage * 0.8,
        color: "#228b22",
        life: 2,
        trail: [],
        isEnemyProjectile: false
      });
    }, i * 50);
  }
}

function activateCupidsBow() {
  addFloatingText(player.x + player.w / 2, player.y - 50, "üíï CUPIDS BOW!", "#ff69b4");
  
  // Charm enemies for 6 seconds
  enemies.forEach(e => {
    if (!e.isBoss) {
      e.charmed = true;
      e.charmTimer = 6;
      e.vx = Math.abs(e.vx); // Move away from player
      spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, "#ff69b4", 8);
    }
  });
}

// Wizard Abilities
function activateMeteorShower() {
  addFloatingText(canvas.width / 2, 150, "‚òÑÔ∏è METEOR SHOWER!", "#8800ff");
  
  for (let i = 0; i < 10; i++) {
    setTimeout(() => {
      if (enemies.length > 0) {
        const target = enemies[Math.floor(Math.random() * enemies.length)];
        spawnMeteor(target.x + target.w / 2, player.damage * 3);
      } else {
        spawnMeteor(Math.random() * canvas.width, player.damage * 3);
      }
    }, i * 200);
  }
}

function spawnMeteor(targetX, damage) {
  // Meteor visual
  const meteor = {
    x: targetX + (Math.random() - 0.5) * 100,
    y: 0,
    targetX: targetX,
    damage: damage
  };
  
  // Animate meteor falling
  let y = 0;
  const interval = setInterval(() => {
    y += 20;
    if (y >= GROUND_Y - 30) {
      clearInterval(interval);
      
      // Impact explosion
      spawnExplosion(targetX, GROUND_Y - 30, "#ff4400", 25);
      screenShake += 10;
      
      // Damage enemies in blast radius
      enemies.forEach(e => {
        const dx = (e.x + e.w / 2) - targetX;
        const dist = Math.abs(dx);
        if (dist < 80) {
          e.hp -= damage * (1 - dist / 80);
        }
      });
      
      // Create fire zone
      fireZones.push({
        x: targetX,
        y: GROUND_Y - 20,
        radius: 60,
        damage: damage * 0.05,
        life: 3
      });
    }
  }, 30);
}

function activateTimeFreeze() {
  abilityEffects.timeFreezeActive = true;
  abilityEffects.timeFreezeTimer = 4;
  addFloatingText(canvas.width / 2, 200, "‚è∞ TIME FREEZE!", "#8800ff");
  
  // Freeze all enemies
  enemies.forEach(e => {
    e.frozen = true;
    e.originalSpeed = e.vx;
    e.vx = 0;
  });
  
  screenShake += 15;
}

// Summoner Abilities
function activateArmyOfLight() {
  addFloatingText(player.x + player.w / 2, player.y - 50, "‚ú® ARMY OF LIGHT!", "#88ff88");
  
  for (let i = 0; i < 5; i++) {
    minions.push({
      x: player.x + 50 + i * 40,
      y: GROUND_Y - 30,
      w: 25,
      h: 30,
      hp: 50 + wave * 5,
      maxHP: 50 + wave * 5,
      damage: player.damage * 0.5,
      fireRate: 1,
      shootTimer: Math.random(),
      color: "#88ff88",
      type: "spirit",
      life: 15
    });
    
    spawnExplosion(player.x + 50 + i * 40, GROUND_Y - 30, "#88ff88", 10);
  }
}

// Bomber Abilities
function activateCarpetBomb() {
  addFloatingText(canvas.width / 2, 150, "üí£ CARPET BOMB!", "#ff8800");
  
  for (let i = 0; i < 10; i++) {
    setTimeout(() => {
      const x = player.x + 100 + i * 80;
      spawnExplosion(x, GROUND_Y - 50, "#ff8800", 20);
      screenShake += 5;
      
      // Damage enemies
      enemies.forEach(e => {
        const dx = (e.x + e.w / 2) - x;
        if (Math.abs(dx) < 60) {
          e.hp -= player.damage * 2;
        }
      });
      
      // Fire zone
      fireZones.push({
        x: x,
        y: GROUND_Y - 20,
        radius: 50,
        damage: player.damage * 0.1,
        life: 4
      });
    }, i * 150);
  }
}

function activateNuclearOption() {
  addFloatingText(canvas.width / 2, 200, "‚ò¢Ô∏è NUCLEAR OPTION! ‚ò¢Ô∏è", "#ff0000");
  screenShake += 50;
  
  // Massive damage to all enemies
  const damage = player.damage * 10;
  enemies.forEach(e => {
    e.hp -= damage;
    spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, "#ffff00", 15);
  });
  
  // Giant explosion at center
  for (let i = 0; i < 100; i++) {
    particles.push({
      x: canvas.width / 2,
      y: GROUND_Y / 2,
      vx: (Math.random() - 0.5) * 20,
      vy: (Math.random() - 0.5) * 20,
      radius: Math.random() * 10 + 3,
      color: Math.random() < 0.5 ? "#ff4400" : "#ffff00",
      life: 2
    });
  }
  
  // Screen flash effect
  setTimeout(() => screenShake += 30, 100);
}

// Sniper Abilities
function activateHeadshot() {
  const target = getTargetEnemy();
  if (target) {
    addFloatingText(player.x + player.w / 2, player.y - 50, "üéØ HEADSHOT!", "#00ffff");
    
    const damage = player.damage * 5;
    target.hp -= damage;
    
    // Laser beam visual
    projectiles.push({
      x: player.x + player.w,
      y: player.y + player.h / 2,
      vx: 30,
      vy: 0,
      radius: 8,
      damage: 0,
      color: "#00ffff",
      life: 0.5,
      trail: [],
      isEnemyProjectile: false
    });
    
    addFloatingText(target.x + target.w / 2, target.y - 30, "üíÄ " + Math.floor(damage), "#ff0000");
    spawnExplosion(target.x + target.w / 2, target.y + target.h / 2, "#00ffff", 20);
    screenShake += 12;
  }
}

function activatePiercingRound() {
  abilityEffects.piercingRoundActive = true;
  abilityEffects.piercingRoundTimer = 10;
  player.pierce = true;
  addFloatingText(player.x + player.w / 2, player.y - 50, "üî≠ PIERCING ROUNDS!", "#00ffff");
  spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#00ffff", 15);
}

// Necromancer Abilities
function activateArmyOfDead() {
  addFloatingText(player.x + player.w / 2, player.y - 50, "üíÄ ARMY OF THE DEAD!", "#9933ff");
  
  for (let i = 0; i < 5; i++) {
    minions.push({
      x: player.x + 50 + i * 50,
      y: GROUND_Y - 35,
      w: 30,
      h: 35,
      hp: 80 + wave * 8,
      maxHP: 80 + wave * 8,
      damage: player.damage * 0.6,
      fireRate: 1.2,
      shootTimer: Math.random(),
      color: "#9933ff",
      type: "skeleton",
      life: 20
    });
    
    spawnExplosion(player.x + 50 + i * 50, GROUND_Y - 35, "#9933ff", 10);
  }
}

function activateDeathAura() {
  abilityEffects.deathAuraActive = true;
  abilityEffects.deathAuraTimer = 8;
  addFloatingText(player.x + player.w / 2, player.y - 50, "‚ò†Ô∏è DEATH AURA!", "#9933ff");
}

// Vecna Abilities
function activateHiveMind() {
  addFloatingText(canvas.width / 2, 200, "üß† HIVE MIND CONTROL!", "#8B0000");
  
  abilityEffects.hiveMindActive = true;
  abilityEffects.hiveMindTimer = 8;
  
  enemies.forEach(e => {
    if (!e.isBoss) {
      e.controlled = true;
      e.vx = Math.abs(e.vx); // Move right (away from player)
      spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, "#8B0000", 8);
    }
  });
  
  screenShake += 20;
}

function activateUpsideDown() {
  abilityEffects.upsideDownActive = true;
  abilityEffects.upsideDownTimer = 6;
  player.invincible = true;
  
  addFloatingText(canvas.width / 2, 200, "üåÄ UPSIDE DOWN!", "#8B0000");
  
  // Spawn Vecna monsters
  for (let i = 0; i < 3; i++) {
    vecnaMonsters.push({
      x: player.x + 80 + i * 60,
      y: GROUND_Y - 50,
      w: 40,
      h: 50,
      damage: player.damage * 0.8,
      speed: 2,
      life: 6,
      color: "#4a0000"
    });
    spawnExplosion(player.x + 80 + i * 60, GROUND_Y - 50, "#8B0000", 15);
  }
  
  screenShake += 25;
}

function updateAbilityEffects(dt) {
  // Update cooldowns
  for (let slot in abilityCooldowns) {
    if (abilityCooldowns[slot] > 0) {
      abilityCooldowns[slot] -= dt;
      if (abilityCooldowns[slot] < 0) abilityCooldowns[slot] = 0;
    }
  }
  
  // Shield Wall
  if (abilityEffects.shieldWall) {
    abilityEffects.shieldWallTimer -= dt;
    if (abilityEffects.shieldWallTimer <= 0) {
      abilityEffects.shieldWall = false;
      player.invincible = false;
    }
  }
  
  // Hunter's Mark
  if (abilityEffects.huntersMark) {
    abilityEffects.huntersMark.timer -= dt;
    if (abilityEffects.huntersMark.timer <= 0 || !enemies.includes(abilityEffects.huntersMark.target)) {
      abilityEffects.huntersMark = null;
    }
  }
  
  // Time Freeze
  if (abilityEffects.timeFreezeActive) {
    abilityEffects.timeFreezeTimer -= dt;
    if (abilityEffects.timeFreezeTimer <= 0) {
      abilityEffects.timeFreezeActive = false;
      enemies.forEach(e => {
        if (e.frozen) {
          e.frozen = false;
          e.vx = e.originalSpeed || -1;
        }
      });
    }
  }
  
  // Piercing Round
  if (abilityEffects.piercingRoundActive) {
    abilityEffects.piercingRoundTimer -= dt;
    if (abilityEffects.piercingRoundTimer <= 0) {
      abilityEffects.piercingRoundActive = false;
      // Only remove pierce if it wasn't a class trait
      const cls = CLASSES[selectedClass];
      if (!cls.stats.pierce) player.pierce = false;
    }
  }
  
  // Death Aura (Necromancer)
  if (abilityEffects.deathAuraActive) {
    abilityEffects.deathAuraTimer -= dt;
    
    // Damage nearby enemies
    enemies.forEach(e => {
      const dx = (e.x + e.w / 2) - (player.x + player.w / 2);
      const dy = (e.y + e.h / 2) - (player.y + player.h / 2);
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist < 150) {
        e.hp -= player.damage * 0.5 * dt;
        e.poisonTimer = 2;
        e.poisonDamage = player.damage * 0.1;
      }
    });
    
    if (abilityEffects.deathAuraTimer <= 0) {
      abilityEffects.deathAuraActive = false;
    }
  }
  
  // Hive Mind (Vecna)
  if (abilityEffects.hiveMindActive) {
    abilityEffects.hiveMindTimer -= dt;
    
    // Controlled enemies fight each other
    enemies.forEach(e => {
      if (e.controlled) {
        // Attack other non-controlled enemies
        enemies.forEach(other => {
          if (other !== e && !other.controlled && !other.isBoss) {
            const dx = (other.x + other.w / 2) - (e.x + e.w / 2);
            const dy = (other.y + other.h / 2) - (e.y + e.h / 2);
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 50) {
              other.hp -= e.damage * 0.3 * dt;
            }
          }
        });
      }
    });
    
    if (abilityEffects.hiveMindTimer <= 0) {
      abilityEffects.hiveMindActive = false;
      enemies.forEach(e => {
        if (e.controlled) {
          e.controlled = false;
          e.vx = -Math.abs(e.vx);
        }
      });
    }
  }
  
  // Upside Down (Vecna)
  if (abilityEffects.upsideDownActive) {
    abilityEffects.upsideDownTimer -= dt;
    if (abilityEffects.upsideDownTimer <= 0) {
      abilityEffects.upsideDownActive = false;
      player.invincible = false;
    }
  }
  
  // Update Vecna monsters
  updateVecnaMonsters(dt);
  
  // Update charmed enemies
  updateCharmedEnemies(dt);
  
  // Update minions
  updateMinions(dt);
}

function updateVecnaMonsters(dt) {
  for (let i = vecnaMonsters.length - 1; i >= 0; i--) {
    const m = vecnaMonsters[i];
    m.life -= dt;
    m.x += m.speed;
    
    if (m.life <= 0 || m.x > canvas.width) {
      vecnaMonsters.splice(i, 1);
      continue;
    }
    
    // Attack enemies
    enemies.forEach(e => {
      if (m.x < e.x + e.w && m.x + m.w > e.x && m.y < e.y + e.h && m.y + m.h > e.y) {
        e.hp -= m.damage * dt * 2;
      }
    });
  }
}

function updateCharmedEnemies(dt) {
  enemies.forEach(e => {
    if (e.charmed) {
      e.charmTimer -= dt;
      if (e.charmTimer <= 0) {
        e.charmed = false;
        e.vx = -Math.abs(e.vx);
      }
    }
  });
}

function updateMinions(dt) {
  for (let i = minions.length - 1; i >= 0; i--) {
    const m = minions[i];
    m.life -= dt;
    m.shootTimer += dt;
    
    if (m.life <= 0 || m.hp <= 0) {
      spawnExplosion(m.x + m.w / 2, m.y + m.h / 2, m.color, 10);
      minions.splice(i, 1);
      continue;
    }
    
    // Shoot at enemies
    if (m.shootTimer >= m.fireRate && enemies.length > 0) {
      m.shootTimer = 0;
      const target = enemies[Math.floor(Math.random() * enemies.length)];
      
      const dx = (target.x + target.w / 2) - (m.x + m.w / 2);
      const dy = (target.y + target.h / 2) - (m.y + m.h / 2);
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      
      projectiles.push({
        x: m.x + m.w / 2,
        y: m.y + m.h / 2,
        vx: (dx / dist) * 7,
        vy: (dy / dist) * 7,
        radius: 4,
        damage: m.damage,
        color: m.color,
        life: 2,
        trail: [],
        isEnemyProjectile: false
      });
    }
  }
}

function updateAbilityDisplay() {
  const bar = document.getElementById("abilityBar");
  if (!bar) return;
  
  const skillTree = SKILL_TREES[selectedClass];
  if (!skillTree) return;
  
  // Update ability 1
  const ult1 = document.getElementById("ability1");
  if (ult1 && skillTree.ult1) {
    const cd = abilityCooldowns.ult1;
    ult1.textContent = cd > 0 ? Math.ceil(cd) : skillTree.ult1.icon;
    ult1.style.opacity = cd > 0 ? "0.5" : "1";
  }
  
  // Update ability 2
  const ult2 = document.getElementById("ability2");
  if (ult2 && skillTree.ult2) {
    const cd = abilityCooldowns.ult2;
    ult2.textContent = cd > 0 ? Math.ceil(cd) : skillTree.ult2.icon;
    ult2.style.opacity = cd > 0 ? "0.5" : "1";
  }
}

// ==================== PARTICLES & EFFECTS ====================
function spawnHitParticles(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 4,
      vy: (Math.random() - 0.5) * 4,
      radius: 3,
      color,
      life: 0.5
    });
  }
}

function spawnExplosion(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 8,
      vy: (Math.random() - 0.5) * 8,
      radius: Math.random() * 4 + 2,
      color,
      life: 0.8
    });
  }
}

function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.life -= dt;
    if (p.life <= 0) {
      particles.splice(i, 1);
    }
  }
}

function addFloatingText(x, y, text, color) {
  floatingTexts.push({ x, y, text, color, life: 1.5, vy: -1.5 });
}

function updateFloatingTexts(dt) {
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const t = floatingTexts[i];
    t.y += t.vy;
    t.life -= dt;
    if (t.life <= 0) {
      floatingTexts.splice(i, 1);
    }
  }
}

// ==================== DRAWING ====================
function draw() {
  ctx.save();
  
  // Screen shake
  if (screenShake > 0) {
    ctx.translate(
      (Math.random() - 0.5) * screenShake,
      (Math.random() - 0.5) * screenShake
    );
  }
  
  // Background - Upside Down effect
  if (abilityEffects.upsideDownActive) {
    ctx.fillStyle = "#1a0010";
  } else {
    ctx.fillStyle = "#0a0015";
  }
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Stars
  drawStars();
  
  // Ground
  if (abilityEffects.upsideDownActive) {
    ctx.fillStyle = "#3a1020";
  } else {
    ctx.fillStyle = "#2a1a3a";
  }
  ctx.fillRect(0, GROUND_Y, canvas.width, canvas.height - GROUND_Y);
  ctx.strokeStyle = abilityEffects.upsideDownActive ? "#ff0044" : "#00ffff";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, GROUND_Y);
  ctx.lineTo(canvas.width, GROUND_Y);
  ctx.stroke();
  
  // Fire zones
  drawFireZones();
  
  // Player
  if (player) drawPlayer();
  
  // Minions
  drawMinions();
  
  // Vecna monsters
  drawVecnaMonsters();
  
  // Enemies
  drawEnemies();
  
  // Projectiles
  drawProjectiles();
  
  // Particles
  drawParticles();
  
  // Floating texts
  drawFloatingTexts();
  
  // Ability effects visuals
  drawAbilityEffects();
  
  // HUD
  drawHUD();
  
  ctx.restore();
}

function drawMinions() {
  for (const m of minions) {
    ctx.shadowColor = m.color;
    ctx.shadowBlur = 12;
    ctx.fillStyle = m.color;
    
    // Body
    ctx.fillRect(m.x, m.y, m.w, m.h);
    ctx.shadowBlur = 0;
    
    // Eyes
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(m.x + m.w * 0.2, m.y + m.h * 0.2, 4, 4);
    ctx.fillRect(m.x + m.w * 0.6, m.y + m.h * 0.2, 4, 4);
    
    // Type indicator
    if (m.type === "skeleton") {
      ctx.fillStyle = "#ffffff";
      ctx.font = "10px 'Press Start 2P'";
      ctx.textAlign = "center";
      ctx.fillText("üíÄ", m.x + m.w / 2, m.y - 5);
    } else if (m.type === "spirit") {
      ctx.fillStyle = "#ffffff";
      ctx.font = "10px 'Press Start 2P'";
      ctx.textAlign = "center";
      ctx.fillText("‚ú®", m.x + m.w / 2, m.y - 5);
    }
    
    // HP bar
    const hpRatio = m.hp / m.maxHP;
    ctx.fillStyle = "rgba(60, 0, 0, 0.8)";
    ctx.fillRect(m.x, m.y - 8, m.w, 4);
    ctx.fillStyle = "#44ff44";
    ctx.fillRect(m.x, m.y - 8, m.w * hpRatio, 4);
  }
  ctx.textAlign = "left";
}

function drawVecnaMonsters() {
  for (const m of vecnaMonsters) {
    ctx.shadowColor = "#8B0000";
    ctx.shadowBlur = 20;
    ctx.fillStyle = m.color;
    
    // Body - tentacle-like shape
    ctx.beginPath();
    ctx.arc(m.x + m.w / 2, m.y + m.h / 2, m.w / 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    
    // Creepy eyes
    ctx.fillStyle = "#ff0000";
    ctx.beginPath();
    ctx.arc(m.x + m.w * 0.3, m.y + m.h * 0.4, 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(m.x + m.w * 0.7, m.y + m.h * 0.4, 5, 0, Math.PI * 2);
    ctx.fill();
    
    // Life indicator
    ctx.globalAlpha = m.life / 6;
    ctx.strokeStyle = "#8B0000";
    ctx.lineWidth = 3;
    ctx.strokeRect(m.x - 2, m.y - 2, m.w + 4, m.h + 4);
    ctx.globalAlpha = 1;
  }
}

function drawAbilityEffects() {
  // Death Aura visual
  if (abilityEffects.deathAuraActive && player) {
    const gradient = ctx.createRadialGradient(
      player.x + player.w / 2, player.y + player.h / 2, 0,
      player.x + player.w / 2, player.y + player.h / 2, 150
    );
    gradient.addColorStop(0, "rgba(153, 51, 255, 0.4)");
    gradient.addColorStop(0.5, "rgba(153, 51, 255, 0.2)");
    gradient.addColorStop(1, "rgba(153, 51, 255, 0)");
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(player.x + player.w / 2, player.y + player.h / 2, 150, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Hunter's Mark visual
  if (abilityEffects.huntersMark && abilityEffects.huntersMark.target) {
    const target = abilityEffects.huntersMark.target;
    ctx.strokeStyle = "#ff0000";
    ctx.lineWidth = 3;
    ctx.setLineDash([5, 5]);
    ctx.strokeRect(target.x - 5, target.y - 5, target.w + 10, target.h + 10);
    ctx.setLineDash([]);
    
    // Target reticle
    ctx.beginPath();
    ctx.arc(target.x + target.w / 2, target.y + target.h / 2, target.w * 0.8, 0, Math.PI * 2);
    ctx.stroke();
  }
  
  // Time Freeze visual
  if (abilityEffects.timeFreezeActive) {
    ctx.fillStyle = "rgba(136, 0, 255, 0.1)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Clock icon
    ctx.fillStyle = "#8800ff";
    ctx.font = "30px 'Press Start 2P'";
    ctx.textAlign = "center";
    ctx.fillText("‚è∞", canvas.width - 50, 150);
    ctx.font = "12px 'Press Start 2P'";
    ctx.fillText(Math.ceil(abilityEffects.timeFreezeTimer) + "s", canvas.width - 50, 175);
    ctx.textAlign = "left";
  }
  
  // Shield Wall visual
  if (abilityEffects.shieldWall && player) {
    ctx.strokeStyle = "#4488ff";
    ctx.lineWidth = 5;
    ctx.globalAlpha = 0.6 + Math.sin(Date.now() / 100) * 0.3;
    ctx.strokeRect(player.x - 15, player.y - 15, player.w + 30, player.h + 30);
    ctx.globalAlpha = 1;
  }
  
  // Hive Mind visual
  if (abilityEffects.hiveMindActive) {
    // Draw lines from player to controlled enemies
    enemies.forEach(e => {
      if (e.controlled) {
        ctx.strokeStyle = "rgba(139, 0, 0, 0.5)";
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(player.x + player.w / 2, player.y + player.h / 2);
        ctx.lineTo(e.x + e.w / 2, e.y + e.h / 2);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Mind control indicator
        ctx.fillStyle = "#8B0000";
        ctx.font = "12px 'Press Start 2P'";
        ctx.textAlign = "center";
        ctx.fillText("üß†", e.x + e.w / 2, e.y - 15);
      }
    });
    ctx.textAlign = "left";
  }
}

function drawStars() {
  const time = Date.now() * 0.0001;
  for (let i = 0; i < 30; i++) {
    const x = (i * 123.456) % canvas.width;
    const y = ((i * 78.9 + time * 20) % (GROUND_Y - 50));
    const brightness = (Math.sin(i + time * 3) + 1) * 0.5;
    ctx.fillStyle = `rgba(255, 255, 255, ${brightness * 0.5})`;
    ctx.fillRect(x, y, 2, 2);
  }
}

function drawPlayer() {
  const skin = gameData.cosmetics.playerSkin;
  
  // Glow based on skin
  ctx.shadowColor = player.color;
  ctx.shadowBlur = 15;
  
  if (skin === "fire") {
    ctx.shadowColor = "#ff4400";
    ctx.fillStyle = "#ff6600";
  } else if (skin === "ice") {
    ctx.shadowColor = "#00ffff";
    ctx.fillStyle = "#88ffff";
  } else if (skin === "shadow") {
    ctx.shadowColor = "#000000";
    ctx.fillStyle = "#333333";
  } else if (skin === "gold") {
    ctx.shadowColor = "#ffdd00";
    ctx.fillStyle = "#ffd700";
  } else if (skin === "rainbow") {
    const hue = (Date.now() / 20) % 360;
    ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;
    ctx.fillStyle = `hsl(${hue}, 100%, 60%)`;
  } else if (skin === "void") {
    ctx.shadowColor = "#8B0000";
    ctx.fillStyle = "#2a0000";
  } else {
    ctx.fillStyle = player.color;
  }
  
  // Body
  ctx.fillRect(player.x, player.y, player.w, player.h);
  ctx.shadowBlur = 0;
  
  // Head
  ctx.fillStyle = "#ffd4a3";
  ctx.fillRect(player.x + player.w * 0.25, player.y - player.h * 0.3, player.w * 0.5, player.h * 0.3);
  
  // Eyes
  ctx.fillStyle = "#00ffff";
  ctx.fillRect(player.x + player.w * 0.35, player.y - player.h * 0.18, 4, 4);
  ctx.fillRect(player.x + player.w * 0.55, player.y - player.h * 0.18, 4, 4);
  
  // Shield visual
  if (player.shield > 0) {
    ctx.strokeStyle = "#00aaff";
    ctx.lineWidth = 3;
    ctx.globalAlpha = 0.5;
    ctx.strokeRect(player.x - 5, player.y - 5, player.w + 10, player.h + 10);
    ctx.globalAlpha = 1;
  }
  
  // Invincibility visual
  if (player.invincible) {
    ctx.strokeStyle = "#ffff00";
    ctx.lineWidth = 3;
    ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 100) * 0.3;
    ctx.strokeRect(player.x - 8, player.y - 8, player.w + 16, player.h + 16);
    ctx.globalAlpha = 1;
  }
}

function drawEnemies() {
  for (const e of enemies) {
    ctx.shadowColor = e.color;
    ctx.shadowBlur = e.isBoss ? 25 : e.isMiniBoss ? 18 : 10;
    ctx.fillStyle = e.color;
    
    const wobble = Math.sin(Date.now() / 200) * 2;
    ctx.fillRect(e.x + 2, e.y + wobble, e.w - 4, e.h - 4);
    
    ctx.shadowBlur = 0;
    
    // Eyes
    ctx.fillStyle = "#ffff00";
    const eyeSize = e.isBoss ? 8 : e.isMiniBoss ? 6 : 5;
    ctx.fillRect(e.x + e.w * 0.25, e.y + e.h * 0.2 + wobble, eyeSize, eyeSize);
    ctx.fillRect(e.x + e.w * 0.65, e.y + e.h * 0.2 + wobble, eyeSize, eyeSize);
    
    // Labels
    if (e.isBoss) {
      ctx.fillStyle = "#ffffff";
      ctx.font = "bold 12px 'Press Start 2P'";
      ctx.textAlign = "center";
      ctx.fillText("BOSS", e.x + e.w / 2, e.y - 25);
    } else if (e.isMiniBoss) {
      ctx.fillStyle = "#ffff00";
      ctx.font = "bold 10px 'Press Start 2P'";
      ctx.textAlign = "center";
      ctx.fillText("ELITE", e.x + e.w / 2, e.y - 20);
    }
    
    // HP bar
    const hpRatio = e.hp / e.maxHP;
    ctx.fillStyle = "rgba(60, 0, 0, 0.8)";
    ctx.fillRect(e.x, e.y - 8, e.w, 5);
    ctx.fillStyle = hpRatio > 0.5 ? "#44ff44" : hpRatio > 0.25 ? "#ffaa44" : "#ff4444";
    ctx.fillRect(e.x, e.y - 8, e.w * hpRatio, 5);
    
    ctx.textAlign = "left";
  }
}

function drawProjectiles() {
  for (const p of projectiles) {
    // Trail
    ctx.globalAlpha = 0.3;
    ctx.strokeStyle = p.color;
    ctx.lineWidth = p.radius;
    ctx.beginPath();
    for (let i = 0; i < p.trail.length; i++) {
      const t = p.trail[i];
      if (i === 0) ctx.moveTo(t.x, t.y);
      else ctx.lineTo(t.x, t.y);
    }
    ctx.stroke();
    ctx.globalAlpha = 1;
    
    // Bullet
    ctx.shadowColor = p.color;
    ctx.shadowBlur = 10;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

function drawFireZones() {
  fireZones.forEach(zone => {
    const gradient = ctx.createRadialGradient(zone.x, zone.y, 0, zone.x, zone.y, zone.radius);
    gradient.addColorStop(0, "rgba(255, 136, 0, 0.6)");
    gradient.addColorStop(0.5, "rgba(255, 68, 0, 0.3)");
    gradient.addColorStop(1, "rgba(255, 68, 0, 0)");
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
    ctx.fill();
  });
}

function drawParticles() {
  for (const p of particles) {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.radius || 3, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function drawFloatingTexts() {
  for (const t of floatingTexts) {
    ctx.globalAlpha = t.life;
    ctx.fillStyle = t.color;
    ctx.font = "bold 14px 'Press Start 2P'";
    ctx.textAlign = "center";
    ctx.fillText(t.text, t.x, t.y);
  }
  ctx.globalAlpha = 1;
  ctx.textAlign = "left";
}

function drawHUD() {
  // Info panel
  ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
  ctx.fillRect(10, 10, 300, 90);
  ctx.strokeStyle = "#00ffff";
  ctx.lineWidth = 2;
  ctx.strokeRect(10, 10, 300, 90);
  
  ctx.fillStyle = "#00ffff";
  ctx.font = "12px 'Press Start 2P'";
  ctx.fillText("‚öîÔ∏è " + selectedClass, 20, 30);
  ctx.fillText("üåä Wave: " + wave + (gameMode === "story" ? "/" + maxWaves : ""), 20, 50);
  ctx.fillText("‚≠ê Level: " + (player?.level || 1), 170, 50);
  
  // HP bar
  if (player) {
    const hpRatio = player.hp / player.maxHP;
    ctx.fillStyle = "rgba(60, 0, 0, 0.8)";
    ctx.fillRect(20, 65, 280, 12);
    ctx.fillStyle = hpRatio > 0.5 ? "#44ff44" : hpRatio > 0.25 ? "#ffaa44" : "#ff4444";
    ctx.fillRect(20, 65, 280 * hpRatio, 12);
    ctx.strokeStyle = "#ff4444";
    ctx.strokeRect(20, 65, 280, 12);
    ctx.fillStyle = "#ffffff";
    ctx.font = "10px 'Press Start 2P'";
    ctx.fillText(Math.floor(player.hp) + "/" + player.maxHP, 25, 75);
    
    // XP bar
    const xpRatio = player.xp / player.xpToNext;
    ctx.fillStyle = "rgba(0, 50, 80, 0.8)";
    ctx.fillRect(20, 82, 280, 8);
    ctx.fillStyle = "#0088ff";
    ctx.fillRect(20, 82, 280 * xpRatio, 8);
  }
  
  // Currency
  ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
  ctx.fillRect(canvas.width - 160, 10, 150, 50);
  ctx.strokeStyle = "#ffff00";
  ctx.strokeRect(canvas.width - 160, 10, 150, 50);
  ctx.fillStyle = "#ffff00";
  ctx.font = "12px 'Press Start 2P'";
  ctx.fillText("üí∞ " + sessionCoins, canvas.width - 150, 30);
  ctx.fillStyle = "#00ffff";
  ctx.fillText("üíé " + sessionGems, canvas.width - 150, 50);
  
  // Combo
  if (combo > 1) {
    ctx.fillStyle = "#ff8800";
    ctx.font = "bold 16px 'Press Start 2P'";
    ctx.fillText("üî• COMBO: " + combo + "x", canvas.width - 200, 80);
  }
  
  // Pause button hint
  ctx.fillStyle = "#888";
  ctx.font = "10px 'Press Start 2P'";
  ctx.fillText("[ESC] Pause", canvas.width - 120, canvas.height - 20);
}

// ==================== KEYBOARD CONTROLS ====================
function handleKeyDown(e) {
  // Pause
  if (e.key === "Escape" && currentScreen === "gameScreen" && gameRunning) {
    if (gamePaused) {
      resumeGame();
    } else {
      pauseGame();
    }
    return;
  }
  
  // Skip title with any key
  if (currentScreen === "title") {
    goToNameEntry();
    return;
  }
  
  // Potions and Abilities (during gameplay)
  if (currentScreen === "gameScreen" && gameRunning && !gamePaused) {
    if (e.key === "1") usePotion("heal");
    if (e.key === "2") usePotion("shield");
    if (e.key === "3") usePotion("crit");
    if (e.key === "4") usePotion("damage");
    if (e.key === "5") usePotion("speed");
    if (e.key === "6") usePotion("dragon");
    
    // Abilities
    if (e.key === "q" || e.key === "Q") useAbility("ult1");
    if (e.key === "e" || e.key === "E") useAbility("ult2");
    
    // Speed toggle
    if (e.key === "f" || e.key === "F") {
      gameSpeed = gameSpeed === 1 ? 2 : 1;
      addFloatingText(canvas.width / 2, 150, "Speed: " + gameSpeed + "x", gameSpeed === 2 ? "#ff8800" : "#ffffff");
    }
  }
}

function pauseGame() {
  gamePaused = true;
  document.getElementById("pauseMenu").classList.add("active");
}

function resumeGame() {
  gamePaused = false;
  document.getElementById("pauseMenu").classList.remove("active");
  document.getElementById("upgradeScreen").classList.remove("active");
}

function restartGame() {
  document.getElementById("pauseMenu").classList.remove("active");
  startBattle();
}

function quitToMenu() {
  gameRunning = false;
  document.getElementById("pauseMenu").classList.remove("active");
  document.getElementById("potionBar").classList.remove("active");
  document.getElementById("abilityBar").classList.remove("active");
  showScreen("mainMenu");
}

// ==================== START ====================
init();
</script>
</body>
</html>