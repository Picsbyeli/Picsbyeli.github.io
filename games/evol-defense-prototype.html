<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Evol Legends – Defense Prototype</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #050510;
      color: #f0f0f0;
      font-family: Arial, sans-serif;
    }
    #container {
      display: flex;
      flex-direction: row;
      height: 100vh;
    }
    #gameWrapper {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      background: radial-gradient(circle at top, #222244 0, #050510 60%);
    }
    #gameCanvas {
      border: 2px solid #444;
      background: #111;
    }
    #ui {
      width: 320px;
      padding: 12px;
      box-sizing: border-box;
      border-left: 1px solid #333;
      background: #0a0a14;
      display: flex;
      flex-direction: column;
      gap: 10px;
      font-size: 14px;
    }
    #ui h2 {
      margin: 4px 0;
      font-size: 18px;
    }
    #ui label, #ui select, #ui button {
      display: block;
      width: 100%;
      margin-bottom: 6px;
    }
    #ui button {
      padding: 6px;
      background: #1b1b33;
      border: 1px solid #555;
      color: #eee;
      cursor: pointer;
    }
    #ui button:hover {
      background: #26264a;
    }
    .upgrade-row {
      display: flex;
      justify-content: space-between;
      gap: 4px;
      margin-bottom: 4px;
    }
    .upgrade-row span {
      flex: 1;
    }
    .upgrade-row button {
      flex-basis: 70px;
      font-size: 11px;
      padding: 3px;
    }
    #log {
      flex: 1;
      margin-top: 6px;
      overflow-y: auto;
      border: 1px solid #333;
      padding: 4px;
      font-size: 11px;
      background: #05050a;
    }
  </style>
</head>
<body>
<div id="container">
  <div id="gameWrapper">
    <canvas id="gameCanvas" width="960" height="540"></canvas>
  </div>
  <div id="ui">
    <h2>Evol Defense</h2>
    <label for="classSelect">Class</label>
    <select id="classSelect"></select>
    <button id="startBtn">Start Game</button>

    <div>
      <strong>Permanent Upgrades</strong>
      <div class="upgrade-row">
        <span>Health (+30 each)</span>
        <button data-upgrade="health">Level: <span class="lvl">0</span></button>
      </div>
      <div class="upgrade-row">
        <span>Damage (+5 each)</span>
        <button data-upgrade="damage">Level: <span class="lvl">0</span></button>
      </div>
      <div class="upgrade-row">
        <span>Fire Rate (-5% cooldown each)</span>
        <button data-upgrade="fireRate">Level: <span class="lvl">0</span></button>
      </div>
      <div class="upgrade-row">
        <span>Crit Chance (+2% each)</span>
        <button data-upgrade="critChance">Level: <span class="lvl">0</span></button>
      </div>
    </div>

    <div>
      <strong>Stats</strong><br/>
      <span id="statClass"></span><br/>
      HP: <span id="statHP"></span><br/>
      Dmg: <span id="statDmg"></span><br/>
      FireRate: <span id="statFR"></span>/s<br/>
      Crit: <span id="statCrit"></span>%
    </div>

    <div>
      <strong>Game Info</strong><br/>
      Wave: <span id="statWave">0</span><br/>
      Score: <span id="statScore">0</span><br/>
      Player HP: <span id="statPlayerHP">0</span>
    </div>

    <div id="log"></div>
  </div>
</div>

<script>
/* =========================================================
   CORE DATA / PERMANENT UPGRADES
   ========================================================= */

// Simple permanent progression (in a real game, hook to coins/costs)
const gameData = {
  permanentUpgrades: {
    health: 0,
    damage: 0,
    fireRate: 0,
    critChance: 0,
    startLevel: 0
  }
};

const SHOP_UPGRADES = {
  health: {
    getBonus(level) { return level * 30; }
  },
  damage: {
    getBonus(level) { return level * 5; }
  },
  fireRate: {
    // multiplier applied to base cooldown (less than 1 = faster)
    getBonus(level) { return 1 - level * 0.05; } // level 2 -> 0.9, etc.
  },
  critChance: {
    getBonus(level) { return level * 0.02; } // +2% per level
  },
  startLevel: {
    getBonus(level) { return level; }
  }
};

// Persist upgrades in localStorage
(function loadUpgrades() {
  try {
    const saved = localStorage.getItem("evolDefenseUpgrades");
    if (saved) {
      const parsed = JSON.parse(saved);
      if (parsed && parsed.permanentUpgrades) {
        Object.assign(gameData.permanentUpgrades, parsed.permanentUpgrades);
      }
    }
  } catch (e) {
    console.warn("Cannot load upgrades:", e);
  }
})();

function saveUpgrades() {
  try {
    localStorage.setItem("evolDefenseUpgrades", JSON.stringify({
      permanentUpgrades: gameData.permanentUpgrades
    }));
  } catch (e) {
    console.warn("Cannot save upgrades:", e);
  }
}

/* =========================================================
   CLASS DEFINITIONS
   You can add all your other classes (Vecna, Berserk, etc.)
   following this pattern.
   ========================================================= */

const CLASSES = {
  // Simple generic class (for testing)
  "Soldier": {
    displayName: "Soldier (Basic)",
    stats: {
      hp: 120,
      damage: 20,
      fireRate: 2.5,    // shots per second
      projectileSpeed: 500,
      range: 380,
      moveSpeed: 140,
      critChance: 0.05
    },
    color: "#4EC3FF"
  },

  /* Complex classes requested */

  "PlagueDoctor": {
    displayName: "Plague Doctor",
    stats: {
      hp: 110,
      damage: 15,
      fireRate: 1.5,
      projectileSpeed: 420,
      range: 320,
      moveSpeed: 130,
      critChance: 0.05
    },
    color: "#65ff9a"
  },

  "CryoSentinel": {
    displayName: "Cryo Sentinel",
    stats: {
      hp: 140,
      damage: 18,
      fireRate: 1.4,
      projectileSpeed: 450,
      range: 340,
      moveSpeed: 120,
      critChance: 0.05
    },
    color: "#7fe0ff"
  },

  "HolyCleric": {
    displayName: "Holy Cleric",
    stats: {
      hp: 150,
      damage: 14,
      fireRate: 1.5,
      projectileSpeed: 380,
      range: 320,
      moveSpeed: 115,
      critChance: 0.03
    },
    color: "#ffd87f"
  },

  "TrickshotRogue": {
    displayName: "Trickshot Rogue",
    stats: {
      hp: 100,
      damage: 16,
      fireRate: 2.4,
      projectileSpeed: 520,
      range: 360,
      moveSpeed: 160,
      critChance: 0.08
    },
    color: "#ff8af2"
  },

  "Starcaller": {
    displayName: "Starcaller",
    stats: {
      hp: 120,
      damage: 18,
      fireRate: 2.0,
      projectileSpeed: 480,
      range: 340,
      moveSpeed: 130,
      critChance: 0.06
    },
    color: "#fff27f"
  },

  "Engineer": {
    displayName: "Engineer",
    stats: {
      hp: 130,
      damage: 14,
      fireRate: 2.2,
      projectileSpeed: 450,
      range: 330,
      moveSpeed: 125,
      critChance: 0.04
    },
    color: "#ffb57f"
  },

  "Druid": {
    displayName: "Druid",
    stats: {
      hp: 140,
      damage: 15,
      fireRate: 1.8,
      projectileSpeed: 430,
      range: 330,
      moveSpeed: 130,
      critChance: 0.04
    },
    color: "#7fff9a"
  },

  "GuardianTank": {
    displayName: "Guardian Tank",
    stats: {
      hp: 220,
      damage: 22,
      fireRate: 1.4,
      projectileSpeed: 420,
      range: 300,
      moveSpeed: 100,
      critChance: 0.02
    },
    color: "#7fb6ff"
  }
};

/* =========================================================
   CANVAS / GAME STATE
   ========================================================= */

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

let lastTime = 0;
let running = false;

let player = null;
let enemies = [];
let projectiles = [];
let floatingTexts = [];
let explosions = [];
let poisonClouds = [];
let iceShards = [];
let helperStars = [];
let turrets = [];
let rootBarriers = [];

let plagueCloudCooldown = 0;
let clericHealTimer = 0;
let engineerTurretsPlacedThisRound = 0;

let wave = 0;
let waveTimer = 0;
let waveInterval = 15; // seconds between waves
let score = 0;

/* =========================================================
   UI HOOKUP
   ========================================================= */

const classSelect = document.getElementById("classSelect");
const startBtn = document.getElementById("startBtn");
const logDiv = document.getElementById("log");

const statClass = document.getElementById("statClass");
const statHP = document.getElementById("statHP");
const statDmg = document.getElementById("statDmg");
const statFR = document.getElementById("statFR");
const statCrit = document.getElementById("statCrit");
const statWave = document.getElementById("statWave");
const statScore = document.getElementById("statScore");
const statPlayerHP = document.getElementById("statPlayerHP");

// Populate class dropdown
Object.keys(CLASSES).forEach(key => {
  const opt = document.createElement("option");
  opt.value = key;
  opt.textContent = CLASSES[key].displayName || key;
  classSelect.appendChild(opt);
});

// Upgrade buttons
document.querySelectorAll('#ui button[data-upgrade]').forEach(btn => {
  const type = btn.getAttribute("data-upgrade");
  const span = btn.querySelector(".lvl");
  span.textContent = gameData.permanentUpgrades[type];

  btn.addEventListener("click", () => {
    gameData.permanentUpgrades[type]++;
    span.textContent = gameData.permanentUpgrades[type];
    saveUpgrades();
    log(`Permanent ${type} upgraded to level ${gameData.permanentUpgrades[type]}. Start a new game to see effect.`);
    if (player) {
      // Show new base stats on next start
      updateStatPreview();
    } else {
      updateStatPreview();
    }
  });
});

classSelect.addEventListener("change", updateStatPreview);

startBtn.addEventListener("click", () => {
  startGame(classSelect.value);
});

function log(msg) {
  const line = document.createElement("div");
  line.textContent = msg;
  logDiv.appendChild(line);
  logDiv.scrollTop = logDiv.scrollHeight;
}

/* =========================================================
   PLAYER INITIALIZATION WITH PERMANENT UPGRADES
   ========================================================= */

function startGame(className) {
  const cls = CLASSES[className];
  if (!cls) return;

  wave = 1;
  waveTimer = 0;
  score = 0;

  enemies = [];
  projectiles = [];
  floatingTexts = [];
  explosions = [];
  poisonClouds = [];
  iceShards = [];
  helperStars = [];
  turrets = [];
  rootBarriers = [];

  plagueCloudCooldown = 0;
  clericHealTimer = 0;
  engineerTurretsPlacedThisRound = 0;

  // 1) Base stats from class
  let baseDamage   = cls.stats.damage;
  let baseMaxHP    = cls.stats.hp;
  let baseFireRate = cls.stats.fireRate;
  let baseCrit     = cls.stats.critChance || 0;

  // 2) Apply permanent upgrades ON TOP
  baseDamage += SHOP_UPGRADES.damage.getBonus(gameData.permanentUpgrades.damage);
  baseMaxHP  += SHOP_UPGRADES.health.getBonus(gameData.permanentUpgrades.health);
  baseFireRate *= SHOP_UPGRADES.fireRate.getBonus(gameData.permanentUpgrades.fireRate);
  baseCrit += SHOP_UPGRADES.critChance.getBonus(gameData.permanentUpgrades.critChance);

  // Convert fireRate (shots/sec) into cooldown seconds
  const shotCooldown = 1 / baseFireRate;

  player = {
    className,
    x: canvas.width * 0.25,
    y: canvas.height * 0.5,
    w: 32,
    h: 32,
    color: cls.color,
    maxHP: baseMaxHP,
    hp: baseMaxHP,
    damage: baseDamage,
    shotCooldown: shotCooldown,
    shotTimer: 0,
    projectileSpeed: cls.stats.projectileSpeed,
    range: cls.stats.range,
    moveSpeed: cls.stats.moveSpeed,
    critChance: baseCrit,
    alive: true,
    knockback: 0
  };

  // Extra base-levels if you want (not wired to UI by default)
  const extraLevels = SHOP_UPGRADES.startLevel.getBonus(gameData.permanentUpgrades.startLevel);
  for (let i = 0; i < extraLevels; i++) {
    // example: simple +5% damage / +5 HP level-up
    player.damage *= 1.05;
    player.maxHP += 5;
    player.hp = player.maxHP;
  }

  // GuardianTank knockback special
  if (className === "GuardianTank") {
    player.knockback = 60; // 20%-ish knockback; tune as you like
  }

  // Starcaller – create helper star
  helperStars = [];
  if (className === "Starcaller") {
    helperStars.push({
      angle: 0,
      distance: 40,
      fireTimer: 0,
      x: player.x,
      y: player.y
    });
  }

  updateStatPreview();
  running = true;
  lastTime = performance.now();
  requestAnimationFrame(gameLoop);

  log(`Game started as ${cls.displayName}.`);
}

/* =========================================================
   STAT PREVIEW (UI)
   ========================================================= */

function updateStatPreview() {
  const key = classSelect.value;
  const cls = CLASSES[key];
  if (!cls) return;

  let baseDamage   = cls.stats.damage;
  let baseMaxHP    = cls.stats.hp;
  let baseFireRate = cls.stats.fireRate;
  let baseCrit     = cls.stats.critChance || 0;

  baseDamage += SHOP_UPGRADES.damage.getBonus(gameData.permanentUpgrades.damage);
  baseMaxHP  += SHOP_UPGRADES.health.getBonus(gameData.permanentUpgrades.health);
  baseFireRate *= SHOP_UPGRADES.fireRate.getBonus(gameData.permanentUpgrades.fireRate);
  baseCrit += SHOP_UPGRADES.critChance.getBonus(gameData.permanentUpgrades.critChance);

  statClass.textContent = cls.displayName;
  statHP.textContent = baseMaxHP.toFixed(0);
  statDmg.textContent = baseDamage.toFixed(1);
  statFR.textContent = baseFireRate.toFixed(2);
  statCrit.textContent = (baseCrit * 100).toFixed(1);
  if (player) {
    statPlayerHP.textContent = `${player.hp.toFixed(0)} / ${player.maxHP.toFixed(0)}`;
  } else {
    statPlayerHP.textContent = "0";
  }
  statWave.textContent = wave;
  statScore.textContent = score;
}
updateStatPreview();

/* =========================================================
   INPUT: BASIC MOUSE CLICK FOR CLASS ABILITIES
   ========================================================= */

canvas.addEventListener("click", e => {
  if (!player || !player.alive) return;

  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left);
  const y = (e.clientY - rect.top);

  // PlagueDoctor – place poison cloud if off cooldown
  if (player.className === "PlagueDoctor" && plagueCloudCooldown <= 0) {
    poisonClouds.push({
      x,
      y,
      radius: 150,
      timeLeft: 10
    });
    plagueCloudCooldown = 60;
    log("Plague cloud placed.");
  }

  // Engineer – place turrets (max 2 per round)
  if (player.className === "Engineer" && engineerTurretsPlacedThisRound < 2) {
    turrets.push({
      x,
      y,
      hp: 100,
      maxHP: 100,
      damage: 8,
      fireRate: 0.5, // cooldown
      fireTimer: 0,
      range: 300
    });
    engineerTurretsPlacedThisRound++;
    log(`Turret placed (${engineerTurretsPlacedThisRound}/2).`);
  }

  // Druid – place root barriers (max 3 active)
  if (player.className === "Druid") {
    if (rootBarriers.length < 3) {
      rootBarriers.push({
        x: x - 20,
        y: y - 40,
        w: 40,
        h: 80,
        hp: 100,
        maxHP: 100,
        thornDamage: 5,
        healOnHit: 2,
        timeLeft: 10
      });
      log(`Root barrier placed (${rootBarriers.length}/3).`);
    }
  }
});

/* =========================================================
   ENEMY SPAWNING
   ========================================================= */

function spawnWave(waveNumber) {
  const count = 6 + waveNumber * 2;
  for (let i = 0; i < count; i++) {
    enemies.push({
      x: canvas.width + 50 + i * 40,
      y: 60 + Math.random() * (canvas.height - 120),
      w: 28,
      h: 28,
      baseSpeed: 60 + waveNumber * 5,
      vx: -1,
      hp: 60 + waveNumber * 15,
      maxHP: 60 + waveNumber * 15,
      slowEffect: 0,
      slowDuration: 0,
      confused: 0,
      plaguePoison: null
    });
  }
  log(`Wave ${waveNumber} incoming.`);
}

/* =========================================================
   UPDATE LOOP
   ========================================================= */

function gameLoop(timestamp) {
  if (!running) return;
  const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
  lastTime = timestamp;

  update(dt);
  draw();

  requestAnimationFrame(gameLoop);
}

function update(dt) {
  if (!player || !player.alive) return;

  statWave.textContent = wave;
  statScore.textContent = score;
  statPlayerHP.textContent = `${player.hp.toFixed(0)} / ${player.maxHP.toFixed(0)}`;

  // Wave handling
  waveTimer += dt;
  if (waveTimer >= waveInterval) {
    waveTimer = 0;
    wave++;
    spawnWave(wave);
  }

  updatePlayer(dt);
  updateEnemies(dt);
  updateProjectiles(dt);
  updateFloatingText(dt);
  updateExplosions(dt);

  updatePoisonClouds(dt);
  updateIceShards(dt);
  updateHelperStars(dt);
  updateTurrets(dt);
  updateRootBarriers(dt);

  // Class specific timers
  if (player.className === "PlagueDoctor") {
    if (plagueCloudCooldown > 0) plagueCloudCooldown -= dt;
  }

  if (player.className === "HolyCleric") {
    clericHealTimer += dt;
    if (clericHealTimer >= 30) {
      clericHealTimer = 0;
      clericHealPulse();
    }
  }

  if (enemies.length === 0 && waveTimer > 2) {
    // Force next wave if things are too slow, optional
  }

  if (player.hp <= 0 && player.alive) {
    player.alive = false;
    log("Player has fallen. Game over.");
  }
}

/* =========================================================
   PLAYER & SHOOTING
   ========================================================= */

function updatePlayer(dt) {
  // Simple horizontal bob to keep it alive visually
  player.y += Math.sin(lastTime / 200) * 0.05;

  // Shoot at nearest enemy automatically
  player.shotTimer += dt;
  if (player.shotTimer >= player.shotCooldown) {
    const target = findNearestEnemyInRange(player.x, player.y, player.range);
    if (target) {
      player.shotTimer = 0;
      shootProjectileAt(target);
    }
  }
}

function findNearestEnemyInRange(x, y, range) {
  let nearest = null;
  let nearestDist = range;
  for (const e of enemies) {
    const ex = e.x + e.w / 2;
    const ey = e.y + e.h / 2;
    const dx = ex - x;
    const dy = ey - y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < nearestDist) {
      nearestDist = dist;
      nearest = e;
    }
  }
  return nearest;
}

function shootProjectileAt(enemy) {
  const px = player.x + player.w;
  const py = player.y + player.h / 2;
  const ex = enemy.x + enemy.w / 2;
  const ey = enemy.y + enemy.h / 2;
  const dx = ex - px;
  const dy = ey - py;
  const dist = Math.sqrt(dx * dx + dy * dy) || 1;
  const angle = Math.atan2(dy, dx);

  // Class-specific projectile overrides
  if (player.className === "CryoSentinel") {
    projectiles.push({
      x: px,
      y: py,
      vx: Math.cos(angle) * player.projectileSpeed,
      vy: Math.sin(angle) * player.projectileSpeed,
      radius: 6,
      damage: player.damage,
      color: "#00ffff",
      life: 0.3,
      isEnemyProjectile: false,
      becomesIceShard: true,
      bounceCount: 0
    });
    return;
  }

  if (player.className === "TrickshotRogue") {
    projectiles.push({
      x: px,
      y: py,
      vx: Math.cos(angle) * player.projectileSpeed,
      vy: Math.sin(angle) * player.projectileSpeed,
      radius: 6,
      damage: player.damage,
      color: "#ff8af2",
      life: 3,
      isEnemyProjectile: false,
      isTrickshot: true,
      bounceCount: 0,
      maxBounces: 5,
      bounceRange: 150
    });
    return;
  }

  if (player.className === "GuardianTank") {
    projectiles.push({
      x: px,
      y: py,
      vx: Math.cos(angle) * player.projectileSpeed,
      vy: Math.sin(angle) * player.projectileSpeed,
      radius: 10,
      damage: player.damage,
      color: "#87ceeb",
      life: 4,
      isEnemyProjectile: false,
      isShield: true,
      knockback: player.knockback
    });
    return;
  }

  // Default projectile for all others
  projectiles.push({
    x: px,
    y: py,
    vx: Math.cos(angle) * player.projectileSpeed,
    vy: Math.sin(angle) * player.projectileSpeed,
    radius: 5,
    damage: player.damage,
    color: player.color,
    life: 3,
    isEnemyProjectile: false
  });
}

/* =========================================================
   ENEMY UPDATE
   ========================================================= */

function updateEnemies(dt) {
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];

    // Slow
    let speed = e.baseSpeed;
    if (e.slowDuration > 0 && e.slowEffect > 0) {
      e.slowDuration -= dt;
      speed *= (1 - e.slowEffect);
      if (e.slowDuration <= 0) {
        e.slowEffect = 0;
      }
    }

    // Confuse: simple reverse
    if (e.confused > 0) {
      e.confused -= dt;
      e.vx = Math.abs(speed) / e.baseSpeed; // move right briefly
      e.x += e.vx * speed * dt;
    } else {
      e.vx = -1;
      e.x += e.vx * speed * dt;
    }

    // Plague poison DOT
    if (e.plaguePoison) {
      e.plaguePoison.timer -= dt;
      e.hp -= e.plaguePoison.dps * dt;
      if (e.plaguePoison.timer <= 0) {
        e.plaguePoison = null;
      }
    }

    // Off-screen to left: damage player
    if (e.x + e.w < 0) {
      enemies.splice(i, 1);
      player.hp -= 10;
      addFloatingText(player.x, player.y - 20, "-10 HP", "#ff5555");
      continue;
    }

    // Dead enemy
    if (e.hp <= 0) {
      score += 10;
      spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, "#ff8844", 12);
      enemies.splice(i, 1);
    }
  }
}

/* =========================================================
   PROJECTILES UPDATE
   ========================================================= */

function updateProjectiles(dt) {
  for (let i = projectiles.length - 1; i >= 0; i--) {
    const p = projectiles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.life -= dt;

    if (p.life <= 0) {
      // CryoSentinel – convert to ice shard
      if (p.becomesIceShard) {
        iceShards.push({
          x: p.x,
          y: p.y,
          radius: 80,
          damage: 30,
          slowAmount: 0.4,
          timeLeft: 8
        });
      }
      projectiles.splice(i, 1);
      continue;
    }

    if (!p.isEnemyProjectile) {
      // Collide with enemies
      for (let j = enemies.length - 1; j >= 0; j--) {
        const e = enemies[j];
        if (p.x > e.x && p.x < e.x + e.w && p.y > e.y && p.y < e.y + e.h) {
          // Damage / crit
          let dmg = p.damage;
          const isCrit = Math.random() < (player.critChance || 0);
          if (isCrit) dmg *= 2.0;

          e.hp -= dmg;
          addFloatingText(e.x + e.w / 2, e.y, "-" + dmg.toFixed(0), isCrit ? "#ffdd55" : "#ffffff");

          // Knockback for GuardianTank
          if (p.knockback && p.knockback > 0) {
            const dx = e.x + e.w / 2 - (player.x + player.w / 2);
            const direction = dx >= 0 ? 1 : -1;
            e.x += direction * p.knockback;
          }

          // Trickshot bounce logic
          if (p.isTrickshot && p.bounceCount < p.maxBounces) {
            let nearest = null;
            let nearestDist = p.bounceRange;
            enemies.forEach(other => {
              if (other === e || other.hp <= 0) return;
              const ox = other.x + other.w / 2;
              const oy = other.y + other.h / 2;
              const dx = ox - p.x;
              const dy = oy - p.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist < nearestDist) {
                nearestDist = dist;
                nearest = other;
              }
            });

            if (nearest) {
              p.bounceCount++;
              p.damage *= 1.2;
              const tx = nearest.x + nearest.w / 2;
              const ty = nearest.y + nearest.h / 2;
              const dx = tx - p.x;
              const dy = ty - p.y;
              const dist = Math.sqrt(dx * dx + dy * dy) || 1;
              p.vx = (dx / dist) * player.projectileSpeed;
              p.vy = (dy / dist) * player.projectileSpeed;
              // do NOT remove projectile
              break;
            }
          }

          // Remove projectile if not bouncing
          if (!p.isTrickshot || p.bounceCount >= p.maxBounces) {
            projectiles.splice(i, 1);
          }
          break;
        }
      }
    }

    // Remove off-screen
    if (p.x < -50 || p.x > canvas.width + 50 || p.y < -50 || p.y > canvas.height + 50) {
      projectiles.splice(i, 1);
    }
  }
}

/* =========================================================
   SPECIAL SYSTEMS
   ========================================================= */

// PlagueDoctor
function updatePoisonClouds(dt) {
  poisonClouds = poisonClouds.filter(cloud => {
    cloud.timeLeft -= dt;
    if (cloud.timeLeft <= 0) return false;

    enemies.forEach(e => {
      const ex = e.x + e.w / 2;
      const ey = e.y + e.h / 2;
      const dx = ex - cloud.x;
      const dy = ey - cloud.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < cloud.radius) {
        if (!e._plagueMarked) {
          e._plagueMarked = true;
          const roll = Math.random();
          if (roll < 0.33) {
            e.confused = 10;
          } else if (roll < 0.66) {
            e.slowEffect = (e.slowEffect || 0) + 0.4;
            e.slowDuration = Math.max(e.slowDuration || 0, 10);
          } else {
            e.plaguePoison = {
              dps: 15,
              timer: 10
            };
          }
          addFloatingText(ex, ey - 18, "PLAGUE!", "#00ff88");
        }
      }
    });

    return true;
  });
}

// CryoSentinel
function updateIceShards(dt) {
  iceShards = iceShards.filter(shard => {
    shard.timeLeft -= dt;
    if (shard.timeLeft <= 0) return false;

    enemies.forEach(e => {
      const ex = e.x + e.w / 2;
      const ey = e.y + e.h / 2;
      const dx = ex - shard.x;
      const dy = ey - shard.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < shard.radius) {
        e.hp -= shard.damage * dt;
        e.slowEffect = (e.slowEffect || 0) + shard.slowAmount;
        e.slowDuration = Math.max(e.slowDuration || 0, 0.5);
      }
    });

    return true;
  });
}

// HolyCleric
function clericHealPulse() {
  if (!player || !player.alive) return;
  const heal = 40;
  player.hp = Math.min(player.hp + heal, player.maxHP);
  addFloatingText(player.x, player.y - 20, "+" + heal + " HP", "#00ff00");

  const radius = 50;
  enemies.forEach(e => {
    const ex = e.x + e.w / 2;
    const ey = e.y + e.h / 2;
    const dx = ex - (player.x + player.w / 2);
    const dy = ey - (player.y + player.h / 2);
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < radius) {
      const nx = dx / (dist || 1);
      const ny = dy / (dist || 1);
      e.x += nx * 60;
      e.y += ny * 60;
    }
  });

  spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#ffffff", 18);
}

// Starcaller
function updateHelperStars(dt) {
  if (!player || !player.alive) return;
  helperStars.forEach(star => {
    star.angle += dt * 2;
    const sx = player.x + player.w / 2 + Math.cos(star.angle) * star.distance;
    const sy = player.y + player.h / 2 + Math.sin(star.angle) * star.distance;
    star.x = sx;
    star.y = sy;

    star.fireTimer += dt;
    if (star.fireTimer >= 1.0) {
      star.fireTimer = 0;
      const target = findNearestEnemyInRange(sx, sy, player.range);
      if (target) {
        const ex = target.x + target.w / 2;
        const ey = target.y + target.h / 2;
        const dx = ex - sx;
        const dy = ey - sy;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        projectiles.push({
          x: sx,
          y: sy,
          vx: (dx / dist) * player.projectileSpeed,
          vy: (dy / dist) * player.projectileSpeed,
          radius: 4,
          damage: player.damage * 0.5,
          color: "#ffff66",
          life: 3,
          isEnemyProjectile: false
        });
      }
    }
  });
}

// Engineer
function updateTurrets(dt) {
  turrets = turrets.filter(turret => {
    if (turret.hp <= 0) return false;
    turret.fireTimer += dt;
    if (turret.fireTimer >= turret.fireRate) {
      turret.fireTimer = 0;
      const target = findNearestEnemyInRange(turret.x, turret.y, turret.range);
      if (target) {
        const ex = target.x + target.w / 2;
        const ey = target.y + target.h / 2;
        const dx = ex - turret.x;
        const dy = ey - turret.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        projectiles.push({
          x: turret.x,
          y: turret.y,
          vx: (dx / dist) * player.projectileSpeed,
          vy: (dy / dist) * player.projectileSpeed,
          radius: 4,
          damage: turret.damage,
          color: "#ffaa00",
          life: 3,
          isEnemyProjectile: false
        });
      }
    }
    return true;
  });
}

// Druid
function updateRootBarriers(dt) {
  rootBarriers = rootBarriers.filter(root => {
    root.timeLeft -= dt;
    if (root.timeLeft <= 0 || root.hp <= 0) return false;

    enemies.forEach(e => {
      if (e.x < root.x + root.w &&
          e.x + e.w > root.x &&
          e.y < root.y + root.h &&
          e.y + e.h > root.y) {

        // push enemy back
        e.x += (e.baseSpeed || 60) * dt;

        // thorn damage
        e.hp -= root.thornDamage * dt;

        // heal player
        if (player && player.alive) {
          player.hp = Math.min(player.hp + root.healOnHit * dt, player.maxHP);
        }

        // root takes some damage over time
        root.hp -= 5 * dt;
      }
    });

    return true;
  });
}

/* =========================================================
   FLOATING TEXT & EXPLOSIONS
   ========================================================= */

function addFloatingText(x, y, text, color) {
  floatingTexts.push({ x, y, text, color, life: 1 });
}

function updateFloatingText(dt) {
  floatingTexts = floatingTexts.filter(ft => {
    ft.y -= 20 * dt;
    ft.life -= dt;
    return ft.life > 0;
  });
}

function spawnExplosion(x, y, color, radius) {
  explosions.push({
    x,
    y,
    color,
    radius,
    life: 0.4
  });
}

function updateExplosions(dt) {
  explosions = explosions.filter(ex => {
    ex.life -= dt;
    return ex.life > 0;
  });
}

/* =========================================================
   DRAW
   ========================================================= */

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Background lanes
  ctx.fillStyle = "#101020";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = "#222244";
  ctx.lineWidth = 1;
  for (let i = 0; i < 5; i++) {
    const y = (i + 1) * (canvas.height / 6);
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  }

  drawPoisonClouds(ctx);
  drawIceShards(ctx);
  drawRootBarriers(ctx);

  drawTurrets(ctx);
  drawEnemies(ctx);
  drawPlayer(ctx);
  drawHelperStars(ctx);
  drawProjectiles(ctx);
  drawExplosions(ctx);
  drawFloatingText(ctx);
}

function drawPlayer(ctx) {
  if (!player) return;
  ctx.save();
  ctx.fillStyle = player.color;
  ctx.fillRect(player.x, player.y, player.w, player.h);

  // HP bar
  const hpRatio = player.hp / player.maxHP;
  ctx.fillStyle = "#ff4444";
  ctx.fillRect(player.x, player.y - 6, player.w, 4);
  ctx.fillStyle = "#44ff44";
  ctx.fillRect(player.x, player.y - 6, player.w * hpRatio, 4);

  ctx.restore();
}

function drawEnemies(ctx) {
  enemies.forEach(e => {
    ctx.save();
    ctx.fillStyle = "#ff5555";
    ctx.fillRect(e.x, e.y, e.w, e.h);

    const hpRatio = e.hp / e.maxHP;
    ctx.fillStyle = "#880000";
    ctx.fillRect(e.x, e.y - 4, e.w, 3);
    ctx.fillStyle = "#00ff00";
    ctx.fillRect(e.x, e.y - 4, e.w * hpRatio, 3);
    ctx.restore();
  });
}

function drawProjectiles(ctx) {
  projectiles.forEach(p => {
    ctx.save();
    ctx.fillStyle = p.color || "#ffffff";
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  });
}

function drawFloatingText(ctx) {
  ctx.save();
  ctx.font = "12px Arial";
  ctx.textAlign = "center";
  floatingTexts.forEach(ft => {
    ctx.globalAlpha = Math.max(0, ft.life);
    ctx.fillStyle = ft.color || "#ffffff";
    ctx.fillText(ft.text, ft.x, ft.y);
  });
  ctx.restore();
}

function drawExplosions(ctx) {
  explosions.forEach(ex => {
    ctx.save();
    const t = ex.life / 0.4;
    ctx.globalAlpha = t;
    ctx.fillStyle = ex.color;
    ctx.beginPath();
    ctx.arc(ex.x, ex.y, ex.radius * (1 - t * 0.4), 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  });
}

function drawPoisonClouds(ctx) {
  ctx.save();
  poisonClouds.forEach(cloud => {
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "#00ff88";
    ctx.beginPath();
    ctx.arc(cloud.x, cloud.y, cloud.radius, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.restore();
}

function drawIceShards(ctx) {
  ctx.save();
  iceShards.forEach(shard => {
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = "#a0e8ff";
    ctx.beginPath();
    ctx.arc(shard.x, shard.y, shard.radius, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.restore();
}

function drawHelperStars(ctx) {
  helperStars.forEach(star => {
    ctx.save();
    ctx.fillStyle = "#ffff66";
    ctx.beginPath();
    ctx.arc(star.x, star.y, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  });
}

function drawTurrets(ctx) {
  turrets.forEach(t => {
    ctx.save();
    ctx.fillStyle = "#555555";
    ctx.fillRect(t.x - 10, t.y - 10, 20, 20);
    ctx.restore();
  });
}

function drawRootBarriers(ctx) {
  rootBarriers.forEach(root => {
    ctx.save();
    ctx.fillStyle = "#228B22";
    ctx.fillRect(root.x, root.y, root.w, root.h);
    ctx.restore();
  });
}

/* =========================================================
   AUTO-START PREVIEW GAME
   ========================================================= */

// Optionally start a default game on load:
startGame(classSelect.value);

</script>
</body>
</html>
