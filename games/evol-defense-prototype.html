<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>EVOL LEGENDS - Tower Defense</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      background: #000;
      width: 100vw;
      height: 100vh;
      font-family: 'Courier New', monospace;
      color: #fff;
      overflow: hidden;
    }
    #gameContainer {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      width: 100%;
      height: 100%;
      background: #000;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    
    /* Title Screen */
    #titleScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: linear-gradient(135deg, #0a0015 0%, #1a0030 100%);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }
    #titleScreen.hidden { display: none; }
    
    .title {
      font-size: 72px;
      font-weight: bold;
      color: #00ffff;
      text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
      margin-bottom: 20px;
      animation: glow 2s ease-in-out infinite;
    }
    @keyframes glow {
      0%, 100% { text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff; }
      50% { text-shadow: 0 0 30px #00ffff, 0 0 60px #00ffff, 0 0 80px #00ffff; }
    }
    
    .subtitle {
      font-size: 24px;
      color: #ff00ff;
      margin-bottom: 40px;
      text-shadow: 0 0 10px #ff00ff;
    }
    
    .start-btn {
      padding: 20px 60px;
      font-size: 28px;
      font-weight: bold;
      background: linear-gradient(135deg, #ff0080 0%, #ff8c00 100%);
      color: #fff;
      border: 4px solid #00ffff;
      border-radius: 15px;
      cursor: pointer;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
      transition: all 0.3s;
    }
    .start-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
    }
    
    /* Class Selection Screen */
    #classSelection {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: linear-gradient(135deg, #0a0015 0%, #1a0030 100%);
      display: none;
      flex-direction: column;
      justify-content: flex-start; /* Start at top! */
      align-items: center;
      z-index: 100;
      overflow-y: auto;
      padding: 20px;
      scroll-behavior: smooth; /* Smooth scrolling */
    }
    #classSelection.active { 
      display: flex; 
      /* Force scroll to top when opened */
    }
    
    .class-title {
      font-size: 42px;
      color: #00ffff;
      text-shadow: 0 0 20px #00ffff;
      margin-bottom: 10px;
    }
    
    .class-subtitle {
      font-size: 16px;
      color: #ffff00;
      margin-bottom: 30px;
    }
    
    .class-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      max-width: 900px;
      width: 100%;
    }
    
    .class-card {
      background: linear-gradient(135deg, #1a1a3a 0%, #2a1a3a 100%);
      border: 3px solid #00ffff;
      border-radius: 15px;
      padding: 20px;
      cursor: pointer;
      transition: all 0.3s;
      position: relative;
    }
    .class-card:hover:not(.locked) {
      transform: translateY(-10px);
      box-shadow: 0 10px 30px rgba(0, 255, 255, 0.5);
      border-color: #ffff00;
    }
    .class-card.locked {
      opacity: 0.5;
      cursor: not-allowed;
      border-color: #666;
    }
    .class-card.locked::after {
      content: "üîí";
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 32px;
    }
    
    .class-icon {
      font-size: 48px;
      text-align: center;
      margin-bottom: 10px;
    }
    .class-name {
      font-size: 22px;
      font-weight: bold;
      text-align: center;
      margin-bottom: 10px;
    }
    .class-stats {
      font-size: 12px;
      color: #aaa;
      line-height: 1.6;
    }
    .class-unlock {
      font-size: 12px;
      color: #ff8800;
      text-align: center;
      margin-top: 10px;
      font-weight: bold;
    }
    
    /* Unlock Requirements Modal */
    #unlockModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      z-index: 200;
      display: none;
      align-items: center;
      justify-content: center;
    }
    
    #unlockModal.active {
      display: flex;
    }
    
    .unlock-modal-content {
      position: relative;
      background: linear-gradient(135deg, #1a1a3a 0%, #2a1a3a 100%);
      border: 3px solid #00ffff;
      border-radius: 15px;
      padding: 30px;
      min-width: 400px;
      max-width: 90%;
      box-shadow: 0 0 50px rgba(0, 255, 255, 0.5);
      animation: modalSlideIn 0.3s ease-out;
    }
    
    @keyframes modalSlideIn {
      from {
        transform: scale(0.8);
        opacity: 0;
      }
      to {
        transform: scale(1);
        opacity: 1;
      }
    }
    
    .unlock-modal-title {
      font-size: 28px;
      color: #00ffff;
      text-align: center;
      margin-bottom: 20px;
      text-shadow: 0 0 10px #00ffff;
    }
    
    .unlock-modal-icon {
      font-size: 60px;
      text-align: center;
      margin-bottom: 15px;
    }
    
    .unlock-modal-requirement {
      font-size: 18px;
      color: #ffff00;
      text-align: center;
      margin-bottom: 15px;
      line-height: 1.6;
    }
    
    .unlock-modal-desc {
      font-size: 14px;
      color: #aaaaaa;
      text-align: center;
      margin-bottom: 25px;
    }
    
    .unlock-modal-close {
      background: #ff4444;
      color: white;
      border: none;
      padding: 12px 40px;
      font-size: 18px;
      border-radius: 8px;
      cursor: pointer;
      display: block;
      margin: 0 auto;
      font-family: 'Courier New', monospace;
      font-weight: bold;
    }
    
    .unlock-modal-close:hover {
      background: #ff6666;
      box-shadow: 0 0 15px #ff4444;
    }
    
    /* Shop Screen */
    #shopScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      flex-direction: column;
      align-items: center;
      z-index: 90;
      overflow-y: auto;
      padding: 20px;
    }
    #shopScreen.active { display: flex; }
    
    .shop-header {
      width: 100%;
      max-width: 900px;
      background: linear-gradient(135deg, #1a1a3a 0%, #2a1a3a 100%);
      border: 3px solid #00ffff;
      border-radius: 15px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .shop-title {
      font-size: 36px;
      color: #ffff00;
      text-shadow: 0 0 20px #ffff00;
      text-align: center;
      margin-bottom: 10px;
    }
    .shop-currency {
      display: flex;
      justify-content: center;
      gap: 40px;
      font-size: 20px;
      color: #00ffff;
    }
    
    .shop-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
      max-width: 900px;
      width: 100%;
      margin-bottom: 20px;
    }
    
    .shop-item {
      background: linear-gradient(135deg, #2a1a3a 0%, #3a2a4a 100%);
      border: 2px solid #00ffff;
      border-radius: 10px;
      padding: 15px;
      cursor: pointer;
      transition: all 0.3s;
    }
    .shop-item:hover:not(.maxed) {
      transform: scale(1.05);
      box-shadow: 0 5px 20px rgba(0, 255, 255, 0.5);
    }
    .shop-item.maxed {
      opacity: 0.6;
      cursor: not-allowed;
      border-color: #666;
    }
    
    .shop-item-name {
      font-size: 18px;
      font-weight: bold;
      color: #ffff00;
      margin-bottom: 5px;
    }
    .shop-item-desc {
      font-size: 12px;
      color: #aaa;
      margin-bottom: 10px;
    }
    .shop-item-level {
      font-size: 14px;
      color: #00ff00;
      margin-bottom: 5px;
    }
    .shop-item-cost {
      font-size: 16px;
      color: #ff8800;
      font-weight: bold;
    }
    
    .shop-close-btn {
      padding: 15px 40px;
      font-size: 20px;
      background: #ff0000;
      color: #fff;
      border: 2px solid #fff;
      border-radius: 10px;
      cursor: pointer;
      font-weight: bold;
    }
    .shop-close-btn:hover {
      background: #cc0000;
      transform: scale(1.05);
    }
    
    /* Upgrade Screen */
    #upgradeScreen {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #1a0030 0%, #2a0050 100%);
      border: 4px solid #00ffff;
      border-radius: 20px;
      padding: 30px;
      display: none;
      flex-direction: column;
      align-items: center;
      z-index: 90;
      box-shadow: 0 0 50px rgba(0, 255, 255, 0.5);
    }
    #upgradeScreen.active { display: flex; }
    
    .upgrade-title {
      font-size: 32px;
      color: #ffff00;
      text-shadow: 0 0 20px #ffff00;
      margin-bottom: 10px;
    }
    .upgrade-subtitle {
      font-size: 16px;
      color: #00ffff;
      margin-bottom: 20px;
    }
    
    #upgradeOptions {
      display: flex;
      gap: 20px;
      flex-wrap: nowrap; /* Single row - all horizontal */
      justify-content: center;
      overflow-x: auto; /* Allow scroll if needed */
    }
    
    .upgrade-card {
      background: linear-gradient(135deg, #2a1a3a 0%, #3a2a4a 100%);
      border: 3px solid #00ffff;
      border-radius: 15px;
      padding: 20px;
      width: 180px; /* Slightly smaller for horizontal fit */
      min-width: 180px; /* Prevent shrinking */
      cursor: pointer;
      transition: all 0.3s;
    }
    .upgrade-card:hover {
      transform: translateY(-10px);
      box-shadow: 0 10px 30px rgba(0, 255, 255, 0.5);
      border-color: #ffff00;
    }
    
    .upgrade-card-icon {
      font-size: 48px;
      text-align: center;
      margin-bottom: 10px;
    }
    .upgrade-card-title {
      font-size: 18px;
      font-weight: bold;
      color: #ffff00;
      text-align: center;
      margin-bottom: 8px;
    }
    .upgrade-card-desc {
      font-size: 13px;
      color: #aaa;
      text-align: center;
    }
    
    .upgrade-card-skip {
      background: linear-gradient(135deg, #3a2a2a 0%, #4a3a3a 100%);
      border-color: #ff4444;
    }
    
    .upgrade-card-skip:hover {
      border-color: #ff8888;
      box-shadow: 0 10px 30px rgba(255, 68, 68, 0.5);
    }
    
    /* Pause Menu */
    #pauseMenu {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 200;
    }
    
    #pauseMenu.active {
      display: flex;
    }
    
    .pause-content {
      background: linear-gradient(135deg, #1a1a3a 0%, #2a1a3a 100%);
      border: 4px solid #00ffff;
      border-radius: 20px;
      padding: 40px;
      min-width: 600px;
      max-height: 90vh;
      overflow-y: auto;
    }
    
    .pause-title {
      font-size: 48px;
      color: #ffff00;
      text-align: center;
      margin-bottom: 30px;
      text-shadow: 0 0 20px #ffff00;
    }
    
    .pause-section {
      margin-bottom: 30px;
      padding: 20px;
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid #00ffff;
      border-radius: 15px;
    }
    
    .pause-section-title {
      font-size: 24px;
      color: #00ffff;
      margin-bottom: 15px;
      text-shadow: 0 0 10px #00ffff;
    }
    
    .pause-stat {
      font-size: 16px;
      color: #ffffff;
      margin: 8px 0;
      display: flex;
      justify-content: space-between;
    }
    
    .pause-stat-label {
      color: #aaaaaa;
    }
    
    .pause-stat-value {
      color: #ffff00;
      font-weight: bold;
    }
    
    .pause-slider {
      width: 100%;
      margin: 10px 0;
    }
    
    .pause-button {
      width: 100%;
      padding: 15px;
      margin: 10px 0;
      font-size: 18px;
      font-weight: bold;
      color: white;
      background: linear-gradient(135deg, #ff0080 0%, #ff8c00 100%);
      border: 3px solid #00ffff;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .pause-button:hover {
      transform: scale(1.05);
      box-shadow: 0 0 20px #00ffff;
    }
    
    .pause-button.danger {
      background: linear-gradient(135deg, #8B0000, #FF0000);
      border-color: #ff0000;
    }
    
    .pause-button.danger:hover {
      box-shadow: 0 0 20px #ff0000;
    }
    
    /* Round Break Screen */
    #roundBreakScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 80;
    }
    #roundBreakScreen.active { display: flex; }
    
    .break-title {
      font-size: 48px;
      color: #00ffff;
      text-shadow: 0 0 20px #00ffff;
      margin-bottom: 20px;
    }
    .break-info {
      font-size: 20px;
      color: #ffff00;
      text-align: center;
      line-height: 1.8;
    }
    .break-timer {
      font-size: 72px;
      color: #ff00ff;
      text-shadow: 0 0 30px #ff00ff;
      margin: 20px 0;
    }
    
    #gameOverScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      color: white;
    }
    #gameOverScreen.active { display: flex; }
    
    .gameover-title {
      font-size: 64px;
      color: #ff0000;
      text-shadow: 0 0 30px #ff0000;
      margin-bottom: 20px;
      animation: pulse 2s infinite;
    }
    
    .gameover-countdown {
      font-size: 18px;
      color: #ffff00;
      margin-bottom: 20px;
      padding: 10px 20px;
      background: rgba(255, 255, 0, 0.1);
      border: 2px solid #ffff00;
      border-radius: 20px;
      text-shadow: 0 0 10px #ffff00;
    }
    
    #countdownTimer {
      font-size: 24px;
      font-weight: bold;
      color: #ff0000;
    }
    
    .gameover-stats {
      background: rgba(20, 20, 20, 0.8);
      border: 3px solid #00ffff;
      border-radius: 15px;
      padding: 30px 50px;
      margin: 20px 0;
      min-width: 500px;
    }
    
    .gameover-stat-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 0;
      border-bottom: 1px solid rgba(0, 255, 255, 0.2);
      font-size: 20px;
    }
    
    .gameover-stat-row:last-child {
      border-bottom: none;
    }
    
    .gameover-stat-label {
      color: #00ffff;
      font-weight: bold;
    }
    
    .gameover-stat-value {
      color: #ffff00;
      font-size: 24px;
      font-weight: bold;
    }
    
    .gameover-earnings {
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(0, 255, 255, 0.2));
      border: 3px solid #ffff00;
      border-radius: 15px;
      padding: 25px 50px;
      margin: 20px 0;
      min-width: 500px;
    }
    
    .gameover-earnings-title {
      font-size: 28px;
      color: #ffff00;
      text-align: center;
      margin-bottom: 20px;
      text-shadow: 0 0 10px #ffff00;
    }
    
    .gameover-continue {
      margin-top: 30px;
      padding: 15px 40px;
      font-size: 20px;
      background: linear-gradient(135deg, #ff0000, #ff8800);
      color: white;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-weight: bold;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
      box-shadow: 0 4px 15px rgba(255, 0, 0, 0.5);
      transition: all 0.3s;
    }
    
    .gameover-continue:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 20px rgba(255, 0, 0, 0.7);
    }
    
    #statusText {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 24px;
      font-weight: bold;
      color: #ff0000;
      text-shadow: 0 0 10px #ff0000;
      text-align: center;
      z-index: 70;
      display: none;
      background: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border: 2px solid #ff0000;
      border-radius: 10px;
    }
    
    #potionBar {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: none; /* HIDDEN - Using canvas version instead */
      gap: 10px;
      z-index: 60;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px 20px;
      border-radius: 15px;
      border: 3px solid #00ffff;
    }
    
    .potion-slot {
      width: 60px;
      height: 70px;
      background: rgba(40, 40, 40, 0.9);
      border: 2px solid #666;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    
    .potion-slot:hover:not(.cooldown) {
      transform: scale(1.1);
      border-color: #00ffff;
      box-shadow: 0 0 15px #00ffff;
    }
    
    .potion-slot.cooldown {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .potion-icon {
      font-size: 32px;
      margin-bottom: 5px;
    }
    
    .potion-count {
      font-size: 14px;
      font-weight: bold;
      color: #ffff00;
      text-shadow: 0 0 5px #000;
    }
    
    .potion-key {
      position: absolute;
      top: 2px;
      left: 4px;
      font-size: 10px;
      color: #aaa;
      font-weight: bold;
    }
    
    .potion-cooldown-overlay {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.7);
      height: 100%;
      transition: height 0.1s;
    }
    
    .potion-effect-indicator {
      position: absolute;
      top: 70px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 255, 0, 0.8);
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 12px;
      color: white;
      white-space: nowrap;
      animation: pulse 1s infinite;
    }
    
    .back-arrow-btn {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #00ffff;
      color: #00ffff;
      font-size: 28px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s;
      z-index: 100;
    }
    
    .back-arrow-btn:hover {
      background: #00ffff;
      color: #000;
      transform: scale(1.1);
      box-shadow: 0 0 20px #00ffff;
    }
    
    .ability-btn {
      position: fixed;
      bottom: 150px;
      background: rgba(0, 0, 0, 0.8);
      border: 3px solid #ff00ff;
      color: #ffff00;
      padding: 15px 20px;
      border-radius: 10px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-weight: bold;
      font-size: 14px;
      transition: all 0.2s;
      min-width: 150px;
      text-align: center;
    }
    
    .ability-btn:hover:not(.cooldown) {
      transform: scale(1.05);
      box-shadow: 0 0 20px #ff00ff;
    }
    
    .ability-btn.cooldown {
      opacity: 0.5;
      cursor: not-allowed;
      border-color: #666;
    }
    
    .ability-btn.ready {
      border-color: #00ff00;
      animation: pulse 1s infinite;
    }
    
    #ability1Btn {
      right: 20px;
    }
    
    #ability2Btn {
      right: 190px;
    }
    
    /* Currency Conversion Button Hover Effects */
    button.shop-btn:hover {
      transform: scale(1.05) !important;
      box-shadow: 0 0 25px rgba(0,255,255,0.6) !important;
    }
    
    button.shop-btn:active {
      transform: scale(0.95) !important;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="1000" height="550"></canvas>
    
    <!-- Give Up Button (visible during gameplay) -->
    <button id="giveUpBtn" style="display: none; position: absolute; top: 10px; right: 180px; padding: 10px 20px; background: linear-gradient(135deg, #8B0000, #FF0000); color: white; font-family: 'Courier New', monospace; font-size: 14px; font-weight: bold; border: 2px solid #ff0000; border-radius: 8px; cursor: pointer; z-index: 100; box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);">
      ‚ùå GIVE UP
    </button>
    
    <!-- Title Screen -->
    <div id="titleScreen">
      <div class="title">EVOL LEGENDS</div>
      <div class="subtitle">‚öîÔ∏è TOWER DEFENSE ‚öîÔ∏è</div>
      <button class="start-btn" id="startBtn">START GAME</button>
      <button class="start-btn" id="waveSelectBtn" style="margin-top: 15px; font-size: 18px; padding: 12px 35px; background: linear-gradient(135deg, #00aaaa, #0066ff);">
        üéØ START FROM WAVE
      </button>
      <div style="margin-top: 30px; font-size: 14px; color: #888;">
        <div>üèÜ Highest Wave: <span id="highestWaveTitleDisplay">1</span></div>
        <div style="margin-top: 10px;">üí∞ <span id="totalCoinsDisplay">0</span> Coins | üíé <span id="totalGemsDisplay">0</span> Gems</div>
      </div>
      <button class="start-btn" id="shopBtn" style="margin-top: 20px; font-size: 20px; padding: 15px 40px;">üõí SHOP</button>
      <button class="start-btn" id="evolAuraBtn" style="margin-top: 10px; font-size: 20px; padding: 15px 40px; background: linear-gradient(135deg, #8B0000, #FF0000);">üåü EVOL AURA</button>
      <button class="start-btn" id="redeemCodeBtn" style="margin-top: 10px; font-size: 20px; padding: 15px 40px; background: linear-gradient(135deg, #ff6600, #ffaa00);">üéÅ REDEEM CODE</button>
      <button class="start-btn" id="tutorialBtn" style="margin-top: 10px; font-size: 20px; padding: 15px 40px; background: linear-gradient(135deg, #00aa00, #00ff00);">üìñ HOW TO PLAY</button>
    </div>
    
    <!-- Tutorial/How to Play Screen -->
    <div id="tutorialScreen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); display: none; flex-direction: column; align-items: center; justify-content: flex-start; z-index: 100; overflow-y: auto; padding: 40px 20px;">
      <button style="position: absolute; top: 20px; left: 20px; padding: 15px 30px; font-size: 24px; background: linear-gradient(135deg, #ff0080 0%, #ff8c00 100%); color: #fff; border: 3px solid #00ffff; border-radius: 10px; cursor: pointer; font-weight: bold;" id="tutorialBackBtn">‚Üê BACK</button>
      
      <div style="max-width: 1000px; width: 100%;">
        <h1 style="font-size: 48px; color: #00ffff; text-align: center; margin-bottom: 30px; text-shadow: 0 0 20px #00ffff;">üìñ HOW TO PLAY</h1>
        
        <!-- CONTROLS -->
        <div style="background: linear-gradient(135deg, #1a1a3a 0%, #2a1a3a 100%); border: 3px solid #00ffff; border-radius: 15px; padding: 25px; margin-bottom: 20px;">
          <h2 style="font-size: 32px; color: #ffff00; margin-bottom: 20px;">üéÆ CONTROLS</h2>
          <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; font-size: 16px; color: #fff;">
            <div><span style="color: #00ff00; font-weight: bold;">[1-6]</span> - Use Potions (Heal, Shield, Crit, Damage, Speed, Dragon)</div>
            <div><span style="color: #00ff00; font-weight: bold;">[Q]</span> - Ultimate Ability 1</div>
            <div><span style="color: #00ff00; font-weight: bold;">[E]</span> - Ultimate Ability 2</div>
            <div><span style="color: #00ff00; font-weight: bold;">[T]</span> - Toggle Auto-Shoot (ON/OFF)</div>
            <div><span style="color: #00ff00; font-weight: bold;">[Y]</span> - Toggle Auto-Aim (ON/OFF)</div>
            <div><span style="color: #00ff00; font-weight: bold;">[R]</span> - Toggle Auto-Start Waves</div>
            <div><span style="color: #00ff00; font-weight: bold;">[F]</span> - Fast-Forward Mode (1x/2x Speed)</div>
            <div><span style="color: #00ff00; font-weight: bold;">[SPACE]</span> - Start Next Wave Manually</div>
          </div>
        </div>
        
        <!-- GAMEPLAY -->
        <div style="background: linear-gradient(135deg, #1a1a3a 0%, #2a1a3a 100%); border: 3px solid #ff00ff; border-radius: 15px; padding: 25px; margin-bottom: 20px;">
          <h2 style="font-size: 32px; color: #ff00ff; margin-bottom: 20px;">‚öîÔ∏è GAMEPLAY</h2>
          <div style="font-size: 16px; color: #fff; line-height: 1.8;">
            <p style="margin-bottom: 15px;">üéØ <strong>OBJECTIVE:</strong> Defend your tower from endless waves of enemies! Survive as long as possible and reach the highest wave.</p>
            <p style="margin-bottom: 15px;">üí∞ <strong>CURRENCY:</strong> Collect coins and gems from defeated enemies. Use them in the shop to unlock new classes and permanent upgrades.</p>
            <p style="margin-bottom: 15px;">‚≠ê <strong>LEVEL UP:</strong> Gain XP from kills to level up and choose powerful upgrades during battle.</p>
            <p style="margin-bottom: 15px;">üß™ <strong>POTIONS:</strong> Use potions (bottom bar) to heal, gain shields, or boost your abilities. They refill each wave!</p>
            <p style="margin-bottom: 15px;">üåü <strong>SKILL TREE:</strong> Unlock 2 ultimate abilities per class by reaching Level 10. Each class has 20 powerful options!</p>
          </div>
        </div>
        
        <!-- ENEMIES -->
        <div style="background: linear-gradient(135deg, #1a1a3a 0%, #2a1a3a 100%); border: 3px solid #ff0000; border-radius: 15px; padding: 25px; margin-bottom: 20px;">
          <h2 style="font-size: 32px; color: #ff0000; margin-bottom: 20px;">üëæ ENEMY TYPES</h2>
          <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; font-size: 16px; color: #fff;">
            <div><span style="color: #ffff00;">üî∫ SPEEDY</span> - Fast moving triangles</div>
            <div><span style="color: #00ff00;">üîµ HEALER</span> - Circles that heal nearby enemies</div>
            <div><span style="color: #ff8800;">üî∂ JUMPER</span> - Teleports toward you</div>
            <div><span style="color: #ff0000;">üí£ KAMIKAZE</span> - Explodes on contact!</div>
            <div><span style="color: #8800ff;">üéØ SHOOTER</span> - Fires projectiles from range</div>
            <div><span style="color: #ff00ff;">üëë MINI-BOSS</span> - Every 5 waves (larger, tougher)</div>
            <div><span style="color: #ff0000;">üíÄ BOSS</span> - Every 10 waves (huge health pool, special attacks)</div>
          </div>
        </div>
        
        <!-- TIPS -->
        <div style="background: linear-gradient(135deg, #1a1a3a 0%, #2a1a3a 100%); border: 3px solid #00ff00; border-radius: 15px; padding: 25px;">
          <h2 style="font-size: 32px; color: #00ff00; margin-bottom: 20px;">üí° PRO TIPS</h2>
          <div style="font-size: 16px; color: #fff; line-height: 1.8;">
            <p style="margin-bottom: 10px;">‚úÖ Use <strong>Auto-Start Waves</strong> [R] + <strong>Fast-Forward</strong> [F] to farm early waves quickly!</p>
            <p style="margin-bottom: 10px;">‚úÖ <strong>Prioritize</strong> kamikazes and healers first - they're the most dangerous!</p>
            <p style="margin-bottom: 10px;">‚úÖ Save your <strong>Dragon Beam</strong> potion [6] for tough bosses</p>
            <p style="margin-bottom: 10px;">‚úÖ Unlock the <strong>Evol Aura</strong> system for powerful permanent bonuses</p>
            <p style="margin-bottom: 10px;">‚úÖ Try different classes! Each has unique abilities and playstyles</p>
            <p style="margin-bottom: 10px;">‚úÖ The <strong>Vecna</strong> class is ultra-rare - unlock it from the shop for a challenge!</p>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Redeem Code Screen -->
    <div id="redeemCodeScreen" style="display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(135deg, #1a0a00 0%, #2a1500 100%); z-index: 100; overflow-y: auto; padding: 50px 20px;">
      <button style="position: absolute; top: 20px; left: 20px; padding: 15px 30px; font-size: 24px; background: linear-gradient(135deg, #ff0080 0%, #ff8c00 100%); color: #fff; border: 3px solid #00ffff; border-radius: 10px; cursor: pointer; font-weight: bold;" id="redeemBackBtn">‚Üê BACK</button>
      
      <div style="max-width: 800px; margin: 0 auto; text-align: center;">
        <h1 style="font-size: 56px; color: #ffaa00; margin-bottom: 20px; text-shadow: 0 0 20px #ff6600;">üéÅ REDEEM CODE</h1>
        <p style="font-size: 20px; color: #ffcc66; margin-bottom: 40px;">Enter special codes to unlock characters, coins, and gems!</p>
        
        <!-- Redeem Input -->
        <div style="background: rgba(0, 0, 0, 0.6); border: 3px solid #ffaa00; border-radius: 15px; padding: 30px; margin-bottom: 30px;">
          <input type="text" id="redeemCodeInput" placeholder="Enter code here..." style="width: 100%; max-width: 500px; padding: 20px; font-size: 24px; text-align: center; background: rgba(255, 255, 255, 0.1); border: 2px solid #ff6600; border-radius: 10px; color: #fff; font-family: 'Courier New', monospace; text-transform: uppercase;" />
          <button id="redeemSubmitBtn" style="margin-top: 20px; padding: 20px 50px; font-size: 24px; background: linear-gradient(135deg, #ff6600, #ffaa00); color: #fff; border: 3px solid #ffd700; border-radius: 10px; cursor: pointer; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">‚ú® REDEEM ‚ú®</button>
        </div>
        
        <!-- Result Message -->
        <div id="redeemResult" style="min-height: 80px; font-size: 20px; color: #fff; margin-bottom: 30px;"></div>
        
        <!-- Redeemed Codes History -->
        <div style="background: rgba(0, 0, 0, 0.6); border: 3px solid #ffaa00; border-radius: 15px; padding: 30px;">
          <h2 style="font-size: 32px; color: #ffaa00; margin-bottom: 20px;">üìú REDEEMED CODES</h2>
          <div id="redeemedCodesList" style="font-size: 18px; color: #ffcc66; max-height: 300px; overflow-y: auto;">
            <p style="color: #888;">No codes redeemed yet...</p>
          </div>
        </div>
        
        <!-- Hints -->
        <div style="margin-top: 30px; padding: 20px; background: rgba(255, 170, 0, 0.1); border: 2px solid #ffaa00; border-radius: 10px;">
          <p style="color: #ffcc66; font-size: 16px;">üí° <strong>Tip:</strong> Codes are case-insensitive and can only be used once!</p>
          <p style="color: #ffcc66; font-size: 16px; margin-top: 10px;">üéÆ <strong>Hint:</strong> Try words related to the game, characters, or special events!</p>
        </div>
      </div>
    </div>
    
    <!-- Class Selection Screen -->
    <div id="classSelection">
      <div class="class-title">SELECT YOUR LEGEND</div>
      <div class="class-subtitle">Choose your class to defend the tower!</div>
      <div class="class-grid" id="classGrid"></div>
    </div>
    
    <!-- Wave Selection Screen -->
    <div id="waveSelectionScreen" style="display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2a 100%); z-index: 100; overflow-y: auto; padding: 50px 20px;">
      <button class="back-arrow-btn" id="waveSelectBackBtn" onclick="closeWaveSelect()">‚Üê</button>
      
      <div style="text-align: center; margin-bottom: 30px;">
        <div style="font-size: 48px; font-weight: bold; color: #00ffff; text-shadow: 0 0 20px #00ffff; margin-bottom: 10px;">
          üéØ SELECT STARTING WAVE
        </div>
        <div style="font-size: 20px; color: #ffff00;">
          Highest Wave Reached: <span id="highestWaveDisplay" style="font-weight: bold;">1</span>
        </div>
        <div style="font-size: 16px; color: #aaa; margin-top: 10px;">
          Start from any wave you've reached before
        </div>
      </div>
      
      <div id="waveGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; max-width: 1200px; margin: 0 auto; padding: 20px;">
        <!-- Wave buttons will be populated by JavaScript -->
      </div>
      
      <div style="text-align: center; margin-top: 40px;">
        <button onclick="closeWaveSelect()" style="padding: 15px 40px; font-size: 18px; font-weight: bold; background: linear-gradient(135deg, #ff0000, #aa0000); border: none; border-radius: 10px; color: white; cursor: pointer; box-shadow: 0 4px 15px rgba(255,0,0,0.4);">
          ‚ùå CANCEL
        </button>
      </div>
    </div>
    
    <!-- Unlock Requirements Modal -->
    <div id="unlockModal">
      <div class="unlock-modal-content">
        <div class="unlock-modal-icon" id="unlockModalIcon">üîí</div>
        <div class="unlock-modal-title" id="unlockModalTitle">Class Locked</div>
        <div class="unlock-modal-requirement" id="unlockModalRequirement">Complete the challenge to unlock!</div>
        <div class="unlock-modal-desc" id="unlockModalDesc">More details here...</div>
        <button class="unlock-modal-close" id="unlockModalClose">‚úñ CLOSE</button>
      </div>
    </div>
    
    <!-- Shop Screen -->
    <div id="shopScreen">
      <button class="back-arrow-btn" id="shopBackBtn">‚Üê</button>
      <div class="shop-header">
        <div class="shop-title">üõí PERMANENT UPGRADES</div>
        <div class="shop-currency">
          <div>üí∞ Coins: <span id="shopCoins">0</span></div>
          <div>üíé Gems: <span id="shopGems">0</span></div>
        </div>
      </div>
      <div class="shop-grid" id="shopGrid"></div>
      
      <!-- Currency Exchange Section -->
      <div style="margin: 30px auto; padding: 25px; background: linear-gradient(135deg, rgba(0,100,200,0.2), rgba(100,0,200,0.2)); border: 3px solid #00ffff; border-radius: 15px; max-width: 600px; box-shadow: 0 0 30px rgba(0,255,255,0.3);">
        <div style="text-align: center; margin-bottom: 20px;">
          <div style="font-size: 28px; font-weight: bold; color: #00ffff; text-shadow: 0 0 10px #00ffff;">üí± CURRENCY EXCHANGE</div>
          <div style="font-size: 14px; color: #aaa; margin-top: 5px;">Convert between Coins and Gems</div>
        </div>
        
        <div style="display: flex; gap: 20px; justify-content: center; flex-wrap: wrap;">
          <button class="shop-btn" onclick="convertGemsToCoins()" 
                  style="flex: 1; min-width: 200px; padding: 20px; background: linear-gradient(135deg, #00ffff, #0088ff); border: none; border-radius: 10px; cursor: pointer; font-size: 16px; font-weight: bold; color: white; transition: transform 0.2s, box-shadow 0.2s;">
            <div style="font-size: 32px; margin-bottom: 8px;">üíé ‚Üí üí∞</div>
            <div>Gems to Coins</div>
            <div style="font-size: 13px; opacity: 0.9; margin-top: 5px;">1 Gem = 100 Coins</div>
          </button>
          
          <button class="shop-btn" onclick="convertCoinsToGems()" 
                  style="flex: 1; min-width: 200px; padding: 20px; background: linear-gradient(135deg, #ffd700, #ff8800); border: none; border-radius: 10px; cursor: pointer; font-size: 16px; font-weight: bold; color: white; transition: transform 0.2s, box-shadow 0.2s;">
            <div style="font-size: 32px; margin-bottom: 8px;">üí∞ ‚Üí üíé</div>
            <div>Coins to Gems</div>
            <div style="font-size: 13px; opacity: 0.9; margin-top: 5px;">100 Coins = 1 Gem</div>
          </button>
        </div>
        
        <div style="margin-top: 20px; text-align: center; font-size: 16px; color: #ffff00;">
          Your Currency: 
          <span style="color: #ffd700; font-weight: bold;">üí∞ <span id="shopCoinsDisplay2">0</span></span> | 
          <span style="color: #00ffff; font-weight: bold;">üíé <span id="shopGemsDisplay2">0</span></span>
        </div>
      </div>
    </div>
    
    <!-- Evol Aura Screen -->
    <div id="evolAuraScreen" style="display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.95); z-index: 50; overflow-y: auto;">
      <button class="back-arrow-btn" id="auraBackBtn">‚Üê</button>
      <div class="shop-header">
        <div class="shop-title">üåü EVOL AURA - SKILL TREES</div>
        <div class="shop-currency">
          <div>üí∞ Coins: <span id="auraCoins">0</span></div>
          <div>üíé Gems: <span id="auraGems">0</span></div>
        </div>
      </div>
      <div id="classTabsContainer" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin: 20px auto; max-width: 900px;">
      </div>
      <div class="shop-grid" id="auraSkillGrid" style="padding-bottom: 50px;"></div>
    </div>
    
    <!-- Upgrade Screen -->
    <div id="upgradeScreen">
      <div class="upgrade-title">üéâ LEVEL UP!</div>
      <div class="upgrade-subtitle" id="upgradeSubtitle">Choose Your Power-Up</div>
      <div id="upgradeOptions"></div>
      <button class="shop-close-btn" id="shuffleBtn" style="margin-top: 20px; background: #0088ff; font-size: 16px; padding: 10px 30px;">
        üîÑ SHUFFLE (<span id="shuffleCount">4</span> left)
      </button>
      <button class="shop-close-btn" id="skipUpgradeBtn" style="margin-top: 10px; background: #ff4444; font-size: 14px; padding: 8px 20px; display: none;">
        ‚ùå SKIP / CLOSE
      </button>
    </div>
    
    <!-- Pause Menu -->
    <div id="pauseMenu">
      <div class="pause-content">
        <div class="pause-title">‚è∏Ô∏è PAUSED</div>
        
        <!-- Character Stats -->
        <div class="pause-section">
          <div class="pause-section-title">üìä Character Stats</div>
          <div id="pauseStats"></div>
        </div>
        
        <!-- Settings -->
        <div class="pause-section">
          <div class="pause-section-title">‚öôÔ∏è Settings</div>
          
          <div class="pause-stat">
            <span>üîÜ Brightness</span>
            <span id="brightnessValue">100%</span>
          </div>
          <input type="range" class="pause-slider" id="brightnessSlider" 
                 min="50" max="150" value="100">
          
          <div class="pause-stat">
            <span>üîä Volume</span>
            <span id="volumeValue">100%</span>
          </div>
          <input type="range" class="pause-slider" id="volumeSlider" 
                 min="0" max="100" value="100">
        </div>
        
        <!-- Buttons -->
        <button class="pause-button" id="resumeBtn">‚ñ∂Ô∏è RESUME</button>
        <button class="pause-button danger" id="returnLobbyBtn">üè† RETURN HOME</button>
      </div>
    </div>
    
    <!-- Round Break Screen -->
    <div id="roundBreakScreen">
      <div class="break-title" id="breakTitle">WAVE COMPLETE!</div>
      <div class="break-timer" id="breakTimer">20</div>
      <div class="break-info" id="breakInfo">
        Prepare for the next wave!<br>
        <br>Press SPACE to start immediately
      </div>
    </div>
    
    <!-- Game Over Screen -->
    <div id="gameOverScreen">
      <button class="back-arrow-btn" id="gameOverBackBtn">‚Üê</button>
      <div class="gameover-title">üíÄ GAME OVER üíÄ</div>
      
      <div class="gameover-countdown" id="gameOverCountdown">Returning to home in <span id="countdownTimer">10</span>s...</div>
      
      <div class="gameover-stats">
        <div class="gameover-stat-row">
          <span class="gameover-stat-label">üåä Wave Reached:</span>
          <span class="gameover-stat-value" id="finalWave">1</span>
        </div>
        <div class="gameover-stat-row">
          <span class="gameover-stat-label">‚≠ê Level Reached:</span>
          <span class="gameover-stat-value" id="finalLevel">1</span>
        </div>
        <div class="gameover-stat-row">
          <span class="gameover-stat-label">üíÄ Enemies Killed:</span>
          <span class="gameover-stat-value" id="finalKills">0</span>
        </div>
        <div class="gameover-stat-row">
          <span class="gameover-stat-label">üî• Max Combo:</span>
          <span class="gameover-stat-value" id="finalCombo">0</span>
        </div>
      </div>
      
      <div class="gameover-earnings">
        <div class="gameover-earnings-title">üí∞ RUN EARNINGS üí∞</div>
        <div class="gameover-stat-row">
          <span class="gameover-stat-label">üí∞ Coins Earned:</span>
          <span class="gameover-stat-value" style="color: #ffff00;" id="earnedCoins">0</span>
        </div>
        <div class="gameover-stat-row">
          <span class="gameover-stat-label">üíé Gems Earned:</span>
          <span class="gameover-stat-value" style="color: #00ffff;" id="earnedGems">0</span>
        </div>
        <div class="gameover-stat-row" style="border-top: 2px solid rgba(255, 255, 255, 0.3); margin-top: 10px; padding-top: 15px;">
          <span class="gameover-stat-label">üí∞ Total Coins:</span>
          <span class="gameover-stat-value" style="color: #ffff00;" id="totalCoinsNow">0</span>
        </div>
        <div class="gameover-stat-row">
          <span class="gameover-stat-label">üíé Total Gems:</span>
          <span class="gameover-stat-value" style="color: #00ffff;" id="totalGemsNow">0</span>
        </div>
      </div>
      
      <div style="display: flex; gap: 15px; width: 100%; max-width: 400px;">
        <button class="gameover-continue" id="retryBtn" style="flex: 1;">üîÑ RETRY</button>
        <button class="gameover-continue" id="continueBtn" style="flex: 1;">üè† RETURN HOME</button>
      </div>
    </div>
    
    <!-- Potion Bar -->
    <div id="potionBar">
      <div class="potion-slot" id="potionHeal" data-key="1">
        <div class="potion-key">1</div>
        <div class="potion-icon">‚ù§Ô∏è</div>
        <div class="potion-count" id="countHeal">3</div>
        <div class="potion-cooldown-overlay" id="cdHeal" style="height: 0%"></div>
      </div>
      <div class="potion-slot" id="potionShield" data-key="2">
        <div class="potion-key">2</div>
        <div class="potion-icon">üõ°Ô∏è</div>
        <div class="potion-count" id="countShield">2</div>
        <div class="potion-cooldown-overlay" id="cdShield" style="height: 0%"></div>
      </div>
      <div class="potion-slot" id="potionCrit" data-key="3">
        <div class="potion-key">3</div>
        <div class="potion-icon">üí•</div>
        <div class="potion-count" id="countCrit">1</div>
        <div class="potion-cooldown-overlay" id="cdCrit" style="height: 0%"></div>
      </div>
      <div class="potion-slot" id="potionDamage" data-key="4">
        <div class="potion-key">4</div>
        <div class="potion-icon">‚öîÔ∏è</div>
        <div class="potion-count" id="countDamage">1</div>
        <div class="potion-cooldown-overlay" id="cdDamage" style="height: 0%"></div>
      </div>
      <div class="potion-slot" id="potionSpeed" data-key="5">
        <div class="potion-key">5</div>
        <div class="potion-icon">‚ö°</div>
        <div class="potion-count" id="countSpeed">1</div>
        <div class="potion-cooldown-overlay" id="cdSpeed" style="height: 0%"></div>
      </div>
      <div class="potion-slot" id="potionDragon" data-key="6">
        <div class="potion-key">6</div>
        <div class="potion-icon">üêâ</div>
        <div class="potion-count" id="countDragon">1</div>
        <div class="potion-cooldown-overlay" id="cdDragon" style="height: 0%"></div>
      </div>
      <div class="potion-slot" id="potionCleanse" data-key="7">
        <div class="potion-key">7</div>
        <div class="potion-icon">‚ú®</div>
        <div class="potion-count" id="countCleanse">2</div>
        <div class="potion-cooldown-overlay" id="cdCleanse" style="height: 0%"></div>
      </div>
    </div>
    
    <!-- Ultimate Ability Buttons -->
    <div id="ability1Btn" class="ability-btn" style="display: none;">
      <div style="font-size: 24px; margin-bottom: 5px;" id="ability1Icon">üéØ</div>
      <div id="ability1Name">Ability 1</div>
      <div style="font-size: 12px; margin-top: 3px;" id="ability1Key">[Q]</div>
      <div style="font-size: 16px; margin-top: 5px; color: #00ff00;" id="ability1CD"></div>
    </div>
    
    <div id="ability2Btn" class="ability-btn" style="display: none;">
      <div style="font-size: 24px; margin-bottom: 5px;" id="ability2Icon">üì¶</div>
      <div id="ability2Name">Ability 2</div>
      <div style="font-size: 12px; margin-top: 3px;" id="ability2Key">[E]</div>
      <div style="font-size: 16px; margin-top: 5px; color: #00ff00;" id="ability2CD"></div>
    </div>
    
    <div id="statusText"></div>
  </div>

  <script>
    // ===============================================
    // üß™ TEST MODE - ALL CLASSES UNLOCKED
    // ===============================================
    const TEST_MODE = true; // Set to false for normal game
    
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    
    const titleScreen = document.getElementById("titleScreen");
    const startBtn = document.getElementById("startBtn");
    const shopBtn = document.getElementById("shopBtn");
    const tutorialBtn = document.getElementById("tutorialBtn");
    const tutorialScreen = document.getElementById("tutorialScreen");
    const tutorialBackBtn = document.getElementById("tutorialBackBtn");
    const classSelection = document.getElementById("classSelection");
    const classGrid = document.getElementById("classGrid");
    const unlockModal = document.getElementById("unlockModal");
    const unlockModalIcon = document.getElementById("unlockModalIcon");
    const unlockModalTitle = document.getElementById("unlockModalTitle");
    const unlockModalRequirement = document.getElementById("unlockModalRequirement");
    const unlockModalDesc = document.getElementById("unlockModalDesc");
    const unlockModalClose = document.getElementById("unlockModalClose");
    const shopScreen = document.getElementById("shopScreen");
    const shopGrid = document.getElementById("shopGrid");
    const shopCloseBtn = document.getElementById("shopCloseBtn");
    const redeemCodeScreen = document.getElementById("redeemCodeScreen");
    const redeemCodeInput = document.getElementById("redeemCodeInput");
    const redeemSubmitBtn = document.getElementById("redeemSubmitBtn");
    const redeemResults = document.getElementById("redeemResults");
    const upgradeScreen = document.getElementById("upgradeScreen");
    const upgradeSubtitle = document.getElementById("upgradeSubtitle");
    const upgradeOptions = document.getElementById("upgradeOptions");
    const shuffleBtn = document.getElementById("shuffleBtn");
    const shuffleCount = document.getElementById("shuffleCount");
    const skipUpgradeBtn = document.getElementById("skipUpgradeBtn");
    const roundBreakScreen = document.getElementById("roundBreakScreen");
    const breakTitle = document.getElementById("breakTitle");
    const breakTimer = document.getElementById("breakTimer");
    const breakInfo = document.getElementById("breakInfo");
    const gameOverScreen = document.getElementById("gameOverScreen");
    const finalWave = document.getElementById("finalWave");
    const finalLevel = document.getElementById("finalLevel");
    const finalKills = document.getElementById("finalKills");
    const finalCombo = document.getElementById("finalCombo");
    const earnedCoins = document.getElementById("earnedCoins");
    const earnedGems = document.getElementById("earnedGems");
    const totalCoinsNow = document.getElementById("totalCoinsNow");
    const totalGemsNow = document.getElementById("totalGemsNow");
    const continueBtn = document.getElementById("continueBtn");
    const retryBtn = document.getElementById("retryBtn");
    const gameOverBackBtn = document.getElementById("gameOverBackBtn");
    const countdownTimer = document.getElementById("countdownTimer");
    const giveUpBtn = document.getElementById("giveUpBtn");
    const statusText = document.getElementById("statusText");
    const highestWaveDisplay = document.getElementById("highestWaveDisplay");
    const totalCoinsDisplay = document.getElementById("totalCoinsDisplay");
    const totalGemsDisplay = document.getElementById("totalGemsDisplay");
    const shopCoins = document.getElementById("shopCoins");
    const shopGems = document.getElementById("shopGems");

    // GAME CONSTANTS
    const GROUND_Y = 470;
    const ROUND_BREAK_TIME = 20;
    const PLAYER_X = 100; // Fixed position

    // PERSISTENT DATA (localStorage)
    let gameData = {
      highestWave: 1,
      totalCoins: 0,
      totalGems: 0,
      unlockedWaves: [1], // Waves player can start from
      shieldUpgradesChosen: 0, // Track for Guardian Tank unlock
      permanentUpgrades: {
        damage: 0,
        health: 0,
        fireRate: 0,
        critChance: 0,
        startLevel: 0
      },
      potionUpgrades: {
        healStrength: 0,
        shieldStrength: 0,
        effectStrength: 0,
        dragonStrength: 0,
        startingHeals: 0,
        startingShields: 0,
        startingOthers: 0,
        potionGen: 0,
        potionDamage: 0,
        potionExplosion: 0
      },
      unlockedClasses: ["Hunter", "Rookie"], // Rookie available from start
      purchasedClasses: [], // Track purchased classes separately
      skillTrees: {}, // Track unlocked abilities for each class
      wave18Restarts: 0, // Track restarts at wave 18 for Dr.Sunshine unlock
      redeemedCodes: [] // Track which codes have been redeemed
    };

    // Load saved data
    function loadGameData() {
      const saved = localStorage.getItem("evolLegendsData");
      if (saved) {
        gameData = JSON.parse(saved);
        
        // Ensure potionUpgrades exists (for backward compatibility)
        if (!gameData.potionUpgrades) {
          gameData.potionUpgrades = {
            healStrength: 0,
            shieldStrength: 0,
            effectStrength: 0,
            dragonStrength: 0,
            startingHeals: 0,
            startingShields: 0,
            startingOthers: 0,
            potionGen: 0,
            potionDamage: 0,
            potionExplosion: 0
          };
        }
        
        // Ensure skillTrees exists (for future compatibility)
        if (!gameData.skillTrees) {
          gameData.skillTrees = {};
        }
        
        // Ensure unlockedWaves exists
        if (!gameData.unlockedWaves) {
          gameData.unlockedWaves = [1];
          // Unlock all waves up to highest wave
          for (let w = 1; w <= gameData.highestWave; w++) {
            if (!gameData.unlockedWaves.includes(w)) {
              gameData.unlockedWaves.push(w);
            }
          }
        }
        
        // Ensure shieldUpgradesChosen exists
        if (gameData.shieldUpgradesChosen === undefined) {
          gameData.shieldUpgradesChosen = 0;
        }
        
        // Ensure Rookie is unlocked
        if (!gameData.unlockedClasses.includes("Rookie")) {
          gameData.unlockedClasses.push("Rookie");
        }
        
        // Ensure redeemedCodes exists
        if (!gameData.redeemedCodes) {
          gameData.redeemedCodes = [];
        }
      }
      
      // ===============================================
      // üß™ TEST MODE: Extra currency for testing
      // ===============================================
      if (TEST_MODE) {
        console.log("üß™ TEST MODE ENABLED - Adding bonus currency!");
        
        // Give extra currency for testing (but don't unlock everything)
        gameData.totalCoins += 1000;
        gameData.totalGems += 50;
        
        console.log("üí∞ Bonus currency added!");
      }
      
      updateTitleScreenDisplay();
    }

    function saveGameData() {
      localStorage.setItem("evolLegendsData", JSON.stringify(gameData));
      updateTitleScreenDisplay();
    }

    function updateTitleScreenDisplay() {
      highestWaveDisplay.textContent = gameData.highestWave;
      const highestWaveTitleDisplay = document.getElementById('highestWaveTitleDisplay');
      if (highestWaveTitleDisplay) {
        highestWaveTitleDisplay.textContent = gameData.highestWave;
      }
      totalCoinsDisplay.textContent = gameData.totalCoins;
      totalGemsDisplay.textContent = gameData.totalGems;
      shopCoins.textContent = gameData.totalCoins;
      shopGems.textContent = gameData.totalGems;
      
      // IMPORTANT: Check if any classes should be unlocked based on highestWave
      // This ensures classes unlock even if the player already reached the wave
      let classesUnlocked = false;
      Object.entries(CLASSES).forEach(([name, data]) => {
        if (!data.purchasable && !data.challengeUnlock && !data.achievementUnlock && 
            data.unlockWave && gameData.highestWave >= data.unlockWave && 
            !gameData.unlockedClasses.includes(name)) {
          gameData.unlockedClasses.push(name);
          classesUnlocked = true;
          console.log(`üîì AUTO-UNLOCKED: ${name} (Wave ${data.unlockWave}) - You've reached wave ${gameData.highestWave}!`);
        }
      });
      
      if (classesUnlocked) {
        saveGameData(); // Save the newly unlocked classes
      }
    }

    // POTION SYSTEM
    function resetPotions() {
      // Base amounts + upgrades
      potions.heal = 3 + gameData.potionUpgrades.startingHeals;
      potions.shield = 2 + gameData.potionUpgrades.startingShields;
      potions.crit = 1 + gameData.potionUpgrades.startingOthers;
      potions.damage = 1 + gameData.potionUpgrades.startingOthers;
      potions.speed = 1 + gameData.potionUpgrades.startingOthers;
      potions.dragon = 1 + gameData.potionUpgrades.startingOthers;
      potions.cleanse = 2 + gameData.potionUpgrades.startingOthers;
      
      // Potion generation chance (10% per level)
      const genChance = gameData.potionUpgrades.potionGen * 0.1;
      if (Math.random() < genChance) {
        const types = ['heal', 'shield', 'crit', 'damage', 'speed', 'dragon'];
        const randomType = types[Math.floor(Math.random() * types.length)];
        potions[randomType]++;
        addFloatingText(player.x + player.w / 2, player.y - 50, "Bonus Potion!", "#ff00ff");
      }
      
      updatePotionDisplay();
    }
    
    function updatePotionDisplay() {
      document.getElementById('countHeal').textContent = potions.heal;
      document.getElementById('countShield').textContent = potions.shield;
      document.getElementById('countCrit').textContent = potions.crit;
      document.getElementById('countDamage').textContent = potions.damage;
      document.getElementById('countSpeed').textContent = potions.speed;
      document.getElementById('countDragon').textContent = potions.dragon;
      document.getElementById('countCleanse').textContent = potions.cleanse;
    }
    
    function usePotion(type) {
      if (!player || !player.alive) return;
      if (potions[type] <= 0) return;
      if (potionCooldowns[type] > 0) return;
      
      potions[type]--;
      potionCooldowns[type] = 1.0; // 1 second cooldown
      
      // Apply effects based on type
      switch(type) {
        case 'heal':
          const healAmount = 50 + (gameData.potionUpgrades.healStrength * 20);
          player.hp = Math.min(player.hp + healAmount, player.maxHP);
          addFloatingText(player.x + player.w / 2, player.y - 30, "+" + healAmount + " HP", "#00ff00");
          spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#00ff00", 10);
          break;
          
        case 'shield':
          const shieldAmount = 50 + (gameData.potionUpgrades.shieldStrength * 25);
          if (player.maxShield === 0) player.maxShield = shieldAmount;
          player.shield = Math.min(player.shield + shieldAmount, player.maxShield);
          addFloatingText(player.x + player.w / 2, player.y - 30, "+" + shieldAmount + " Shield", "#00aaff");
          spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#00aaff", 10);
          break;
          
        case 'crit':
          const critBonus = 0.25 + (gameData.potionUpgrades.effectStrength * 0.1);
          potionEffects.critActive = true;
          potionEffects.critTimer = 10; // 10 seconds
          player.critChance += critBonus;
          addFloatingText(player.x + player.w / 2, player.y - 30, "Crit Boost!", "#ff0000");
          spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#ff0000", 10);
          break;
          
        case 'damage':
          const damageBonus = 10 + (gameData.potionUpgrades.effectStrength * 5);
          potionEffects.damageActive = true;
          potionEffects.damageTimer = 10; // 10 seconds
          player.damage += damageBonus;
          addFloatingText(player.x + player.w / 2, player.y - 30, "Damage Boost!", "#ff8800");
          spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#ff8800", 10);
          break;
          
        case 'speed':
          const speedBonus = 0.15 + (gameData.potionUpgrades.effectStrength * 0.05);
          potionEffects.speedActive = true;
          potionEffects.speedTimer = 10; // 10 seconds
          player.fireRate *= (1 - speedBonus);
          addFloatingText(player.x + player.w / 2, player.y - 30, "Speed Boost!", "#ffff00");
          spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, "#ffff00", 10);
          break;
          
        case 'dragon':
          useDragonBeam();
          break;
        case 'cleanse':
          // Remove all debuffs
          playerDebuffs.cursed = false;
          playerDebuffs.cursedTimer = 0;
          playerDebuffs.poisoned = false;
          playerDebuffs.poisonedTimer = 0;
          playerDebuffs.poisonDamage = 0;
          
          const healStrength = 20 + (gameData.potionUpgrades.healStrength * 5);
          player.hp = Math.min(player.hp + healStrength, player.maxHP);
          addFloatingText(player.x + player.w / 2, player.y - 40, "‚ú® CLEANSED! +" + healStrength, "#FFD700");
          break;
      }
      
      // Potion explosion damage upgrade
      if (gameData.potionUpgrades.potionExplosion > 0 && enemies.length > 0) {
        const randomEnemy = enemies[Math.floor(Math.random() * enemies.length)];
        const explosionDamage = 30 * gameData.potionUpgrades.potionExplosion;
        randomEnemy.hp -= explosionDamage;
        spawnExplosion(randomEnemy.x + randomEnemy.w / 2, randomEnemy.y + randomEnemy.h / 2, "#ff00ff", 15);
        addFloatingText(randomEnemy.x + randomEnemy.w / 2, randomEnemy.y - 20, "-" + explosionDamage, "#ff00ff");
      }
      
      updatePotionDisplay();
      screenShake += 3;
    }
    
    function useDragonBeam() {
      const dragonDamage = (player.damage * 3) + (gameData.potionUpgrades.dragonStrength * 20);
      
      addFloatingText(canvas.width / 2, 200, "üêâ DRAGON BEAM! üêâ", "#ff00ff");
      screenShake += 25;
      
      // Create single massive laser beam that goes across the entire screen
      projectiles.push({
        x: player.x + player.w / 2,
        y: player.y + player.h / 2,
        vx: 30, // Very fast to cross screen
        vy: 0,
        radius: 30, // Wide beam
        damage: dragonDamage,
        color: "#ff4400",
        glowColor: "#ff8800",
        life: 3,
        trail: [],
        pierce: true,
        pierceCount: 0,
        explosive: false,
        isCrit: true,
        critMultiplier: 2.0,
        isDragonBeam: true,
        isEnemyProjectile: false
      });
      
      // Create fire zones along the ground that last 5 seconds with DOT
      const startX = player.x + player.w / 2;
      const y = GROUND_Y - 20; // On the ground
      const numZones = 25; // Create zones across screen
      
      for (let i = 0; i < numZones; i++) {
        const x = startX + (i * 40); // Space them out
        
        // Create fire zone that damages enemies
        fireZones.push({
          x: x,
          y: y,
          radius: 50,
          damage: dragonDamage * 0.2, // 20% of beam damage per second
          life: 5, // Lasts 5 seconds
          color: "#ff4400"
        });
      }
      
      // Visual particles for laser effect
      for (let i = 0; i < 80; i++) {
        particles.push({
          x: player.x + player.w / 2,
          y: player.y + player.h / 2,
          vx: Math.random() * 20 + 10,
          vy: Math.random() * 10 - 5,
          radius: Math.random() * 8 + 3,
          color: i % 2 === 0 ? "#ff4400" : "#ff8800",
          life: 2
        });
      }
    }
    
    function updateFireZones(dt) {
      for (let i = fireZones.length - 1; i >= 0; i--) {
        const zone = fireZones[i];
        zone.life -= dt;
        
        if (zone.life <= 0) {
          fireZones.splice(i, 1);
          continue;
        }
        
        // Damage enemies in fire zone
        enemies.forEach(e => {
          const dx = (e.x + e.w / 2) - zone.x;
          const dy = (e.y + e.h / 2) - zone.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < zone.radius) {
            e.hp -= zone.damage * dt;
            
            // Visual fire damage
            if (Math.random() < 0.1) {
              particles.push({
                x: e.x + e.w / 2,
                y: e.y + e.h / 2,
                vx: Math.random() * 4 - 2,
                vy: Math.random() * 4 - 2,
                radius: 3,
                color: "#ff4400",
                life: 0.5
              });
            }
          }
        });
      }
    }
    
    function updateMiniSun(dt) {
      if (!player.miniSun) return;
      
      const sun = player.miniSun;
      const keys = window.keys || {};
      const sunSpeed = 200; // Pixels per second
      
      // Arrow key movement for mini sun
      if (keys['ArrowUp']) sun.y -= sunSpeed * dt;
      if (keys['ArrowDown']) sun.y += sunSpeed * dt;
      if (keys['ArrowLeft']) sun.x -= sunSpeed * dt;
      if (keys['ArrowRight']) sun.x += sunSpeed * dt;
      
      // Keep sun within bounds
      sun.x = Math.max(sun.radius, Math.min(canvas.width - sun.radius, sun.x));
      sun.y = Math.max(sun.radius, Math.min(GROUND_Y - sun.radius, sun.y));
      
      // Burn enemies within radius
      enemies.forEach(e => {
        const dx = (e.x + e.w / 2) - sun.x;
        const dy = (e.y + e.h / 2) - sun.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < sun.burnRadius) {
          const burnDmg = sun.damage * dt;
          if (e.hasShield && e.shieldHP > 0) {
            e.shieldHP -= burnDmg;
          } else {
            e.hp -= burnDmg;
          }
          
          // Visual burn particles
          if (Math.random() < 0.15) {
            particles.push({
              x: e.x + e.w / 2,
              y: e.y + e.h / 2,
              vx: (Math.random() - 0.5) * 3,
              vy: (Math.random() - 0.5) * 3,
              radius: 4,
              color: ["#FFD700", "#FFA500", "#FF8C00"][Math.floor(Math.random() * 3)],
              life: 0.8
            });
          }
        }
      });
      
      // Sun particle effects
      if (Math.random() < 0.3) {
        particles.push({
          x: sun.x + (Math.random() - 0.5) * sun.radius,
          y: sun.y + (Math.random() - 0.5) * sun.radius,
          vx: (Math.random() - 0.5) * 2,
          vy: (Math.random() - 0.5) * 2,
          radius: 3,
          color: ["#FFD700", "#FFA500", "#FFFF00"][Math.floor(Math.random() * 3)],
          life: 0.5
        });
      }
    }
    
    function updatePotionEffects(dt) {
      // Update crit effect
      if (potionEffects.critActive) {
        potionEffects.critTimer -= dt;
        if (potionEffects.critTimer <= 0) {
          potionEffects.critActive = false;
          const critBonus = 0.25 + (gameData.potionUpgrades.effectStrength * 0.1);
          player.critChance -= critBonus;
        }
      }
      
      // Update damage effect
      if (potionEffects.damageActive) {
        potionEffects.damageTimer -= dt;
        if (potionEffects.damageTimer <= 0) {
          potionEffects.damageActive = false;
          const damageBonus = 10 + (gameData.potionUpgrades.effectStrength * 5);
          player.damage -= damageBonus;
        }
      }
      
      // Update speed effect
      if (potionEffects.speedActive) {
        potionEffects.speedTimer -= dt;
        if (potionEffects.speedTimer <= 0) {
          potionEffects.speedActive = false;
          const speedBonus = 0.15 + (gameData.potionUpgrades.effectStrength * 0.05);
          player.fireRate /= (1 - speedBonus);
        }
      }
      
      // Update cooldowns
      for (let type in potionCooldowns) {
        if (potionCooldowns[type] > 0) {
          potionCooldowns[type] -= dt;
          if (potionCooldowns[type] < 0) potionCooldowns[type] = 0;
        }
      }
    }
    
    function updatePotionCooldownDisplay() {
      const types = ['heal', 'shield', 'crit', 'damage', 'speed', 'dragon', 'cleanse'];
      types.forEach((type) => {
        const cooldownPercent = (potionCooldowns[type] / 1.0) * 100;
        document.getElementById('cd' + type.charAt(0).toUpperCase() + type.slice(1)).style.height = cooldownPercent + '%';
        
        const slot = document.getElementById('potion' + type.charAt(0).toUpperCase() + type.slice(1));
        if (potionCooldowns[type] > 0 || potions[type] <= 0) {
          slot.classList.add('cooldown');
        } else {
          slot.classList.remove('cooldown');
        }
      });
    }

    // UPGRADE POPUP SYSTEM
    function openUpgradePopup(type, target) {
      upgradePopup.active = true;
      upgradePopup.target = target;
      upgradePopup.type = type;
      upgradePopup.x = canvas.width / 2 - 150;
      upgradePopup.y = canvas.height / 2 - 200;
    }
    
    function openTurretCraftUI() {
      turretCraftUI.active = true;
      turretCraftUI.selectedType = null;
      turretCraftUI.dragging = false;
    }
    
    function closeUpgradePopup() {
      upgradePopup.active = false;
      upgradePopup.target = null;
      upgradePopup.type = null;
    }
    
    function closeTurretCraftUI() {
      turretCraftUI.active = false;
      turretCraftUI.selectedType = null;
      turretCraftUI.dragging = false;
    }
    
    function purchaseUpgrade(upgradeType) {
      const target = upgradePopup.target;
      const type = upgradePopup.type;
      
      if (!target) return;
      
      let cost = 0;
      const currentLevel = target.upgradeLevel || 0;
      
      // Calculate cost based on level (500 for level 1, 750 for level 2, 1000 for level 3, etc.)
      cost = 500 + (currentLevel * 250);
      
      if (coins < cost) {
        return; // Not enough coins
      }
      
      // Deduct coins and apply upgrade
      coins -= cost;
      
      if (!target.upgradeLevel) target.upgradeLevel = 0;
      target.upgradeLevel++;
      
      // Apply upgrade based on type
      if (type === 'clone') {
        if (upgradeType === 'damage') {
          target.damage = (target.damage || 10) * 1.15;
        } else if (upgradeType === 'fireRate') {
          target.fireRate = (target.fireRate || 1000) * 0.9;
        } else if (upgradeType === 'hp') {
          target.maxHp = (target.maxHp || 50) * 1.2;
          target.hp = Math.min(target.hp + 20, target.maxHp);
        }
      } else if (type === 'sun') {
        if (upgradeType === 'damage') {
          target.damage = (target.damage || 25) * 1.1;
        } else if (upgradeType === 'radius') {
          target.radius = (target.radius || 40) + 10;
          target.burnRadius = (target.burnRadius || 150) + 15;
        } else if (upgradeType === 'speed') {
          target.speed = (target.speed || 200) * 1.1;
        }
      } else if (type === 'turret') {
        if (upgradeType === 'damage') {
          target.damage = (target.damage || 15) * 1.15;
        } else if (upgradeType === 'fireRate') {
          target.fireRate = (target.fireRate || 1000) * 0.9;
        } else if (upgradeType === 'range') {
          target.range = (target.range || 200) * 1.1;
        }
      } else if (type === 'root') {
        if (upgradeType === 'damage') {
          target.damage = (target.damage || 5) * 1.2;
        } else if (upgradeType === 'slow') {
          target.slow = (target.slow || 0.5) * 1.1;
        } else if (upgradeType === 'duration') {
          target.duration = (target.duration || 3000) * 1.15;
        }
      }
      
      updateCoinsDisplay();
    }

    // SKILL TREE SYSTEM
    let currentSelectedClass = "Hunter";
    let selectedClassName = null;
    
    function showEvolAura() {
      document.getElementById('evolAuraScreen').style.display = 'block';
      updateAuraDisplay();
      renderClassTabs();
      displaySkillTree(currentSelectedClass);
    }
    
    function updateAuraDisplay() {
      document.getElementById('auraCoins').textContent = gameData.totalCoins;
      document.getElementById('auraGems').textContent = gameData.totalGems;
    }
    
    function renderClassTabs() {
      const container = document.getElementById('classTabsContainer');
      container.innerHTML = '';
      
      Object.entries(CLASSES).forEach(([className, classData]) => {
        const isUnlocked = gameData.unlockedClasses.includes(className) || 
                          gameData.purchasedClasses.includes(className);
        
        const tab = document.createElement('button');
        tab.style.cssText = `
          padding: 12px 20px;
          font-size: 16px;
          font-weight: bold;
          border: 2px solid ${currentSelectedClass === className ? '#00ff00' : '#00ffff'};
          background: ${currentSelectedClass === className ? 'rgba(0, 255, 0, 0.2)' : 'rgba(0, 0, 0, 0.8)'};
          color: ${isUnlocked ? '#ffff00' : '#666'};
          border-radius: 8px;
          cursor: ${isUnlocked ? 'pointer' : 'not-allowed'};
          transition: all 0.2s;
          font-family: 'Courier New', monospace;
        `;
        
        tab.innerHTML = `${classData.icon} ${className}`;
        
        if (isUnlocked) {
          tab.addEventListener('click', () => {
            currentSelectedClass = className;
            renderClassTabs();
            displaySkillTree(className);
          });
          
          tab.addEventListener('mouseenter', () => {
            if (currentSelectedClass !== className) {
              tab.style.background = 'rgba(0, 255, 255, 0.2)';
            }
          });
          
          tab.addEventListener('mouseleave', () => {
            if (currentSelectedClass !== className) {
              tab.style.background = 'rgba(0, 0, 0, 0.8)';
            }
          });
        }
        
        container.appendChild(tab);
      });
    }
    
    function displaySkillTree(className) {
      const skillGrid = document.getElementById('auraSkillGrid');
      skillGrid.innerHTML = '';
      
      if (!SKILL_TREES[className]) {
        skillGrid.innerHTML = '<div style="text-align: center; color: #ff0000; font-size: 20px; padding: 50px;">Skill tree coming soon for this class!</div>';
        return;
      }
      
      // Initialize class skill data if not exists
      if (!gameData.skillTrees[className]) {
        gameData.skillTrees[className] = {
          ultimate1: false,
          ultimate2: false
        };
      }
      
      const abilities = SKILL_TREES[className];
      
      // Ultimate 1
      const ability1 = abilities.ultimate1;
      const isUnlocked1 = gameData.skillTrees[className].ultimate1;
      
      const card1 = document.createElement('div');
      card1.className = 'shop-item';
      if (isUnlocked1) card1.classList.add('maxed');
      
      card1.innerHTML = `
        <div class="shop-item-name">${ability1.icon} ${ability1.name}</div>
        <div class="shop-item-desc">${ability1.desc}</div>
        <div class="shop-item-level">Activation: ${getActivationText(ability1)}</div>
        ${ability1.cooldown ? `<div class="shop-item-level">Cooldown: ${ability1.cooldown}s</div>` : ''}
        ${!isUnlocked1 ? `
          <div class="shop-item-cost">
            üí∞ ${ability1.cost.coins} | üíé ${ability1.cost.gems}
          </div>
        ` : '<div class="shop-item-cost" style="color: #00ff00;">‚úÖ UNLOCKED</div>'}
      `;
      
      if (!isUnlocked1) {
        card1.onclick = () => purchaseAbility(className, 'ultimate1');
      }
      
      skillGrid.appendChild(card1);
      
      // Ultimate 2
      const ability2 = abilities.ultimate2;
      const isUnlocked2 = gameData.skillTrees[className].ultimate2;
      
      const card2 = document.createElement('div');
      card2.className = 'shop-item';
      if (isUnlocked2) card2.classList.add('maxed');
      
      card2.innerHTML = `
        <div class="shop-item-name">${ability2.icon} ${ability2.name}</div>
        <div class="shop-item-desc">${ability2.desc}</div>
        <div class="shop-item-level">Activation: ${getActivationText(ability2)}</div>
        ${ability2.cooldown ? `<div class="shop-item-level">Cooldown: ${ability2.cooldown}s</div>` : ''}
        ${!isUnlocked2 ? `
          <div class="shop-item-cost">
            üí∞ ${ability2.cost.coins} | üíé ${ability2.cost.gems}
          </div>
        ` : '<div class="shop-item-cost" style="color: #00ff00;">‚úÖ UNLOCKED</div>'}
      `;
      
      if (!isUnlocked2) {
        card2.onclick = () => purchaseAbility(className, 'ultimate2');
      }
      
      skillGrid.appendChild(card2);
    }
    
    function getActivationText(ability) {
      if (ability.activation === 'kills') {
        return `After ${ability.killRequirement} kills`;
      } else if (ability.activation === 'manual') {
        return `Press ${ability.hotkey.toUpperCase()} key`;
      } else if (ability.activation === 'auto') {
        return 'Automatic when conditions met';
      }
      return 'Special';
    }
    
    function purchaseAbility(className, abilityKey) {
      const ability = SKILL_TREES[className][abilityKey];
      
      // PHANTOM CLONE RESTRICTION: Only Thief can use it
      if (ability.name === "Phantom Clone" && className !== "Thief") {
        alert("‚ùå Phantom Clone is exclusive to the Thief class!");
        return;
      }
      
      const cost = ability.cost;
      
      // Can purchase with EITHER enough coins OR enough gems (not both required)
      const canAffordCoins = gameData.totalCoins >= cost.coins;
      const canAffordGems = gameData.totalGems >= cost.gems;
      
      if (canAffordCoins || canAffordGems) {
        // Deduct ONLY ONE currency - prioritize coins if player has enough of both
        if (canAffordCoins) {
          gameData.totalCoins -= cost.coins;
        } else if (canAffordGems) {
          gameData.totalGems -= cost.gems;
        }
        
        gameData.skillTrees[className][abilityKey] = true;
        
        saveGameData();
        updateAuraDisplay();
        displaySkillTree(className);
        
        alert(`‚úÖ Unlocked ${ability.name}! You can now use this ability in battle!`);
      } else {
        alert(`‚ùå Not enough currency! Need either ${cost.coins} coins OR ${cost.gems} gems.`);
      }
    }

    // ABILITY ACTIVATION SYSTEM
    function initializeAbilities() {
      ability1Cooldown = 0;
      ability2Cooldown = 0;
      ability1KillCounter = 0;
      ability2KillCounter = 0;
      lastStandUsed = false;
      chainReactionShots = 0;
      headhunterShots = 0;
      overwatchActive = false;
      bladeStormActive = false;
      soulHarvestActive = false;
      timeFreezeActive = false;
      hiveMindActive = false;
      upsideDownActive = false;
      vecnaKillCounter = 0;
      
      const className = selectedClassName;
      if (!className || !gameData.skillTrees[className]) return;
      
      const ability1Unlocked = gameData.skillTrees[className].ultimate1;
      const ability2Unlocked = gameData.skillTrees[className].ultimate2;
      
      const ability1Btn = document.getElementById('ability1Btn');
      const ability2Btn = document.getElementById('ability2Btn');
      
      if (ability1Unlocked && SKILL_TREES[className]) {
        const ability = SKILL_TREES[className].ultimate1;
        document.getElementById('ability1Icon').textContent = ability.icon;
        document.getElementById('ability1Name').textContent = ability.name;
        document.getElementById('ability1Key').textContent = `[${ability.hotkey ? ability.hotkey.toUpperCase() : 'AUTO'}]`;
        ability1Btn.style.display = 'block';
      } else {
        ability1Btn.style.display = 'none';
      }
      
      if (ability2Unlocked && SKILL_TREES[className]) {
        const ability = SKILL_TREES[className].ultimate2;
        document.getElementById('ability2Icon').textContent = ability.icon;
        document.getElementById('ability2Name').textContent = ability.name;
        document.getElementById('ability2Key').textContent = `[${ability.hotkey ? ability.hotkey.toUpperCase() : 'AUTO'}]`;
        ability2Btn.style.display = 'block';
      } else {
        ability2Btn.style.display = 'none';
      }
    }
    
    function updateAbilities(dt) {
      // Update cooldowns
      if (ability1Cooldown > 0) ability1Cooldown -= dt;
      if (ability2Cooldown > 0) ability2Cooldown -= dt;
      
      // Update special timers
      if (overwatchTimer > 0) {
        overwatchTimer -= dt;
        if (overwatchTimer <= 0) overwatchActive = false;
      }
      if (bladeStormTimer > 0) {
        bladeStormTimer -= dt;
        if (bladeStormTimer <= 0) bladeStormActive = false;
      }
      if (soulHarvestTimer > 0) {
        soulHarvestTimer -= dt;
        if (soulHarvestTimer <= 0) soulHarvestActive = false;
      }
      if (timeFreezeTimer > 0) {
        timeFreezeTimer -= dt;
        if (timeFreezeTimer <= 0) {
          timeFreezeActive = false;
          enemies.forEach(e => e.frozen = false);
        }
      }
      if (hiveMindTimer > 0) {
        hiveMindTimer -= dt;
        if (hiveMindTimer <= 0) hiveMindActive = false;
      }
      if (upsideDownTimer > 0) {
        upsideDownTimer -= dt;
        if (upsideDownTimer <= 0) upsideDownActive = false;
      }
      
      // Blade storm damage
      if (bladeStormActive) {
        enemies.forEach(enemy => {
          const dx = enemy.x - player.x;
          const dy = enemy.y - player.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 150) {
            enemy.hp -= 50 * dt;
            if (enemy.hp <= 0 && !enemy.dead) {
              enemy.dead = true;
              onEnemyKilled(enemy);
            }
          }
        });
      }
      
      // Check auto-trigger abilities
      checkAutoAbilities();
      
      // Update display
      updateAbilityDisplay();
      
      // Update Vecna monsters
      if (selectedClassName === 'Vecna' && player.alive) {
        updateVecnaMonsters(dt);
      }
    }
    
    function checkAutoAbilities() {
      if (!selectedClassName || !gameData.skillTrees[selectedClassName]) return;
      
      const abilities = SKILL_TREES[selectedClassName];
      
      // Check ability 1 kill requirement
      if (abilities.ultimate1 && gameData.skillTrees[selectedClassName].ultimate1) {
        if (abilities.ultimate1.activation === 'kills' && 
            ability1KillCounter >= abilities.ultimate1.killRequirement &&
            ability1Cooldown <= 0) {
          activateAbility1();
        }
      }
      
      // Check ability 2 kill requirement
      if (abilities.ultimate2 && gameData.skillTrees[selectedClassName].ultimate2) {
        if (abilities.ultimate2.activation === 'kills' && 
            ability2KillCounter >= abilities.ultimate2.killRequirement &&
            ability2Cooldown <= 0) {
          activateAbility2();
        }
      }
      
      // Check Knight Last Stand
      if (selectedClassName === 'Knight' && 
          gameData.skillTrees.Knight?.ultimate2 &&
          player.hp < player.maxHP * 0.2 && 
          !lastStandUsed && 
          player.alive) {
        activateLastStand();
      }
    }
    
    function updateAbilityDisplay() {
      const ability1Btn = document.getElementById('ability1Btn');
      const ability2Btn = document.getElementById('ability2Btn');
      
      if (ability1Btn.style.display !== 'none') {
        const cd1 = document.getElementById('ability1CD');
        if (ability1Cooldown > 0) {
          cd1.textContent = Math.ceil(ability1Cooldown) + 's';
          ability1Btn.classList.add('cooldown');
          ability1Btn.classList.remove('ready');
        } else {
          cd1.textContent = 'READY';
          ability1Btn.classList.remove('cooldown');
          ability1Btn.classList.add('ready');
        }
      }
      
      if (ability2Btn.style.display !== 'none') {
        const cd2 = document.getElementById('ability2CD');
        if (ability2Cooldown > 0) {
          cd2.textContent = Math.ceil(ability2Cooldown) + 's';
          ability2Btn.classList.add('cooldown');
          ability2Btn.classList.remove('ready');
        } else {
          cd2.textContent = 'READY';
          ability2Btn.classList.remove('cooldown');
          ability2Btn.classList.add('ready');
        }
      }
    }
    
    function activateAbility1() {
      if (ability1Cooldown > 0 || !player.alive) return;
      
      const className = selectedClassName;
      if (!className || !gameData.skillTrees[className]?.ultimate1) return;
      
      const ability = SKILL_TREES[className].ultimate1;
      ability1Cooldown = ability.cooldown || 30;
      ability1KillCounter = 0;
      
      // Activate specific ability
      switch(className) {
        case 'Hunter': activateSniperShot(); break;
        case 'Knight': activateShieldBash(); break;
        case 'Assassin': activateShadowStrike(); break;
        case 'Wizard': activateMeteorStorm(); break;
        case 'Archer': activateArrowBarrage(); break;
        case 'Summoner': activateArmyOfDead(); break;
        case 'Bomber': activateNuke(); break;
        case 'Sniper': activateHeadhunter(); break;
        case 'Necromancer': activatePlague(); break;
        case 'Vecna': activateHiveMind(); break;
      }
    }
    
    function activateAbility2() {
      if (ability2Cooldown > 0 || !player.alive) return;
      
      const className = selectedClassName;
      if (!className || !gameData.skillTrees[className]?.ultimate2) return;
      
      const ability = SKILL_TREES[className].ultimate2;
      ability2Cooldown = ability.cooldown || 30;
      ability2KillCounter = 0;
      
      // Activate specific ability
      switch(className) {
        case 'Hunter': activateCarePackage(); break;
        case 'Knight': activateLastStand(); break;
        case 'Assassin': activateBladeStorm(); break;
        case 'Wizard': activateTimeFreeze(); break;
        case 'Archer': activateExplosiveArrow(); break;
        case 'Summoner': activateSacrifice(); break;
        case 'Bomber': activateChainReaction(); break;
        case 'Sniper': activateOverwatch(); break;
        case 'Necromancer': activateSoulHarvest(); break;
        case 'Vecna': activateVecnasCurse(); break;
      }
    }

    // ========== ABILITY IMPLEMENTATIONS ==========
    
    // HUNTER ABILITIES
    function activateSniperShot() {
      createFloatingText("üéØ SNIPER SHOT!", player.x, player.y - 30, "#00ffff");
      screenShake = 15;
      
      // Create massive cross-screen beam
      const damage = 500;
      projectiles.push({
        x: player.x,
        y: player.y,
        vx: 25,
        vy: 0,
        radius: 20,
        color: "#ff0000",
        damage: damage,
        pierce: true,
        isCrit: true,
        critMultiplier: 3,
        life: 3,
        isSniperShot: true
      });
    }
    
    function activateCarePackage() {
      createFloatingText("üì¶ CARE PACKAGE!", player.x, player.y - 30, "#00ff00");
      screenShake = 10;
      
      // Drop potions from sky
      potions.heal += 2;
      potions.shield += 1;
      potions.damage += 1;
      updatePotionDisplay();
      
      createExplosion(player.x, player.y, "#00ff00");
    }
    
    // KNIGHT ABILITIES
    function activateShieldBash() {
      createFloatingText("üõ°Ô∏è SHIELD BASH!", player.x, player.y - 30, "#0088ff");
      screenShake = 12;
      
      // Charge forward
      const chargeSpeed = 300;
      const chargeDist = 300;
      let chargeRemaining = chargeDist;
      
      const chargeInterval = setInterval(() => {
        if (chargeRemaining > 0 && player.alive) {
          player.x += 15;
          chargeRemaining -= 15;
          
          // Damage and stun enemies
          enemies.forEach(enemy => {
            const dx = enemy.x - player.x;
            const dy = enemy.y - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 80) {
              enemy.hp -= 100;
              enemy.stunned = true;
              enemy.stunnedTimer = 2;
              if (enemy.hp <= 0 && !enemy.dead) {
                enemy.dead = true;
                onEnemyKilled(enemy);
              }
            }
          });
        } else {
          clearInterval(chargeInterval);
        }
      }, 50);
    }
    
    function activateLastStand() {
      createFloatingText("‚ö° LAST STAND!", player.x, player.y - 30, "#ffff00");
      screenShake = 20;
      lastStandUsed = true;
      
      // Invincible for 5 seconds
      player.invincible = true;
      setTimeout(() => {
        player.invincible = false;
      }, 5000);
    }
    
    // ASSASSIN ABILITIES
    function activateShadowStrike() {
      if (enemies.length === 0) return;
      
      const target = enemies[Math.floor(Math.random() * enemies.length)];
      createFloatingText("üëª SHADOW STRIKE!", player.x, player.y - 30, "#9933ff");
      
      // Teleport behind enemy
      player.x = target.x - 50;
      player.y = target.y;
      
      // Deal massive damage
      target.hp -= 300;
      createExplosion(target.x, target.y, "#9933ff");
      screenShake = 15;
      
      if (target.hp <= 0 && !target.dead) {
        target.dead = true;
        onEnemyKilled(target);
      }
    }
    
    function activateBladeStorm() {
      createFloatingText("üåÄ BLADE STORM!", player.x, player.y - 30, "#ff00ff");
      screenShake = 10;
      bladeStormActive = true;
      bladeStormTimer = 5;
    }
    
    // WIZARD ABILITIES
    function activateMeteorStorm() {
      createFloatingText("‚òÑÔ∏è METEOR STORM!", player.x, player.y - 30, "#ff8800");
      screenShake = 15;
      
      // Drop 10 meteors
      for (let i = 0; i < 10; i++) {
        setTimeout(() => {
          const x = Math.random() * canvas.width;
          const y = 0;
          
          projectiles.push({
            x: x,
            y: y,
            vx: 0,
            vy: 15,
            radius: 15,
            color: "#ff8800",
            damage: 150,
            explosive: true,
            explosionRadius: 100,
            isCrit: true,
            life: 5
          });
        }, i * 200);
      }
    }
    
    function activateTimeFreeze() {
      createFloatingText("‚ùÑÔ∏è TIME FREEZE!", player.x, player.y - 30, "#00ffff");
      screenShake = 12;
      timeFreezeActive = true;
      timeFreezeTimer = 5;
      
      enemies.forEach(enemy => {
        enemy.frozen = true;
      });
    }

    // ARCHER ABILITIES
    function activateArrowBarrage() {
      createFloatingText("üèπ ARROW BARRAGE!", player.x, player.y - 30, "#00ff00");
      screenShake = 12;
      
      // Fire 50 arrows in all directions
      for (let i = 0; i < 50; i++) {
        const angle = (i / 50) * Math.PI * 2;
        projectiles.push({
          x: player.x,
          y: player.y,
          vx: Math.cos(angle) * 10,
          vy: Math.sin(angle) * 10,
          radius: 8,
          color: "#00ff00",
          damage: 30,
          pierce: true,
          life: 2
        });
      }
    }
    
    function activateExplosiveArrow() {
      createFloatingText("üí• EXPLOSIVE ARROW!", player.x, player.y - 30, "#ff0000");
      screenShake = 20;
      
      // Find nearest enemy
      let nearest = null;
      let minDist = Infinity;
      enemies.forEach(enemy => {
        const dx = enemy.x - player.x;
        const dy = enemy.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < minDist) {
          minDist = dist;
          nearest = enemy;
        }
      });
      
      if (nearest) {
        const angle = Math.atan2(nearest.y - player.y, nearest.x - player.x);
        projectiles.push({
          x: player.x,
          y: player.y,
          vx: Math.cos(angle) * 15,
          vy: Math.sin(angle) * 15,
          radius: 25,
          color: "#ff6600",
          damage: 800,
          explosive: true,
          explosionRadius: 300,
          isCrit: true,
          critMultiplier: 3,
          life: 5
        });
      }
    }
    
    // SUMMONER ABILITIES
    function activateArmyOfDead() {
      createFloatingText("üíÄ ARMY OF THE DEAD!", player.x, player.y - 30, "#9933ff");
      screenShake = 15;
      
      // Spawn 10 skeletons
      for (let i = 0; i < 10; i++) {
        const angle = (i / 10) * Math.PI * 2;
        const dist = 80;
        minions.push({
          x: player.x + Math.cos(angle) * dist,
          y: player.y + Math.sin(angle) * dist,
          hp: 40,
          maxHP: 40,
          damage: 8,
          speed: 2,
          radius: 8,
          color: "#9933ff"
        });
      }
    }
    
    function activateSacrifice() {
      createFloatingText("üîÆ SACRIFICE!", player.x, player.y - 30, "#ff00ff");
      screenShake = 10;
      
      const minionCount = minions.length;
      const shieldGain = minionCount * 30;
      
      player.shield += shieldGain;
      minions = [];
      
      createFloatingText("+" + shieldGain + " Shield", player.x, player.y, "#00ffff");
    }
    
    // BOMBER ABILITIES
    function activateNuke() {
      createFloatingText("‚ò¢Ô∏è NUKE!", player.x, player.y - 30, "#ff0000");
      screenShake = 30;
      
      // Damage all enemies
      enemies.forEach(enemy => {
        enemy.hp -= 1000;
        if (enemy.hp <= 0 && !enemy.dead) {
          enemy.dead = true;
          onEnemyKilled(enemy);
        }
      });
      
      // Massive explosion
      createExplosion(canvas.width / 2, canvas.height / 2, "#ff0000", 400);
    }
    
    function activateChainReaction() {
      createFloatingText("‚õìÔ∏è CHAIN REACTION!", player.x, player.y - 30, "#ff8800");
      screenShake = 10;
      chainReactionShots = 10;
    }
    
    // SNIPER ABILITIES
    function activateHeadhunter() {
      createFloatingText("üíÄ HEADHUNTER!", player.x, player.y - 30, "#ff0000");
      screenShake = 10;
      headhunterShots = 5;
    }
    
    function activateOverwatch() {
      createFloatingText("üî≠ OVERWATCH!", player.x, player.y - 30, "#00ffff");
      screenShake = 8;
      overwatchActive = true;
      overwatchTimer = 15;
    }
    
    // NECROMANCER ABILITIES
    function activatePlague() {
      createFloatingText("ü¶† PLAGUE!", player.x, player.y - 30, "#00ff00");
      screenShake = 12;
      
      enemies.forEach(enemy => {
        enemy.poisoned = true;
        enemy.poisonDamage = 20;
        enemy.poisonDuration = 10;
        enemy.poisonTimer = 10;
      });
    }
    
    function activateSoulHarvest() {
      createFloatingText("üëª SOUL HARVEST!", player.x, player.y - 30, "#9933ff");
      screenShake = 10;
      soulHarvestActive = true;
      soulHarvestTimer = 10;
    }
    
    // VECNA ABILITIES
    function activateHiveMind() {
      createFloatingText("üëÅÔ∏è HIVE MIND!", player.x, player.y - 30, "#8B0000");
      screenShake = 20;
      hiveMindActive = true;
      hiveMindTimer = 15;
    }
    
    function activateVecnasCurse() {
      createFloatingText("üåÄ VECNA'S CURSE!", player.x, player.y - 30, "#FF0000");
      screenShake = 25;
      upsideDownActive = true;
      upsideDownTimer = 20;
    }
    
    // VECNA SPECIAL MECHANICS
    function spawnVecnaMonster() {
      vecnaMonsters.push({
        x: player.x + (Math.random() - 0.5) * 100,
        y: player.y + (Math.random() - 0.5) * 100,
        hp: 50,
        maxHP: 50,
        damage: 10,
        speed: 2.5,
        radius: 12,
        color: "#8B0000",
        target: null
      });
    }
    
    function updateVecnaMonsters(dt) {
      vecnaMonsters.forEach((monster, idx) => {
        if (monster.hp <= 0) {
          vecnaMonsters.splice(idx, 1);
          return;
        }
        
        // Find nearest enemy
        let nearest = null;
        let minDist = Infinity;
        enemies.forEach(enemy => {
          const dx = enemy.x - monster.x;
          const dy = enemy.y - monster.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < minDist) {
            minDist = dist;
            nearest = enemy;
          }
        });
        
        if (nearest) {
          const dx = nearest.x - monster.x;
          const dy = nearest.y - monster.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist > 30) {
            monster.x += (dx / dist) * (monster.speed || 2.5);
            monster.y += (dy / dist) * (monster.speed || 2.5);
          } else {
            // VECNA UPGRADE: Attack faster (3x speed) and slow enemies
            nearest.hp -= (monster.damage || 10) * dt * 3; // 3x faster attacks
            
            // Apply slow effect on touch
            if (!nearest.slowEffect) nearest.slowEffect = 0;
            nearest.slowEffect = Math.max(nearest.slowEffect, 0.5); // 50% slow
            nearest.slowDuration = 2; // 2 seconds
            
            if (nearest.hp <= 0 && !nearest.dead) {
              nearest.dead = true;
              onEnemyKilled(nearest);
            }
          }
        }
      });
    }

    // LEGENDARY UPGRADES - Powerful one-time upgrades available after maxing basic stats
    const LEGENDARY_UPGRADES = {
      bigBullets: {
        icon: "üí•",
        name: "MEGA BULLETS",
        desc: "Bullets 3x size with 30% knockback!",
        requiresMaxed: "damage",
        apply: (player) => {
          player.legendaryUpgrades.bigBullets = true;
          player.bulletSizeMultiplier = 3.0;
          player.knockback = (player.knockback || 0) + 30;
        }
      },
      flamingBullets: {
        icon: "üî•",
        name: "FLAMING ROUNDS",
        desc: "All bullets burn enemies for 25 DPS!",
        requiresMaxed: "fireRate",
        apply: (player) => {
          player.legendaryUpgrades.flamingBullets = true;
          player.flameBurst = true;
          player.burnDamage = 25;
          player.burnDuration = 4;
        }
      },
      ultraSense: {
        icon: "üëÅÔ∏è",
        name: "ULTRA SENSE",
        desc: "5% chance to dodge enemy bullets!",
        requiresMaxed: "range",
        apply: (player) => {
          player.legendaryUpgrades.ultraSense = true;
          player.dodgeChance = 0.05;
        }
      },
      shieldPenetration: {
        icon: "üéØ",
        name: "SHIELD BUSTER",
        desc: "Homing shots have 5% chance to ignore shields!",
        requiresMaxed: "homingShots",
        apply: (player) => {
          player.legendaryUpgrades.shieldPenetration = true;
          player.shieldPierce = 0.05;
        }
      },
      explosiveShield: {
        icon: "üí£",
        name: "EXPLOSIVE BARRIER",
        desc: "Shield explodes when broken, damaging nearby enemies!",
        requiresMaxed: "shield",
        apply: (player) => {
          player.legendaryUpgrades.explosiveShield = true;
          player.shieldExplosion = true;
          player.shieldExplosionDamage = 100;
        }
      },
      speedDemon: {
        icon: "‚ö°",
        name: "SPEED DEMON",
        desc: "Move 50% faster, leave damaging trail!",
        requiresMaxed: "projectileSpeed",
        apply: (player) => {
          player.legendaryUpgrades.speedDemon = true;
          player.speed *= 1.5;
          player.speedTrail = true;
          player.trailDamage = 15;
        }
      },
      vampiricAura: {
        icon: "ü©∏",
        name: "VAMPIRIC AURA",
        desc: "Drain 5 HP/sec from nearby enemies!",
        requiresMaxed: "lifesteal",
        apply: (player) => {
          player.legendaryUpgrades.vampiricAura = true;
          player.vampireAura = true;
          player.vampireAuraRange = 200;
          player.vampireAuraDrain = 5;
        }
      },
      luckyStreak: {
        icon: "üçÄ",
        name: "LUCKY STREAK",
        desc: "Double crit chance, crits grant temporary invulnerability!",
        requiresMaxed: "criticalHit",
        apply: (player) => {
          player.legendaryUpgrades.luckyStreak = true;
          player.critChance *= 2;
          player.critInvuln = true;
        }
      }
    };

    // REDEEM CODES - Special codes for rewards
    const REDEEM_CODES = {
      "WELCOME": {
        type: "currency",
        coins: 1000,
        gems: 50,
        desc: "Welcome bonus!"
      },
      "SUNSHINE": {
        type: "character",
        character: "Dr.Sunshine",
        desc: "Unlock Dr.Sunshine!"
      },
      "THIEF": {
        type: "character",
        character: "Thief",
        desc: "Unlock Thief!"
      },
      "COINS500": {
        type: "currency",
        coins: 500,
        desc: "500 coins!"
      },
      "GEMS100": {
        type: "currency",
        gems: 100,
        desc: "100 gems!"
      },
      "JACKPOT": {
        type: "currency",
        coins: 5000,
        gems: 250,
        desc: "Jackpot! 5000 coins + 250 gems!"
      },
      "STARTER": {
        type: "currency",
        coins: 2000,
        gems: 100,
        desc: "Starter pack!"
      },
      "LEGENDARY": {
        type: "currency",
        coins: 10000,
        gems: 500,
        desc: "Legendary reward!"
      },
      "Mrvalentine": {
        type: "currency",
        coins: 10000,
        gems: 100,
        desc: "Mr. Valentine's gift! 10,000 coins + 100 gems!"
      }
    };

    // CLASS DEFINITIONS
    const CLASSES = {
      Hunter: {
        icon: "üèπ",
        color: "#00ff88",
        accent: "#88ffaa",
        bulletColor: "#00ff88",
        glowColor: "#00ff88",
        unlockWave: 0,
        purchasable: false,
        stats: {
          maxHP: 100,
          damage: 10,
          fireRate: 0.8, // 1.25/sec
          range: 650,
          projectileSpeed: 8
        },
        description: "Balanced starter class"
      },
      Knight: {
        icon: "‚öîÔ∏è",
        color: "#4488ff",
        accent: "#88aaff",
        bulletColor: "#4488ff",
        glowColor: "#4488ff",
        unlockWave: 20,
        purchasable: false,
        stats: {
          maxHP: 140,
          damage: 14,
          fireRate: 1.111, // 0.9/sec
          range: 400,
          projectileSpeed: 6.5
        },
        description: "Durable frontline fighter with slower heavy shots"
      },
      Archer: {
        icon: "üèπ",
        color: "#228b22",
        accent: "#32cd32",
        bulletColor: "#228b22",
        glowColor: "#32cd32",
        unlockWave: 20, // Unlocks at wave 20
        purchasable: false,
        stats: {
          maxHP: 90,
          damage: 12,
          fireRate: 0.556, // 1.8/sec
          range: 700,
          projectileSpeed: 10,
          alwaysPierce: true // Rapid-firing ranged attacker
        },
        description: "Rapid-firing ranged attacker"
      },
      Thief: {
        icon: "ü•∑",
        color: "#4a0080",
        accent: "#8800ff",
        bulletColor: "#4a0080",
        glowColor: "#8800ff",
        unlockWave: 15, // Unlocks at wave 15 - 5x money class!
        purchasable: false,
        stats: {
          maxHP: 85,
          damage: 8,
          fireRate: 0.455, // 2.2/sec - Fast dagger-throwing
          range: 350,
          projectileSpeed: 8,
          coinMultiplier: 5, // Earns 5x coins!
          gemMultiplier: 5 // Earns 5x gems!
        },
        description: "Fast dagger-throwing crit-based DPS"
      },
      Assassin: {
        icon: "üó°Ô∏è",
        color: "#ff00ff",
        accent: "#ff88ff",
        bulletColor: "#ff00ff",
        glowColor: "#ff00ff",
        unlockWave: 35,
        purchasable: false,
        stats: {
          maxHP: 95,
          damage: 9,
          fireRate: 0.357, // 2.8/sec - Ultra-fast
          range: 400,
          projectileSpeed: 9.5
        },
        description: "Ultra-fast glass cannon"
      },
      Summoner: {
        icon: "‚ú®",
        color: "#88ff88",
        accent: "#aaffaa",
        bulletColor: "#88ff88",
        glowColor: "#88ff88",
        unlockWave: 65,
        purchasable: false,
        stats: {
          maxHP: 110,
          damage: 12,
          fireRate: 1.0, // 1.0/sec
          range: 500,
          projectileSpeed: 7
        },
        description: "Summons spirit helpers to assist with damage"
      },
      DarkMagician: {
        icon: "üîÆ",
        color: "#8800ff",
        accent: "#aa88ff",
        bulletColor: "#8800ff",
        glowColor: "#8800ff",
        unlockWave: 95,
        purchasable: false,
        stats: {
          maxHP: 85,
          damage: 35,
          fireRate: 1.818, // 0.55/sec - Slow but powerful
          range: 550,
          projectileSpeed: 5.5
        },
        description: "Slow but extremely powerful caster"
      },
      // PURCHASABLE CLASSES
      Bomber: {
        icon: "üí£",
        color: "#ff8800",
        accent: "#ffaa44",
        bulletColor: "#ff8800",
        glowColor: "#ff8800",
        unlockWave: 0,
        purchasable: true,
        cost: { coins: 500, gems: 2 }, // MUCH cheaper early unlock!
        stats: {
          maxHP: 130,
          damage: 30, // 3x Hunter's damage (Hunter = 10)
          fireRate: 1.2, // 0.83/sec - Slightly faster
          range: 500,
          projectileSpeed: 6,
          alwaysExplosive: true, // Every shot explodes!
          explosionRadius: 120, // HUGE explosion radius
          explosionDamage: 90 // AOE explosion does 3x the projectile damage!
        },
        description: "Massive AOE explosions ‚Äî 3x direct hit, 3x AOE blast damage!"
      },
      Sniper: {
        icon: "üéØ",
        color: "#00ffff",
        accent: "#88ffff",
        bulletColor: "#00ffff",
        glowColor: "#00ffff",
        unlockWave: 0,
        purchasable: true,
        cost: { coins: 15000, gems: 150 },
        stats: {
          maxHP: 100,
          damage: 45,
          fireRate: 2.222, // 0.45/sec - Very slow
          range: 900,
          projectileSpeed: 12,
          alwaysCrit: true // Highest single-hit damage
        },
        description: "Highest single-hit damage. Very slow fire rate"
      },
      Necromancer: {
        icon: "üíÄ",
        color: "#9933ff",
        accent: "#bb66ff",
        bulletColor: "#9933ff",
        glowColor: "#9933ff",
        unlockWave: 0,
        purchasable: true,
        cost: { coins: 25000, gems: 250 },
        stats: {
          maxHP: 105,
          damage: 15,
          fireRate: 1.111, // 0.9/sec
          range: 550,
          projectileSpeed: 7,
          alwaysPoison: true, // Poisons enemies
          spawnSkeletonsOnKill: true // Raises skeletons
        },
        description: "Poisons enemies and raises skeletons"
      },
      Vecna: {
        icon: "üëÅÔ∏è",
        color: "#8B0000",
        accent: "#FF0000",
        bulletColor: "#8B0000",
        glowColor: "#FF0000",
        unlockWave: 0,
        purchasable: true,
        cost: { coins: 10000000, gems: 10000 },
        stats: {
          maxHP: 110,
          damage: 18,
          fireRate: 1.333, // 0.75/sec
          range: 600,
          projectileSpeed: 7.5,
          summonMonsters: true,
          shieldOnKills: 10,
          enemyConversionChance: 0.2
        },
        description: "Converts enemies, summons monsters"
      },
      // NEW CLASSES
      Pyromancer: {
        icon: "üî•",
        color: "#ff4500",
        accent: "#ff6347",
        bulletColor: "#ff4500",
        glowColor: "#ff6347",
        unlockWave: 45,
        purchasable: false,
        stats: {
          maxHP: 90,
          damage: 22,
          fireRate: 0.909, // 1.1/sec
          range: 550,
          projectileSpeed: 7,
          burnDamageOverTime: true // Burns enemies
        },
        description: "Burns enemies over time with flame shots"
      },
      CryoSentinel: {
        icon: "‚ùÑÔ∏è",
        color: "#00bfff",
        accent: "#87ceeb",
        bulletColor: "#00bfff",
        glowColor: "#87ceeb",
        unlockWave: 0,
        purchasable: false,
        achievementUnlock: "freeze100", // Freeze 100 enemies
        stats: {
          maxHP: 120,
          damage: 14,
          fireRate: 1.053, // 0.95/sec
          range: 500,
          projectileSpeed: 6.5,
          slowOnHit: 0.5, // 50% slow
          freezeChance: 0.1 // 10% chance to freeze
        },
        description: "Ice shots slow enemies and add control"
      },
      PlagueDoctor: {
        icon: "ü¶†",
        color: "#32cd32",
        accent: "#90ee90",
        bulletColor: "#32cd32",
        glowColor: "#90ee90",
        unlockWave: 0,
        purchasable: true,
        cost: { coins: 20000, gems: 200 },
        stats: {
          maxHP: 100,
          damage: 16,
          fireRate: 0.833, // 1.2/sec
          range: 500,
          projectileSpeed: 7,
          stackingPoison: true, // Stacking poison
          poisonSpread: true // Spreads between enemies
        },
        description: "Applies stacking poison that spreads"
      },
      LightningRanger: {
        icon: "‚ö°",
        color: "#ffd700",
        accent: "#ffff00",
        bulletColor: "#ffd700",
        glowColor: "#ffff00",
        unlockWave: 75,
        purchasable: false,
        stats: {
          maxHP: 105,
          damage: 28,
          fireRate: 1.176, // 0.85/sec
          range: 600,
          projectileSpeed: 9,
          chainLightning: 3 // Chains to 3 enemies
        },
        description: "Electric shots chain between enemies"
      },
      BloodReaver: {
        icon: "ü©∏",
        color: "#8b0000",
        accent: "#dc143c",
        bulletColor: "#8b0000",
        glowColor: "#dc143c",
        unlockWave: 0,
        purchasable: false,
        achievementUnlock: "defeat3Elites", // Defeat 3 elite enemies
        stats: {
          maxHP: 140,
          damage: 18,
          fireRate: 1.0, // 1.0/sec
          range: 450,
          projectileSpeed: 7,
          lifestealPercent: 0.15, // 15% lifesteal (UPDATED)
          bleedDamage: true // Applies bleed
        },
        description: "Lifesteal and bleed-based DPS"
      },
      CrystalGuardian: {
        icon: "üíé",
        color: "#9370db",
        accent: "#ba55d3",
        bulletColor: "#9370db",
        glowColor: "#ba55d3",
        unlockWave: 0,
        purchasable: true,
        cost: { coins: 40000, gems: 350 },
        stats: {
          maxHP: 160, // HP as requested
          damage: 12,
          fireRate: 1.25, // 0.8/sec
          range: 500,
          projectileSpeed: 6,
          startingShield: 200, // START WITH 200 SHIELD
          reflectDamage: 0.15, // 15% reflect
          reflectProjectiles: true // Reflect enemy projectiles when shielded
        },
        description: "Crystal energy bolts and reflect defense"
      },
      ShadowMonk: {
        icon: "ü•ã",
        color: "#2f4f4f",
        accent: "#696969",
        bulletColor: "#2f4f4f",
        glowColor: "#696969",
        unlockWave: 85,
        purchasable: false,
        stats: {
          maxHP: 110,
          damage: 20,
          fireRate: 0.714, // 1.4/sec
          range: 300, // LOW RANGE (UPDATED)
          projectileSpeed: 8,
          knockback: 40, // MEDIUM KNOCKBACK (ADDED)
          critBonus: 0.5 // +50% crit damage
        },
        description: "Crit-focused martial artist"
      },
      ArcWarden: {
        icon: "‚ö°",
        color: "#4169e1",
        accent: "#6495ed",
        bulletColor: "#4169e1",
        glowColor: "#6495ed",
        unlockWave: 0,
        purchasable: false,
        achievementUnlock: "collect5ArcCores", // Collect 5 Arc Cores
        stats: {
          maxHP: 95,
          damage: 30,
          fireRate: 1.429, // 0.7/sec
          range: 550,
          projectileSpeed: 7.5,
          stunChance: 0.15 // 15% stun chance
        },
        description: "Electric cannon with stun potential"
      },
      HolyCleric: {
        icon: "‚úùÔ∏è",
        color: "#ffd700",
        accent: "#ffffe0",
        bulletColor: "#ffd700",
        glowColor: "#ffffe0",
        unlockWave: 0,
        purchasable: false,
        achievementUnlock: "heal1000HP", // Heal 1000 total HP
        stats: {
          maxHP: 150,
          damage: 10,
          fireRate: 0.909, // 1.1/sec
          range: 500,
          projectileSpeed: 6.5,
          healOnHit: 2 // Heals 2 HP per hit
        },
        description: "Healing and radiant beam damage"
      },
      TrickshotRogue: {
        icon: "üé≤",
        color: "#ff1493",
        accent: "#ff69b4",
        bulletColor: "#ff1493",
        glowColor: "#ff69b4",
        unlockWave: 100,
        purchasable: false,
        stats: {
          maxHP: 80,
          damage: 35,
          fireRate: 1.0, // 1.0/sec
          range: 600,
          projectileSpeed: 9,
          ricochetShots: 2 // Ricochets 2 times
        },
        description: "Ricocheting shots with burst potential"
      },
      Starcaller: {
        icon: "üåü",
        color: "#9400d3",
        accent: "#ba55d3",
        bulletColor: "#9400d3",
        glowColor: "#ba55d3",
        unlockWave: 0,
        purchasable: false,
        achievementUnlock: "fallingStarDrop", // Rare drop
        stats: {
          maxHP: 115,
          damage: 18,
          fireRate: 1.0, // 1.0/sec
          range: 550,
          projectileSpeed: 7,
          gravityPull: true // Pulls enemies
        },
        description: "Cosmic caster with gravity effects"
      },
      VoidAssassin: {
        icon: "üåë",
        color: "#191970",
        accent: "#483d8b",
        bulletColor: "#191970",
        glowColor: "#483d8b",
        unlockWave: 0,
        purchasable: false,
        achievementUnlock: "kill100In10Sec", // Challenge completion
        stats: {
          maxHP: 90,
          damage: 40,
          fireRate: 1.111, // 0.9/sec
          range: 450,
          projectileSpeed: 8.5,
          voidStrike: true, // Void damage
          invulnFrames: 0.5 // 0.5s invuln on hit
        },
        description: "High crit void strikes with brief invuln"
      },
      Shadowblade: {
        icon: "‚öîÔ∏è",
        color: "#000000",
        accent: "#696969",
        bulletColor: "#000000",
        glowColor: "#696969",
        unlockWave: 0,
        purchasable: true,
        cost: { coins: 5000, gems: 0 }, // OR shadow scroll drop
        stats: {
          maxHP: 100,
          damage: 12,
          fireRate: 0.526, // 1.9/sec
          range: 400,
          projectileSpeed: 8,
          curseOnHit: true, // Curses enemies
          bonusCritDamage: 0.75 // +75% crit damage
        },
        description: "Curses enemies and deals bonus crit"
      },
      AstralGolem: {
        icon: "üóø",
        color: "#708090",
        accent: "#a9a9a9",
        bulletColor: "#708090",
        glowColor: "#a9a9a9",
        unlockWave: 120,
        purchasable: false,
        stats: {
          maxHP: 400, // MASSIVE HP (UPDATED)
          damage: 22,
          fireRate: 1.818, // 0.55/sec - Very slow
          range: 500,
          projectileSpeed: 5,
          damageReduction: 0.30, // 30% DAMAGE REDUCTION
          heavyProjectiles: true // Heavy star projectiles
        },
        description: "Heavy star projectiles and tanky build"
      },
      Engineer: {
        icon: "üîß",
        color: "#FF8C00",
        accent: "#FFA500",
        bulletColor: "#FF8C00",
        glowColor: "#FFA500",
        unlockWave: 25,
        purchasable: false,
        stats: {
          maxHP: 95,
          damage: 7, // Lower personal damage
          fireRate: 1.0, // 1.0/sec
          range: 450,
          projectileSpeed: 7,
          turretClass: true, // Special flag for turret mechanics
          maxTurrets: 3, // Can place up to 3 basic turrets
          turretDamage: 5, // Base turret damage
          turretRange: 300, // Turret attack range
          turretFireRate: 0.5, // 2.0/sec
          turretHP: 100 // Base turret health
        },
        description: "Deploys defensive turrets with specialized abilities"
      },
      TheForsakenOne: {
        icon: "üíÄ",
        color: "#4B0082",
        accent: "#8B00FF",
        bulletColor: "#4B0082",
        glowColor: "#8B00FF",
        unlockWave: 0,
        purchasable: false,
        challengeUnlock: "rejectAllPowerups", // Reject all level-ups & potions, survive to wave 11
        stats: {
          maxHP: 115,
          damage: 17,
          fireRate: 0.741, // 1.35/sec - Balanced hybrid
          range: 500,
          projectileSpeed: 7.5,
          knockback: 1.5, // Strong knockback on all shots
          cursedFlux: true, // Random buffs every 15 seconds
          cursedFluxTimer: 0,
          cursedFluxDuration: 6,
          currentBuff: null
        },
        description: "A cursed survivor who chose nothing and overcame everything. Chaos fuels their power."
      },
      Rookie: {
        icon: "üéØ",
        color: "#cccccc",
        accent: "#ffffff",
        bulletColor: "#999999",
        glowColor: "#cccccc",
        unlockWave: 0,  // Available from start
        purchasable: false,
        stats: {
          maxHP: 80,        // Weakest HP
          damage: 6,        // Weakest damage
          fireRate: 1.25,   // Slowest fire rate (0.8/sec)
          range: 350,       // Shortest range
          projectileSpeed: 6, // Slowest projectile
          xpMultiplier: 1.5,  // 50% more XP gained
          powerUpMultiplier: 1.2 // 20% bonus to all upgrades
        },
        description: "Beginner class that levels up faster and gets 20% better upgrades"
      },
      GuardianTank: {
        icon: "üõ°Ô∏è",
        color: "#4169e1",
        accent: "#6495ed",
        bulletColor: "#4169e1",
        glowColor: "#87ceeb",
        unlockWave: 0,
        purchasable: false,
        unlockedByCondition: true,  // Special unlock condition
        stats: {
          maxHP: 180,
          damage: 35,       // High damage
          fireRate: 2.0,    // Slow (0.5/sec)
          range: 500,       // Decent range
          projectileSpeed: 4.5, // Slow but strong
          knockback: 80,    // Pushes enemies back
          projectileSize: 24 // Giant shield visual
        },
        description: "Throws massive shields with high damage and knockback. Unlock: 5 shield upgrades + HP > 200"
      },
      // NEW REQUESTED CLASSES
      Mage: {
        icon: "üßô",
        color: "#9932cc",
        accent: "#ba55d3",
        bulletColor: "#9932cc",
        glowColor: "#ba55d3",
        unlockWave: 30,
        purchasable: false,
        stats: {
          maxHP: 90,
          damage: 32,
          fireRate: 1.667, // 0.6/sec - Slow but powerful
          range: 600,
          projectileSpeed: 6,
          magicMissiles: true,
          manaBased: true
        },
        description: "Basic wizard with high-damage magic missiles"
      },
      Berserk: {
        icon: "ü™ì",
        color: "#8B0000",
        accent: "#DC143C",
        bulletColor: "#8B0000",
        glowColor: "#DC143C",
        unlockWave: 40,
        purchasable: false,
        stats: {
          maxHP: 150,
          damage: 25,
          fireRate: 0.667, // 1.5/sec
          range: 350,
          projectileSpeed: 9,
          rageMode: true, // Damage increases as HP decreases
          increasedSpeedOnLowHP: true
        },
        description: "Wild berserker - stronger when damaged"
      },
      Samurai: {
        icon: "‚öîÔ∏è",
        color: "#C0C0C0",
        accent: "#E8E8E8",
        bulletColor: "#C0C0C0",
        glowColor: "#E8E8E8",
        unlockWave: 50,
        purchasable: false,
        stats: {
          maxHP: 110,
          damage: 28,
          fireRate: 0.909, // 1.1/sec
          range: 450,
          projectileSpeed: 10,
          honorBound: true,
          critBonus: 1.0, // +100% crit damage
          perfectBlock: 0.1 // 10% chance to block
        },
        description: "Honor-bound warrior with devastating crits"
      },
      Warlock: {
        icon: "üëπ",
        color: "#4B0082",
        accent: "#6A0DAD",
        bulletColor: "#4B0082",
        glowColor: "#6A0DAD",
        unlockWave: 0,
        purchasable: true,
        cost: { coins: 50000, gems: 500 },
        stats: {
          maxHP: 95,
          damage: 20,
          fireRate: 1.111, // 0.9/sec
          range: 550,
          projectileSpeed: 7,
          curseShots: true,
          lifeDrain: 0.2, // 20% lifesteal
          soulCollect: true
        },
        description: "Dark sorcerer with curses and life drain"
      },
      Druid: {
        icon: "üåø",
        color: "#228B22",
        accent: "#32CD32",
        bulletColor: "#228B22",
        glowColor: "#32CD32",
        unlockWave: 60,
        purchasable: false,
        stats: {
          maxHP: 120,
          damage: 18,
          fireRate: 1.0, // 1.0/sec
          range: 500,
          projectileSpeed: 7,
          natureMagic: true,
          summonSpirits: true,
          healOverTime: 1 // Regenerates 1 HP/sec
        },
        description: "Nature caster with spirits and healing"
      },
      Gunslinger: {
        icon: "ü§†",
        color: "#8B4513",
        accent: "#D2691E",
        bulletColor: "#8B4513",
        glowColor: "#D2691E",
        unlockWave: 0,
        purchasable: true,
        cost: { coins: 30000, gems: 300 },
        stats: {
          maxHP: 100,
          damage: 15,
          fireRate: 0.333, // 3.0/sec - Very fast!
          range: 550,
          projectileSpeed: 12,
          dualWield: true,
          ricochetChance: 0.3, // 30% ricochet
          quickDraw: true
        },
        description: "Western shooter with dual pistols and ricochets"
      },
      Ranger: {
        icon: "üèπ",
        color: "#2F4F2F",
        accent: "#556B2F",
        bulletColor: "#2F4F2F",
        glowColor: "#556B2F",
        unlockWave: 25,
        purchasable: false,
        stats: {
          maxHP: 95,
          damage: 20,
          fireRate: 0.769, // 1.3/sec
          range: 750, // Very long range
          projectileSpeed: 11,
          alwaysPierce: true,
          trackingShots: true,
          forestBonus: 1.2 // 20% damage bonus
        },
        description: "Forest tracker with piercing long-range arrows"
      },
      DrSunshine: {
        icon: "‚òÄÔ∏è",
        color: "#FFD700",
        accent: "#FFA500",
        bulletColor: "#FFD700",
        glowColor: "#FF8C00",
        unlockWave: 0,
        purchasable: false,
        challengeUnlock: "wave18Restart7Times", // Restart at wave 18, 7 times
        stats: {
          maxHP: 120,
          damage: 15,
          fireRate: 1.0, // 1/sec
          range: 600,
          projectileSpeed: 7,
          miniSun: true, // Has placeable mini sun
          sunDamage: 25, // Sun burns for 25 damage/sec
          sunRadius: 150 // Sun burn radius
        },
        description: "Controls a blazing mini sun that burns enemies. Arrow keys to move sun. Unlock: Restart at wave 18, 7 times"
      },
      Illusionist: {
        icon: "üé≠",
        color: "#9370DB",
        accent: "#BA55D3",
        bulletColor: "#9370DB",
        glowColor: "#BA55D3",
        unlockWave: 0,
        purchasable: true,
        cost: { coins: 75000, gems: 750 },
        stats: {
          maxHP: 110,
          damage: 12,
          fireRate: 0.909, // 1.1/sec
          range: 550,
          projectileSpeed: 7.5,
          createClone: true, // Can create clone of another class
          cloneHealthRatio: 0.5, // Clone has 50% of original class HP
          cloneRangeBonus: 150 // Clone has +150 range
        },
        description: "Master of illusions - creates a fighting clone positioned above with half health (added to your HP pool)"
      },
      DrEclipse: {
        icon: "üåô",
        color: "#2C1E4A",
        accent: "#4A2C6A",
        bulletColor: "#8B7AB8",
        glowColor: "#9D8BC9",
        unlockWave: 0,
        purchasable: true,
        cost: { coins: 100000, gems: 1000 },
        stats: {
          maxHP: 115,
          damage: 18,
          fireRate: 1.111, // 0.9/sec
          range: 600,
          projectileSpeed: 7,
          hasKnockback: true, // Bullets knock enemies back
          knockbackForce: 25,
          moonControl: true, // Has controllable moon
          moonGravityRadius: 200, // Moon's gravity pull radius
          moonLiftForce: 150, // Force to lift enemies
          moonSlamDamage: 100 // Base damage when enemies crash down
        },
        description: "Master of lunar magic - controls a moon that lifts enemies with gravity and slams them down. Arrow keys move moon. Bullets have knockback."
      }
    };

    // BOSSES - Named bosses with unique mechanics
    const BOSSES = {
      BoneKnight: {
        name: "The Bone Knight",
        wave: 10,
        hp: 4000,
        damage: 20,
        attackRate: 2.2,
        speed: 0.8,
        size: 60,
        color: "#d3d3d3",
        icon: "üíÄ",
        reward: { type: "permanentHP", bonus: 0.05 }
      },
      HollowArcher: {
        name: "The Hollow Archer",
        wave: 20,
        hp: 5000,
        damage: 15,
        attackRate: 0.8,
        speed: 1.2,
        size: 55,
        color: "#8b4513",
        icon: "üèπ",
        reward: { type: "classUnlock", className: "Thief" }
      },
      FireBroodmother: {
        name: "The Fire Broodmother",
        wave: 30,
        hp: 6200,
        damage: 18,
        attackRate: 1.5,
        speed: 0.6,
        size: 70,
        color: "#ff4500",
        icon: "üï∑Ô∏è",
        reward: { type: "abilityPoint", amount: 1 }
      },
      FrostColossus: {
        name: "Frost Colossus",
        wave: 45,
        hp: 12000,
        damage: 25,
        attackRate: 2.0,
        speed: 0.5,
        size: 80,
        color: "#00bfff",
        icon: "‚ùÑÔ∏è",
        reward: { type: "classUnlock", className: "CryoSentinel" }
      },
      ChainReaper: {
        name: "The Chain Reaper",
        wave: 55,
        hp: 14000,
        damage: 35,
        attackRate: 1.8,
        speed: 1.0,
        size: 65,
        color: "#696969",
        icon: "‚õìÔ∏è",
        reward: { type: "currency", coins: 5000, gems: 200 }
      },
      ThunderHydra: {
        name: "Thunder Hydra",
        wave: 75,
        hp: 18000,
        damage: 15,
        attackRate: 1.5,
        speed: 0.7,
        size: 90,
        color: "#ffd700",
        icon: "üêâ",
        reward: { type: "classUnlock", className: "LightningRanger" }
      },
      CrystalTitan: {
        name: "Crystal Titan",
        wave: 85,
        hp: 20000,
        damage: 40,
        attackRate: 1.4,
        speed: 0.4,
        size: 85,
        color: "#9370db",
        icon: "üíé",
        reward: { type: "classUnlock", className: "CrystalGuardian" }
      },
      SpiritEmperor: {
        name: "The Spirit Emperor",
        wave: 100,
        hp: 30000,
        damage: 28,
        attackRate: 1.1,
        speed: 0.9,
        size: 75,
        color: "#00ffff",
        icon: "üëª",
        reward: { type: "currency", coins: 10000, gems: 500 }
      },
      VoidTyrant: {
        name: "The Void Tyrant",
        wave: 120,
        hp: 35000,
        damage: 55,
        attackRate: 2.2,
        speed: 0.6,
        size: 95,
        color: "#191970",
        icon: "üåë",
        reward: { type: "classUnlock", className: "VoidAssassin" }
      },
      BloodKing: {
        name: "The Blood King",
        wave: 135,
        hp: 38500,
        damage: 30,
        attackRate: 1.3,
        speed: 0.8,
        size: 70,
        color: "#8b0000",
        icon: "üëë",
        reward: { type: "permanentLifesteal", bonus: 0.05 }
      },
      ArcCelestial: {
        name: "The Arc Celestial",
        wave: 150,
        hp: 50000,
        damage: 42,
        attackRate: 1.0,
        speed: 1.0,
        size: 85,
        color: "#ff1493",
        icon: "‚≠ê",
        reward: { type: "classUnlock", className: "AstralGolem" }
      },
      ShadowMonarch: {
        name: "The Shadow Monarch",
        wave: 170,
        hp: 55000,
        damage: 48,
        attackRate: 0.9,
        speed: 1.1,
        size: 75,
        color: "#000000",
        icon: "üë§",
        reward: { type: "classUnlock", className: "ShadowMonk" }
      },
      EtheriumWarden: {
        name: "Etherium Warden",
        wave: 185,
        hp: 70000,
        damage: 60,
        attackRate: 1.7,
        speed: 0.5,
        size: 100,
        color: "#4169e1",
        icon: "‚ö°",
        reward: { type: "classUnlock", className: "ArcWarden" }
      },
      ChronoSeraph: {
        name: "The Chrono Seraph",
        wave: 200,
        hp: 100000,
        damage: 65,
        attackRate: 1.0,
        speed: 1.2,
        size: 90,
        color: "#ffd700",
        icon: "‚è∞",
        reward: { type: "permanentFireRate", bonus: 0.1 }
      },
      HeadThrower: {
        name: "The Head Thrower",
        wave: 15,
        hp: 8000,
        damage: 25,
        attackRate: 3.0,
        speed: 0.7,
        size: 65,
        color: "#ff6347",
        icon: "üéÉ",
        reward: { type: "currency", coins: 2000, gems: 50 }
      }
    };

    // SKILL TREES - Ultimate Abilities for Each Class
    const SKILL_TREES = {
      Hunter: {
        ultimate1: {
          name: "Sniper Shot",
          icon: "üéØ",
          desc: "Fire devastating cross-screen shot after 15 kills",
          cost: { coins: 5000, gems: 50 },
          activation: "kills",
          killRequirement: 15,
          cooldown: 30,
          damage: 500
        },
        ultimate2: {
          name: "Care Package",
          icon: "üì¶",
          desc: "Supply drop with potions (Q key)",
          cost: { coins: 10000, gems: 100 },
          activation: "manual",
          hotkey: "q",
          cooldown: 60
        }
      },
      Knight: {
        ultimate1: {
          name: "Shield Bash",
          icon: "üõ°Ô∏è",
          desc: "Charge forward, stunning enemies (Q key)",
          cost: { coins: 5000, gems: 50 },
          activation: "manual",
          hotkey: "q",
          cooldown: 20,
          damage: 100,
          stunDuration: 2
        },
        ultimate2: {
          name: "Last Stand",
          icon: "‚ö°",
          desc: "Invincible for 5s when HP < 20%",
          cost: { coins: 10000, gems: 100 },
          activation: "auto",
          duration: 5
        }
      },
      Archer: {
        ultimate1: {
          name: "Cupid's Bow",
          icon: "üíò",
          desc: "Next 5 shots convert enemies to allies (Q key)",
          cost: { coins: 5000, gems: 50 },
          activation: "manual",
          hotkey: "q",
          cooldown: 45,
          shotsRemaining: 5
        },
        ultimate2: {
          name: "Hook Shot",
          icon: "ü™ù",
          desc: "50% chance to root enemies in place (E key to toggle)",
          cost: { coins: 10000, gems: 100 },
          activation: "toggle",
          hotkey: "e",
          rootChance: 0.5,
          rootDuration: 3
        }
      },
      Thief: {
        ultimate1: {
          name: "Thief's Hand",
          icon: "ü§ö",
          desc: "Stuns all enemies, steals half their HP (Q key)",
          cost: { coins: 5000, gems: 50 },
          activation: "manual",
          hotkey: "q",
          cooldown: 60,
          stunDuration: 2
        },
        ultimate2: {
          name: "Phantom Clone",
          icon: "üë§",
          desc: "Create shadow clone that mirrors actions (E key)",
          cost: { coins: 10000, gems: 100 },
          activation: "manual",
          hotkey: "e",
          cooldown: 90,
          duration: 30,
          speedBoostOnDeath: 2.0,
          speedBoostDuration: 15
        }
      },
      Assassin: {
        ultimate1: {
          name: "Shadow Strike",
          icon: "üëª",
          desc: "Teleport behind enemy after 10 kills",
          cost: { coins: 5000, gems: 50 },
          activation: "kills",
          killRequirement: 10,
          cooldown: 25,
          damage: 300
        },
        ultimate2: {
          name: "Blade Storm",
          icon: "üåÄ",
          desc: "Spinning blades around player (Q key)",
          cost: { coins: 10000, gems: 100 },
          activation: "manual",
          hotkey: "q",
          cooldown: 45,
          duration: 5,
          damagePerSec: 50
        }
      },
      Wizard: {
        ultimate1: {
          name: "Meteor Storm",
          icon: "‚òÑÔ∏è",
          desc: "Rain 10 meteors from sky (Q key)",
          cost: { coins: 5000, gems: 50 },
          activation: "manual",
          hotkey: "q",
          cooldown: 40,
          count: 10,
          damage: 150
        },
        ultimate2: {
          name: "Time Freeze",
          icon: "‚ùÑÔ∏è",
          desc: "Freeze all enemies for 5s (E key)",
          cost: { coins: 10000, gems: 100 },
          activation: "manual",
          hotkey: "e",
          cooldown: 60,
          duration: 5
        }
      },
      Archer: {
        ultimate1: {
          name: "Arrow Barrage",
          icon: "üèπ",
          desc: "Fire 50 arrows in all directions after 20 kills",
          cost: { coins: 5000, gems: 50 },
          activation: "kills",
          killRequirement: 20,
          cooldown: 35,
          count: 50,
          damage: 30
        },
        ultimate2: {
          name: "Explosive Arrow",
          icon: "üí•",
          desc: "One massive explosive arrow (Q key)",
          cost: { coins: 10000, gems: 100 },
          activation: "manual",
          hotkey: "q",
          cooldown: 50,
          damage: 800,
          explosionRadius: 300
        }
      },
      Summoner: {
        ultimate1: {
          name: "Army of the Dead",
          icon: "üíÄ",
          desc: "Summon 10 skeletons instantly (Q key)",
          cost: { coins: 5000, gems: 50 },
          activation: "manual",
          hotkey: "q",
          cooldown: 70,
          count: 10
        },
        ultimate2: {
          name: "Sacrifice",
          icon: "üîÆ",
          desc: "Convert minions to shields (E key)",
          cost: { coins: 10000, gems: 100 },
          activation: "manual",
          hotkey: "e",
          cooldown: 40,
          shieldPerMinion: 30
        }
      },
      Bomber: {
        ultimate1: {
          name: "Nuke",
          icon: "‚ò¢Ô∏è",
          desc: "Massive screen explosion after 25 kills",
          cost: { coins: 5000, gems: 50 },
          activation: "kills",
          killRequirement: 25,
          cooldown: 80,
          damage: 1000
        },
        ultimate2: {
          name: "Chain Reaction",
          icon: "‚õìÔ∏è",
          desc: "Next 10 shots have 2x explosion radius (Q key)",
          cost: { coins: 10000, gems: 100 },
          activation: "manual",
          hotkey: "q",
          cooldown: 55,
          shotCount: 10
        }
      },
      Sniper: {
        ultimate1: {
          name: "Headhunter",
          icon: "üíÄ",
          desc: "Next 5 shots guaranteed 5x crits (Q key)",
          cost: { coins: 5000, gems: 50 },
          activation: "manual",
          hotkey: "q",
          cooldown: 35,
          shotCount: 5,
          critMultiplier: 5
        },
        ultimate2: {
          name: "Overwatch",
          icon: "üî≠",
          desc: "Auto-target highest HP enemy for 15s (E key)",
          cost: { coins: 10000, gems: 100 },
          activation: "manual",
          hotkey: "e",
          cooldown: 50,
          duration: 15
        }
      },
      Necromancer: {
        ultimate1: {
          name: "Plague",
          icon: "ü¶†",
          desc: "Poison all on-screen enemies (Q key)",
          cost: { coins: 5000, gems: 50 },
          activation: "manual",
          hotkey: "q",
          cooldown: 60,
          damagePerSec: 20,
          duration: 10
        },
        ultimate2: {
          name: "Soul Harvest",
          icon: "üëª",
          desc: "Heal from poison damage for 10s (E key)",
          cost: { coins: 10000, gems: 100 },
          activation: "manual",
          hotkey: "e",
          cooldown: 45,
          duration: 10
        }
      },
      Vecna: {
        ultimate1: {
          name: "Hive Mind",
          icon: "üëÅÔ∏è",
          desc: "Link all enemy HP - kill one, kill all (Q key)",
          cost: { coins: 50000, gems: 500 },
          activation: "manual",
          hotkey: "q",
          cooldown: 120,
          duration: 15
        },
        ultimate2: {
          name: "Vecna's Curse",
          icon: "üåÄ",
          desc: "Enter Upside Down: +50% dmg, 50% lifesteal (E key)",
          cost: { coins: 75000, gems: 750 },
          activation: "manual",
          hotkey: "e",
          cooldown: 90,
          duration: 20,
          damageBonus: 0.5,
          lifesteal: 0.5
        }
      },
      Engineer: {
        ultimate1: {
          name: "The Sentry",
          icon: "üî´",
          desc: "Deploy massive turret that shoots laser (50% of your HP damage) for 5s. Cooldown: 120 kills",
          cost: { coins: 15000, gems: 150 },
          activation: "kills",
          killRequirement: 120,
          cooldown: 0, // Reset by kills
          duration: 5,
          laserDamagePercent: 0.5 // 50% of player HP
        },
        ultimate2: {
          name: "The Protector",
          icon: "üõ°Ô∏è",
          desc: "Deploy shield turret that creates protective wall. Your shots slow enemies through it (E key)",
          cost: { coins: 20000, gems: 200 },
          activation: "manual",
          hotkey: "e",
          cooldown: 60,
          duration: 20,
          shieldRadius: 200,
          wallHP: 500,
          slowEffect: 0.5 // 50% slow
        }
      },
      TheForsakenOne: {
        ultimate1: {
          name: "Void Within",
          icon: "üåÄ",
          desc: "All random buffs activate at once for 5 seconds (Q key)",
          cost: { coins: 30000, gems: 300 },
          activation: "manual",
          hotkey: "q",
          cooldown: 30,
          duration: 5
        },
        ultimate2: {
          name: "Fractured Fate",
          icon: "üí•",
          desc: "Massive projectile that splits into 4 knockback fragments (E key)",
          cost: { coins: 40000, gems: 400 },
          activation: "manual",
          hotkey: "e",
          cooldown: 14,
          mainDamage: 100,
          fragmentDamage: 30,
          fragmentCount: 4,
          knockbackMultiplier: 2.0
        }
      }
    };

    // PERMANENT UPGRADES (Shop)
    const SHOP_UPGRADES = {
      damage: {
        name: "üí• Base Damage",
        desc: "Increase starting damage",
        maxLevel: 10,
        getBonus: (level) => level * 3,
        getCost: (level) => ({ coins: 50 + level * 30, gems: 0 })
      },
      health: {
        name: "‚ù§Ô∏è Base Health",
        desc: "Increase starting HP",
        maxLevel: 10,
        getBonus: (level) => level * 15,
        getCost: (level) => ({ coins: 40 + level * 25, gems: 0 })
      },
      fireRate: {
        name: "‚ö° Fire Rate",
        desc: "Shoot faster (reduces fire delay)",
        maxLevel: 5,
        getBonus: (level) => level * 0.05,
        getCost: (level) => ({ coins: 100 + level * 50, gems: level * 2 })
      },
      critChance: {
        name: "üí¢ Crit Chance",
        desc: "Start with critical hit chance",
        maxLevel: 5,
        getBonus: (level) => level * 0.05,
        getCost: (level) => ({ coins: 150 + level * 75, gems: level * 3 })
      },
      startLevel: {
        name: "‚≠ê Starting Level",
        desc: "Begin at higher level",
        maxLevel: 100, // Increased from 3 to 100
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 300 + (level * 50), gems: Math.floor(level / 2) }) // 300, 350, 400, etc.
      },
      healStrength: {
        name: "‚ù§Ô∏è Heal Potion Strength",
        desc: "+20 HP restored per level",
        maxLevel: 5,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 100 + level * 50, gems: level * 2 })
      },
      shieldStrength: {
        name: "üõ°Ô∏è Shield Potion Strength",
        desc: "+25 shield per level",
        maxLevel: 5,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 100 + level * 50, gems: level * 2 })
      },
      effectStrength: {
        name: "üí• Effect Potion Strength",
        desc: "Boost crit/damage/speed potions",
        maxLevel: 5,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 150 + level * 75, gems: level * 3 })
      },
      dragonStrength: {
        name: "üêâ Dragon Beam Power",
        desc: "+20 damage per level",
        maxLevel: 5,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 200 + level * 100, gems: level * 5 })
      },
      startingHeals: {
        name: "‚ù§Ô∏è Starting Heal Potions",
        desc: "+1 heal potion at wave start",
        maxLevel: 3,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 150 + level * 75, gems: level * 3 })
      },
      startingShields: {
        name: "üõ°Ô∏è Starting Shield Potions",
        desc: "+1 shield potion at wave start",
        maxLevel: 3,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 150 + level * 75, gems: level * 3 })
      },
      startingOthers: {
        name: "‚ö° Starting Effect Potions",
        desc: "+1 to all effect potions",
        maxLevel: 3,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 200 + level * 100, gems: level * 5 })
      },
      potionGen: {
        name: "üçÄ Potion Generation",
        desc: "Boosts potion drops (scales with wave #)",
        maxLevel: 5,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 250 + level * 125, gems: level * 6 })
      },
      potionDamage: {
        name: "‚öîÔ∏è Potion Damage Bonus",
        desc: "+2 damage per potion held",
        maxLevel: 5,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 200 + level * 100, gems: level * 4 })
      },
      potionExplosion: {
        name: "üí£ Potion Explosion",
        desc: "30 damage to random enemy when using potion",
        maxLevel: 5,
        getBonus: (level) => level,
        getCost: (level) => ({ coins: 300 + level * 150, gems: level * 7 })
      }
    };

    // TEMPORARY UPGRADES (Level-up)
    const UPGRADE_TYPES = {
      multiShot: {
        icon: "üåü",
        name: "Multi-Shot",
        maxLevel: 5,
        getCurrentLevel: (player) => player.upgradeLevels.multiShot,
        getDesc: (level) => {
          const descriptions = [
            "Fire +1 additional projectile (2 total)",
            "Fire +2 additional projectiles (3 total)", 
            "Fire +3 additional projectiles (4 total)",
            "Fire +4 additional projectiles (5 total)",
            "Fire +5 additional projectiles (6 total)"
          ];
          return descriptions[level - 1] || descriptions[0];
        },
        apply: (player, level) => {
          player.multiShot++;
          player.upgradeLevels.multiShot = level;
        },
        superUpgrade: {
          name: "‚ö° LASER BEAM",
          desc: "Constant damage beam instead of shots!",
          icon: "‚ö°",
          apply: (player) => {
            player.superUpgrades.laserBeam = true;
            player.laserBeam = true;
            player.laserDamage = player.damage * 0.5; // 50% damage per frame
          }
        }
      },
      damage: {
        icon: "‚öîÔ∏è",
        name: "Power Strike",
        maxLevel: 5,
        getCurrentLevel: (player) => player.upgradeLevels.damage,
        getDesc: (level) => `Increase damage by ${level * 25}% (Level ${level}/5)`,
        apply: (player, level) => {
          player.damage *= 1.25;
          player.upgradeLevels.damage = level;
        },
        superUpgrade: {
          name: "üí• BUCKSHOT",
          desc: "Spread shot + 25% knockback!",
          icon: "üí•",
          apply: (player) => {
            player.superUpgrades.buckshot = true;
            player.buckshot = true;
            player.buckshotSpread = 5; // 5 projectiles in spread
            player.knockback = (player.knockback || 0) + 25;
          }
        }
      },
      fireRate: {
        icon: "‚ö°",
        name: "Rapid Fire",
        maxLevel: 5,
        getCurrentLevel: (player) => player.upgradeLevels.fireRate,
        getDesc: (level) => `Attack ${level * 20}% faster (Level ${level}/5)`,
        apply: (player, level) => {
          player.fireRate *= 0.8;
          player.upgradeLevels.fireRate = level;
        },
        superUpgrade: {
          name: "üî• INSTANT FIRE",
          desc: "No attack delay - constant shooting!",
          icon: "üî•",
          apply: (player) => {
            player.superUpgrades.rapidFire = true;
            player.fireRate = 0.01; // Nearly instant
          }
        }
      },
      hp: {
        icon: "‚ù§Ô∏è",
        name: "Vitality Boost",
        maxLevel: 5,
        getCurrentLevel: (player) => player.upgradeLevels.hp,
        getDesc: (level) => `Gain +${30 * level} Max HP (Level ${level}/5)`,
        apply: (player, level) => {
          player.maxHP += 30;
          player.hp = player.maxHP;
          player.upgradeLevels.hp = level;
        },
        superUpgrade: {
          name: "üóø TITAN FORM",
          desc: "Double size + 200 HP + damage reduction!",
          icon: "üóø",
          apply: (player) => {
            player.superUpgrades.titanForm = true;
            player.maxHP += 200;
            player.hp = player.maxHP;
            player.titanForm = true;
            player.damageReduction = 0.3; // 30% damage reduction
          }
        }
      },
      range: {
        icon: "üéØ",
        name: "Extended Range",
        maxLevel: 5,
        getCurrentLevel: (player) => player.upgradeLevels.range,
        getDesc: (level) => `+${level * 30}% attack range (Level ${level}/5)`,
        apply: (player, level) => {
          player.range *= 1.3;
          player.upgradeLevels.range = level;
        },
        superUpgrade: {
          name: "‚ôæÔ∏è INFINITE RANGE",
          desc: "No distance limit - hit anywhere!",
          icon: "‚ôæÔ∏è",
          apply: (player) => {
            player.superUpgrades.infiniteRange = true;
            player.range = 99999;
          }
        }
      },
      projectileSpeed: {
        icon: "üöÄ",
        name: "Bullet Velocity",
        maxLevel: 5,
        getCurrentLevel: (player) => player.upgradeLevels.projectileSpeed,
        getDesc: (level) => `Projectiles ${level * 30}% faster (Level ${level}/5)`,
        apply: (player, level) => {
          player.projectileSpeed *= 1.3;
          player.upgradeLevels.projectileSpeed = level;
        },
        superUpgrade: {
          name: "üí´ LIGHT SPEED",
          desc: "Instant hit - bullets teleport!",
          icon: "üí´",
          apply: (player) => {
            player.superUpgrades.lightSpeed = true;
            player.projectileSpeed = 999;
          }
        }
      },
      pierce: {
        icon: "üî±",
        name: "Piercing Shots",
        maxLevel: 5,
        getCurrentLevel: (player) => player.upgradeLevels.pierce,
        getDesc: (level) => `Pierce ${level} enemies (Level ${level}/5)`,
        apply: (player, level) => {
          player.pierce = true;
          player.pierceCount = level;
          player.upgradeLevels.pierce = level;
        },
        superUpgrade: {
          name: "üëª PHASE BULLETS",
          desc: "Pass through everything - infinite pierce!",
          icon: "üëª",
          apply: (player) => {
            player.superUpgrades.phaseBullets = true;
            player.pierceCount = 999;
          }
        }
      },
      lifesteal: {
        icon: "ü©∏",
        name: "Life Drain",
        maxLevel: 5,
        getCurrentLevel: (player) => player.upgradeLevels.lifesteal,
        getDesc: (level) => `Heal ${level * 15}% of damage dealt (Level ${level}/5)`,
        apply: (player, level) => {
          player.lifesteal = (player.lifesteal || 0) + 0.15;
          player.upgradeLevels.lifesteal = level;
        },
        superUpgrade: {
          name: "üßõ VAMPIRE MODE",
          desc: "100% lifesteal + health regen!",
          icon: "üßõ",
          apply: (player) => {
            player.superUpgrades.vampireMode = true;
            player.lifesteal = 1.0; // 100%
            player.regen = (player.regen || 0) + 5; // +5 HP/sec
          }
        }
      },
      explosive: {
        icon: "üí•",
        name: "Explosive Rounds",
        maxLevel: 5,
        getCurrentLevel: (player) => player.upgradeLevels.explosive,
        getDesc: (level) => `Explosion radius +${level * 20} (Level ${level}/5)`,
        apply: (player, level) => {
          player.explosive = true;
          player.explosionRadius = 60 + (level * 20);
          player.upgradeLevels.explosive = level;
        },
        superUpgrade: {
          name: "‚ò¢Ô∏è NUKE SHOTS",
          desc: "Screen-wide explosions!",
          icon: "‚ò¢Ô∏è",
          apply: (player) => {
            player.superUpgrades.nukeShots = true;
            player.explosionRadius = 500;
          }
        }
      },
      criticalHit: {
        icon: "üí¢",
        name: "Critical Strike",
        maxLevel: 5,
        getCurrentLevel: (player) => player.upgradeLevels.criticalHit,
        getDesc: (level) => `${level * 20}% crit chance, ${1.5 + level * 0.5}x damage (Level ${level}/5)`,
        apply: (player, level) => {
          player.critChance = (player.critChance || 0) + 0.2;
          player.critMultiplier = 1.5 + (level * 0.5);
          player.upgradeLevels.criticalHit = level;
        },
        superUpgrade: {
          name: "üéØ GUARANTEED CRITS",
          desc: "Every shot crits for 5x damage!",
          icon: "üéØ",
          apply: (player) => {
            player.superUpgrades.guaranteedCrits = true;
            player.critChance = 1.0; // 100%
            player.critMultiplier = 5.0; // 5x damage
          }
        }
      },
      shield: {
        icon: "üõ°Ô∏è",
        name: "Energy Shield",
        maxLevel: 5,
        getCurrentLevel: (player) => player.upgradeLevels.shield,
        getDesc: (level) => `+${level * 50} shield capacity (Level ${level}/5)`,
        apply: (player, level) => {
          player.shield = (player.shield || 0) + 50;
          player.maxShield = (player.maxShield || 0) + 50;
          player.upgradeLevels.shield = level;
        },
        superUpgrade: {
          name: "üõ°Ô∏è INVINCIBLE",
          desc: "Permanent shield regeneration!",
          icon: "üõ°Ô∏è",
          apply: (player) => {
            player.superUpgrades.invincible = true;
            player.shieldRegen = 10; // 10 shield per second
          }
        }
      },
      regeneration: {
        icon: "üíö",
        name: "Regeneration",
        maxLevel: 5,
        getCurrentLevel: (player) => player.upgradeLevels.regeneration,
        getDesc: (level) => `Heal ${level * 2} HP per second (Level ${level}/5)`,
        apply: (player, level) => {
          player.regen = (player.regen || 0) + 2;
          player.upgradeLevels.regeneration = level;
        },
        superUpgrade: {
          name: "‚ôæÔ∏è IMMORTAL",
          desc: "Massive regen + can't die for 5 seconds after damage!",
          icon: "‚ôæÔ∏è",
          apply: (player) => {
            player.superUpgrades.immortal = true;
            player.regen = 20; // 20 HP/sec
            player.immortalWindow = true; // Brief invuln after hit
          }
        }
      },
      chainLightning: {
        icon: "‚ö°",
        name: "Chain Lightning",
        maxLevel: 5,
        getCurrentLevel: (player) => player.upgradeLevels.chainLightning,
        getDesc: (level) => `Chains to ${level * 2} enemies (Level ${level}/5)`,
        apply: (player, level) => {
          player.chainLightning = level * 2;
          player.upgradeLevels.chainLightning = level;
        },
        superUpgrade: {
          name: "‚õàÔ∏è STORM",
          desc: "Infinite chains - hits every enemy!",
          icon: "‚õàÔ∏è",
          apply: (player) => {
            player.superUpgrades.storm = true;
            player.chainLightning = 999;
          }
        }
      },
      damageAura: {
        icon: "üî•",
        name: "Flame Aura",
        maxLevel: 5,
        getCurrentLevel: (player) => player.upgradeLevels.damageAura,
        getDesc: (level) => `${level * 3} damage/sec in ${60 + level * 20} radius (Level ${level}/5)`,
        apply: (player, level) => {
          player.aura = { 
            damage: level * 3,
            radius: 60 + (level * 20)
          };
          player.upgradeLevels.damageAura = level;
        },
        superUpgrade: {
          name: "üî• INFERNO",
          desc: "Screen-wide burning aura!",
          icon: "üî•",
          apply: (player) => {
            player.superUpgrades.inferno = true;
            player.aura = { damage: 50, radius: 800 };
          }
        }
      },
      freezeBullets: {
        icon: "üßä",
        name: "Freeze Bullets",
        maxLevel: 5,
        getCurrentLevel: (player) => player.upgradeLevels.freezeBullets,
        getDesc: (level) => `${level * 20}% slow + ${level * 10}% freeze chance (Level ${level}/5)`,
        apply: (player, level) => {
          player.freezeBullets = true;
          player.slowAmount = level * 0.2; // 20% per level
          player.freezeChance = level * 0.1; // 10% per level
          player.upgradeLevels.freezeBullets = level;
        },
        superUpgrade: {
          name: "‚ùÑÔ∏è ABSOLUTE ZERO",
          desc: "Freeze entire screen on hit!",
          icon: "‚ùÑÔ∏è",
          apply: (player) => {
            player.superUpgrades.absoluteZero = true;
            player.freezeChance = 1.0; // 100% freeze
            player.freezeDuration = 5; // 5 seconds
          }
        }
      },
      knockback: {
        icon: "üí®",
        name: "Knockback Power",
        maxLevel: 5,
        getCurrentLevel: (player) => player.upgradeLevels.knockback,
        getDesc: (level) => `Push enemies back ${level * 15} units (Level ${level}/5)`,
        apply: (player, level) => {
          player.knockback = (player.knockback || 0) + 15;
          player.upgradeLevels.knockback = level;
        },
        superUpgrade: {
          name: "üåÄ GRAVITY WELL",
          desc: "Pull all enemies together then explode!",
          icon: "üåÄ",
          apply: (player) => {
            player.superUpgrades.gravityWell = true;
            player.gravityPull = true;
            player.gravityRadius = 400;
          }
        }
      },
      homingShots: {
        icon: "üéØ",
        name: "Homing Shots",
        maxLevel: 5,
        getCurrentLevel: (player) => player.upgradeLevels.homingShots,
        getDesc: (level) => `Tracking strength: ${level * 20}% (Level ${level}/5)`,
        apply: (player, level) => {
          player.homingShots = true;
          player.homingStrength = level * 0.2;
          player.upgradeLevels.homingShots = level;
        },
        superUpgrade: {
          name: "üêù SEEKING SWARM",
          desc: "All bullets track perfectly and split!",
          icon: "üêù",
          apply: (player) => {
            player.superUpgrades.seekingSwarm = true;
            player.homingStrength = 1.0;
            player.bulletSplit = true; // Bullets split on hit
          }
        }
      },
      potionDamageBonus: {
        icon: "‚öîÔ∏è",
        name: "Potion Damage Bonus",
        maxLevel: 99, // No max for potion upgrades
        getCurrentLevel: (player) => 0, // Always show
        getDesc: () => "+2 damage per potion held",
        apply: (player) => {
          gameData.potionUpgrades.potionDamage = (gameData.potionUpgrades.potionDamage || 0) + 1;
          saveGameData();
        }
      },
      potionExplosion: {
        icon: "üí£",
        name: "Potion Explosion",
        maxLevel: 99, // No max for potion upgrades
        getCurrentLevel: (player) => 0, // Always show
        getDesc: () => "30 damage to random enemy when using potion",
        apply: (player) => {
          gameData.potionUpgrades.potionExplosion = (gameData.potionUpgrades.potionExplosion || 0) + 1;
          saveGameData();
        }
      },
      potionGeneration: {
        icon: "üçÄ",
        name: "Potion Generation",
        maxLevel: 99, // No max for potion upgrades
        getCurrentLevel: (player) => 0, // Always show
        getDesc: () => "Boost potion drops (scales with wave)",
        apply: (player) => {
          gameData.potionUpgrades.potionGen = (gameData.potionUpgrades.potionGen || 0) + 1;
          saveGameData();
        }
      },
      flameBurst: {
        icon: "üî•",
        name: "Flame Burst",
        maxLevel: 5,
        classRestriction: ["Pyromancer"], // Only Pyromancer can get this
        getCurrentLevel: (player) => player.upgradeLevels.flameBurst,
        getDesc: (level) => `Bullets burn for ${level * 10} damage over 3s (Level ${level}/5)`,
        apply: (player, level) => {
          player.flameBurst = true;
          player.burnDamage = level * 10;
          player.burnDuration = 3;
          player.upgradeLevels.flameBurst = level;
        },
        superUpgrade: {
          name: "üåã INFERNO CHAIN",
          desc: "Burns chain to nearby enemies!",
          icon: "üåã",
          apply: (player) => {
            player.superUpgrades.infernoChain = true;
            player.burnChain = true;
            player.burnChainRange = 150;
            player.burnDamage = 100; // Massive burn damage
          }
        }
      }
    };

    // ACHIEVEMENT UNLOCK REQUIREMENTS
    const ACHIEVEMENT_UNLOCKS = {
      freeze100: {
        title: "Freeze 100 Enemies",
        requirement: "üßä Freeze 100 enemies total",
        description: "Use ice-based abilities or upgrades to freeze enemies. Progress is saved across all runs.",
        icon: "‚ùÑÔ∏è"
      },
      defeat3Elites: {
        title: "Defeat 3 Elite Enemies",
        requirement: "üíÄ Defeat 3 elite enemies (mini-bosses or bosses)",
        description: "Elite enemies appear every 5 waves (mini-bosses) and every 10 waves (bosses). Kill 3 total.",
        icon: "ü©∏"
      },
      collect5ArcCores: {
        title: "Collect 5 Arc Cores",
        requirement: "‚ö° Collect 5 Arc Cores from enemies",
        description: "Arc Cores are rare drops from electric-type enemies. Look for glowing blue orbs.",
        icon: "‚ö°"
      },
      heal1000HP: {
        title: "Heal 1000 Total HP",
        requirement: "üíö Heal 1000 HP across all runs",
        description: "Use heal potions, lifesteal, regeneration upgrades. All healing counts toward this total.",
        icon: "‚úùÔ∏è"
      },
      fallingStarDrop: {
        title: "Find a Falling Star",
        requirement: "üåü Obtain a rare Falling Star drop",
        description: "Extremely rare random drop from any enemy. Higher waves = slightly better chance.",
        icon: "üåü"
      },
      kill100In10Sec: {
        title: "Kill 100 in 10 Seconds",
        requirement: "‚öîÔ∏è Kill 100 enemies within 10 seconds",
        description: "Use AoE classes (Bomber, Necromancer) on high-wave swarms. Requires explosive damage!",
        icon: "üåë"
      },
      rejectAllPowerups: {
        title: "The Forsaken Challenge",
        requirement: "üíÄ Reject ALL powerups and reach Wave 11",
        description: "Don't choose ANY level-up upgrades. Don't use ANY potions. Survive to Wave 11 without help!",
        icon: "üíÄ"
      },
      wave18Restart7Times: {
        title: "The Solar Sacrifice",
        requirement: "‚òÄÔ∏è Restart at Wave 18 exactly, 7 times",
        description: "When you reach Wave 18, restart the game. Do this 7 times to unlock Dr.Sunshine!",
        icon: "‚òÄÔ∏è"
      }
    };

    // BOSS PATTERNS
    const BOSS_PATTERNS = [
      {
        name: "The Charger",
        color: "#ff00ff",
        pattern: "charge", // Speeds up periodically
        speed: 0.8,
        attackInterval: 2,
        specialAbility: "Speed Burst"
      },
      {
        name: "The Sniper",
        color: "#ff4444",
        pattern: "ranged", // Shoots multiple projectiles
        speed: 0.5,
        attackInterval: 3,
        specialAbility: "Triple Shot"
      },
      {
        name: "The Tank",
        color: "#4444ff",
        pattern: "tank", // Extra HP and shield
        speed: 0.6,
        attackInterval: 2.5,
        specialAbility: "Shield Regen"
      },
      {
        name: "The Alchemist",
        color: "#9932CC",
        pattern: "alchemist", // Stays at start, shoots blasts, casts debuffs
        speed: 0.2, // Very slow, waits for enemies
        attackInterval: 2,
        specialAbility: "Debuff Blast",
        wave: 30 // Only spawns at wave 30
      },
      {
        name: "The Summoner",
        color: "#88ff88",
        pattern: "summon", // Spawns extra enemies
        speed: 0.7,
        attackInterval: 4,
        specialAbility: "Spawn Minions"
      },
      {
        name: "Boss CremeCheese Bagel",
        color: "#F5DEB3",
        pattern: "bagel", // Flying boss with clones
        speed: 1.5, // Fast flyer
        attackInterval: 1.5,
        specialAbility: "Clone Army",
        wave: 40, // Only spawns at wave 40
        isFlying: true
      },
      {
        name: "Spiderman Boss",
        color: "#DC143C",
        pattern: "spiderman", // Multiple enemies stacked, kill each leg
        speed: 0.6,
        attackInterval: 2,
        specialAbility: "Spider Legs",
        wave: 50 // Only spawns at wave 50
      },
      {
        name: "The Berserker",
        color: "#ff8800",
        pattern: "berserk", // Gets faster as HP lowers
        speed: 0.9,
        attackInterval: 1.5,
        specialAbility: "Rage Mode"
      },
      {
        name: "The Headless",
        color: "#8B0000",
        pattern: "headthrow", // Throws its head as projectile
        speed: 0.7,
        attackInterval: 3,
        specialAbility: "Head Throw"
      }
    ];

    // GAME STATE
    let keys = {};
    window.keys = keys; // Make accessible for sprite animation
    let lastTime = 0;
    let gameRunning = false;
    let screenShake = 0;
    let gameState = "playing";
    let gamePaused = false;
    let brightnessLevel = 1.0;
    let volumeLevel = 1.0;
    let roundBreakTimer = 0;
    
    // PLAYER DEBUFF SYSTEM
    let playerDebuffs = {
      cursed: false,
      cursedTimer: 0,
      poisoned: false,
      poisonedTimer: 0,
      poisonDamage: 0
    };
    
    // MOUSE POSITION for cursor aiming
    let mouseX = canvas.width / 2;
    let mouseY = canvas.height / 2;
    let mouseAiming = false;

    // SPRITE SYSTEM
    const characterSprites = {};
    let spritesLoaded = false;
    const SPRITE_MAP = {
      'Hunter': 'hunter',
      'Knight': 'knight',
      'Archer': 'archer',
      'Thief': 'thief',
      'Mage': null, // Need sprite
      'Pyromancer': 'pyromancer',
      'Frostmage': 'frostmage',
      'Tank': 'tank',
      'Berserk': null, // Need sprite
      'Paladin': 'healer',
      'Ninja': 'ninja',
      'Bomber': 'bomber',
      'Sniper': 'sniper',
      'Samurai': null, // Need sprite
      'Monk': 'monk',
      'Warlock': null, // Need sprite
      'Druid': null, // Need sprite
      'Assassin': 'assassin',
      'Summoner': 'summoner',
      'Gunslinger': null, // Need sprite
      'DarkMagician': 'dark_magician',
      'Ranger': null, // Need sprite
      'Necromancer': 'necromancer',
      'Vecna': 'vecna',
      'Engineer': 'engineer',
      'TheForsakenOne': null // Need sprite
    };

    let player = null;
    let enemies = [];
    let projectiles = [];
    let minions = [];
    let particles = [];
    let floatingTexts = [];
    let currencyDrops = [];

    let shootTimer = 0;
    let wave = 1;
    let enemiesToSpawn = 0;
    let spawnTimer = 0;
    let autoShoot = true;
    let autoAim = true;
    let autoStartWave = false; // Auto-start next wave when ready
    let gameSpeed = 1; // Game speed multiplier (1 = normal, 2 = 2x, 3 = 3x)
    let combo = 0;
    let comboTimer = 0;
    let maxCombo = 0;
    
    let sessionCoins = 0;
    let sessionGems = 0;
    
    // Game over countdown
    let gameOverCountdownInterval = null;
    
    // New features
    let shufflesRemaining = 4; // Shuffle counter for upgrades
    let currentMap = 1; // Map tracking
    let mapsCompleted = 0;
    let enemiesKilled = 0; // Track kills for stats
    let enemiesThisWave = 0; // Total enemies spawned this wave
    let enemiesKilledThisWave = 0; // Enemies killed this wave
    let waveTimer = 0; // Timer for next wave (30s after last spawn)
    let waveTimerActive = false; // Is wave timer counting down?
    let shieldUpgradesChosen = 0; // Track shield upgrades for Guardian Tank unlock
    
    // Dragon beam fire zones
    let fireZones = [];
    
    // NEW CLASS MECHANICS
    let iceShards = []; // CryoSentinel ice shards stuck in ground
    let poisonClouds = []; // PlagueDoctor placeable clouds
    let rootBarriers = []; // Druid root walls
    let helperStars = []; // Starcaller mini star helpers
    let turrets = []; // Engineer turrets
    let samuraiSlashes = []; // Samurai chain reaction slashes
    let illusionistClone = null; // Illusionist's fighting clone
    let eclipseMoon = null; // Dr.Eclipse's controllable moon
    
    // Clickable upgrade UI state
    let upgradePopup = {
      active: false,
      target: null, // What's being upgraded (sun, turret, clone, etc)
      x: 0,
      y: 0
    };
    
    // Engineer turret crafting UI
    let turretCraftUI = {
      active: false,
      selectedType: null, // 'shield' or 'dps'
      dragging: false,
      dragX: 0,
      dragY: 0
    };
    
    // Cooldowns for special abilities
    let plagueCloudCooldown = 0;
    let clericHealCooldown = 0;
    let druidRootCooldown = 0;
    
    // Potion system
    let potions = {
      heal: 3,
      shield: 2,
      crit: 1,
      damage: 1,
      speed: 1,
      dragon: 1,
      cleanse: 2
    };
    
    let potionCooldowns = {
      heal: 0,
      shield: 0,
      crit: 0,
      damage: 0,
      speed: 0,
      dragon: 0,
      cleanse: 0
    };
    
    let potionEffects = {
      critActive: false,
      critTimer: 0,
      damageActive: false,
      damageTimer: 0,
      speedActive: false,
      speedTimer: 0
    };

    // ABILITY SYSTEM
    let ability1Cooldown = 0;
    let ability2Cooldown = 0;
    let ability1KillCounter = 0;
    let ability2KillCounter = 0;
    let ability1Active = false;
    let ability2Active = false;
    
    // Special ability states
    let lastStandUsed = false;
    let chainReactionShots = 0;
    let headhunterShots = 0;
    let overwatchActive = false;
    let overwatchTimer = 0;
    let bladeStormActive = false;
    let bladeStormTimer = 0;
    let soulHarvestActive = false;
    let soulHarvestTimer = 0;
    let timeFreezeActive = false;
    let timeFreezeTimer = 0;
    
    // Vecna special states
    let hiveMindActive = false;
    let hiveMindTimer = 0;
    let upsideDownActive = false;
    let upsideDownTimer = 0;
    let vecnaKillCounter = 0;
    let vecnaMonsters = [];
    let vecnaMonsterKillCounter = 0;
    let convertedEnemies = [];
    
    // Archer special states
    let cupidsBowActive = false;
    let cupidsBowShots = 0;
    let hookShotActive = false;
    
    // Thief special states
    let phantomClone = null;
    let phantomSpeedBoost = false;
    let phantomSpeedBoostTimer = 0;

    // Initialize
    loadGameData();
    updateShopDisplay();
    updateTitleScreenDisplay();
    
    // Ensure correct initial screen state
    titleScreen.classList.remove("hidden");
    classSelection.classList.remove("active");
    shopScreen.classList.remove("active");
    tutorialScreen.style.display = "none";
    roundBreakScreen.classList.remove("active");
    gameOverScreen.classList.remove("active");
    upgradeScreen.classList.remove("active");

    // EVENT LISTENERS
    startBtn.addEventListener("click", () => {
      titleScreen.classList.add("hidden");
      showClassSelection();
    });

    shopBtn.addEventListener("click", () => {
      titleScreen.classList.add("hidden");
      showShop();
    });
    
    waveSelectBtn.addEventListener("click", () => {
      titleScreen.classList.add("hidden");
      showWaveSelect();
    });
    
    evolAuraBtn.addEventListener("click", () => {
      titleScreen.classList.add("hidden");
      showEvolAura();
    });

    shopBackBtn.addEventListener("click", () => {
      shopScreen.classList.remove("active");
      titleScreen.classList.remove("hidden");
    });
    
    auraBackBtn.addEventListener("click", () => {
      document.getElementById('evolAuraScreen').style.display = 'none';
      titleScreen.classList.remove("hidden");
    });
    
    tutorialBtn.addEventListener("click", () => {
      titleScreen.classList.add("hidden");
      tutorialScreen.style.display = "flex";
    });
    
    tutorialBackBtn.addEventListener("click", () => {
      tutorialScreen.style.display = "none";
      titleScreen.classList.remove("hidden");
    });
    
    redeemCodeBtn.addEventListener("click", () => {
      titleScreen.classList.add("hidden");
      showRedeemCodeScreen();
    });
    
    redeemBackBtn.addEventListener("click", () => {
      document.getElementById('redeemCodeScreen').style.display = 'none';
      titleScreen.classList.remove("hidden");
    });
    
    redeemSubmitBtn.addEventListener("click", () => {
      redeemCode();
    });
    
    redeemCodeInput.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        redeemCode();
      }
    });
    
    // Unlock modal close button
    unlockModalClose.addEventListener("click", () => {
      closeUnlockModal();
    });
    
    // Close modal when clicking the backdrop (not the content)
    unlockModal.addEventListener("click", (e) => {
      // If click is directly on the modal backdrop (not bubbled from content), close it
      if (e.target === unlockModal) {
        closeUnlockModal();
      }
    });
    
    // Potion click handlers
    document.getElementById('potionHeal').addEventListener('click', () => usePotion('heal'));
    document.getElementById('potionShield').addEventListener('click', () => usePotion('shield'));
    document.getElementById('potionCrit').addEventListener('click', () => usePotion('crit'));
    document.getElementById('potionDamage').addEventListener('click', () => usePotion('damage'));
    document.getElementById('potionSpeed').addEventListener('click', () => usePotion('speed'));
    document.getElementById('potionDragon').addEventListener('click', () => usePotion('dragon'));
    document.getElementById('potionCleanse').addEventListener('click', () => usePotion('cleanse'));
    
    // Ability button click handlers
    document.getElementById('ability1Btn').addEventListener('click', () => activateAbility1());
    document.getElementById('ability2Btn').addEventListener('click', () => activateAbility2());
    
    // Pause menu button listeners
    document.getElementById('resumeBtn').addEventListener('click', () => {
      togglePause();
    });
    
    document.getElementById('returnLobbyBtn').addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      console.log('üè† Return Home button clicked - returning immediately');
      
      // IMMEDIATELY stop everything
      gameRunning = false;
      gamePaused = false;
      gameState = "title";
      
      // Get pause menu element
      const pauseMenu = document.getElementById('pauseMenu');
      
      // COMPLETELY HIDE pause menu
      pauseMenu.classList.remove('active');
      pauseMenu.style.display = 'none';
      pauseMenu.style.visibility = 'hidden';
      pauseMenu.style.opacity = '0';
      pauseMenu.style.zIndex = '-100';
      pauseMenu.style.pointerEvents = 'none';
      
      // COMPLETELY HIDE canvas
      canvas.style.display = 'none';
      canvas.style.visibility = 'hidden';
      canvas.style.opacity = '0';
      canvas.style.zIndex = '-100';
      canvas.style.pointerEvents = 'none';
      
      // Hide ALL other screens
      document.getElementById('classSelection').classList.remove('active');
      document.getElementById('shopScreen').classList.remove('active');
      document.getElementById('gameOverScreen').classList.remove('active');
      document.getElementById('upgradeScreen').classList.remove('active');
      document.getElementById('roundBreakScreen').classList.remove('active');
      document.getElementById('tutorialScreen').style.display = 'none';
      document.getElementById('evolAuraScreen').style.display = 'none';
      
      // SHOW title screen - remove hidden class, clear ALL inline styles
      titleScreen.classList.remove('hidden');
      titleScreen.removeAttribute('style'); // Remove ALL inline styles completely!
      
      // Force reflow to ensure browser processes changes
      void titleScreen.offsetHeight;
      
      // Use setTimeout to ensure browser has processed everything
      setTimeout(() => {
        // Double-check title screen is visible
        if (titleScreen.classList.contains('hidden')) {
          titleScreen.classList.remove('hidden');
        }
        
        // Ensure canvas is still hidden
        canvas.style.display = 'none';
        
        console.log('‚úÖ Title screen forced visible after delay');
      }, 50);
      
      // Then do cleanup
      returnToHome();
      
      console.log('‚úÖ Returned to home screen - fully visible!');
      console.log('   Canvas display:', canvas.style.display);
      console.log('   Title screen classes:', titleScreen.className);
    });
    
    document.getElementById('brightnessSlider').addEventListener('input', (e) => {
      setBrightness(e.target.value);
    });
    
    document.getElementById('volumeSlider').addEventListener('input', (e) => {
      setVolume(e.target.value);
    });

    window.addEventListener("keydown", (e) => {
      keys[e.key] = true;
      
      // ESC to pause/unpause - ALWAYS works when playing
      if (e.key === "Escape" && gameState === "playing") {
        e.preventDefault();
        console.log('üéÆ ESC pressed - toggling pause');
        console.log('   Current gamePaused:', gamePaused);
        togglePause();
        console.log('   New gamePaused:', gamePaused);
        return;
      }
      
      if (e.key === " " || e.code === "Space") {
        e.preventDefault();
        if (gameState === "roundBreak") {
          endRoundBreak();
        } else if (waveTimerActive && waveTimer <= 0 && !autoStartWave) {
          // Manually start next wave
          wave++;
          waveTimerActive = false;
          
          // Check for map progression (every 20 waves)
          if (wave % 20 === 1 && wave > 1) {
            currentMap++;
            mapsCompleted++;
            shufflesRemaining = 4;
            addFloatingText(canvas.width / 2, 200, `üó∫Ô∏è MAP ${currentMap} üó∫Ô∏è`, "#ff00ff");
            addFloatingText(canvas.width / 2, 230, "SHUFFLES RESET!", "#00ffff");
            screenShake += 15;
          }
          
          // Give wave bonus XP
          const waveBonus = 50 + wave * 10;
          giveXP(waveBonus);
          addFloatingText(canvas.width / 2, 150, "WAVE " + wave + " START!", "#00ffff");
          
          // Potions DO NOT reset - Summoner ability only!
          
          // Reset Last Stand for new wave
          lastStandUsed = false;
          
          // Start next wave
          enemiesToSpawn = calcEnemiesForWave(wave);
          spawnTimer = 0;
          
          // Spawn boss/mini-boss immediately if applicable
          if (wave % 10 === 0) {
            spawnEnemy(true, false);
            enemiesToSpawn--;
          } else if (wave % 5 === 0) {
            spawnEnemy(false, true);
            enemiesToSpawn--;
          }
        }
      }
      if (e.key === "t" || e.key === "T") {
        autoShoot = !autoShoot;
      }
      if (e.key === "y" || e.key === "Y") {
        autoAim = !autoAim;
      }
      if (e.key === "r" || e.key === "R") {
        autoStartWave = !autoStartWave;
        addFloatingText(canvas.width / 2, 150, autoStartWave ? "Auto-Start: ON" : "Auto-Start: OFF", autoStartWave ? "#00ff00" : "#ff0000");
      }
      if (e.key === "f" || e.key === "F") {
        gameSpeed = gameSpeed === 1 ? 2 : 1; // Toggle between 1x and 2x
        addFloatingText(canvas.width / 2, 180, "Game Speed: " + gameSpeed + "x", gameSpeed === 2 ? "#ff8800" : "#ffffff");
      }
      
      // Potion hotkeys
      if (e.key === "1") usePotion('heal');
      if (e.key === "2") usePotion('shield');
      if (e.key === "3") usePotion('crit');
      if (e.key === "4") usePotion('damage');
      if (e.key === "5") usePotion('speed');
      if (e.key === "6") usePotion('dragon');
      if (e.key === "7") usePotion('cleanse');
      
      // Ability hotkeys
      if ((e.key === "q" || e.key === "Q") && gameState === "playing") {
        activateAbility1();
      }
      if ((e.key === "e" || e.key === "E") && gameState === "playing") {
        activateAbility2();
      }
      
      // Dr.Sunshine password unlock (Press 'U' key)
      if ((e.key === "u" || e.key === "U") && !gameData.unlockedClasses.includes("DrSunshine")) {
        e.preventDefault();
        const password = prompt("üîê Enter the password to unlock Dr.Sunshine:");
        if (password === "Mr.Cotter" || password === "Mr. Cotter" || password === "mr.cotter" || password === "mr. cotter") {
          gameData.unlockedClasses.push("DrSunshine");
          saveGameData();
          addFloatingText(canvas.width / 2, 150, "‚òÄÔ∏è DR.SUNSHINE UNLOCKED! ‚òÄÔ∏è", "#FFD700");
          screenShake += 8;
          console.log("‚òÄÔ∏è DR.SUNSHINE UNLOCKED! (Password: Mr.Cotter)");
          alert("üéâ Dr.Sunshine has been unlocked! Select him from the class selection screen.");
        } else if (password) {
          alert("‚ùå Incorrect password. Hint: Think about your teacher!");
        }
      }
    });
    
    window.addEventListener("keyup", (e) => {
      keys[e.key] = false;
    });
    
    // CANVAS MOUSEMOVE for turret drag tracking AND cursor aiming
    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      mouseY = e.clientY - rect.top;
      
      // Enable mouse aiming if cursor is in valid area (not underground/potion bar)
      const potionBarY = canvas.height - 80; // Potion bar area
      if (mouseY < player.y && mouseY < potionBarY) {
        mouseAiming = true;
      } else {
        mouseAiming = false; // Fall back to auto-aim
      }
      
      if (turretCraftUI.dragging) {
        turretCraftUI.dragX = mouseX;
        turretCraftUI.dragY = mouseY;
      }
    });
    
    // CANVAS CLICK EVENTS for clickable upgrades
    canvas.addEventListener("click", (e) => {
      if (!gameRunning || gameState !== "playing") return;
      
      const rect = canvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      
      // Handle upgrade popup clicks
      if (upgradePopup.active) {
        const popupW = 300;
        const popupH = 350;
        const popupX = upgradePopup.x;
        const popupY = upgradePopup.y;
        
        // Check close button
        if (clickX >= popupX + popupW - 30 && clickX <= popupX + popupW - 10 &&
            clickY >= popupY + 10 && clickY <= popupY + 30) {
          closeUpgradePopup();
          return;
        }
        
        // Check upgrade buttons
        const buttonY = [popupY + 200, popupY + 250, popupY + 300];
        for (let i = 0; i < 3; i++) {
          if (clickX >= popupX + 20 && clickX <= popupX + popupW - 20 &&
              clickY >= buttonY[i] && clickY <= buttonY[i] + 35) {
            const upgradeTypes = {
              'clone': ['damage', 'fireRate', 'hp'],
              'sun': ['damage', 'radius', 'speed'],
              'turret': ['damage', 'fireRate', 'range'],
              'root': ['damage', 'slow', 'duration']
            };
            purchaseUpgrade(upgradeTypes[upgradePopup.type][i]);
            return;
          }
        }
        return;
      }
      
      // Handle turret craft UI clicks
      if (turretCraftUI.active && !turretCraftUI.dragging) {
        const craftX = canvas.width / 2 - 150;
        const craftY = canvas.height / 2 - 100;
        
        // Close button
        if (clickX >= craftX + 270 && clickX <= craftX + 290 &&
            clickY >= craftY + 10 && clickY <= craftY + 30) {
          closeTurretCraftUI();
          return;
        }
        
        // Shield Turret button
        if (clickX >= craftX + 20 && clickX <= craftX + 280 &&
            clickY >= craftY + 50 && clickY <= craftY + 90) {
          turretCraftUI.selectedType = 'shield';
          turretCraftUI.dragging = true;
          return;
        }
        
        // DPS Turret button
        if (clickX >= craftX + 20 && clickX <= craftX + 280 &&
            clickY >= craftY + 100 && clickY <= craftY + 140) {
          turretCraftUI.selectedType = 'dps';
          turretCraftUI.dragging = true;
          return;
        }
        return;
      }
      
      // Handle turret placement while dragging
      if (turretCraftUI.dragging) {
        const dx = clickX - player.x;
        const dy = clickY - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist <= 250) { // 50 radius increased to 250 for better gameplay
          // Place turret
          const turretCost = 500;
          if (coins >= turretCost) {
            coins -= turretCost;
            updateCoinsDisplay();
            
            turrets.push({
              x: clickX,
              y: clickY,
              damage: turretCraftUI.selectedType === 'shield' ? 5 : 20,
              fireRate: turretCraftUI.selectedType === 'shield' ? 1500 : 800,
              range: turretCraftUI.selectedType === 'shield' ? 150 : 250,
              lastShot: 0,
              type: turretCraftUI.selectedType,
              upgradeLevel: 0
            });
            
            addFloatingText(clickX, clickY - 30, "TURRET PLACED!", "#00ff00");
          } else {
            addFloatingText(player.x, player.y - 50, "Need 500 coins!", "#ff0000");
          }
        } else {
          addFloatingText(player.x, player.y - 50, "Too far! (Max 250 range)", "#ff0000");
        }
        
        closeTurretCraftUI();
        return;
      }
      
      // Check if clicked on Illusionist clone
      if (illusionistClone && illusionistClone.hp > 0) {
        if (clickX >= illusionistClone.x && clickX <= illusionistClone.x + illusionistClone.w &&
            clickY >= illusionistClone.y && clickY <= illusionistClone.y + illusionistClone.h) {
          openUpgradePopup('clone', illusionistClone);
          return;
        }
      }
      
      // Check if clicked on Dr.Sunshine's mini sun
      if (player.miniSun) {
        const sun = player.miniSun;
        const dx = clickX - sun.x;
        const dy = clickY - sun.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < sun.radius) {
          openUpgradePopup('sun', sun);
          return;
        }
      }
      
      // Check if clicked on Engineer (for turret crafting)
      if (player.className === "Engineer") {
        if (clickX >= player.x && clickX <= player.x + player.w &&
            clickY >= player.y && clickY <= player.y + player.h) {
          openTurretCraftUI();
          return;
        }
      }
      
      // Check if clicked on turrets
      for (const turret of turrets) {
        const dx = clickX - turret.x;
        const dy = clickY - turret.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < 20) { // Turret click radius
          openUpgradePopup('turret', turret);
          return;
        }
      }
      
      // Check if clicked on root barriers
      for (const root of rootBarriers) {
        if (clickX >= root.x && clickX <= root.x + root.w &&
            clickY >= root.y && clickY <= root.y + root.h) {
          openUpgradePopup('root', root);
          return;
        }
      }
    });

    // CLASS SELECTION
    function showClassSelection() {
      classSelection.classList.add("active");
      classSelection.scrollTop = 0; // Scroll to top!
      classGrid.innerHTML = "";
      
      // Debug logging
      console.log(`üéÆ Class Selection Screen`);
      console.log(`  Highest Wave: ${gameData.highestWave}`);
      console.log(`  Unlocked Classes:`, gameData.unlockedClasses);
      console.log(`  Purchased Classes:`, gameData.purchasedClasses);
      
      Object.entries(CLASSES).forEach(([className, classData]) => {
        const card = document.createElement("div");
        card.className = "class-card";
        
        let isUnlocked = false;
        let lockReason = "";
        let hasAchievementUnlock = false;
        let achievementKey = "";
        
        // Check if it's a challenge unlock (The Forsaken One)
        if (classData.challengeUnlock) {
          achievementKey = classData.challengeUnlock;
          hasAchievementUnlock = true;
          isUnlocked = gameData.unlockedClasses.includes(className);
          if (!isUnlocked) {
            lockReason = `üîí Complete Challenge`;
          }
        }
        // Check if it's an achievement unlock
        else if (classData.achievementUnlock) {
          achievementKey = classData.achievementUnlock;
          hasAchievementUnlock = true;
          isUnlocked = gameData.unlockedClasses.includes(className);
          if (!isUnlocked) {
            lockReason = `üèÜ Complete Achievement`;
          }
        }
        // Purchasable class
        else if (classData.purchasable) {
          isUnlocked = gameData.purchasedClasses.includes(className);
          if (!isUnlocked) {
            lockReason = `üí∞ ${classData.cost.coins} coins, üíé ${classData.cost.gems} gems`;
          }
        }
        // Wave-unlock class
        else {
          isUnlocked = gameData.unlockedClasses.includes(className);
          if (!isUnlocked && gameData.highestWave < classData.unlockWave) {
            lockReason = `Unlock at Wave ${classData.unlockWave}`;
          }
          
          // Debug Thief specifically
          if (className === "Thief") {
            console.log(`ü•∑ THIEF STATUS:`);
            console.log(`  - Unlock Wave Required: ${classData.unlockWave}`);
            console.log(`  - Your Highest Wave: ${gameData.highestWave}`);
            console.log(`  - In unlockedClasses array: ${gameData.unlockedClasses.includes(className)}`);
            console.log(`  - isUnlocked: ${isUnlocked}`);
            console.log(`  - lockReason: ${lockReason}`);
          }
        }
        
        const isLocked = !isUnlocked;
        
        if (isLocked) {
          card.classList.add("locked");
        }
        
        card.innerHTML = `
          <div class="class-icon">${classData.icon}</div>
          <div class="class-name" style="color: ${classData.color}">${className}</div>
          <div class="class-stats">
            HP: ${classData.stats.maxHP}<br>
            DMG: ${classData.stats.damage}<br>
            ${classData.description}
          </div>
          ${isLocked ? `<div class="class-unlock">${lockReason}</div>` : ""}
          ${classData.purchasable && isLocked ? '<div class="class-unlock" style="color: #00ff00; margin-top: 5px;">Available in Shop!</div>' : ""}
          ${isLocked ? '<div class="class-unlock" style="color: #ffff00; margin-top: 5px; cursor: pointer;">üìã Click for details</div>' : ""}
        `;
        
        if (!isLocked) {
          card.onclick = () => selectClass(className);
        } else {
          // ALL locked classes show unlock requirements when clicked or hovered
          card.style.cursor = "pointer";
          card.onclick = () => showUnlockRequirements(className, classData, achievementKey, lockReason);
          card.title = "Click to see unlock requirements";
        }
        
        classGrid.appendChild(card);
      });
    }

    // WAVE SELECTION FUNCTIONS
    let selectedStartingWave = 1; // Track which wave player wants to start from
    
    function showWaveSelect() {
      const waveScreen = document.getElementById('waveSelectionScreen');
      const highestDisplay = document.getElementById('highestWaveDisplay');
      const waveGrid = document.getElementById('waveGrid');
      
      // Update highest wave display
      highestDisplay.textContent = gameData.highestWave;
      
      // Clear and populate wave grid
      waveGrid.innerHTML = '';
      
      // Create buttons for each unlocked wave
      gameData.unlockedWaves.sort((a, b) => a - b); // Sort waves in order
      
      for (let w of gameData.unlockedWaves) {
        const btn = document.createElement('button');
        btn.className = 'wave-select-btn';
        btn.innerHTML = `
          <div style="font-size: 32px; font-weight: bold; color: #00ffff; margin-bottom: 5px;">
            Wave ${w}
          </div>
          <div style="font-size: 12px; color: #aaa;">
            ${w === 1 ? 'Start' : 'Skip to'}
          </div>
        `;
        btn.style.cssText = `
          padding: 20px;
          background: linear-gradient(135deg, #1a3a5a, #2a1a5a);
          border: 2px solid #00ffff;
          border-radius: 10px;
          color: white;
          cursor: pointer;
          transition: all 0.3s;
          font-family: 'Orbitron', monospace;
        `;
        
        // Hover effects
        btn.onmouseenter = () => {
          btn.style.transform = 'scale(1.1)';
          btn.style.boxShadow = '0 0 25px rgba(0,255,255,0.6)';
          btn.style.borderColor = '#ffff00';
        };
        btn.onmouseleave = () => {
          btn.style.transform = 'scale(1)';
          btn.style.boxShadow = 'none';
          btn.style.borderColor = '#00ffff';
        };
        
        btn.onclick = () => startFromWave(w);
        
        waveGrid.appendChild(btn);
      }
      
      // Show the screen
      waveScreen.style.display = 'block';
    }
    
    function closeWaveSelect() {
      const waveScreen = document.getElementById('waveSelectionScreen');
      waveScreen.style.display = 'none';
    }
    
    function startFromWave(startWave) {
      selectedStartingWave = startWave;
      closeWaveSelect();
      showClassSelection(); // Go to class selection with selected wave
    }

    function selectClass(className) {
      classSelection.classList.remove("active");
      startGame(className, selectedStartingWave); // Pass starting wave
      selectedStartingWave = 1; // Reset for next time
    }

    function showUnlockRequirements(className, classData, achievementKey, lockReason) {
      // Set icon and title
      unlockModalIcon.textContent = classData.icon;
      unlockModalTitle.textContent = className;
      
      // Check what type of unlock this class has
      if (achievementKey && ACHIEVEMENT_UNLOCKS[achievementKey]) {
        // Achievement-locked class (like The Forsaken One)
        const unlockInfo = ACHIEVEMENT_UNLOCKS[achievementKey];
        unlockModalRequirement.innerHTML = `<strong>${unlockInfo.requirement}</strong>`;
        unlockModalDesc.textContent = unlockInfo.description;
      } else if (classData.challengeUnlock) {
        // Challenge unlock without defined achievement info
        unlockModalRequirement.innerHTML = "üîí <strong>Complete Special Challenge</strong>";
        unlockModalDesc.textContent = "This class requires completing a special achievement or challenge.";
      } else if (classData.purchasable) {
        // Purchasable class
        unlockModalRequirement.innerHTML = `üí∞ <strong>${classData.cost.coins} Coins</strong><br>üíé <strong>${classData.cost.gems} Gems</strong>`;
        unlockModalDesc.textContent = `This class can be purchased in the Shop! Go to the main menu and click the Shop button to unlock ${className}.`;
      } else if (classData.unlockWave) {
        // Wave-unlock class
        const wavesNeeded = classData.unlockWave - gameData.highestWave;
        if (wavesNeeded > 0) {
          unlockModalRequirement.innerHTML = `üåä <strong>Reach Wave ${classData.unlockWave}</strong>`;
          unlockModalDesc.textContent = `You need to reach wave ${classData.unlockWave} with any class to unlock ${className}. You're currently at wave ${gameData.highestWave} (${wavesNeeded} more wave${wavesNeeded > 1 ? 's' : ''} to go!).`;
        } else {
          unlockModalRequirement.innerHTML = `üåä <strong>Wave ${classData.unlockWave} Unlocked!</strong>`;
          unlockModalDesc.textContent = `You've reached wave ${classData.unlockWave}! This class is now unlocked. Start a new game to play as ${className}!`;
        }
      } else {
        // Fallback for unknown unlock type
        unlockModalRequirement.innerHTML = lockReason || "üîí <strong>Class Locked</strong>";
        unlockModalDesc.textContent = `Keep playing to unlock ${className}!`;
      }
      
      // Show the modal
      unlockModal.classList.add("active");
    }

    function closeUnlockModal() {
      unlockModal.classList.remove("active");
    }

    // SHOP
    function showShop() {
      shopScreen.classList.add("active");
      updateShopDisplay();
    }

    function updateShopDisplay() {
      shopGrid.innerHTML = "";
      shopCoins.textContent = gameData.totalCoins;
      shopGems.textContent = gameData.totalGems;
      
      // Update currency exchange displays
      const coinsDisplay2 = document.getElementById('shopCoinsDisplay2');
      const gemsDisplay2 = document.getElementById('shopGemsDisplay2');
      if (coinsDisplay2) coinsDisplay2.textContent = gameData.totalCoins;
      if (gemsDisplay2) gemsDisplay2.textContent = gameData.totalGems;
      
      // PURCHASABLE CLASSES SECTION
      const classesHeader = document.createElement("div");
      classesHeader.style.gridColumn = "1 / -1";
      classesHeader.style.fontSize = "24px";
      classesHeader.style.color = "#ff00ff";
      classesHeader.style.fontWeight = "bold";
      classesHeader.style.marginTop = "10px";
      classesHeader.style.marginBottom = "10px";
      classesHeader.textContent = "üéØ UNLOCK CLASSES";
      shopGrid.appendChild(classesHeader);
      
      Object.entries(CLASSES).forEach(([className, classData]) => {
        if (!classData.purchasable) return;
        
        const isPurchased = gameData.purchasedClasses.includes(className);
        
        const card = document.createElement("div");
        card.className = "shop-item";
        if (isPurchased) card.classList.add("maxed");
        
        card.innerHTML = `
          <div class="shop-item-name">${classData.icon} ${className}</div>
          <div class="shop-item-desc">${classData.description}</div>
          <div class="shop-item-level">HP: ${classData.stats.maxHP} | DMG: ${classData.stats.damage}</div>
          ${!isPurchased ? `
            <div class="shop-item-cost">
              üí∞ ${classData.cost.coins} | üíé ${classData.cost.gems}
            </div>
          ` : '<div class="shop-item-cost" style="color: #00ff00;">‚úÖ OWNED</div>'}
        `;
        
        if (!isPurchased) {
          card.onclick = () => purchaseClass(className);
        }
        
        shopGrid.appendChild(card);
      });
      
      // PERMANENT UPGRADES SECTION
      const upgradesHeader = document.createElement("div");
      upgradesHeader.style.gridColumn = "1 / -1";
      upgradesHeader.style.fontSize = "24px";
      upgradesHeader.style.color = "#ffff00";
      upgradesHeader.style.fontWeight = "bold";
      upgradesHeader.style.marginTop = "20px";
      upgradesHeader.style.marginBottom = "10px";
      upgradesHeader.textContent = "‚¨ÜÔ∏è PERMANENT UPGRADES";
      shopGrid.appendChild(upgradesHeader);
      
      const permanentUpgradeKeys = ['damage', 'health', 'fireRate', 'critChance', 'startLevel'];
      permanentUpgradeKeys.forEach((key) => {
        const upgrade = SHOP_UPGRADES[key];
        const currentLevel = gameData.permanentUpgrades[key];
        const isMaxed = currentLevel >= upgrade.maxLevel;
        const cost = isMaxed ? null : upgrade.getCost(currentLevel);
        const bonus = upgrade.getBonus(currentLevel);
        const nextBonus = isMaxed ? 0 : upgrade.getBonus(currentLevel + 1);
        
        const card = document.createElement("div");
        card.className = "shop-item";
        if (isMaxed) card.classList.add("maxed");
        
        card.innerHTML = `
          <div class="shop-item-name">${upgrade.name}</div>
          <div class="shop-item-desc">${upgrade.desc}</div>
          <div class="shop-item-level">Level: ${currentLevel}/${upgrade.maxLevel}</div>
          <div class="shop-item-level">Current: +${bonus}${key === 'fireRate' ? 's faster' : ''}</div>
          ${!isMaxed ? `
            <div class="shop-item-level" style="color: #00ff00;">Next: +${nextBonus}</div>
            <div class="shop-item-cost">
              ${cost.coins > 0 ? `üí∞ ${cost.coins}` : ''}
              ${cost.gems > 0 ? ` üíé ${cost.gems}` : ''}
            </div>
          ` : '<div class="shop-item-cost" style="color: #00ff00;">MAX LEVEL</div>'}
        `;
        
        if (!isMaxed) {
          card.onclick = () => purchaseUpgrade(key);
        }
        
        shopGrid.appendChild(card);
      });
      
      // POTION UPGRADES SECTION
      const potionHeader = document.createElement("div");
      potionHeader.style.gridColumn = "1 / -1";
      potionHeader.style.fontSize = "24px";
      potionHeader.style.color = "#ff00ff";
      potionHeader.style.fontWeight = "bold";
      potionHeader.style.marginTop = "20px";
      potionHeader.style.marginBottom = "10px";
      potionHeader.textContent = "üß™ POTION UPGRADES";
      shopGrid.appendChild(potionHeader);
      
      const potionUpgradeKeys = ['healStrength', 'shieldStrength', 'effectStrength', 'dragonStrength', 
                                  'startingHeals', 'startingShields', 'startingOthers', 
                                  'potionGen', 'potionDamage', 'potionExplosion'];
      potionUpgradeKeys.forEach((key) => {
        const upgrade = SHOP_UPGRADES[key];
        const currentLevel = gameData.potionUpgrades[key];
        const isMaxed = currentLevel >= upgrade.maxLevel;
        const cost = isMaxed ? null : upgrade.getCost(currentLevel);
        const bonus = upgrade.getBonus(currentLevel);
        const nextBonus = isMaxed ? 0 : upgrade.getBonus(currentLevel + 1);
        
        const card = document.createElement("div");
        card.className = "shop-item";
        if (isMaxed) card.classList.add("maxed");
        
        card.innerHTML = `
          <div class="shop-item-name">${upgrade.name}</div>
          <div class="shop-item-desc">${upgrade.desc}</div>
          <div class="shop-item-level">Level: ${currentLevel}/${upgrade.maxLevel}</div>
          <div class="shop-item-level">Current: Level ${currentLevel}</div>
          ${!isMaxed ? `
            <div class="shop-item-level" style="color: #00ff00;">Next: Level ${currentLevel + 1}</div>
            <div class="shop-item-cost">
              ${cost.coins > 0 ? `üí∞ ${cost.coins}` : ''}
              ${cost.gems > 0 ? ` üíé ${cost.gems}` : ''}
            </div>
          ` : '<div class="shop-item-cost" style="color: #00ff00;">MAX LEVEL</div>'}
        `;
        
        if (!isMaxed) {
          card.onclick = () => purchaseUpgrade(key);
        }
        
        shopGrid.appendChild(card);
      });
    }

    function purchaseClass(className) {
      const classData = CLASSES[className];
      const cost = classData.cost;
      
      // Can purchase with EITHER enough coins OR enough gems (not both required)
      const canAffordCoins = gameData.totalCoins >= cost.coins;
      const canAffordGems = gameData.totalGems >= cost.gems;
      
      if (canAffordCoins || canAffordGems) {
        // Deduct ONLY ONE currency - prioritize coins if player has enough of both
        if (canAffordCoins) {
          gameData.totalCoins -= cost.coins;
        } else if (canAffordGems) {
          gameData.totalGems -= cost.gems;
        }
        
        gameData.purchasedClasses.push(className);
        gameData.unlockedClasses.push(className); // Also add to unlocked
        
        saveGameData();
        updateShopDisplay();
        
        alert(`‚úÖ Unlocked ${className}! You can now play as this class!`);
      } else {
        alert(`‚ùå Not enough currency! Need either ${cost.coins} coins OR ${cost.gems} gems.`);
      }
    }

    function purchaseUpgrade(upgradeKey) {
      const upgrade = SHOP_UPGRADES[upgradeKey];
      
      // Determine which upgrade category this belongs to
      const isPotionUpgrade = upgradeKey in gameData.potionUpgrades;
      const currentLevel = isPotionUpgrade ? 
        gameData.potionUpgrades[upgradeKey] : 
        gameData.permanentUpgrades[upgradeKey];
      
      if (currentLevel >= upgrade.maxLevel) return;
      
      const cost = upgrade.getCost(currentLevel);
      
      // Can purchase with EITHER enough coins OR enough gems (not both required)
      const canAffordCoins = gameData.totalCoins >= cost.coins;
      const canAffordGems = gameData.totalGems >= cost.gems;
      
      if (canAffordCoins || canAffordGems) {
        // Deduct ONLY ONE currency - prioritize coins if player has enough of both
        if (canAffordCoins) {
          gameData.totalCoins -= cost.coins;
        } else if (canAffordGems) {
          gameData.totalGems -= cost.gems;
        }
        
        if (isPotionUpgrade) {
          gameData.potionUpgrades[upgradeKey]++;
        } else {
          gameData.permanentUpgrades[upgradeKey]++;
        }
        
        saveGameData();
        updateShopDisplay();
        
        // Visual feedback
        const newLevel = isPotionUpgrade ? 
          gameData.potionUpgrades[upgradeKey] : 
          gameData.permanentUpgrades[upgradeKey];
        alert(`‚úÖ Upgraded ${upgrade.name} to level ${newLevel}!`);
      } else {
        alert(`‚ùå Not enough currency! Need either ${cost.coins} coins OR ${cost.gems} gems.`);
      }
    }

    // CURRENCY CONVERSION FUNCTIONS
    function convertGemsToCoins() {
      const gemsToConvert = prompt("How many gems would you like to convert?\n\nüíé ‚Üí üí∞ (1 Gem = 100 Coins)\n\nYou have " + gameData.totalGems + " gems.");
      const amount = parseInt(gemsToConvert);
      
      if (isNaN(amount) || amount <= 0) {
        if (gemsToConvert !== null) { // User didn't cancel
          alert("‚ùå Invalid amount! Please enter a positive number.");
        }
        return;
      }
      
      if (gameData.totalGems < amount) {
        alert(`‚ùå Not enough gems! You only have ${gameData.totalGems} gems.`);
        return;
      }
      
      // Convert gems to coins
      gameData.totalGems -= amount;
      gameData.totalCoins += amount * 100;
      saveGameData();
      updateShopDisplay();
      
      alert(`‚úÖ Converted ${amount} gems ‚Üí ${amount * 100} coins!\n\nüíé ${gameData.totalGems} gems remaining\nüí∞ ${gameData.totalCoins} coins total`);
    }

    function convertCoinsToGems() {
      const coinsToConvert = prompt("How many coins would you like to convert?\n\nüí∞ ‚Üí üíé (100 Coins = 1 Gem)\n\nYou have " + gameData.totalCoins + " coins.\n\nMust be a multiple of 100!");
      const amount = parseInt(coinsToConvert);
      
      if (isNaN(amount) || amount <= 0) {
        if (coinsToConvert !== null) { // User didn't cancel
          alert("‚ùå Invalid amount! Please enter a positive number.");
        }
        return;
      }
      
      if (amount % 100 !== 0) {
        alert("‚ùå Invalid amount! Must be a multiple of 100.\n\nExample: 100, 200, 500, 1000");
        return;
      }
      
      if (gameData.totalCoins < amount) {
        alert(`‚ùå Not enough coins! You only have ${gameData.totalCoins} coins.`);
        return;
      }
      
      // Convert coins to gems
      gameData.totalCoins -= amount;
      gameData.totalGems += amount / 100;
      saveGameData();
      updateShopDisplay();
      
      alert(`‚úÖ Converted ${amount} coins ‚Üí ${amount / 100} gems!\n\nüí∞ ${gameData.totalCoins} coins remaining\nüíé ${gameData.totalGems} gems total`);
    }

    // REDEEM CODE SYSTEM
    function showRedeemCodeScreen() {
      redeemCodeScreen.style.display = "block";
      redeemCodeInput.value = "";
      redeemResults.textContent = "";
      redeemCodeInput.focus();
      updateRedeemedCodesList();
    }

    function updateRedeemedCodesList() {
      const redeemedList = document.getElementById("redeemedList");
      if (!redeemedList) return;
      
      if (gameData.redeemedCodes.length === 0) {
        redeemedList.innerHTML = '<div style="color: #888; text-align: center; padding: 20px;">No codes redeemed yet</div>';
        return;
      }
      
      redeemedList.innerHTML = gameData.redeemedCodes.map(code => 
        `<div style="padding: 8px; background: rgba(255,255,255,0.05); margin: 5px; border-radius: 5px; color: #aaa;">
          üéÅ ${code}
        </div>`
      ).join('');
    }

    function redeemCode() {
      const code = redeemCodeInput.value.trim().toUpperCase();
      
      if (!code) {
        redeemResults.innerHTML = '<div style="color: #ff4444;">‚ùå Please enter a code!</div>';
        return;
      }
      
      // Check if code exists
      if (!REDEEM_CODES[code]) {
        redeemResults.innerHTML = '<div style="color: #ff4444;">‚ùå Invalid code!</div>';
        return;
      }
      
      // Check if already redeemed
      if (gameData.redeemedCodes.includes(code)) {
        redeemResults.innerHTML = '<div style="color: #ff9900;">‚ö†Ô∏è Code already redeemed!</div>';
        return;
      }
      
      // Redeem the code
      const reward = REDEEM_CODES[code];
      let resultText = '<div style="color: #00ff00; font-weight: bold;">‚úÖ CODE REDEEMED!</div>';
      
      if (reward.type === "currency") {
        if (reward.coins) {
          gameData.totalCoins += reward.coins;
          resultText += `<div style="color: #ffaa00;">üí∞ +${reward.coins} coins</div>`;
        }
        if (reward.gems) {
          gameData.totalGems += reward.gems;
          resultText += `<div style="color: #00aaff;">üíé +${reward.gems} gems</div>`;
        }
      } else if (reward.type === "character") {
        const character = reward.character;
        if (!gameData.unlockedClasses.includes(character)) {
          gameData.unlockedClasses.push(character);
          if (!gameData.purchasedClasses.includes(character)) {
            gameData.purchasedClasses.push(character);
          }
          resultText += `<div style="color: #ff00ff;">üéØ Unlocked ${character}!</div>`;
        } else {
          resultText += `<div style="color: #ff9900;">‚ö†Ô∏è ${character} already unlocked! Here's 1000 coins instead.</div>`;
          gameData.totalCoins += 1000;
        }
      }
      
      // Mark code as redeemed
      gameData.redeemedCodes.push(code);
      saveGameData();
      
      // Update displays
      redeemResults.innerHTML = resultText;
      updateRedeemedCodesList();
      updateTitleScreenDisplay();
      
      // Clear input
      redeemCodeInput.value = "";
    }

    // ABILITY ACTIVATION SYSTEM
    function initializeAbilities(className) {
      selectedClassName = className;
      ability1Cooldown = 0;
      ability2Cooldown = 0;
      ability1KillCounter = 0;
      ability2KillCounter = 0;
      lastStandUsed = false;
      chainReactionShots = 0;
      headhunterShots = 0;
      overwatchActive = false;
      bladeStormActive = false;
      soulHarvestActive = false;
      timeFreezeActive = false;
      hiveMindActive = false;
      upsideDownActive = false;
      vecnaKillCounter = 0;
      vecnaMonsters = [];
      vecnaMonsterKillCounter = 0;
      convertedEnemies = [];
      cupidsBowActive = false;
      cupidsBowShots = 0;
      hookShotActive = false;
      
      updateAbilityDisplay();
    }
    
    function updateAbilities(dt) {
      if (!selectedClassName) return;
      
      // Update cooldowns
      if (ability1Cooldown > 0) ability1Cooldown -= dt;
      if (ability2Cooldown > 0) ability2Cooldown -= dt;
      
      // Update special ability timers
      if (overwatchTimer > 0) {
        overwatchTimer -= dt;
        if (overwatchTimer <= 0) overwatchActive = false;
      }
      
      if (bladeStormTimer > 0) {
        bladeStormTimer -= dt;
        if (bladeStormTimer <= 0) bladeStormActive = false;
      }
      
      if (soulHarvestTimer > 0) {
        soulHarvestTimer -= dt;
        if (soulHarvestTimer <= 0) soulHarvestActive = false;
      }
      
      if (timeFreezeTimer > 0) {
        timeFreezeTimer -= dt;
        if (timeFreezeTimer <= 0) timeFreezeActive = false;
      }
      
      if (hiveMindTimer > 0) {
        hiveMindTimer -= dt;
        if (hiveMindTimer <= 0) hiveMindActive = false;
      }
      
      if (upsideDownTimer > 0) {
        upsideDownTimer -= dt;
        if (upsideDownTimer <= 0) {
          upsideDownActive = false;
          // Reset damage and remove lifesteal
          if (player.damage > player.baseDamage) {
            player.damage = player.baseDamage;
          }
        }
      }
      
      // Update Vecna monsters
      vecnaMonsters = vecnaMonsters.filter(monster => {
        if (monster.hp <= 0) return false;
        
        // Find nearest enemy
        let nearest = null;
        let minDist = Infinity;
        enemies.forEach(e => {
          const dist = Math.hypot(e.x - monster.x, e.y - monster.y);
          if (dist < minDist) {
            minDist = dist;
            nearest = e;
          }
        });
        
        if (nearest) {
          const dx = nearest.x - monster.x;
          const dy = nearest.y - monster.y;
          const dist = Math.hypot(dx, dy);
          
          if (dist > 30) {
            monster.x += (dx / dist) * 2;
            monster.y += (dy / dist) * 2;
          } else {
            // Attack
            monster.attackTimer -= dt;
            if (monster.attackTimer <= 0) {
              nearest.hp -= 10;
              if (nearest.hp <= 0) {
                onEnemyKilled(nearest);
              }
              monster.attackTimer = 1;
            }
          }
        }
        
        return true;
      });
      
      // Update converted enemies
      convertedEnemies = convertedEnemies.filter(e => {
        e.convertTimer -= dt;
        if (e.convertTimer <= 0) {
          e.isConverted = false;
          e.color = e.originalColor;
          return false;
        }
        
        // Attack other enemies
        let nearest = null;
        let minDist = Infinity;
        enemies.forEach(enemy => {
          if (enemy === e || enemy.isConverted) return;
          const dist = Math.hypot(enemy.x - e.x, enemy.y - e.y);
          if (dist < minDist) {
            minDist = dist;
            nearest = enemy;
          }
        });
        
        if (nearest && minDist < 100) {
          e.attackTimer = (e.attackTimer || 0) - dt;
          if (e.attackTimer <= 0) {
            nearest.hp -= e.damage;
            if (nearest.hp <= 0) {
              onEnemyKilled(nearest);
            }
            e.attackTimer = 1;
          }
        }
        
        return true;
      });
      
      // Blade storm damage
      if (bladeStormActive) {
        enemies.forEach(e => {
          const dist = Math.hypot(e.x - player.x, e.y - player.y);
          if (dist < 150) {
            e.hp -= 50 * dt;
            if (e.hp <= 0) {
              onEnemyKilled(e);
            }
          }
        });
      }
      
      // Check auto-activation abilities
      checkAutoAbilities();
      
      // Check for Last Stand
      if (selectedClassName === "Knight" && gameData.skillTrees.Knight?.ultimate2 && !lastStandUsed) {
        if (player.hp < player.maxHP * 0.2) {
          activateLastStand();
        }
      }
      
      // Vecna shield on kills
      if (selectedClassName === "Vecna") {
        if (vecnaKillCounter >= 10) {
          player.shield = Math.min(player.shield + 50, 200);
          vecnaKillCounter = 0;
          floatingText("üí† SHIELD +50", player.x, player.y - 30, "#00ffff", 1.5);
        }
      }
      
      updateAbilityDisplay();
    }
    
    function checkAutoAbilities() {
      if (!selectedClassName || !SKILL_TREES[selectedClassName]) return;
      
      const abilities = SKILL_TREES[selectedClassName];
      const classSkills = gameData.skillTrees[selectedClassName];
      if (!classSkills) return;
      
      // Check ability 1 (kills-based)
      if (classSkills.ultimate1 && abilities.ultimate1.activation === 'kills') {
        if (ability1KillCounter >= abilities.ultimate1.killRequirement && ability1Cooldown <= 0) {
          activateAbility(1);
        }
      }
      
      // Check ability 2 (kills-based)
      if (classSkills.ultimate2 && abilities.ultimate2.activation === 'kills') {
        if (ability2KillCounter >= abilities.ultimate2.killRequirement && ability2Cooldown <= 0) {
          activateAbility(2);
        }
      }
    }
    
    function updateAbilityDisplay() {
      if (!selectedClassName || !SKILL_TREES[selectedClassName]) {
        document.getElementById('ability1Btn').style.display = 'none';
        document.getElementById('ability2Btn').style.display = 'none';
        return;
      }
      
      const abilities = SKILL_TREES[selectedClassName];
      const classSkills = gameData.skillTrees[selectedClassName];
      
      // Ability 1
      if (classSkills?.ultimate1) {
        const btn = document.getElementById('ability1Btn');
        btn.style.display = 'block';
        document.getElementById('ability1Icon').textContent = abilities.ultimate1.icon;
        document.getElementById('ability1Name').textContent = abilities.ultimate1.name;
        document.getElementById('ability1Key').textContent = `[${abilities.ultimate1.hotkey?.toUpperCase() || 'Q'}]`;
        
        if (ability1Cooldown > 0) {
          document.getElementById('ability1CD').textContent = `${Math.ceil(ability1Cooldown)}s`;
          btn.classList.add('cooldown');
          btn.classList.remove('ready');
        } else if (abilities.ultimate1.activation === 'kills') {
          const progress = `${ability1KillCounter}/${abilities.ultimate1.killRequirement}`;
          document.getElementById('ability1CD').textContent = progress;
          if (ability1KillCounter >= abilities.ultimate1.killRequirement) {
            btn.classList.add('ready');
            btn.classList.remove('cooldown');
          } else {
            btn.classList.remove('ready', 'cooldown');
          }
        } else {
          document.getElementById('ability1CD').textContent = 'READY';
          btn.classList.add('ready');
          btn.classList.remove('cooldown');
        }
      } else {
        document.getElementById('ability1Btn').style.display = 'none';
      }
      
      // Ability 2
      if (classSkills?.ultimate2) {
        const btn = document.getElementById('ability2Btn');
        btn.style.display = 'block';
        document.getElementById('ability2Icon').textContent = abilities.ultimate2.icon;
        document.getElementById('ability2Name').textContent = abilities.ultimate2.name;
        document.getElementById('ability2Key').textContent = `[${abilities.ultimate2.hotkey?.toUpperCase() || 'E'}]`;
        
        if (ability2Cooldown > 0) {
          document.getElementById('ability2CD').textContent = `${Math.ceil(ability2Cooldown)}s`;
          btn.classList.add('cooldown');
          btn.classList.remove('ready');
        } else if (abilities.ultimate2.activation === 'kills') {
          const progress = `${ability2KillCounter}/${abilities.ultimate2.killRequirement}`;
          document.getElementById('ability2CD').textContent = progress;
          if (ability2KillCounter >= abilities.ultimate2.killRequirement) {
            btn.classList.add('ready');
            btn.classList.remove('cooldown');
          } else {
            btn.classList.remove('ready', 'cooldown');
          }
        } else {
          document.getElementById('ability2CD').textContent = 'READY';
          btn.classList.add('ready');
          btn.classList.remove('cooldown');
        }
      } else {
        document.getElementById('ability2Btn').style.display = 'none';
      }
    }
    
    function onEnemyKilled(enemy) {
      ability1KillCounter++;
      ability2KillCounter++;
      vecnaKillCounter++;
      enemiesKilledThisWave++; // Track for progress bar
      
      // Illusionist clone gains XP from clone kills
      if (illusionistClone && enemy.killedByClone) {
        const xpGained = enemy.xpValue || 10;
        illusionistClone.xp += xpGained;
        
        // Check for level up
        const xpNeeded = xpForLevel(illusionistClone.level);
        if (illusionistClone.xp >= xpNeeded) {
          illusionistClone.xp -= xpNeeded;
          illusionistClone.level++;
          createFloatingText("CLONE LVL UP!", illusionistClone.x, illusionistClone.y - 30, "#BA55D3");
          showUpgradeScreen(); // Clone gets upgrade too!
        }
      }
      
      // Enemy conversion chance for Vecna
      if (selectedClassName === "Vecna" && Math.random() < 0.2 && !enemy.isConverted) {
        enemy.isConverted = true;
        enemy.originalColor = enemy.color;
        enemy.color = "#9933ff";
        enemy.convertTimer = 15;
        convertedEnemies.push(enemy);
        floatingText("üëÅÔ∏è CONVERTED!", enemy.x, enemy.y, "#9933ff", 1);
      }
      
      // Vecna monster spawning (every 5 kills)
      if (selectedClassName === "Vecna") {
        vecnaMonsterKillCounter++;
        if (vecnaMonsterKillCounter >= 5 && vecnaMonsters.length < 3) {
          spawnVecnaMonster();
          vecnaMonsterKillCounter = 0;
        }
      }
    }
    
    function activateAbility1() {
      activateAbility(1);
    }
    
    function activateAbility2() {
      activateAbility(2);
    }

    // ABILITY IMPLEMENTATIONS
    function activateAbility(abilityNum) {
      if (!selectedClassName || !SKILL_TREES[selectedClassName]) return;
      
      const abilities = SKILL_TREES[selectedClassName];
      const ability = abilityNum === 1 ? abilities.ultimate1 : abilities.ultimate2;
      
      // Check if ability is purchased
      if (!gameData.skillTrees[selectedClassName]) {
        gameData.skillTrees[selectedClassName] = {};
      }
      const abilityKey = abilityNum === 1 ? 'ultimate1' : 'ultimate2';
      if (!gameData.skillTrees[selectedClassName][abilityKey]) {
        addFloatingText(canvas.width / 2, canvas.height / 2, "‚ùå ABILITY NOT PURCHASED!", "#ff0000", 2);
        return; // Ability not purchased yet!
      }
      
      if (abilityNum === 1 && ability1Cooldown > 0) return;
      if (abilityNum === 2 && ability2Cooldown > 0) return;
      
      // Set cooldown
      if (abilityNum === 1) {
        ability1Cooldown = ability.cooldown;
        ability1KillCounter = 0;
      } else {
        ability2Cooldown = ability.cooldown;
        ability2KillCounter = 0;
      }
      
      // Execute ability based on class and ability
      const abilityName = ability.name;
      
      // Hunter abilities
      if (abilityName === "Sniper Shot") {
        activateSniperShot();
      } else if (abilityName === "Care Package") {
        activateCarePackage();
      }
      // Knight abilities
      else if (abilityName === "Shield Bash") {
        activateShieldBash();
      } else if (abilityName === "Last Stand") {
        activateLastStand();
      }
      // Assassin abilities
      else if (abilityName === "Shadow Strike") {
        activateShadowStrike();
      } else if (abilityName === "Blade Storm") {
        activateBladeStorm();
      }
      // Archer abilities (NEW Archer class)
      else if (abilityName === "Cupid's Bow") {
        activateCupidsBow();
      } else if (abilityName === "Hook Shot") {
        activateHookShot();
      }
      // Thief abilities (NEW Thief class)
      else if (abilityName === "Thief's Hand") {
        activateThiefsHand();
      } else if (abilityName === "Phantom Clone") {
        activatePhantomClone();
      }
      // Wizard abilities
      else if (abilityName === "Meteor Storm") {
        activateMeteorStorm();
      } else if (abilityName === "Time Freeze") {
        activateTimeFreeze();
      }
      // Archer abilities
      else if (abilityName === "Arrow Barrage") {
        activateArrowBarrage();
      } else if (abilityName === "Explosive Arrow") {
        activateExplosiveArrow();
      }
      // Summoner abilities
      else if (abilityName === "Army of the Dead") {
        activateArmyOfDead();
      } else if (abilityName === "Sacrifice") {
        activateSacrifice();
      }
      // Bomber abilities
      else if (abilityName === "Nuke") {
        activateNuke();
      } else if (abilityName === "Chain Reaction") {
        activateChainReaction();
      }
      // Sniper abilities
      else if (abilityName === "Headhunter") {
        activateHeadhunter();
      } else if (abilityName === "Overwatch") {
        activateOverwatch();
      }
      // Necromancer abilities
      else if (abilityName === "Plague") {
        activatePlague();
      } else if (abilityName === "Soul Harvest") {
        activateSoulHarvest();
      }
      // Vecna abilities
      else if (abilityName === "Hive Mind") {
        activateHiveMind();
      } else if (abilityName === "Vecna's Curse") {
        activateVecnasCurse();
      }
      
      updateAbilityDisplay();
    }
    
    // HUNTER ABILITIES
    function activateSniperShot() {
      screenShake = 15;
      floatingText("üéØ SNIPER SHOT!", canvas.width / 2, 100, "#00ffff", 2);
      
      // Create massive laser beam across screen
      const beam = {
        x: player.x,
        y: player.y,
        vx: 20,
        vy: 0,
        radius: 15,
        damage: 500,
        color: "#ff0000",
        pierce: true,
        life: 2,
        isSniperShot: true
      };
      projectiles.push(beam);
      
      // Add visual effect
      for (let i = 0; i < 30; i++) {
        particles.push({
          x: player.x,
          y: player.y,
          vx: Math.random() * 10 - 5,
          vy: Math.random() * 10 - 5,
          radius: Math.random() * 3 + 2,
          color: "#ff0000",
          life: 1
        });
      }
    }
    
    function activateCarePackage() {
      floatingText("üì¶ CARE PACKAGE!", player.x, player.y - 50, "#ffff00", 2);
      
      // Add potions
      potions.heal += 2;
      potions.shield += 1;
      potions.damage += 1;
      updatePotionDisplay();
      
      // Visual effect - parachute drop
      for (let i = 0; i < 20; i++) {
        particles.push({
          x: player.x,
          y: player.y - 100,
          vx: Math.random() * 4 - 2,
          vy: Math.random() * 2 + 2,
          radius: Math.random() * 4 + 2,
          color: "#00ff00",
          life: 1.5
        });
      }
      
      screenShake = 8;
    }
    
    // KNIGHT ABILITIES
    function activateShieldBash() {
      floatingText("üõ°Ô∏è SHIELD BASH!", player.x, player.y - 50, "#0088ff", 2);
      
      // Dash forward
      const dashDistance = 300;
      const dashSpeed = 15;
      let dashedDistance = 0;
      
      const dashInterval = setInterval(() => {
        if (dashedDistance >= dashDistance || !gameActive) {
          clearInterval(dashInterval);
          return;
        }
        
        player.x += dashSpeed;
        dashedDistance += dashSpeed;
        
        // Damage enemies in path
        enemies.forEach(e => {
          const dist = Math.hypot(e.x - player.x, e.y - player.y);
          if (dist < 80) {
            e.hp -= 100;
            e.stunned = true;
            e.stunnedTimer = 2;
            if (e.hp <= 0) {
              onEnemyKilled(e);
            }
          }
        });
        
        // Particles
        particles.push({
          x: player.x,
          y: player.y,
          vx: Math.random() * 4 - 2,
          vy: Math.random() * 4 - 2,
          radius: 5,
          color: "#0088ff",
          life: 0.5
        });
      }, 50);
      
      screenShake = 10;
    }
    
    function activateLastStand() {
      floatingText("‚ö° LAST STAND!", player.x, player.y - 50, "#ffff00", 2);
      player.invincible = true;
      lastStandUsed = true;
      
      setTimeout(() => {
        player.invincible = false;
      }, 5000);
      
      // Golden aura particles
      const particleInterval = setInterval(() => {
        if (!player.invincible) {
          clearInterval(particleInterval);
          return;
        }
        for (let i = 0; i < 5; i++) {
          particles.push({
            x: player.x,
            y: player.y,
            vx: Math.random() * 6 - 3,
            vy: Math.random() * 6 - 3,
            radius: 4,
            color: "#ffff00",
            life: 0.5
          });
        }
      }, 100);
      
      screenShake = 12;
    }
    
    // ARCHER ABILITIES
    function activateCupidsBow() {
      floatingText("üíò CUPID'S BOW!", player.x, player.y - 50, "#ff1493", 2);
      
      cupidsBowActive = true;
      cupidsBowShots = 5;
      
      // Pink heart particles
      for (let i = 0; i < 30; i++) {
        particles.push({
          x: player.x,
          y: player.y,
          vx: Math.random() * 8 - 4,
          vy: Math.random() * 8 - 4,
          radius: Math.random() * 4 + 2,
          color: "#ff1493",
          life: 1
        });
      }
      
      screenShake = 8;
    }
    
    function activateHookShot() {
      hookShotActive = !hookShotActive;
      
      if (hookShotActive) {
        floatingText("ü™ù HOOK SHOT ON!", player.x, player.y - 50, "#00ff00", 2);
      } else {
        floatingText("ü™ù HOOK SHOT OFF!", player.x, player.y - 50, "#ff0000", 2);
      }
      
      // Chain particles when toggling on
      if (hookShotActive) {
        for (let i = 0; i < 20; i++) {
          particles.push({
            x: player.x,
            y: player.y,
            vx: Math.random() * 6 - 3,
            vy: Math.random() * 6 - 3,
            radius: Math.random() * 3 + 1,
            color: "#888888",
            life: 0.8
          });
        }
      }
      
      screenShake = 5;
    }
    
    // ASSASSIN ABILITIES
    function activateShadowStrike() {
      if (enemies.length === 0) return;
      
      // Find random enemy
      const target = enemies[Math.floor(Math.random() * enemies.length)];
      
      floatingText("üëª SHADOW STRIKE!", player.x, player.y - 50, "#9933ff", 2);
      
      // Teleport behind enemy
      player.x = target.x - 50;
      player.y = target.y;
      
      // Deal backstab damage
      target.hp -= 300;
      if (target.hp <= 0) {
        onEnemyKilled(target);
      }
      
      // Smoke effect
      for (let i = 0; i < 40; i++) {
        particles.push({
          x: player.x,
          y: player.y,
          vx: Math.random() * 8 - 4,
          vy: Math.random() * 8 - 4,
          radius: Math.random() * 6 + 2,
          color: "#000000",
          life: 1
        });
      }
      
      screenShake = 10;
    }
    
    function activateBladeStorm() {
      floatingText("üåÄ BLADE STORM!", player.x, player.y - 50, "#9933ff", 2);
      bladeStormActive = true;
      bladeStormTimer = 5;
      screenShake = 8;
    }
    
    // WIZARD ABILITIES
    function activateMeteorStorm() {
      floatingText("‚òÑÔ∏è METEOR STORM!", canvas.width / 2, 100, "#ff8800", 2);
      
      for (let i = 0; i < 10; i++) {
        setTimeout(() => {
          const x = Math.random() * canvas.width;
          const y = 0;
          
          projectiles.push({
            x: x,
            y: y,
            vx: 0,
            vy: 8,
            radius: 20,
            damage: 150,
            color: "#ff8800",
            explosive: true,
            life: 3,
            isMeteor: true
          });
          
          screenShake = 5;
        }, i * 200);
      }
    }
    
    function activateTimeFreeze() {
      floatingText("‚ùÑÔ∏è TIME FREEZE!", canvas.width / 2, 100, "#00ffff", 2);
      timeFreezeActive = true;
      timeFreezeTimer = 5;
      
      // Freeze all enemies
      enemies.forEach(e => {
        e.frozen = true;
      });
      
      setTimeout(() => {
        enemies.forEach(e => {
          e.frozen = false;
        });
      }, 5000);
      
      screenShake = 10;
    }

    // ARCHER ABILITIES
    function activateArrowBarrage() {
      floatingText("üèπ ARROW BARRAGE!", player.x, player.y - 50, "#00ff88", 2);
      
      for (let i = 0; i < 50; i++) {
        const angle = (Math.PI * 2 / 50) * i;
        projectiles.push({
          x: player.x,
          y: player.y,
          vx: Math.cos(angle) * 10,
          vy: Math.sin(angle) * 10,
          radius: 8,
          damage: 30,
          color: "#00ff88",
          pierce: true,
          life: 2
        });
      }
      
      screenShake = 12;
    }
    
    function activateExplosiveArrow() {
      floatingText("üí• EXPLOSIVE ARROW!", player.x, player.y - 50, "#ff0000", 2);
      
      projectiles.push({
        x: player.x,
        y: player.y,
        vx: 15,
        vy: 0,
        radius: 25,
        damage: 800,
        color: "#ff4400",
        explosive: true,
        explosionRadius: 300,
        life: 3,
        isExplosiveArrow: true
      });
      
      screenShake = 15;
    }
    
    // THIEF ABILITIES
    function activateThiefsHand() {
      floatingText("ü§ö THIEF'S HAND!", player.x, player.y - 50, "#8800ff", 2);
      floatingText("üí∞ STEAL!", player.x, player.y - 70, "#ffd700", 2);
      
      // Screen flash effect
      screenShake += 8;
      
      // Massive purple explosion from player
      for (let i = 0; i < 50; i++) {
        particles.push({
          x: player.x + player.w / 2,
          y: player.y + player.h / 2,
          vx: (Math.random() - 0.5) * 20,
          vy: (Math.random() - 0.5) * 20,
          radius: 4 + Math.random() * 4,
          color: i % 2 === 0 ? "#8800ff" : "#ffd700",
          life: 1.5,
          alpha: 0.8
        });
      }
      
      let totalHealthStolen = 0;
      
      // Stun and steal health from ALL enemies on screen
      enemies.forEach(e => {
        // Stun enemy
        e.stunned = true;
        e.stunnedTimer = 2;
        e.vx = 0;
        
        // Steal half their HP
        const stolenHP = e.hp * 0.5;
        totalHealthStolen += stolenHP;
        e.hp -= stolenHP;
        
        // Visual effect on enemy
        addFloatingText(e.x + e.w / 2, e.y - 20, "-" + Math.floor(stolenHP), "#8800ff");
        addFloatingText(e.x + e.w / 2, e.y - 40, "üí∏ ROBBED!", "#ffd700", 1);
        
        // Purple + gold particles streaming toward player
        for (let i = 0; i < 8; i++) {
          const angle = Math.atan2((player.y + player.h/2) - (e.y + e.h/2), (player.x + player.w/2) - (e.x + e.w/2));
          particles.push({
            x: e.x + e.w / 2,
            y: e.y + e.h / 2,
            vx: Math.cos(angle) * (6 + Math.random() * 4),
            vy: Math.sin(angle) * (6 + Math.random() * 4),
            radius: 3 + Math.random() * 3,
            color: i % 3 === 0 ? "#ffd700" : "#8800ff",
            life: 1.0,
            alpha: 0.9
          });
        }
        
        // Check if enemy died from health steal
        if (e.hp <= 0) {
          onEnemyKilled(e);
        }
      });
      
      // Heal player by total stolen amount
      player.hp = Math.min(player.hp + totalHealthStolen, player.maxHP);
      addFloatingText(player.x + player.w / 2, player.y - 30, "+" + Math.floor(totalHealthStolen) + " HP!", "#00ff00");
      
      // Player aura effect
      for (let i = 0; i < 30; i++) {
        particles.push({
          x: player.x + player.w / 2,
          y: player.y + player.h / 2,
          vx: Math.random() * 10 - 5,
          vy: Math.random() * 10 - 5,
          radius: Math.random() * 4 + 2,
          color: "#8800ff",
          life: 1
        });
      }
      
      screenShake = 12;
    }
    
    function activatePhantomClone() {
      floatingText("üë§ PHANTOM CLONE!", player.x, player.y - 50, "#000000", 2);
      
      // Increase player's health by half of max HP
      const hpBoost = player.maxHP * 0.5;
      player.maxHP += hpBoost;
      player.hp += hpBoost;
      addFloatingText(player.x + player.w / 2, player.y - 40, "+" + Math.floor(hpBoost) + " MAX HP!", "#00ff00");
      
      // Create phantom clone
      phantomClone = {
        active: true,
        x: player.x - 50,
        y: player.y,
        w: player.w,
        h: player.h,
        hp: player.maxHP,
        duration: 30,
        timer: 30,
        color: "#000000",
        alpha: 0.6
      };
      
      // Shadow particles
      for (let i = 0; i < 40; i++) {
        particles.push({
          x: phantomClone.x + phantomClone.w / 2,
          y: phantomClone.y + phantomClone.h / 2,
          vx: Math.random() * 8 - 4,
          vy: Math.random() * 8 - 4,
          radius: Math.random() * 5 + 2,
          color: "#000000",
          life: 1.2
        });
      }
      
      screenShake = 10;
    }
    
    // SUMMONER ABILITIES
    function activateArmyOfDead() {
      floatingText("üíÄ ARMY OF THE DEAD!", player.x, player.y - 50, "#9933ff", 2);
      
      for (let i = 0; i < 10; i++) {
        const angle = (Math.PI * 2 / 10) * i;
        const distance = 80;
        
        minions.push({
          x: player.x + Math.cos(angle) * distance,
          y: player.y + Math.sin(angle) * distance,
          hp: 50,
          maxHP: 50,
          damage: 15,
          speed: 2,
          radius: 15,
          color: "#9933ff",
          attackTimer: 0,
          isArmy: true
        });
      }
      
      // Ground eruption effect
      for (let i = 0; i < 50; i++) {
        particles.push({
          x: player.x,
          y: player.y,
          vx: Math.random() * 12 - 6,
          vy: Math.random() * 12 - 6,
          radius: Math.random() * 5 + 2,
          color: "#9933ff",
          life: 1.5
        });
      }
      
      screenShake = 10;
    }
    
    function activateSacrifice() {
      if (minions.length === 0) {
        floatingText("‚ùå No minions to sacrifice!", player.x, player.y - 50, "#ff0000", 1.5);
        return;
      }
      
      const minionCount = minions.length;
      floatingText(`üîÆ SACRIFICE ${minionCount} MINIONS!`, player.x, player.y - 50, "#9933ff", 2);
      
      // Convert minions to shields
      player.shield += minionCount * 30;
      
      // Remove minions with soul effect
      minions.forEach(m => {
        for (let i = 0; i < 10; i++) {
          particles.push({
            x: m.x,
            y: m.y,
            vx: (player.x - m.x) / 20 + Math.random() * 2 - 1,
            vy: (player.y - m.y) / 20 + Math.random() * 2 - 1,
            radius: 4,
            color: "#9933ff",
            life: 1
          });
        }
      });
      
      minions.length = 0;
      screenShake = 8;
    }
    
    // BOMBER ABILITIES
    function activateNuke() {
      floatingText("‚ò¢Ô∏è NUCLEAR STRIKE!", canvas.width / 2, canvas.height / 2, "#ff0000", 3);
      
      // Damage all enemies
      enemies.forEach(e => {
        e.hp -= 1000;
        if (e.hp <= 0) {
          onEnemyKilled(e);
        }
      });
      
      // Massive explosion effect
      for (let i = 0; i < 100; i++) {
        particles.push({
          x: canvas.width / 2,
          y: canvas.height / 2,
          vx: Math.random() * 20 - 10,
          vy: Math.random() * 20 - 10,
          radius: Math.random() * 10 + 5,
          color: i % 2 === 0 ? "#ff8800" : "#ffff00",
          life: 2
        });
      }
      
      screenShake = 25;
    }
    
    function activateChainReaction() {
      floatingText("‚õìÔ∏è CHAIN REACTION!", player.x, player.y - 50, "#ff8800", 2);
      chainReactionShots = 10;
      screenShake = 8;
    }
    
    // SNIPER ABILITIES
    function activateHeadhunter() {
      floatingText("üíÄ HEADHUNTER MODE!", player.x, player.y - 50, "#00ffff", 2);
      headhunterShots = 5;
      screenShake = 8;
    }
    
    function activateOverwatch() {
      floatingText("üî≠ OVERWATCH ACTIVE!", player.x, player.y - 50, "#00ffff", 2);
      overwatchActive = true;
      overwatchTimer = 15;
      screenShake = 8;
    }
    
    // NECROMANCER ABILITIES
    function activatePlague() {
      floatingText("ü¶† PLAGUE UNLEASHED!", canvas.width / 2, 100, "#00ff00", 2);
      
      enemies.forEach(e => {
        if (!e.poisoned) {
          e.poisoned = true;
          e.poisonDamage = 20;
          e.poisonTimer = 10;
        }
      });
      
      // Green gas effect
      for (let i = 0; i < 80; i++) {
        particles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          vx: Math.random() * 4 - 2,
          vy: Math.random() * 4 - 2,
          radius: Math.random() * 8 + 3,
          color: "#00ff00",
          life: 3
        });
      }
      
      screenShake = 10;
    }
    
    function activateSoulHarvest() {
      floatingText("üëª SOUL HARVEST!", player.x, player.y - 50, "#9933ff", 2);
      soulHarvestActive = true;
      soulHarvestTimer = 10;
      screenShake = 8;
    }
    
    // VECNA ABILITIES
    function activateHiveMind() {
      if (enemies.length === 0) {
        floatingText("‚ùå No enemies to link!", player.x, player.y - 50, "#ff0000", 1.5);
        return;
      }
      
      floatingText("üëÅÔ∏è HIVE MIND ACTIVATED!", canvas.width / 2, 100, "#ff0000", 3);
      hiveMindActive = true;
      hiveMindTimer = 15;
      
      // Mark all enemies as linked
      enemies.forEach(e => {
        e.hiveMindLinked = true;
      });
      
      screenShake = 15;
    }
    
    function activateVecnasCurse() {
      floatingText("üåÄ ENTERING THE UPSIDE DOWN!", canvas.width / 2, canvas.height / 2, "#8B0000", 3);
      upsideDownActive = true;
      upsideDownTimer = 20;
      
      // Store base damage
      player.baseDamage = player.damage;
      
      // Apply damage boost
      player.damage = player.baseDamage * 1.5;
      
      screenShake = 20;
    }
    
    function spawnVecnaMonster() {
      vecnaMonsters.push({
        x: player.x + Math.random() * 100 - 50,
        y: player.y + Math.random() * 100 - 50,
        hp: 50,
        maxHP: 50,
        damage: 10,
        radius: 12,
        color: "#8B0000",
        attackTimer: 1
      });
      
      floatingText("üëÅÔ∏è Monster Spawned!", player.x, player.y - 50, "#8B0000", 1);
    }

    // SPRITE SYSTEM FUNCTIONS
    function loadCharacterSprites() {
      console.log('üé® Loading character sprites...');
      let loadedCount = 0;
      let failedCount = 0;
      let totalSprites = 0;
      
      // Count total sprites to load
      Object.values(SPRITE_MAP).forEach(spriteFile => {
        if (spriteFile) totalSprites++;
      });
      
      Object.entries(SPRITE_MAP).forEach(([className, spriteFile]) => {
        if (spriteFile) {
          const img = new Image();
          
          img.onload = () => {
            characterSprites[className] = img;
            loadedCount++;
            console.log(`‚úÖ Loaded sprite: ${className} (${loadedCount}/${totalSprites})`);
            
            if (loadedCount + failedCount === totalSprites) {
              if (loadedCount > 0) {
                spritesLoaded = true;
                console.log(`üéâ ${loadedCount}/${totalSprites} sprites loaded successfully!`);
              } else {
                console.log(`‚ö†Ô∏è No sprites loaded. Using fallback graphics.`);
              }
            }
          };
          
          img.onerror = () => {
            failedCount++;
            console.log(`‚ùå Failed to load sprite: ${className} (${spriteFile})`);
            
            if (loadedCount + failedCount === totalSprites) {
              if (loadedCount > 0) {
                spritesLoaded = true;
                console.log(`üéâ ${loadedCount}/${totalSprites} sprites loaded successfully!`);
              } else {
                console.log(`‚ö†Ô∏è No sprites loaded. Using fallback graphics.`);
                console.log(`‚ÑπÔ∏è  To use sprites, create a 'sprites/' folder and add PNG files.`);
              }
            }
          };
          
          // Try to load from sprites folder
          // Works when you have: your-website/sprites/hunter.png, etc.
          img.src = `sprites/${spriteFile}.png`;
        }
      });
      
      if (totalSprites === 0) {
        console.log('‚ÑπÔ∏è  No sprite files configured.');
      }
    }
    
    function getSpriteFrame(animFrame, frameCount = 4) {
      return Math.floor(animFrame * frameCount) % frameCount;
    }
    
    function drawPhantomClone(playerX, playerY, playerW, playerH) {
      // Phantom clone: darker, transparent copy of player
      // Position slightly behind and to the side
      const cloneX = playerX - 20;
      const cloneY = playerY;
      
      // Get player sprite
      const sprite = characterSprites[player.className];
      
      // Set transparency and darker filter
      ctx.globalAlpha = 0.3; // Very transparent
      
      if (sprite && spritesLoaded) {
        // DRAW SPRITE CLONE (darker)
        const frame = getSpriteFrame(player.animFrame || 0);
        const spriteWidth = sprite.width;
        const spriteHeight = sprite.height;
        const frameWidth = spriteWidth / 4;
        
        ctx.save();
        ctx.filter = 'brightness(0.4)'; // Much darker
        
        // Flip sprite if facing left
        if (player.facingLeft) {
          ctx.scale(-1, 1);
          ctx.drawImage(
            sprite,
            frame * frameWidth, 0,
            frameWidth, spriteHeight,
            -(cloneX + playerW), cloneY,
            playerW, playerH
          );
        } else {
          ctx.drawImage(
            sprite,
            frame * frameWidth, 0,
            frameWidth, spriteHeight,
            cloneX, cloneY,
            playerW, playerH
          );
        }
        
        ctx.restore();
      } else {
        // FALLBACK: Draw colored square clone (darker)
        // Darken the colors
        const darkerColor = darkenColor(player.color);
        const darkerAccent = darkenColor(player.accent);
        const darkerGlow = darkenColor(player.glowColor);
        
        ctx.shadowColor = darkerGlow;
        ctx.shadowBlur = 10;
        ctx.fillStyle = darkerColor;
        ctx.fillRect(cloneX, cloneY, playerW, playerH);

        ctx.shadowBlur = 0;
        ctx.fillStyle = darkerAccent;
        ctx.fillRect(cloneX + 4, cloneY + 4, playerW - 8, playerH - 8);

        // Darker face
        ctx.fillStyle = "#8b7355"; // Darker skin tone
        ctx.fillRect(cloneX + playerW * 0.25, cloneY - playerH * 0.3, playerW * 0.5, playerH * 0.3);

        // Darker eyes
        ctx.fillStyle = "#555555";
        ctx.fillRect(cloneX + playerW * 0.35, cloneY - playerH * 0.18, 4, 4);
        ctx.fillRect(cloneX + playerW * 0.55, cloneY - playerH * 0.18, 4, 4);
      }
      
      // Reset transparency
      ctx.globalAlpha = 1.0;
      ctx.filter = 'none';
    }
    
    function darkenColor(color) {
      // Convert hex color to RGB, darken it, return hex
      if (!color || color === 'transparent') return '#333333';
      
      // Remove # if present
      color = color.replace('#', '');
      
      // Parse RGB
      const r = parseInt(color.substr(0, 2), 16);
      const g = parseInt(color.substr(2, 2), 16);
      const b = parseInt(color.substr(4, 2), 16);
      
      // Darken by 60%
      const darkR = Math.floor(r * 0.4);
      const darkG = Math.floor(g * 0.4);
      const darkB = Math.floor(b * 0.4);
      
      // Convert back to hex
      return `#${darkR.toString(16).padStart(2, '0')}${darkG.toString(16).padStart(2, '0')}${darkB.toString(16).padStart(2, '0')}`;
    }

    // GAME INITIALIZATION
    function startGame(className, startingWave = 1) {
      const cls = CLASSES[className];
      
      // Apply permanent upgrades
      const baseDamage = cls.stats.damage + SHOP_UPGRADES.damage.getBonus(gameData.permanentUpgrades.damage);
      const baseHP = cls.stats.maxHP + SHOP_UPGRADES.health.getBonus(gameData.permanentUpgrades.health);
      const fireRateBonus = SHOP_UPGRADES.fireRate.getBonus(gameData.permanentUpgrades.fireRate);
      const startCrit = SHOP_UPGRADES.critChance.getBonus(gameData.permanentUpgrades.critChance);
      const startLevel = 1 + SHOP_UPGRADES.startLevel.getBonus(gameData.permanentUpgrades.startLevel);
      
      player = {
        className: className,
        x: PLAYER_X,
        y: GROUND_Y - 44,
        w: 36,
        h: 44,
        maxHP: baseHP,
        hp: baseHP,
        fireRate: cls.stats.fireRate * (1 - fireRateBonus),
        damage: baseDamage,
        range: cls.stats.range,
        projectileSpeed: cls.stats.projectileSpeed,
        color: cls.color,
        accent: cls.accent,
        bulletColor: cls.bulletColor,
        glowColor: cls.glowColor,
        xp: 0,
        level: startLevel,
        xpToNext: xpForLevel(startLevel),
        alive: true,
        // Upgrades
        multiShot: 0,
        pierce: cls.stats.alwaysPierce || false, // Archer gets piercing by default
        lifesteal: 0,
        explosive: cls.stats.alwaysExplosive || false, // Bomber gets this
        explosionRadius: cls.stats.explosionRadius || 60, // Bomber has 120, others default 60
        explosionDamage: cls.stats.explosionDamage || null, // Bomber has 90, others use formula
        critChance: cls.stats.alwaysCrit ? 0.5 : startCrit, // Sniper gets 50% base crit
        critMultiplier: 1.0,
        shield: 0,
        maxShield: 0,
        regen: 0,
        chainLightning: 0,
        aura: null,
        // Power-up card level tracking (max 5 per card)
        upgradeLevels: {
          multiShot: 0, damage: 0, fireRate: 0, hp: 0, range: 0,
          projectileSpeed: 0, pierce: 0, lifesteal: 0, explosive: 0,
          criticalHit: 0, shield: 0, regeneration: 0, chainLightning: 0,
          damageAura: 0, freezeBullets: 0, knockback: 0, homingShots: 0
        },
        // Super upgrades unlocked flags
        superUpgrades: {
          laserBeam: false, buckshot: false, rapidFire: false, phaseBullets: false,
          titanForm: false, infiniteRange: false, lightSpeed: false, vampireMode: false,
          nukeShots: false, guaranteedCrits: false, invincible: false, immortal: false,
          storm: false, inferno: false, absoluteZero: false, gravityWell: false, seekingSwarm: false
        },
        // Legendary upgrades (one-time powerful upgrades from maxed stats)
        legendaryUpgrades: {
          bigBullets: false, flamingBullets: false, ultraSense: false, shieldPenetration: false,
          explosiveShield: false, speedDemon: false, vampiricAura: false, luckyStreak: false
        },
        // Necromancer traits
        poison: cls.stats.alwaysPoison ? { damage: 5, duration: 3 } : null,
        spawnSkeletonsOnKill: cls.stats.spawnSkeletonsOnKill || false,
        // Sprite animation
        animFrame: 0,
        facingLeft: false,
        // Special class properties
        xpMultiplier: cls.stats.xpMultiplier || 1.0,
        powerUpMultiplier: cls.stats.powerUpMultiplier || 1.0
      };

      enemies = [];
      projectiles = [];
      minions = [];
      particles = [];
      floatingTexts = [];
      currencyDrops = [];
      
      // Reset special class arrays
      iceShards = [];
      poisonClouds = [];
      rootBarriers = [];
      helperStars = [];
      turrets = [];
      samuraiSlashes = [];
      fireZones = [];
      vecnaMonsters = [];
      
      // Dr.Sunshine mini sun (if playing as Dr.Sunshine)
      if (className === "DrSunshine") {
        player.miniSun = {
          x: player.x,
          y: player.y - 120, // Start above player
          radius: 40,
          damage: cls.stats.sunDamage || 25,
          burnRadius: cls.stats.sunRadius || 150,
          level: 1,
          upgradeCost: 500 // Coins to upgrade
        };
      }
      
      // Illusionist clone (if playing as Illusionist)
      if (className === "Illusionist") {
        // Choose a random unlocked class for the clone
        const availableClasses = gameData.unlockedClasses.filter(c => c !== "Illusionist" && c !== "Rookie");
        const cloneClassName = availableClasses[Math.floor(Math.random() * availableClasses.length)] || "Hunter";
        const cloneCls = CLASSES[cloneClassName];
        
        const cloneMaxHP = Math.floor(cloneCls.stats.maxHP * (cls.stats.cloneHealthRatio || 0.5));
        const cloneRange = cloneCls.stats.range + (cls.stats.cloneRangeBonus || 0);
        
        illusionistClone = {
          className: cloneClassName,
          x: player.x,
          y: player.y - 80, // Position above player (non-overlapping)
          w: 36,
          h: 44,
          maxHP: cloneMaxHP,
          hp: cloneMaxHP,
          damage: cloneCls.stats.damage,
          fireRate: cloneCls.stats.fireRate,
          range: cloneRange, // Farther range than original
          projectileSpeed: cloneCls.stats.projectileSpeed,
          color: cloneCls.color,
          accent: cloneCls.accent,
          bulletColor: cloneCls.bulletColor,
          glowColor: cloneCls.glowColor,
          shootTimer: 0,
          animFrame: 0,
          facingLeft: false,
          level: 1,
          xp: 0, // Clone has its own XP
          upgradeCost: 750 // Coins to upgrade
        };
        
        // Add clone HP to player's total HP pool
        player.maxHP += cloneMaxHP;
        player.hp += cloneMaxHP;
      }
      
      // Dr.Eclipse moon (if playing as Dr.Eclipse)
      if (className === "DrEclipse") {
        eclipseMoon = {
          x: player.x + 150,
          y: player.y - 100,
          radius: 40,
          gravityRadius: cls.stats.moonGravityRadius || 200,
          liftForce: cls.stats.moonLiftForce || 150,
          slamDamage: cls.stats.moonSlamDamage || 100,
          liftedEnemies: [] // Track which enemies are being lifted
        };
      }
      
      // Reset cooldowns
      plagueCloudCooldown = 0;
      clericHealCooldown = 30; // Start ready for HolyCleric
      druidRootCooldown = 0;
      
      shootTimer = 0;
      wave = startingWave; // Use selected starting wave
      enemiesToSpawn = calcEnemiesForWave(wave);
      spawnTimer = 0;
      combo = 0;
      comboTimer = 0;
      maxCombo = 0;
      screenShake = 0;
      gameState = "playing";
      roundBreakTimer = 0;
      sessionCoins = 0;
      sessionGems = 0;
      shufflesRemaining = 4; // Reset shuffle counter
      currentMap = 1;
      mapsCompleted = 0;
      enemiesKilled = 0; // Reset kill counter
      waveTimer = 0; // Reset wave timer
      waveTimerActive = false; // Wave timer not active yet
      shieldUpgradesChosen = 0; // Reset shield upgrade counter for Guardian Tank unlock

      if (className === "Summoner") {
        spawnMinion();
        spawnMinion();
      }
      
      // STARCALLER: Spawn helper star
      if (className === "Starcaller") {
        helperStars.push({
          angle: 0,
          distance: 60,
          attackTimer: 0,
          attackRate: 1.0 // Attacks every 1 second
        });
      }
      
      // Initialize potions for first wave
      resetPotions();
      
      // Initialize abilities
      initializeAbilities(className);

      // Give up button removed - player must finish the run!
      giveUpBtn.style.display = "none";
      
      // RESTORE canvas to full visibility - clear hidden styles
      canvas.style.display = 'block';
      canvas.style.visibility = 'visible';
      canvas.style.opacity = '1';
      canvas.style.zIndex = '0';
      canvas.style.pointerEvents = 'auto';
      
      // RESET pause menu so ESC key always works
      const pauseMenu = document.getElementById('pauseMenu');
      pauseMenu.classList.remove('active');
      pauseMenu.style.display = '';  // Clear inline styles
      pauseMenu.style.visibility = '';
      pauseMenu.style.opacity = '';
      pauseMenu.style.zIndex = '';
      pauseMenu.style.pointerEvents = '';
      gamePaused = false;  // Ensure not paused when starting
      
      // Give free level-up choices based on starting level
      const startingLevelBonus = gameData.permanentUpgrades.startLevel || 0;
      if (startingLevelBonus > 0) {
        // Player already has levels from permanent upgrade
        // Show upgrade screen for each starting level
        for (let i = 0; i < startingLevelBonus; i++) {
          // Queue will be processed - show first upgrade screen
          if (i === 0) {
            showUpgradeScreen();
          }
        }
        // Store remaining upgrades to show after each selection
        player.queuedUpgrades = startingLevelBonus - 1;
      }
      
      // Hide title screen completely
      titleScreen.classList.add('hidden');
      
      gameRunning = true;
      statusText.style.display = "none";
      lastTime = performance.now();
      requestAnimationFrame(gameLoop);
    }

    function xpForLevel(level) {
      // Much steeper XP curve - exponential growth
      // Level 1: 60 XP
      // Level 5: 670 XP
      // Level 10: 3,100 XP
      // Level 15: 8,800 XP
      // Level 20: 18,700 XP
      return Math.floor(60 * Math.pow(level, 2.1));
    }

    function calcEnemiesForWave(w) {
      if (w === 1) return 5;
      if (w === 2) return 7;
      if (w === 3) return 9;
      if (w === 4) return 11;
      if (w === 5) return 15;
      
      // After wave 5, MUCH more aggressive scaling
      // Wave 6: 20, Wave 10: 35, Wave 15: 55, Wave 20: 80
      const base = 15;
      const increment = (w - 5) * 3; // 3 enemies per wave
      const waveBonus = Math.floor(w / 5) * 5; // Bonus every 5 waves
      return base + increment + waveBonus;
    }

    function getShieldHP(wave, isBoss = false, isMiniBoss = false) {
      // Shield HP scaling - EXPONENTIAL at wave 25+
      let shieldHP;
      
      if (wave < 25) {
        // Wave 1-24: Linear scaling
        if (isBoss) {
          shieldHP = 200 + wave * 20;
        } else if (isMiniBoss) {
          shieldHP = 80 + wave * 4;
        } else {
          shieldHP = 40 + wave * 2;
        }
      } else {
        // Wave 25+: EXPONENTIAL scaling  - Much stronger shields!
        const baseShield = isBoss ? 700 : isMiniBoss ? 200 : 100;
        const exponentialGrowth = Math.pow(wave - 24, 1.8) * (isBoss ? 50 : isMiniBoss ? 15 : 8);
        shieldHP = baseShield + exponentialGrowth;
      }
      
      return Math.floor(shieldHP);
    }

    function getEnemyHP(wave, isBoss = false, isMiniBoss = false) {
      // WAVES 1-9: Fixed HP - difficulty increases by enemy COUNT only
      // WAVE 10+: HP starts scaling
      // WAVE 20+: HARDER SCALING - Significant difficulty increase!
      // WAVE 25+: EXPONENTIAL SCALING - Much harder!
      
      // Wave 1-9: 20 HP (2-shot from Hunter's 10 damage)
      // Wave 10: 140 HP
      // Wave 20: 800 HP (HARDER)
      // Wave 25: 1,200 HP
      // Wave 30: 2,500 HP (with exponential boost)
      // Wave 40: 6,000 HP (with exponential boost)
      // Wave 50: 15,000 HP (with exponential boost)
      
      let hp;
      
      if (wave < 10) {
        // Waves 1-9: FIXED HP, no scaling
        hp = 20; // Always 2-shot for Hunter
      } else if (wave < 20) {
        // Wave 10-19: Normal scaling
        const adjustedWave = wave;
        const baseHP = 20;
        const linearGrowth = adjustedWave * 8;
        const exponentialGrowth = Math.pow(adjustedWave, 1.8) * 1.0;
        hp = baseHP + linearGrowth + exponentialGrowth;
      } else if (wave < 25) {
        // Wave 20-24: HARDER SCALING - Significant difficulty spike!
        const adjustedWave = wave;
        const baseHP = 50;
        const linearGrowth = adjustedWave * 15; // Increased from 8
        const exponentialGrowth = Math.pow(adjustedWave, 2.0) * 1.5; // Increased exponent
        hp = baseHP + linearGrowth + exponentialGrowth;
      } else {
        // Wave 25+: EXPONENTIAL SCALING - Much harder!
        const baseHP = 1200; // Increased from 800
        const exponentialGrowth = Math.pow(wave - 24, 2.3) * 20; // More aggressive
        hp = baseHP + exponentialGrowth;
      }
      
      if (isBoss) hp *= 12; // Bosses very tanky
      else if (isMiniBoss) hp *= 5; // Mini-bosses tanky
      
      return Math.floor(hp);
    }

    // SPAWNING
    function handleSpawning(dt) {
      if (enemiesToSpawn <= 0) return;
      
      spawnTimer += dt;
      
      // Spawn rate increases dramatically with waves
      // Wave 1: 2.0s, Wave 10: 1.2s, Wave 20: 0.4s (FASTER!), Wave 30: 0.2s
      let spawnInterval = 2.0 - (wave * 0.05);
      spawnInterval = Math.max(spawnInterval, 0.15); // Minimum 0.15s between spawns (reduced from 0.2s)

      if (spawnTimer >= spawnInterval) {
        spawnTimer = 0;
        enemiesToSpawn--;
        
        // DIFFICULTY SCALING: Spawn multiple enemies at once on higher waves
        let spawnCount = 1; // Default: 1 enemy
        if (wave >= 35) {
          spawnCount = 4; // Wave 35+: 4 enemies at once (increased from 3)
        } else if (wave >= 25) {
          spawnCount = 3; // Wave 25-34: 3 enemies at once (increased from 2)
        } else if (wave >= 20) {
          spawnCount = 2; // Wave 20-24: 2 enemies at once (NEW!)
        }
        
        // Spawn multiple enemies
        for (let i = 0; i < spawnCount; i++) {
          spawnEnemy();
        }
        
        // Start wave timer when last enemy spawns (30s until next wave)
        if (enemiesToSpawn === 0) {
          waveTimer = 30;
          waveTimerActive = true;
          addFloatingText(canvas.width / 2, 100, "30s until next wave!", "#ffff00");
        }
      }
    }

    function spawnEnemy(isBoss = false, isMiniBoss = false) {
      let size, hp, speed, color, glowColor, type, damage, hasShield, isRanged, pattern;

      if (isBoss) {
        let bossPattern;
        
        // SPECIAL WAVE-SPECIFIC BOSSES
        if (wave === 30) {
          bossPattern = BOSS_PATTERNS.find(b => b.pattern === "alchemist");
        } else if (wave === 40) {
          bossPattern = BOSS_PATTERNS.find(b => b.pattern === "bagel");
        } else if (wave === 50) {
          bossPattern = BOSS_PATTERNS.find(b => b.pattern === "spiderman");
        } else {
          // Regular boss patterns (cycling through)
          const regularPatterns = BOSS_PATTERNS.filter(b => !b.wave);
          const patternIndex = Math.floor((wave - 1) / 10) % regularPatterns.length;
          bossPattern = regularPatterns[patternIndex];
        }
        
        // Boss size varies (bigger for special bosses)
        if (wave === 50) size = 100; // Spiderman is huge
        else if (wave === 40) size = 90; // Bagel is big
        else if (wave === 30) size = 85; // Alchemist
        else size = 80 + (wave / 10) * 5; // Scaling size
        
        hp = getEnemyHP(wave, true, false);
        speed = bossPattern.speed;
        color = bossPattern.color;
        glowColor = bossPattern.color;
        type = "boss";
        
        // Boss damage - first boss deals 50, scales up
        // Wave 10: 50, Wave 20: 70, Wave 30: 90, Wave 40: 110
        damage = 30 + (wave * 2);
        hasShield = bossPattern.pattern === "tank";
        isRanged = bossPattern.pattern === "ranged" || bossPattern.pattern === "alchemist";
        pattern = bossPattern;
        
      } else if (isMiniBoss) {
        size = 55;
        hp = getEnemyHP(wave, false, true);
        speed = 1.2 + (wave * 0.02); // Mini-bosses get faster
        color = "#ff8800";
        glowColor = "#ff8800";
        type = "miniboss";
        
        // Mini-boss damage - more reasonable scaling
        // Wave 5: 35, Wave 10: 40, Wave 20: 50, Wave 30: 60
        damage = 30 + Math.floor(wave / 5) * 5;
        hasShield = Math.random() < 0.4; // More likely to have shields
        isRanged = Math.random() < 0.3; // More likely to be ranged
        pattern = null;
      } else {
        size = 32 + Math.random() * 16;
        hp = getEnemyHP(wave);
        
        // Speed scales with waves
        const baseSpeed = 1.2 + (wave * 0.03);
        speed = baseSpeed + Math.random() * 0.4;
        
        const rand = Math.random();
        if (rand < 0.12) {
          // TRIANGLE - Extremely fast
          color = "#ffff00";
          glowColor = "#ffaa00";
          type = "triangle";
          hasShield = false;
          isRanged = false;
          speed *= 2.5; // Extremely fast!
          hp *= 0.5; // Low HP
          size = 28;
        } else if (rand < 0.24) {
          // CIRCLE - Heals over time
          color = "#00ff88";
          glowColor = "#00ffaa";
          type = "circle";
          hasShield = false;
          isRanged = false;
          speed *= 0.6; // Slow
          hp *= 1.5; // More HP
          size = 36;
        } else if (rand < 0.36) {
          // JUMPER - Jumps ahead periodically
          color = "#ff00ff";
          glowColor = "#ff88ff";
          type = "jumper";
          hasShield = false;
          isRanged = false;
          speed *= 0.8;
          size = 32;
        } else if (rand < 0.45) {
          // KAMIKAZE - Fastest, explodes on contact
          color = "#ff8800";
          glowColor = "#ffaa00";
          type = "kamikaze";
          hasShield = false;
          isRanged = false;
          speed *= 3.0; // Fastest!
          hp *= 0.3; // Very low HP
          size = 24;
        } else if (rand < 0.60 && wave >= 15) {
          // SHIELDED - Blue with shield (Wave 15+ only)
          color = "#4444ff";
          glowColor = "#4444ff";
          type = "shielded";
          hasShield = true;
          isRanged = false;
          
          // Shield HP scales with wave
          hp = 50 + (wave * 10) + Math.pow(wave, 1.6) * 1.2;
        } else if (rand < 0.75) {
          // SHOOTER - Ranged attacker
          color = "#ff4444";
          glowColor = "#ffaa00";
          type = "shooter";
          hasShield = false;
          isRanged = true;
          speed *= 0.7;
        }
        // NEW ENEMY TYPES - Unlock at higher waves
        else if (rand < 0.78 && wave >= 15) {
          // ARMORED - High HP, slow, always shielded (Wave 15+)
          color = "#888888";
          glowColor = "#aaaaaa";
          type = "armored";
          hasShield = true;
          isRanged = false;
          speed *= 0.5; // Very slow
          hp *= 2.0; // Double HP!
          size = 44; // Larger
        } else if (rand < 0.81 && wave >= 20) {
          // SPLITTER - Splits into 2 on death (Wave 20+)
          color = "#ff00ff";
          glowColor = "#ff88ff";
          type = "splitter";
          hasShield = false;
          isRanged = false;
          speed *= 0.9;
          hp *= 1.2;
          size = 36;
        } else if (rand < 0.82 && wave >= 12) {
          // FLYER - Flies above ground, can lift enemies at wave 25+ (Wave 12+)
          color = "#00ccff";
          glowColor = "#66ddff";
          type = "flyer";
          hasShield = false;
          isRanged = false;
          speed *= 1.2;
          hp *= 0.9; // Slightly less HP
          size = 28; // Smaller
        } else if (rand < 0.85 && wave >= 23) {
          // CARRIER - Flies and carries regular enemies, drops them midway (Wave 23+)
          color = "#FF6347";
          glowColor = "#FF4500";
          type = "carrier";
          hasShield = false;
          isRanged = true;
          speed *= 1.5; // Faster
          hp *= 1.1;
          size = 32;
        } else if (rand < 0.86 && wave >= 25) {
          // TELEPORTER - Randomly teleports (Wave 25+)
          color = "#00ffff";
          glowColor = "#88ffff";
          type = "teleporter";
          hasShield = false;
          isRanged = false;
          speed *= 0.7;
          size = 32;
        } else if (rand < 0.89 && wave >= 30) {
          // BERSERKER - Gets faster when low HP (Wave 30+)
          color = "#ff0000";
          glowColor = "#ff4400";
          type = "berserker";
          hasShield = false;
          isRanged = false;
          speed *= 1.0;
          hp *= 1.3;
          size = 38;
        } else if (rand < 0.92 && wave >= 35) {
          // DRAINER - Steals HP on hit (Wave 35+)
          color = "#8800ff";
          glowColor = "#aa44ff";
          type = "drainer";
          hasShield = false;
          isRanged = false;
          speed *= 0.8;
          hp *= 1.4;
          size = 34;
        } else if (rand < 0.95 && wave >= 40) {
          // SUMMONER - Spawns minion enemies (Wave 40+)
          color = "#ffaa00";
          glowColor = "#ffcc44";
          type = "summoner";
          hasShield = false;
          isRanged = false;
          speed *= 0.6; // Slow
          hp *= 1.6;
          size = 40;
        } else if (rand < 0.96 && wave >= 15) {
          // ROLLING SPLITTER - Big circle that splits when killed (Wave 15+)
          color = "#8B4513";
          glowColor = "#A0522D";
          type = "roller";
          hasShield = false;
          isRanged = false;
          speed *= 0.4; // Very slow
          hp *= 3.0; // Lots of HP
          size = 60; // Big!
        } else if (rand < 0.97 && wave >= 27) {
          // WITCH - Debuffs player in radius (Wave 27+)
          // Check: Max 2 witches on screen at once
          const witchCount = enemies.filter(e => e.type === "witch").length;
          if (witchCount >= 2) {
            // Skip witch spawn, use grunt instead
            color = "#ff4444";
            glowColor = "#ff8888";
            type = "grunt";
            hasShield = false;
            isRanged = false;
            speed *= 1.0;
            hp *= 1.0;
            size = 40;
          } else {
            color = "#9400D3";
            glowColor = "#BA55D3";
            type = "witch";
            hasShield = false;
            isRanged = false;
            speed *= 0.7;
            hp *= 1.2;
            size = 35;
          }
        } else if (rand < 0.98 && wave >= 25) {
          // BIG WITCH - Buffs other enemies (Wave 25+)
          color = "#4B0082";
          glowColor = "#8A2BE2";
          type = "bigwitch";
          hasShield = false;
          isRanged = false;
          speed *= 0.5; // Slow
          hp *= 1.8;
          size = 50; // Bigger
        } else {
          // GRUNT - Basic enemy
          color = "#ff4444";
          glowColor = "#ff0000";
          type = "grunt";
          hasShield = false;
          isRanged = false;
        }
        
        // Damage scales - HARDER at wave 20+, EXPONENTIAL at wave 25+
        if (wave < 20) {
          damage = 20 + Math.floor(wave / 5) * 4;
        } else if (wave < 25) {
          // Wave 20-24: HARDER DAMAGE SCALING
          const baseDamage = 30;
          const scalingDamage = (wave - 19) * 10; // +10 per wave
          damage = baseDamage + scalingDamage;
        } else {
          // Wave 25+: Much higher damage!
          const baseDamage = 80; // Increased from 40
          const scalingDamage = (wave - 24) * 12; // Increased from +8 to +12 per wave
          damage = baseDamage + scalingDamage;
        }
        
        // Kamikaze does massive explosion damage
        if (type === "kamikaze") {
          damage = 50 + wave * 6; // Slightly increased multiplier
        }
        
        pattern = null;
      }
      
      const enemy = {
        x: canvas.width + 30,
        y: GROUND_Y - size,
        vx: -speed,
        w: size,
        h: size,
        maxHP: hp,
        hp: hp,
        color: color,
        glowColor: glowColor,
        type: type,
        isBoss: isBoss,
        isMiniBoss: isMiniBoss,
        baseSpeed: speed,
        damage: damage,
        hasShield: hasShield,
        shieldHP: hasShield ? getShieldHP(wave, isBoss, isMiniBoss) : 0,
        maxShieldHP: hasShield ? getShieldHP(wave, isBoss, isMiniBoss) : 0,
        isRanged: isRanged,
        shootTimer: 0,
        shootCooldown: 2.5 + Math.random(),
        attackTimer: 0,
        attackCooldown: 1.5,
        // New AI state machine for attack behavior
        attackState: "approaching", // States: "approaching", "attacking", "returning", "waiting"
        savedAttackX: null, // Position where enemy stopped to attack
        pattern: pattern,
        patternTimer: 0,
        animFrame: 0,
        // Special properties for new enemy types
        healTimer: 0,
        healCooldown: 2, // Circle heals every 2 seconds
        jumpTimer: 0,
        jumpCooldown: 3 + Math.random() * 2, // Jumper jumps every 3-5 seconds
        // New enemy type properties
        teleportTimer: 0,
        teleportCooldown: 5, // Teleporter teleports every 5 seconds
        berserkerEnraged: false, // Berserker speed boost when low HP
        drainAmount: 5 + Math.floor(wave / 5), // Drainer HP steal amount
        summonTimer: 0,
        summonCooldown: 8, // Summoner spawns minion every 8 seconds
        summonCount: 0, // Track how many minions spawned
        isSplitterChild: false, // Track if this is a split offspring
        shape: type === "triangle" ? "triangle" : type === "circle" ? "circle" : "square",
        // Freeze resistance system - larger enemies need more freeze stacks
        freezeStacks: 0, // Current freeze stacks
        maxFreezeStacks: Math.ceil((size / 32) * (isBoss ? 10 : isMiniBoss ? 5 : 3)), // Boss: ~25, Mini: ~8, Normal: ~3
        freezeSlowPerStack: 0.15, // 15% slow per stack
        // Flyer properties
        isFlying: type === "flyer" || (pattern && pattern.isFlying),
        flyHeight: (type === "flyer" || (pattern && pattern.isFlying)) ? 80 + Math.random() * 40 : 0, // Flying height above ground
        liftTimer: 0,
        liftCooldown: 6, // Flyer can lift an enemy every 6 seconds
        liftingEnemy: null, // Reference to enemy being lifted
        // Carrier properties (Wave 23+)
        isCarrier: type === "carrier",
        carriedEnemy: type === "carrier" ? {
          type: "grunt",
          color: "#ff4444",
          size: 24,
          hp: getEnemyHP(wave) * 0.6,
          maxHP: getEnemyHP(wave) * 0.6,
          damage: damage * 0.7
        } : null,
        dropTimer: 0,
        hasDropped: false,
        waitTimer: 0,
        // Alchemist boss properties
        isAlchemist: pattern && pattern.pattern === "alchemist",
        debuffTimer: 0,
        debuffCooldown: 3, // Cast debuff every 3 seconds
        waitingForEnemies: pattern && pattern.pattern === "alchemist", // Waits at start
        // Bagel boss properties
        isBagel: pattern && pattern.pattern === "bagel",
        bagelClones: [], // Array of clone objects
        healTimer: 0,
        healCooldown: 2, // Heals every 2 seconds
        // Spiderman boss properties
        isSpiderman: pattern && pattern.pattern === "spiderman",
        spiderLegs: [], // Array of leg objects
        // Roller properties
        isRoller: type === "roller",
        rollerGeneration: 0, // 0 = big, 1 = medium, 2 = small
        // Witch properties
        isWitch: type === "witch",
        witchDebuffTimer: 0,
        witchDebuffCooldown: 4, // Cast debuff every 4 seconds
        witchRadius: 150, // Debuff radius
        // Big Witch properties
        isBigWitch: type === "bigwitch",
        bigWitchBuffTimer: 0,
        bigWitchBuffCooldown: 5, // Cast buff every 5 seconds
        bigWitchRadius: 200 // Buff radius
      };
      
      // Spawn Bagel clones if it's the Bagel boss
      if (enemy.isBagel && isBoss) {
        enemy.bagelClones = [
          { x: enemy.x - 100, y: enemy.y - 150, vy: 2, hp: hp * 0.4, maxHP: hp * 0.4 },
          { x: enemy.x - 100, y: enemy.y + 150, vy: -2, hp: hp * 0.4, maxHP: hp * 0.4 }
        ];
      }
      
      // Spawn spider legs if it's the Spiderman boss
      if (enemy.isSpiderman && isBoss) {
        // 8 spider legs arranged around the body
        const legHP = hp * 0.15; // Each leg has 15% of boss HP
        enemy.spiderLegs = [];
        for (let i = 0; i < 8; i++) {
          const angle = (i / 8) * Math.PI * 2;
          const distance = size * 0.8;
          enemy.spiderLegs.push({
            angle: angle,
            distance: distance,
            hp: legHP,
            maxHP: legHP,
            shootTimer: Math.random() * 2 // Stagger shooting
          });
        }
      }
      
      enemies.push(enemy);
      enemiesThisWave++; // Track for progress bar
    }

    // CURRENCY SYSTEM
    function dropCurrency(x, y, coins, gems) {
      if (coins > 0) {
        currencyDrops.push({
          x: x,
          y: y,
          type: "coin",
          amount: coins,
          vy: -3,
          life: 5
        });
      }
      if (gems > 0) {
        currencyDrops.push({
          x: x,
          y: y + 20,
          type: "gem",
          amount: gems,
          vy: -2.5,
          life: 5
        });
      }
    }

    function updateCurrencyDrops(dt) {
      for (let i = currencyDrops.length - 1; i >= 0; i--) {
        const drop = currencyDrops[i];
        
        drop.vy += 0.3; // Gravity
        drop.y += drop.vy;
        drop.x += (PLAYER_X + player.w / 2 - drop.x) * 0.05; // Move toward player
        
        drop.life -= dt;
        
        // Collect if close to player
        const dx = drop.x - (player.x + player.w / 2);
        const dy = drop.y - (player.y + player.h / 2);
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < 50) {
          // Apply Thief coin/gem multiplier (5x)
          const coinMult = CLASSES[player.className]?.stats?.coinMultiplier || 1;
          const gemMult = CLASSES[player.className]?.stats?.gemMultiplier || 1;
          
          if (drop.type === "coin") {
            const amount = drop.amount * coinMult;
            sessionCoins += amount;
            gameData.totalCoins += amount;
            addFloatingText(drop.x, drop.y, `+${Math.floor(amount)} üí∞`, coinMult > 1 ? "#ffff00" : "#ffff00");
          } else {
            const amount = drop.amount * gemMult;
            sessionGems += amount;
            gameData.totalGems += amount;
            addFloatingText(drop.x, drop.y, `+${Math.floor(amount)} üíé`, gemMult > 1 ? "#00ff00" : "#00ffff");
          }
          currencyDrops.splice(i, 1);
          continue;
        }
        
        if (drop.life <= 0 || drop.y > canvas.height) {
          currencyDrops.splice(i, 1);
        }
      }
    }

    // ENEMY UPDATES
    function updateEnemies(dt) {
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        
        // SUPER UPGRADE: Handle frozen/slowed enemies
        if (e.frozen && e.frozenDuration > 0) {
          e.frozenDuration -= dt;
          if (e.frozenDuration <= 0) {
            e.frozen = false;
            e.freezeStacks = 0; // Reset freeze stacks when thawed
          } else {
            // Frozen enemies can't move
            continue; // Skip this enemy's update
          }
        }
        
        // Apply slow effect
        let speedMultiplier = 1.0;
        if (e.slowEffect > 0) {
          speedMultiplier = Math.max(0.1, 1 - e.slowEffect); // Minimum 10% speed
          if (e.slowDuration > 0) {
            e.slowDuration -= dt;
            if (e.slowDuration <= 0) {
              e.slowEffect = 0;
            }
          }
        }
        
        // BOSS SPECIAL ABILITIES
        if (e.pattern) {
          e.patternTimer += dt;
          
          if (e.pattern.pattern === "charge" && e.patternTimer > 5) {
            // Speed burst every 5 seconds
            e.vx = -e.baseSpeed * 3;
            setTimeout(() => { e.vx = -e.baseSpeed; }, 1000);
            e.patternTimer = 0;
          } else if (e.pattern.pattern === "summon" && e.patternTimer > 6) {
            // Spawn 2 extra enemies
            for (let j = 0; j < 2; j++) {
              setTimeout(() => spawnEnemy(false, false), j * 500);
            }
            addFloatingText(canvas.width / 2, 200, "Boss summons minions!", "#ff00ff");
            e.patternTimer = 0;
          } else if (e.pattern.pattern === "tank" && e.shieldHP <= 0 && e.hp < e.maxHP * 0.5 && e.patternTimer > 8) {
            // Regenerate shield at 50% HP
            e.shieldHP = e.maxShieldHP;
            addFloatingText(e.x + e.w / 2, e.y - 30, "SHIELD REGEN!", "#00aaff");
            e.patternTimer = 0;
          } else if (e.pattern.pattern === "berserk") {
            // Speed increases as HP lowers
            const hpPercent = e.hp / e.maxHP;
            e.vx = -e.baseSpeed * (2 - hpPercent);
          } else if (e.pattern.pattern === "headthrow" && e.patternTimer > 3) {
            // Throws head as projectile every 3 seconds
            const ex = e.x + e.w / 2;
            const ey = e.y + e.h / 4; // Head position (top quarter)
            const px = player.x + player.w / 2;
            const py = player.y + player.h / 2;
            
            let dx = px - ex;
            let dy = py - ey;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            dx /= dist;
            dy /= dist;
            
            // Throw spinning head
            projectiles.push({
              x: ex, y: ey,
              vx: dx * 10, vy: dy * 10,
              radius: 20, // Large head projectile
              damage: e.damage * 1.5, // Massive damage
              color: "#8B0000",
              glowColor: "#ff0000",
              life: 5,
              trail: [],
              isEnemyProjectile: true,
              isHeadProjectile: true, // Special flag for visual
              rotation: 0
            });
            
            addFloatingText(e.x + e.w / 2, e.y - 40, "üíÄ HEAD THROW!", "#ff0000");
            spawnExplosion(ex, ey, "#8B0000", 12);
            screenShake += 3;
            e.patternTimer = 0;
          }
        }
        
        // SPECIAL ENEMY TYPE BEHAVIORS
        if (e.type === "circle") {
          // Circle heals over time
          e.healTimer += dt;
          if (e.healTimer >= e.healCooldown) {
            e.hp = Math.min(e.hp + e.maxHP * 0.05, e.maxHP); // Heal 5% max HP
            addFloatingText(e.x + e.w / 2, e.y - 20, "+HP", "#00ff00", 0.5);
            e.healTimer = 0;
          }
        } else if (e.type === "jumper") {
          // Jumper teleports forward periodically
          e.jumpTimer += dt;
          if (e.jumpTimer >= e.jumpCooldown) {
            e.x -= 200; // Jump forward 200 pixels
            addFloatingText(e.x + e.w / 2, e.y - 20, "JUMP!", "#ff00ff", 0.5);
            // Visual effect
            spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, "#ff00ff", 8);
            e.jumpTimer = 0;
          }
        } else if (e.type === "kamikaze" && e.x + e.w < player.x + player.w) {
          // Kamikaze explodes when it reaches player
          screenShake += 5;
          spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, "#ff8800", 20);
          addFloatingText(e.x + e.w / 2, e.y - 30, "üí• BOOM! üí•", "#ff8800");
          
          // Damage player
          const damageDealt = damagePlayer(e.damage);
          if (damageDealt > 0) {
            addFloatingText(player.x + player.w / 2, player.y - 30, `-${damageDealt} HP`, "#ff0000");
          }
          
          // Remove kamikaze (it died)
          enemies.splice(i, 1);
          continue;
        }
        
        // NEW ENEMY TYPE BEHAVIORS
        
        // TELEPORTER: Randomly teleports around the screen
        if (e.type === "teleporter") {
          e.teleportTimer += dt;
          if (e.teleportTimer >= e.teleportCooldown) {
            // Teleport to random position
            const oldX = e.x;
            const oldY = e.y;
            e.x = Math.random() * (canvas.width - 200) + 100;
            e.y = Math.random() * (GROUND_Y - 250) + 100;
            
            // Visual effects at old and new positions
            spawnExplosion(oldX + e.w/2, oldY + e.h/2, "#00ffff", 15);
            spawnExplosion(e.x + e.w/2, e.y + e.h/2, "#00ffff", 15);
            addFloatingText(e.x + e.w / 2, e.y - 20, "TELEPORT!", "#00ffff", 0.7);
            
            e.teleportTimer = 0;
            e.teleportCooldown = 4 + Math.random() * 2; // Random cooldown
          }
        }
        
        // BERSERKER: Gets faster when low HP
        else if (e.type === "berserker") {
          const hpPercent = e.hp / e.maxHP;
          if (hpPercent < 0.3 && !e.berserkerEnraged) {
            // Enrage at 30% HP!
            e.berserkerEnraged = true;
            e.vx = e.baseSpeed * -2; // Double speed!
            e.color = "#ff4400"; // Brighter red
            addFloatingText(e.x + e.w / 2, e.y - 30, "ENRAGED!", "#ff0000");
            screenShake += 2;
            spawnExplosion(e.x + e.w/2, e.y + e.h/2, "#ff0000", 20);
          }
        }
        
        // DRAINER: Heals itself when hitting player
        // (Handled in player damage function)
        
        // CARRIER: Flies and carries regular enemy, drops midway, waits 2s, then attacks
        if (e.type === "carrier") {
          // Floating animation
          e.y = (GROUND_Y - 120) + Math.sin(Date.now() / 400 + e.x) * 15;
          
          // Drop enemy at midway point (canvas.width / 2)
          if (e.carriedEnemy && !e.hasDropped && e.x < canvas.width / 2) {
            // Drop the carried enemy
            const dropped = {
              x: e.x,
              y: GROUND_Y - e.carriedEnemy.size,
              vx: -1.0,
              w: e.carriedEnemy.size,
              h: e.carriedEnemy.size,
              maxHP: e.carriedEnemy.maxHP,
              hp: e.carriedEnemy.hp,
              color: e.carriedEnemy.color,
              glowColor: e.carriedEnemy.color,
              type: e.carriedEnemy.type,
              isBoss: false,
              isMiniBoss: false,
              baseSpeed: 1.0,
              damage: e.carriedEnemy.damage,
              hasShield: false,
              shieldHP: 0,
              maxShieldHP: 0,
              isRanged: false,
              shootTimer: 0,
              shootCooldown: 2.5,
              attackTimer: 0,
              attackCooldown: 1.5,
              attackState: "approaching",
              savedAttackX: null,
              pattern: null,
              patternTimer: 0,
              animFrame: 0,
              shape: "square"
            };
            enemies.push(dropped);
            e.carriedEnemy = null;
            e.hasDropped = true;
            e.waitTimer = 2.0; // Wait 2 seconds
            e.vx = 0; // Stop moving
            addFloatingText(e.x + e.w/2, e.y - 30, "DROPPED!", "#FF4500");
          }
          
          // Wait 2 seconds after dropping
          if (e.hasDropped && e.waitTimer > 0) {
            e.waitTimer -= dt;
            if (e.waitTimer <= 0) {
              // Resume movement and become ranged attacker
              e.vx = -e.baseSpeed;
              e.isRanged = true;
            }
          }
        }
        
        // ALCHEMIST BOSS: Stays at start, shoots debuff blasts, waits for enemies to engage
        else if (e.isAlchemist) {
          // Stay near the start position until other enemies engage
          if (e.waitingForEnemies) {
            // Check if any other enemies have gotten close to player
            const otherEnemiesEngaged = enemies.some(enemy => 
              enemy !== e && enemy.x < canvas.width * 0.6
            );
            
            if (otherEnemiesEngaged) {
              e.waitingForEnemies = false;
              e.vx = -e.baseSpeed;
              addFloatingText(e.x + e.w/2, e.y - 50, "The Alchemist advances!", "#9932CC");
            } else {
              // Stay at spawn area
              if (e.x < canvas.width - 100) {
                e.x += 0.5; // Drift back slowly
              }
              e.vx = 0;
            }
          }
          
          // Cast debuffs periodically
          e.debuffTimer += dt;
          if (e.debuffTimer >= e.debuffCooldown) {
            // Shoot debuff blast at player
            const ex = e.x + e.w / 2;
            const ey = e.y + e.h / 2;
            const px = player.x + player.w / 2;
            const py = player.y + player.h / 2;
            
            let dx = px - ex;
            let dy = py - ey;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            dx /= dist;
            dy /= dist;
            
            projectiles.push({
              x: ex, y: ey,
              vx: dx * 7, vy: dy * 7,
              radius: 15,
              damage: e.damage * 0.5,
              color: "#9932CC",
              glowColor: "#BA55D3",
              life: 5,
              trail: [],
              isEnemyProjectile: true,
              isDebuffBlast: true // Special flag for debuffs
            });
            
            e.debuffTimer = 0;
          }
        }
        
        // BAGEL BOSS: Flying boss with clones
        else if (e.isBagel) {
          // Fly to middle of screen
          const targetX = canvas.width / 2;
          if (Math.abs(e.x - targetX) > 10) {
            e.x += (targetX - e.x) * 0.01;
          }
          
          // Floating animation
          e.y = (GROUND_Y - 150) + Math.sin(Date.now() / 300) * 20;
          
          // Update clones
          if (e.bagelClones) {
            e.bagelClones.forEach((clone, idx) => {
              // Move clones up and down
              clone.y += clone.vy * dt * 60;
              
              // Bounce at boundaries
              if (clone.y < GROUND_Y - 250) clone.vy = 2;
              if (clone.y > GROUND_Y - 50) clone.vy = -2;
              
              // Keep clones near main boss
              clone.x = e.x - 100;
              
              // Clones shoot at player
              if (!clone.shootTimer) clone.shootTimer = 0;
              clone.shootTimer += dt;
              
              if (clone.shootTimer >= 1.5 && clone.hp > 0) {
                const cx = clone.x;
                const cy = clone.y;
                const px = player.x + player.w / 2;
                const py = player.y + player.h / 2;
                
                let dx = px - cx;
                let dy = py - cy;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                dx /= dist;
                dy /= dist;
                
                projectiles.push({
                  x: cx, y: cy,
                  vx: dx * 8, vy: dy * 8,
                  radius: 10,
                  damage: e.damage * 0.6,
                  color: "#F5DEB3",
                  glowColor: "#FFE4B5",
                  life: 5,
                  trail: [],
                  isEnemyProjectile: true
                });
                
                clone.shootTimer = 0;
              }
            });
          }
          
          // Main boss heals over time
          e.healTimer += dt;
          if (e.healTimer >= e.healCooldown) {
            if (e.hp < e.maxHP) {
              // Heal self
              const healAmount = e.maxHP * 0.02;
              e.hp = Math.min(e.hp + healAmount, e.maxHP);
              addFloatingText(e.x + e.w/2, e.y - 30, `+${Math.floor(healAmount)}`, "#00ff00");
            } else if (e.bagelClones) {
              // Heal clones if at full HP
              e.bagelClones.forEach(clone => {
                if (clone.hp > 0 && clone.hp < clone.maxHP) {
                  const cloneHeal = clone.maxHP * 0.03;
                  clone.hp = Math.min(clone.hp + cloneHeal, clone.maxHP);
                  addFloatingText(e.x - 100, clone.y - 20, `+${Math.floor(cloneHeal)}`, "#00ff00");
                }
              });
            }
            e.healTimer = 0;
          }
        }
        
        // SPIDERMAN BOSS: Spider with 8 legs that shoot independently
        else if (e.isSpiderman) {
          // Fly/hover in center area
          const targetX = canvas.width / 2;
          if (Math.abs(e.x - targetX) > 10) {
            e.x += (targetX - e.x) * 0.005;
          }
          
          // Floating animation (spider hovers)
          e.y = (GROUND_Y - 180) + Math.sin(Date.now() / 400) * 15;
          
          // Update spider legs
          if (e.spiderLegs) {
            e.spiderLegs.forEach((leg, idx) => {
              if (leg.hp <= 0) return; // Dead leg doesn't shoot
              
              // Calculate leg position
              const legX = e.x + e.w / 2 + Math.cos(leg.angle) * leg.distance;
              const legY = e.y + e.h / 2 + Math.sin(leg.angle) * leg.distance;
              
              // Each leg shoots at player independently
              leg.shootTimer += dt;
              if (leg.shootTimer >= 1.2) {
                const px = player.x + player.w / 2;
                const py = player.y + player.h / 2;
                
                let dx = px - legX;
                let dy = py - legY;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                dx /= dist;
                dy /= dist;
                
                projectiles.push({
                  x: legX, y: legY,
                  vx: dx * 9, vy: dy * 9,
                  radius: 8,
                  damage: e.damage * 0.4,
                  color: "#8B0000",
                  glowColor: "#DC143C",
                  life: 5,
                  trail: [],
                  isEnemyProjectile: true
                });
                
                leg.shootTimer = 0;
              }
            });
            
            // Check if all legs are destroyed
            const legsAlive = e.spiderLegs.filter(leg => leg.hp > 0).length;
            if (legsAlive === 0) {
              // Kill the main boss when all legs are destroyed
              e.hp = 0;
            }
          }
        }
        
        // FLYER: Flies above ground, shoots at player, can lift other enemies at wave 25+
        else if (e.type === "flyer") {
          // Flyers move at elevated Y position
          if (!e.liftingEnemy) {
            // Floating animation - bob up and down
            e.y = (GROUND_Y - e.flyHeight) + Math.sin(Date.now() / 400 + e.x) * 10;
            
            // Slow down when near player to engage in combat
            const distToPlayer = Math.abs((e.x + e.w/2) - (player.x + player.w/2));
            if (distToPlayer < 400) {
              e.vx = -e.baseSpeed * 0.2; // Move very slowly when in range
            } else {
              e.vx = -e.baseSpeed; // Normal speed when far away
            }
            
            // Flyers shoot at player instead of flying past
            e.shootTimer += dt;
            if (e.shootTimer >= 2.0) {
              // Shoot at player
              const ex = e.x + e.w / 2;
              const ey = e.y + e.h / 2;
              const px = player.x + player.w / 2;
              const py = player.y + player.h / 2;
              
              let dx = px - ex;
              let dy = py - ey;
              const dist = Math.sqrt(dx * dx + dy * dy) || 1;
              dx /= dist;
              dy /= dist;
              
              projectiles.push({
                x: ex, y: ey,
                vx: dx * 7, vy: dy * 7,
                radius: 8,
                damage: e.damage * 0.5,
                color: "#00ccff",
                glowColor: "#66ddff",
                life: 5,
                trail: [],
                isEnemyProjectile: true
              });
              
              e.shootTimer = 0;
            }
            
            // At wave 25+, flyers can grab and lift ground enemies
            if (wave >= 25) {
              e.liftTimer += dt;
              if (e.liftTimer >= e.liftCooldown) {
                // Find a nearby ground enemy to lift
                for (const target of enemies) {
                  if (target !== e && !target.isFlying && !target.isBoss && !target.isMiniBoss && !target.isBeingLifted) {
                    const dx = target.x - e.x;
                    const dy = (target.y + target.h/2) - (e.y + e.h/2);
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if (dist < 100) {
                      // Grab this enemy!
                      e.liftingEnemy = target;
                      target.isBeingLifted = true;
                      target.liftedBy = e;
                      addFloatingText(e.x + e.w/2, e.y - 30, "LIFTED!", "#00ccff");
                      e.liftTimer = 0;
                      break;
                    }
                  }
                }
              }
            }
          } else {
            // Currently lifting an enemy - carry it forward
            if (e.liftingEnemy && e.liftingEnemy.hp > 0) {
              e.liftingEnemy.x = e.x;
              e.liftingEnemy.y = e.y + e.h + 5; // Position below flyer
              e.liftingEnemy.vx = 0; // Stop horizontal movement while lifted
            } else {
              // Dropped or enemy died
              if (e.liftingEnemy) {
                e.liftingEnemy.isBeingLifted = false;
                e.liftingEnemy.liftedBy = null;
              }
              e.liftingEnemy = null;
            }
          }
        }
        
        // SUMMONER: Spawns minion enemies periodically
        else if (e.type === "summoner") {
          e.summonTimer += dt;
          if (e.summonTimer >= e.summonCooldown && enemies.length < 50 && e.summonCount < 3) {
            // Spawn a smaller minion enemy
            const minion = {
              x: e.x,
              y: e.y,
              vx: -e.baseSpeed * 1.2,
              w: 20,
              h: 20,
              maxHP: e.maxHP * 0.3,
              hp: e.maxHP * 0.3,
              color: "#ffcc00",
              glowColor: "#ffee88",
              type: "grunt",
              isBoss: false,
              isMiniBoss: false,
              baseSpeed: e.baseSpeed * 1.2,
              damage: e.damage * 0.5,
              hasShield: false,
              shieldHP: 0,
              maxShieldHP: 0,
              isRanged: false,
              shootTimer: 0,
              shootCooldown: 2.5,
              attackTimer: 0,
              attackCooldown: 1.5,
              attackState: "approaching",
              savedAttackX: null,
              pattern: null,
              patternTimer: 0,
              animFrame: 0,
              healTimer: 0,
              healCooldown: 2,
              jumpTimer: 0,
              jumpCooldown: 5,
              teleportTimer: 0,
              teleportCooldown: 5,
              berserkerEnraged: false,
              drainAmount: 0,
              summonTimer: 0,
              summonCooldown: 8,
              summonCount: 0,
              isSplitterChild: false,
              shape: "square"
            };
            
            enemies.push(minion);
            e.summonCount++;
            e.summonTimer = 0;
            addFloatingText(e.x + e.w / 2, e.y - 30, "SUMMON!", "#ffaa00");
            spawnExplosion(e.x + e.w/2, e.y + e.h/2, "#ffaa00", 12);
          }
        }
        
        // WITCH: Debuffs player when in radius
        if (e.isWitch) {
          e.witchDebuffTimer += dt;
          const dx = (player.x + player.w/2) - (e.x + e.w/2);
          const dy = (player.y + player.h/2) - (e.y + e.h/2);
          const dist = Math.sqrt(dx*dx + dy*dy);
          
          if (dist < e.witchRadius && e.witchDebuffTimer >= e.witchDebuffCooldown) {
            // Apply random debuff (unless HolyCleric)
            if (player.className !== "HolyCleric") {
              const debuffType = Math.random() < 0.5 ? "curse" : "poison";
              if (debuffType === "curse") {
                playerDebuffs.cursed = true;
                playerDebuffs.cursedTimer = 3.0;
                addFloatingText(e.x + e.w/2, e.y - 40, "üßô CURSE!", "#9400D3");
              } else {
                playerDebuffs.poisoned = true;
                playerDebuffs.poisonedTimer = 3.0;
                playerDebuffs.poisonDamage = 3 + wave;
                addFloatingText(e.x + e.w/2, e.y - 40, "üßô POISON!", "#00ff00");
              }
            } else {
              addFloatingText(player.x + player.w/2, player.y - 40, "IMMUNE!", "#FFD700");
            }
            e.witchDebuffTimer = 0;
          }
        }
        
        // BIG WITCH: Buffs nearby enemies
        if (e.isBigWitch) {
          e.bigWitchBuffTimer += dt;
          if (e.bigWitchBuffTimer >= e.bigWitchBuffCooldown) {
            // Buff nearby enemies
            for (const other of enemies) {
              if (other === e || other.isBoss) continue;
              const dx = (other.x + other.w/2) - (e.x + e.w/2);
              const dy = (other.y + other.h/2) - (e.y + e.h/2);
              const dist = Math.sqrt(dx*dx + dy*dy);
              
              if (dist < e.bigWitchRadius) {
                // Apply buff
                if (!other.witchBuffed) {
                  other.witchBuffed = true;
                  other.witchBuffDuration = 3.0;
                  other.witchBuffDamage = other.damage * 1.5; // 50% damage boost
                  other.witchBuffHealRate = 2; // 2 HP/sec
                  addFloatingText(other.x + other.w/2, other.y - 30, "üßô BUFFED!", "#4B0082", 0.8);
                }
              }
            }
            addFloatingText(e.x + e.w/2, e.y - 40, "üßô BUFF WAVE!", "#8A2BE2");
            spawnExplosion(e.x + e.w/2, e.y + e.h/2, "#8A2BE2", 20);
            e.bigWitchBuffTimer = 0;
          }
        }
        
        // Handle witch buffs on enemies
        if (e.witchBuffed) {
          e.witchBuffDuration -= dt;
          if (e.witchBuffDuration <= 0) {
            e.witchBuffed = false;
            e.damage = e.damage / 1.5; // Remove damage boost
          } else {
            // Apply heal over time
            if (Math.floor(e.witchBuffDuration * 2) !== Math.floor((e.witchBuffDuration + dt) * 2)) {
              e.hp = Math.min(e.hp + e.witchBuffHealRate, e.maxHP);
              addFloatingText(e.x + e.w/2, e.y - 20, `+${e.witchBuffHealRate}`, "#00ff00", 0.5);
            }
          }
        }
        
        // Ranged enemies shoot
        if (e.isRanged && player.alive) {
          e.shootTimer += dt;
          const distToPlayer = Math.abs(e.x - player.x);
          
          // Shooters need to get within 300 pixels to shoot
          if (distToPlayer <= 300) {
            // In range - stop and shoot
            e.vx = 0;
            
            if (e.shootTimer >= e.shootCooldown) {
              e.shootTimer = 0;
              e.shootCooldown = 2 + Math.random() * 1.5;
              
              // Boss triple shot
              const shots = (e.pattern && e.pattern.pattern === "ranged") ? 3 : 1;
              
              for (let s = 0; s < shots; s++) {
                setTimeout(() => {
                  const ex = e.x + e.w / 2;
                  const ey = e.y + e.h / 2;
                  const px = player.x + player.w / 2;
                  const py = player.y + player.h / 2;
                  
                  let dx = px - ex;
                  let dy = py - ey;
                  const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                  dx /= dist;
                  dy /= dist;
                  
                  // Add spread for triple shot
                  if (shots > 1) {
                    const angle = Math.atan2(dy, dx) + (s - 1) * 0.3;
                    dx = Math.cos(angle);
                    dy = Math.sin(angle);
                  }
                  
                  projectiles.push({
                    x: ex, y: ey,
                    vx: dx * 7, vy: dy * 7, // Faster projectiles
                    radius: 8,
                    damage: e.damage * 0.6,
                    color: "#ff4444",
                    glowColor: "#ff0000",
                    life: 3,
                    trail: [],
                    isEnemyProjectile: true
                  });
                }, s * 200);
              }
              
              spawnHitParticles(e.x + e.w / 2, e.y + e.h / 2, "#ff8800", 6);
            }
          } else {
            // Not in range - move closer actively
            e.vx = -e.baseSpeed * 0.9; // Move toward player at 90% speed
          }
        }
        
        // Attack cooldown timer
        if (e.attackTimer > 0) {
          e.attackTimer -= dt;
        }
        
        // NEW AI STATE MACHINE
        // State: "approaching" - enemy moves toward player
        if (e.attackState === "approaching") {
          // Normal movement toward player
          if (!e.frozen) {
            e.x += e.vx;
          }
          
          // Check if close enough to attack (collision range)
          if (
            player.alive &&
            e.x < player.x + player.w + 5 && // Slightly ahead for better positioning
            e.x + e.w > player.x &&
            e.y < player.y + player.h &&
            e.y + e.h > player.y
          ) {
            // STOP! Save this position and prepare to attack
            e.attackState = "attacking";
            e.savedAttackX = e.x; // Save position to return to later
            e.vx = 0; // Stop moving
            e.attackTimer = 0; // Ready to attack immediately
          }
        }
        
        // State: "attacking" - enemy is stopped and attacking player
        else if (e.attackState === "attacking") {
          e.vx = 0; // Stay still
          
          // Attack when timer is ready
          if (e.attackTimer <= 0 && player.alive) {
            // Check if still in range
            if (
              e.x < player.x + player.w &&
              e.x + e.w > player.x &&
              e.y < player.y + player.h &&
              e.y + e.h > player.y
            ) {
              // ATTACK!
              let damage = e.damage || 20;
              
              if (player.shield > 0) {
                if (player.shield >= damage) {
                  player.shield -= damage;
                  damage = 0;
                } else {
                  damage -= player.shield;
                  player.shield = 0;
                }
              }
              
              player.hp -= damage;
              screenShake += 2;
              
              // DRAINER: Steals HP from player
              if (e.type === "drainer" && damage > 0) {
                const healAmount = Math.min(e.drainAmount, e.maxHP - e.hp);
                e.hp = Math.min(e.hp + healAmount, e.maxHP);
                addFloatingText(e.x + e.w / 2, e.y - 30, `+${healAmount} HP`, "#8800ff", 0.8);
                spawnHitParticles(e.x + e.w / 2, e.y + e.h / 2, "#8800ff", 6);
              }
              
              addFloatingText(player.x + player.w / 2, player.y - 10, "-" + Math.floor(damage), "#ff0000");
              spawnHitParticles(player.x + player.w / 2, player.y + player.h / 2, "#ff0000", 8);
              
              // After attacking, return to saved position
              e.attackState = "returning";
              e.attackTimer = 0; // Reset timer for return movement
              
              if (player.hp <= 0) {
                player.hp = 0;
                player.alive = false;
                endGame();
              }
            } else {
              // Player moved away - return to approaching
              e.attackState = "approaching";
              e.vx = -e.baseSpeed;
            }
          }
        }
        
        // State: "returning" - enemy moves back to saved position
        else if (e.attackState === "returning") {
          if (e.savedAttackX !== null) {
            const distanceToReturn = Math.abs(e.x - e.savedAttackX);
            
            if (distanceToReturn > 2) {
              // Move back toward saved position
              if (e.x < e.savedAttackX) {
                e.vx = e.baseSpeed; // Move right
              } else {
                e.vx = -e.baseSpeed * 0.5; // Move left slower
              }
              
              if (!e.frozen) {
                e.x += e.vx;
              }
            } else {
              // Reached saved position - now wait
              e.x = e.savedAttackX; // Snap to exact position
              e.vx = 0;
              e.attackState = "waiting";
              e.attackTimer = 1.5; // Wait 1.5 seconds before next attack
            }
          } else {
            // No saved position - go back to approaching
            e.attackState = "approaching";
            e.vx = -e.baseSpeed;
          }
        }
        
        // State: "waiting" - enemy waits at position before attacking again
        else if (e.attackState === "waiting") {
          e.vx = 0; // Stay still
          
          if (e.attackTimer <= 0) {
            // Wait time is up - advance toward player again!
            e.attackState = "approaching";
            e.vx = -e.baseSpeed; // Move toward player
          }
        }
        
        // Frozen enemies don't move (but can still be in any state)
        // Apply slow effect to movement
        const effectiveVx = e.vx * speedMultiplier;
        if (!e.frozen && !e.isBeingLifted) {
          e.x += effectiveVx;
        }
        e.animFrame = ((e.animFrame || 0) + dt * 10) % 1;
        
        // Aura damage
        if (player.aura && player.alive) {
          const dx = (e.x + e.w / 2) - (player.x + player.w / 2);
          const dy = (e.y + e.h / 2) - (player.y + player.h / 2);
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < player.aura.radius) {
            if (e.hasShield && e.shieldHP > 0) {
              e.shieldHP -= player.aura.damage * dt;
            } else {
              e.hp -= player.aura.damage * dt;
            }
          }
        }
        
        // Burn damage over time
        if (e.burnStacks && e.burnStacks.length > 0) {
          for (let b = e.burnStacks.length - 1; b >= 0; b--) {
            const burn = e.burnStacks[b];
            burn.timeSinceLastTick += dt;
            burn.duration -= dt;
            
            // Apply damage every tick interval
            if (burn.timeSinceLastTick >= burn.tickInterval) {
              const burnDmg = burn.damage / (burn.tickInterval * 2); // Spread damage over ticks
              if (e.hasShield && e.shieldHP > 0) {
                e.shieldHP -= burnDmg;
              } else {
                e.hp -= burnDmg;
              }
              burn.timeSinceLastTick = 0;
            }
            
            // Remove expired burn
            if (burn.duration <= 0) {
              e.burnStacks.splice(b, 1);
            }
          }
        }

        // Check death
        if (e.hp <= 0) {
          // ROLLER: Split into smaller rollers when killed
          if (e.isRoller && e.rollerGeneration < 2) {
            const newGen = e.rollerGeneration + 1;
            const newSize = e.w * 0.6; // 60% smaller
            const newHP = e.maxHP * 0.5; // 50% HP
            const speedMultiplier = 1.5 + (newGen * 0.3); // Much faster with each generation
            
            // Spawn 2 smaller rollers
            for (let r = 0; r < 2; r++) {
              enemies.push({
                x: e.x + (r * 30),
                y: e.y,
                vx: -e.baseSpeed * speedMultiplier, // Gets faster each generation
                w: newSize,
                h: newSize,
                maxHP: newHP,
                hp: newHP,
                color: e.color,
                glowColor: e.glowColor,
                type: "roller",
                isBoss: false,
                isMiniBoss: false,
                baseSpeed: e.baseSpeed * speedMultiplier,
                damage: e.damage * 0.8,
                hasShield: false,
                shieldHP: 0,
                maxShieldHP: 0,
                isRanged: false,
                shootTimer: 0,
                shootCooldown: 2.5,
                attackTimer: 0,
                attackCooldown: 1.5,
                attackState: "approaching",
                savedAttackX: null,
                pattern: null,
                patternTimer: 0,
                animFrame: 0,
                shape: "circle",
                isRoller: true,
                rollerGeneration: newGen
              });
            }
            addFloatingText(e.x + e.w/2, e.y - 30, "SPLIT!", "#8B4513", 1.5);
            spawnExplosion(e.x + e.w/2, e.y + e.h/2, "#8B4513", 15);
          }
          
          // Hive Mind: Kill all linked enemies
          if (hiveMindActive && e.hiveMindLinked) {
            enemies.forEach(enemy => {
              if (enemy.hiveMindLinked && enemy !== e) {
                enemy.hp = 0;
              }
            });
            floatingText("üëÅÔ∏è HIVE MIND TRIGGERED!", canvas.width / 2, 150, "#ff0000", 2);
            screenShake += 5;
          }
          
          // Track kill for abilities
          onEnemyKilled(e);
          
          // Increment kill counter
          enemiesKilled++;
          
          let xpGain = 18 + 7 * wave;
          let coinReward = 1; // 1 coin per regular enemy
          let gemReward = 0; // Only bosses and mini-bosses drop gems
          
          // Regular enemies: 1 coin each (all sizes)
          if (!e.isMiniBoss && !e.isBoss) {
            coinReward = 1; // Flat 1 coin for all regular enemies
          }
          
          // Mini-bosses: 5 coins + 1 gem
          if (e.isMiniBoss) {
            xpGain *= 3;
            coinReward = 5; // Fixed 5 coins
            gemReward = 1; // Fixed 1 gem
          }
          
          // Bosses: 7 coins + 3 gems
          if (e.isBoss) {
            xpGain *= 8;
            coinReward = 7; // Fixed 7 coins
            gemReward = 3; // Fixed 3 gems
          }
          
          // IMMEDIATE REWARDS (no drops to collect!)
          const coinMult = CLASSES[player.className]?.stats?.coinMultiplier || 1;
          const gemMult = CLASSES[player.className]?.stats?.gemMultiplier || 1;
          
          const finalCoins = Math.floor(coinReward * coinMult);
          const finalGems = Math.floor(gemReward * gemMult);
          
          sessionCoins += finalCoins;
          gameData.totalCoins += finalCoins;
          
          if (finalGems > 0) {
            sessionGems += finalGems;
            gameData.totalGems += finalGems;
          }
          
          // Console log for debugging
          console.log(`üíÄ Enemy killed! Wave ${wave} | Coins: +${finalCoins} (Total: ${gameData.totalCoins}) | Gems: +${finalGems} | Boss: ${e.isBoss} | MiniBoss: ${e.isMiniBoss}`);
          
          // Give XP
          giveXP(xpGain);
          
          // Show rewards as floating text
          if (finalCoins > 0) {
            // Bigger text for bosses/mini-bosses
            const textSize = (e.isBoss || e.isMiniBoss) ? 2.5 : 1.5;
            addFloatingText(e.x + e.w / 2, e.y - 20, `+${finalCoins} üí∞`, "#ffff00", textSize);
          }
          if (finalGems > 0) {
            const textSize = (e.isBoss || e.isMiniBoss) ? 2.5 : 1.5;
            addFloatingText(e.x + e.w / 2, e.y - 40, `+${finalGems} üíé`, "#00ffff", textSize);
          }
          
          // Extra large text for boss kills
          if (e.isBoss) {
            addFloatingText(e.x + e.w / 2, e.y - 80, `üí∞ BOSS BONUS! üí∞`, "#ffff00", 2);
          }
          if (e.isMiniBoss) {
            addFloatingText(e.x + e.w / 2, e.y - 80, `‚≠ê MINI-BOSS BONUS! ‚≠ê`, "#00ffff", 2);
          }
          
          spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, e.color, 15);
          
          // THEN handle boss wave completion
          if (e.isBoss) {
            // BOSS DEATH = START WAVE TIMER!
            enemiesToSpawn = 0;
            // Clear all remaining enemies
            for (let j = enemies.length - 1; j >= 0; j--) {
              if (enemies[j] !== e) {
                spawnExplosion(enemies[j].x + enemies[j].w / 2, enemies[j].y + enemies[j].h / 2, enemies[j].color, 10);
              }
            }
            enemies.length = 0; // Clear all
            
            addFloatingText(canvas.width / 2, 250, "üéâ BOSS DEFEATED! üéâ", "#ff00ff");
            addFloatingText(canvas.width / 2, 280, "Next wave in 30s!", "#ffff00");
            screenShake += 8;
            
            // Start 30-second timer for next wave
            waveTimer = 30;
            waveTimerActive = true;
          }
          
          // Necromancer: Spawn skeleton minion
          if (player.spawnSkeletonsOnKill && Math.random() < 0.3) {
            spawnMinion();
            addFloatingText(player.x + player.w / 2, player.y - 40, "Skeleton Raised!", "#9933ff");
          }
          
          combo++;
          comboTimer = 2.0;
          if (combo > maxCombo) maxCombo = combo;
          
          enemiesKilled++; // Track kills for stats
          
          // SPLITTER: Splits into 2 smaller enemies on death
          if (e.type === "splitter" && !e.isSplitterChild) {
            // Spawn 2 smaller split offspring
            for (let split = 0; split < 2; split++) {
              const splitEnemy = {
                x: e.x + (split * 20),
                y: e.y,
                vx: -e.baseSpeed * 1.3,
                w: e.w * 0.7, // Smaller
                h: e.h * 0.7,
                maxHP: e.maxHP * 0.4, // 40% HP
                hp: e.maxHP * 0.4,
                color: "#cc00cc",
                glowColor: "#ff44ff",
                type: "splitter",
                isBoss: false,
                isMiniBoss: false,
                baseSpeed: e.baseSpeed * 1.3,
                damage: e.damage * 0.6,
                hasShield: false,
                shieldHP: 0,
                maxShieldHP: 0,
                isRanged: false,
                shootTimer: 0,
                shootCooldown: 2.5,
                attackTimer: 0,
                attackCooldown: 1.5,
                attackState: "approaching",
                savedAttackX: null,
                pattern: null,
                patternTimer: 0,
                animFrame: 0,
                healTimer: 0,
                healCooldown: 2,
                jumpTimer: 0,
                jumpCooldown: 5,
                teleportTimer: 0,
                teleportCooldown: 5,
                berserkerEnraged: false,
                drainAmount: 0,
                summonTimer: 0,
                summonCooldown: 8,
                summonCount: 0,
                isSplitterChild: true, // Mark as child so it doesn't split again
                shape: "square"
              };
              
              enemies.push(splitEnemy);
            }
            
            addFloatingText(e.x + e.w / 2, e.y - 40, "SPLIT!", "#ff00ff", 1.5);
            spawnExplosion(e.x + e.w/2, e.y + e.h/2, "#ff00ff", 20);
            screenShake += 6;
          }
          
          if (!e.isBoss) { // Boss already cleared enemies array above
            enemies.splice(i, 1);
          }
          continue;
        }

        if (e.x + e.w < -50) {
          enemies.splice(i, 1);
        }
      }
    }

    // SHOOTING
    function handleShooting(dt) {
      shootTimer += dt;
      const target = getTargetEnemy();
      
      if (!autoShoot || !target) return;

      if (shootTimer >= player.fireRate) {
        shootTimer = 0;
        
        // If laser beam is unlocked, fire horizontal laser beam instead
        if (player.superUpgrades.laserBeam) {
          // Fire horizontal laser beam across entire screen
          const beamY = player.y + player.h / 2;
          projectiles.push({
            x: player.x,
            y: beamY,
            vx: 0, // Stationary
            vy: 0,
            radius: 20,
            damage: player.damage * 2, // Laser does more damage
            color: "#ffaa00",
            glowColor: "#ff0000",
            life: 0.3, // Short lifetime (visual effect)
            trail: [],
            isDragonBeam: true // Use dragon beam rendering
          });
          
          // Damage all enemies in beam path
          for (const e of enemies) {
            const ey = e.y + e.h / 2;
            if (Math.abs(ey - beamY) < 30) {
              e.hp -= player.damage * 0.5; // Continuous damage per shot
              addFloatingText(e.x + e.w / 2, e.y - 20, `-${Math.floor(player.damage * 0.5)}`, "#ffaa00", 0.5);
            }
          }
        } else {
          // Regular shooting
          shootProjectile(target);
          
          // Multishot: Fire additional shots based on multiShot level
          // multiShot = 1: 2 total shots, multiShot = 2: 3 total shots, etc.
          if (player.multiShot > 0) {
            for (let i = 0; i < player.multiShot; i++) {
              setTimeout(() => {
                const currentTarget = getTargetEnemy();
                if (currentTarget) {
                  shootProjectile(currentTarget, 0);
                }
              }, 100 * (i + 1)); // Stagger shots by 100ms each
            }
          }
        }
      }
      
      // Illusionist clone shooting
      if (illusionistClone && illusionistClone.hp > 0) {
        illusionistClone.shootTimer += dt;
        const cloneTarget = getTargetEnemyForClone();
        
        if (cloneTarget && illusionistClone.shootTimer >= illusionistClone.fireRate) {
          illusionistClone.shootTimer = 0;
          shootCloneProjectile(illusionistClone, cloneTarget);
        }
      }
      
      // Dr.Eclipse moon gravity and movement
      if (eclipseMoon && selectedClassName === "DrEclipse") {
        // Moon movement (arrow keys)
        const moonSpeed = 300 * dt;
        if (keys['ArrowLeft']) eclipseMoon.x -= moonSpeed;
        if (keys['ArrowRight']) eclipseMoon.x += moonSpeed;
        if (keys['ArrowUp']) eclipseMoon.y -= moonSpeed;
        if (keys['ArrowDown']) eclipseMoon.y += moonSpeed;
        
        // Keep moon on screen
        eclipseMoon.x = Math.max(eclipseMoon.radius, Math.min(canvas.width - eclipseMoon.radius, eclipseMoon.x));
        eclipseMoon.y = Math.max(eclipseMoon.radius, Math.min(canvas.height - eclipseMoon.radius, eclipseMoon.y));
        
        // Moon gravity effect on enemies
        for (let i = 0; i < enemies.length; i++) {
          const e = enemies[i];
          const dx = eclipseMoon.x - (e.x + e.w / 2);
          const dy = eclipseMoon.y - (e.y + e.h / 2);
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < eclipseMoon.gravityRadius) {
            // Check if enemy should be lifted
            const enemySize = e.w * e.h;
            const liftDifficulty = Math.max(1, enemySize / 2000); // Bigger = harder to lift
            const liftChance = eclipseMoon.liftForce / (liftDifficulty * 100);
            
            if (!e.lifted && Math.random() < liftChance * dt * 2) {
              // Start lifting enemy
              e.lifted = true;
              e.liftTime = 0;
              e.maxLiftTime = 2 + liftDifficulty * 0.5; // Bigger enemies take longer
              e.originalY = e.y;
              e.liftHeight = 100 + Math.random() * 50;
              createFloatingText("\ud83c\udf19 LIFTED!", e.x + e.w/2, e.y - 30, "#9D8BC9");
            }
            
            if (e.lifted) {
              e.liftTime += dt;
              const liftProgress = Math.min(1, e.liftTime / (e.maxLiftTime * 0.3));
              e.y = e.originalY - (e.liftHeight * liftProgress);
              e.vx = 0; // Stop moving forward while lifted
              
              // Slam down after lift time
              if (e.liftTime >= e.maxLiftTime) {
                const slamDamage = eclipseMoon.slamDamage * liftDifficulty;
                e.hp -= slamDamage;
                e.lifted = false;
                e.y = e.originalY;
                createFloatingText("-" + Math.floor(slamDamage) + " SLAM!", e.x + e.w/2, e.y - 20, "#ff4444");
                spawnExplosion(e.x + e.w/2, e.y + e.h/2, "#9D8BC9", 20);
                screenShake += 5;
                
                if (e.hp <= 0 && !e.dead) {
                  e.dead = true;
                  onEnemyKilled(e);
                }
              }
            }
          } else {
            // Out of range, reset lift
            if (e.lifted) {
              e.lifted = false;
              e.y = e.originalY;
            }
          }
        }
      }
      
      // Turret shooting
      turrets.forEach(turret => {
        turret.lastShot += dt * 1000; // Convert to ms
        
        // Find closest enemy in range
        let closestEnemy = null;
        let closestDist = turret.range;
        
        for (const e of enemies) {
          const dx = (e.x + e.w / 2) - turret.x;
          const dy = (e.y + e.h / 2) - turret.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < closestDist) {
            closestDist = dist;
            closestEnemy = e;
          }
        }
        
        // Shoot at enemy if found and fire rate allows
        if (closestEnemy && turret.lastShot >= turret.fireRate) {
          turret.lastShot = 0;
          
          const dx = (closestEnemy.x + closestEnemy.w / 2) - turret.x;
          const dy = (closestEnemy.y + closestEnemy.h / 2) - turret.y;
          const angle = Math.atan2(dy, dx);
          
          projectiles.push({
            x: turret.x,
            y: turret.y,
            vx: Math.cos(angle) * 8,
            vy: Math.sin(angle) * 8,
            damage: turret.damage,
            color: turret.type === 'shield' ? "#4444ff" : "#ff4444",
            isTurret: true
          });
        }
      });
    }

    function getTargetEnemy() {
      if (enemies.length === 0) return null;
      
      // Overwatch: Target highest HP enemy
      if (overwatchActive) {
        let highestHP = null;
        let maxHP = 0;
        
        for (const e of enemies) {
          const dx = (e.x + e.w / 2) - (player.x + player.w / 2);
          const dy = (e.y + e.h / 2) - (player.y + player.h / 2);
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < player.range && e.hp > maxHP) {
            maxHP = e.hp;
            highestHP = e;
          }
        }
        
        return highestHP;
      }
      
      if (!autoAim) {
        return enemies.find(e => 
          Math.abs((e.x + e.w / 2) - (player.x + player.w / 2)) < player.range
        ) || null;
      }
      
      let closestInRange = null;
      let closestDist = player.range;
      
      for (const e of enemies) {
        const dx = (e.x + e.w / 2) - (player.x + player.w / 2);
        const dy = (e.y + e.h / 2) - (player.y + player.h / 2);
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < closestDist) {
          closestDist = dist;
          closestInRange = e;
        }
      }
      
      return closestInRange;
    }

    function shootProjectile(target, angleOffset = 0) {
      const px = player.x + player.w / 2;
      const py = player.y + player.h / 2;
      
      let tx, ty;
      
      // Use mouse cursor aiming if enabled, otherwise use target
      if (mouseAiming) {
        tx = mouseX;
        ty = mouseY;
      } else {
        tx = target.x + target.w / 2;
        ty = target.y + target.h / 2;
      }

      let dx = tx - px;
      let dy = ty - py;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      dx /= dist;
      dy /= dist;

      if (angleOffset !== 0) {
        const angle = Math.atan2(dy, dx) + (angleOffset * Math.PI / 180);
        dx = Math.cos(angle);
        dy = Math.sin(angle);
      }

      let isCrit = false;
      if (player.critChance && Math.random() < player.critChance) {
        isCrit = true;
      }
      
      // Headhunter: Guaranteed 5x crits
      if (headhunterShots > 0) {
        isCrit = true;
        headhunterShots--;
      }
      
      // Chain Reaction: Double explosion radius
      let explosiveRadius = player.explosive ? player.explosionRadius : 0;
      if (chainReactionShots > 0) {
        explosiveRadius = player.explosionRadius * 2; // Double the player's base explosion radius
        chainReactionShots--;
      }
      
      // Calculate potion damage bonus
      const totalPotions = potions.heal + potions.shield + potions.crit + potions.damage + potions.speed + potions.dragon;
      const potionDamageBonus = totalPotions * gameData.potionUpgrades.potionDamage * 2;
      const finalDamage = player.damage + potionDamageBonus;
      
      let critMultiplier = player.critMultiplier || 1.0;
      if (headhunterShots >= 0 && isCrit) {
        critMultiplier = 5.0; // Headhunter 5x crits
      }

      // Guardian Tank: Create rotating shield projectile
      if (player.className === "GuardianTank") {
        projectiles.push({
          x: px, y: py,
          vx: dx * player.projectileSpeed,
          vy: dy * player.projectileSpeed,
          radius: 12, // Larger hitbox
          damage: finalDamage,
          color: isCrit ? "#ff0000" : player.bulletColor,
          glowColor: isCrit ? "#ff0000" : player.glowColor,
          life: 3.5,
          trail: [],
          pierce: false, // Shields don't pierce
          pierceCount: 0,
          explosive: false, // No explosion
          isCrit: isCrit,
          critMultiplier: critMultiplier,
          chainLightning: 0,
          isEnemyProjectile: false,
          isShield: true, // Special flag for rendering
          rotation: 0, // Start rotation
          knockback: player.knockback || 80 // Guardian Tank knockback
        });
      } else {
        // Legendary: Big Bullets - 3x size with knockback
        const bulletSize = player.legendaryUpgrades.bigBullets ? 15 : 5;
        
        // Legendary: Flaming Bullets - apply burn effect
        const hasFlame = player.legendaryUpgrades.flamingBullets;
        
        // Dr.Eclipse: Bullets have knockback
        const classData = CLASSES[player.className];
        const hasClassKnockback = classData && classData.stats.hasKnockback;
        const classKnockback = hasClassKnockback ? (classData.stats.knockbackForce || 25) : 0;
        
        // Normal projectile for other classes
        projectiles.push({
          x: px, y: py,
          vx: dx * player.projectileSpeed,
          vy: dy * player.projectileSpeed,
          radius: bulletSize,
          damage: finalDamage,
          color: hasFlame ? "#ff4500" : (isCrit ? "#ff0000" : player.bulletColor),
          glowColor: hasFlame ? "#ffa500" : (isCrit ? "#ff0000" : player.glowColor),
          life: 3.5,
          trail: [],
          pierce: player.pierce,
          pierceCount: 0,
          explosive: player.explosive || explosiveRadius > 0,
          explosionRadius: explosiveRadius,
          explosionDamage: player.explosionDamage, // Bomber's 90 AOE damage
          isCrit: isCrit,
          critMultiplier: critMultiplier,
          chainLightning: player.chainLightning || 0,
          poison: player.poison, // Necromancer poison
          isEnemyProjectile: false,
          // Super upgrade properties
          homing: player.homingShots || false,
          homingStrength: player.homingStrength || 0,
          freeze: player.freezeBullets || false,
          slowAmount: player.slowAmount || 0,
          freezeChance: player.freezeChance || 0,
          // Legendary properties
          flameBurn: hasFlame,
          knockback: (player.knockback || 0) + classKnockback,
          shieldPierce: player.legendaryUpgrades.shieldPenetration ? player.shieldPierce : 0
        });
        
        // GUNSLINGER: Dual shot (2 projectiles with slight spread)
        if (player.className === "Gunslinger") {
          // Left gun
          const leftAngle = Math.atan2(dy, dx) - (5 * Math.PI / 180);
          projectiles.push({
            x: px - 5, y: py,
            vx: Math.cos(leftAngle) * player.projectileSpeed,
            vy: Math.sin(leftAngle) * player.projectileSpeed,
            radius: 5,
            damage: finalDamage * 0.8, // Dual shots do 80% damage each
            color: isCrit ? "#ff0000" : player.bulletColor,
            glowColor: isCrit ? "#ff0000" : player.glowColor,
            life: 3.5,
            trail: [],
            pierce: player.pierce,
            pierceCount: 0,
            ricochet: 2, // 2 ricochets for Gunslinger
            ricochetCount: 0,
            explosive: false,
            isCrit: isCrit,
            critMultiplier: critMultiplier,
            chainLightning: 0,
            isEnemyProjectile: false
          });
          
          // Right gun
          const rightAngle = Math.atan2(dy, dx) + (5 * Math.PI / 180);
          projectiles.push({
            x: px + 5, y: py,
            vx: Math.cos(rightAngle) * player.projectileSpeed,
            vy: Math.sin(rightAngle) * player.projectileSpeed,
            radius: 5,
            damage: finalDamage * 0.8,
            color: isCrit ? "#ff0000" : player.bulletColor,
            glowColor: isCrit ? "#ff0000" : player.glowColor,
            life: 3.5,
            trail: [],
            pierce: player.pierce,
            pierceCount: 0,
            ricochet: 2,
            ricochetCount: 0,
            explosive: false,
            isCrit: isCrit,
            critMultiplier: critMultiplier,
            chainLightning: 0,
            isEnemyProjectile: false
          });
        }
        
        // SAMURAI: Screen-wide slash projectiles
        if (player.className === "Samurai") {
          projectiles.push({
            x: px,
            y: py,
            vx: dx * 3, // Slow movement across screen
            vy: dy * 3,
            width: 500, // Wide slash
            height: 20, // Thin slash
            damage: finalDamage * 1.5, // Strong slash
            color: "#C0C0C0",
            glowColor: "#E8E8E8",
            life: 2.0, // Shorter life
            trail: [],
            pierce: true, // Always pierce
            pierceCount: 0,
            maxPierce: 999,
            knockback: player.knockback || 10, // 2% knockback = ~10 units
            isCrit: isCrit,
            critMultiplier: critMultiplier,
            isEnemyProjectile: false,
            isSlash: true, // Special flag for rendering
            chainKills: true // Can trigger chain slashes
          });
        }
        
        // SUPER UPGRADE: Buckshot (spread shot)
        if (player.buckshot && player.buckshotSpread) {
          const spreadCount = player.buckshotSpread;
          const spreadAngle = 30; // Total spread in degrees
          
          for (let i = 0; i < spreadCount; i++) {
            const angle = -spreadAngle/2 + (spreadAngle / (spreadCount - 1)) * i;
            if (Math.abs(angle) > 1) { // Don't duplicate center shot
              const spreadAngle = Math.atan2(dy, dx) + (angle * Math.PI / 180);
              const sdx = Math.cos(spreadAngle);
              const sdy = Math.sin(spreadAngle);
              
              projectiles.push({
                x: px, y: py,
                vx: sdx * player.projectileSpeed,
                vy: sdy * player.projectileSpeed,
                radius: 5,
                damage: finalDamage * 0.5, // Spread shots do half damage
                color: player.bulletColor,
                glowColor: player.glowColor,
                life: 3.5,
                trail: [],
                pierce: player.pierce,
                pierceCount: 0,
                explosive: player.explosive,
                explosionRadius: explosiveRadius,
                isCrit: false,
                critMultiplier: 1,
                chainLightning: 0,
                isEnemyProjectile: false,
                homing: false
              });
            }
          }
        }
      }
    }
    
    // CLONE SHOOTING HELPERS
    function getTargetEnemyForClone() {
      if (enemies.length === 0 || !illusionistClone) return null;
      
      let closestInRange = null;
      let closestDist = illusionistClone.range;
      
      for (const e of enemies) {
        const dx = (e.x + e.w / 2) - (illusionistClone.x + illusionistClone.w / 2);
        const dy = (e.y + e.h / 2) - (illusionistClone.y + illusionistClone.h / 2);
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < closestDist) {
          closestDist = dist;
          closestInRange = e;
        }
      }
      
      return closestInRange;
    }
    
    function shootCloneProjectile(clone, target) {
      const cx = clone.x + clone.w / 2;
      const cy = clone.y + clone.h / 2;
      const tx = target.x + target.w / 2;
      const ty = target.y + target.h / 2;

      let dx = tx - cx;
      let dy = ty - cy;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      dx /= dist;
      dy /= dist;

      projectiles.push({
        x: cx,
        y: cy,
        vx: dx * clone.projectileSpeed,
        vy: dy * clone.projectileSpeed,
        radius: 4,
        damage: clone.damage,
        color: clone.bulletColor,
        glowColor: clone.glowColor,
        life: 3.5,
        trail: [],
        pierce: false,
        pierceCount: 0,
        explosive: false,
        isCrit: false,
        critMultiplier: 1,
        chainLightning: 0,
        isEnemyProjectile: false,
        isCloneProjectile: true // Flag for clone bullets
      });
    }

    // PROJECTILE UPDATES
    function updateProjectiles(dt) {
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        
        if (p.trail.length > 8) p.trail.shift();
        p.trail.push({ x: p.x, y: p.y });
        
        p.x += p.vx;
        p.y += p.vy;
        p.life -= dt;
        
        // SUPER UPGRADE: Homing Shots
        if (p.homing && p.homingStrength > 0 && !p.isEnemyProjectile) {
          // Find nearest enemy
          let nearest = null;
          let nearestDist = Infinity;
          
          enemies.forEach(enemy => {
            const dx = enemy.x - p.x;
            const dy = enemy.y - p.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < nearestDist) {
              nearestDist = dist;
              nearest = enemy;
            }
          });
          
          if (nearest) {
            const dx = nearest.x - p.x;
            const dy = nearest.y - p.y;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            const ndx = dx / dist;
            const ndy = dy / dist;
            
            // Gradually adjust velocity toward target
            const adjustSpeed = p.homingStrength * 0.5;
            p.vx += ndx * adjustSpeed;
            p.vy += ndy * adjustSpeed;
            
            // Normalize to maintain speed
            const currentSpeed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
            const targetSpeed = player.projectileSpeed;
            p.vx = (p.vx / currentSpeed) * targetSpeed;
            p.vy = (p.vy / currentSpeed) * targetSpeed;
          }
        }
        
        // Rotate shield projectile
        if (p.isShield) {
          p.rotation = (p.rotation || 0) + 0.15; // Rotate continuously
        }

        if (p.life <= 0 || p.x < -50 || p.x > canvas.width + 50 || p.y < -50 || p.y > canvas.height + 50) {
          projectiles.splice(i, 1);
          continue;
        }

        // Enemy projectile hitting player
        if (p.isEnemyProjectile && player.alive) {
          if (p.x > player.x && p.x < player.x + player.w && p.y > player.y && p.y < player.y + player.h) {
            // LEGENDARY: Lucky Streak - crit invulnerability
            if (player.critInvulnTimer && player.critInvulnTimer > 0) {
              addFloatingText(player.x + player.w/2, player.y - 30, "‚≠ê INVULNERABLE!", "#ffff00", 1.0);
              projectiles.splice(i, 1);
              continue; // Skip damage
            }
            
            // LEGENDARY: Ultra Sense - 5% chance to dodge
            if (player.legendaryUpgrades.ultraSense && player.dodgeChance > 0) {
              if (Math.random() < player.dodgeChance) {
                addFloatingText(player.x + player.w/2, player.y - 30, "üëÅÔ∏è DODGED!", "#00ffff", 1.2);
                spawnExplosion(player.x + player.w/2, player.y + player.h/2, "#00ffff", 15);
                projectiles.splice(i, 1);
                continue; // Skip damage
              }
            }
            
            let damage = p.damage;
            
            if (player.shield > 0) {
              if (player.shield >= damage) {
                player.shield -= damage;
                damage = 0;
              } else {
                damage -= player.shield;
                player.shield = 0;
                
                // LEGENDARY: Explosive Shield - explode when shield breaks
                if (player.legendaryUpgrades.explosiveShield && player.shieldExplosion) {
                  // Damage all nearby enemies
                  enemies.forEach(enemy => {
                    const dx = (enemy.x + enemy.w/2) - (player.x + player.w/2);
                    const dy = (enemy.y + enemy.h/2) - (player.y + player.h/2);
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 200) {
                      enemy.hp -= player.shieldExplosionDamage || 100;
                      addFloatingText(enemy.x + enemy.w/2, enemy.y - 30, `-${player.shieldExplosionDamage || 100}`, "#ffaa00");
                    }
                  });
                  addFloatingText(player.x + player.w/2, player.y - 50, "üí£ SHIELD BLAST!", "#ffaa00", 1.5);
                  spawnExplosion(player.x + player.w/2, player.y + player.h/2, "#ffaa00", 40);
                  screenShake += 5;
                }
              }
            }
            
            // Apply debuffs from Alchemist blast (unless HolyCleric)
            if (p.isDebuffBlast && player.className !== "HolyCleric") {
              const debuffType = Math.random() < 0.5 ? "curse" : "poison";
              if (debuffType === "curse") {
                playerDebuffs.cursed = true;
                playerDebuffs.cursedTimer = 5.0; // 5 seconds
                addFloatingText(player.x + player.w/2, player.y - 40, "CURSED!", "#9932CC");
              } else {
                playerDebuffs.poisoned = true;
                playerDebuffs.poisonedTimer = 5.0; // 5 seconds
                playerDebuffs.poisonDamage = 5 + wave; // Scales with wave
                addFloatingText(player.x + player.w/2, player.y - 40, "POISONED!", "#00ff00");
              }
            } else if (p.isDebuffBlast && player.className === "HolyCleric") {
              addFloatingText(player.x + player.w/2, player.y - 40, "IMMUNE!", "#FFD700");
            }
            
            player.hp -= damage;
            addFloatingText(p.x, p.y - 20, "-" + Math.floor(damage), "#ff0000"); // Show damage taken!
            spawnHitParticles(p.x, p.y, "#ff0000", 8);
            screenShake += 2;
            projectiles.splice(i, 1);
            
            if (player.hp <= 0) {
              player.hp = 0;
              player.alive = false;
              endGame();
            }
            continue;
          }
        }

        // Player projectile hitting enemies
        if (!p.isEnemyProjectile) {
          for (let j = enemies.length - 1; j >= 0; j--) {
            const e = enemies[j];
            if (p.x > e.x && p.x < e.x + e.w && p.y > e.y && p.y < e.y + e.h) {
              let actualDamage = p.damage;
              if (p.isCrit) {
                actualDamage *= p.critMultiplier;
                addFloatingText(e.x + e.w / 2, e.y - 30, "CRIT!", "#ff0000");
              }
              
              // LEGENDARY: Shield Penetration - 5% chance to ignore shields (only on homing shots)
              const ignoreShield = p.shieldPierce && p.homing && Math.random() < p.shieldPierce;
              if (ignoreShield) {
                addFloatingText(e.x + e.w / 2, e.y - 40, "üéØ PIERCED!", "#ffff00", 1.2);
              }
              
              // Shielded enemies take 50% less damage
              if (e.hasShield && e.shieldHP > 0 && !ignoreShield) {
                actualDamage *= 0.5;
              }
              
              // Damage shield first (unless Warlock or shield pierce)
              if (player.className !== "Warlock" && !ignoreShield) {
                if (e.hasShield && e.shieldHP > 0) {
                  if (e.shieldHP >= actualDamage) {
                    e.shieldHP -= actualDamage;
                    actualDamage = 0;
                    addFloatingText(e.x + e.w / 2, e.y - 10, "SHIELD", "#00aaff");
                  } else {
                    actualDamage -= e.shieldHP;
                    e.shieldHP = 0;
                    addFloatingText(e.x + e.w / 2, e.y - 10, "SHIELD BROKEN!", "#ffaa00");
                  }
                }
              } else if (player.className === "Warlock") {
                // WARLOCK: Ignore shields, weaken enemies
                if (e.hasShield && e.shieldHP > 0) {
                  addFloatingText(e.x + e.w / 2, e.y - 10, "üåÄ CURSED!", "#6A0DAD");
                }
                // Weaken enemy damage output
                if (!e.weakened) {
                  e.weakened = true;
                  e.damageMultiplier = 0.8; // 20% weaker
                }
              }
              
              e.hp -= actualDamage;
              spawnHitParticles(p.x, p.y, p.color, p.isCrit ? 12 : 6);
              screenShake += p.isCrit ? 1 : 0.5;
              
              // LEGENDARY: Lucky Streak - crits grant brief invulnerability
              if (p.isCrit && player.legendaryUpgrades.luckyStreak && player.critInvuln) {
                if (!player.critInvulnTimer || player.critInvulnTimer <= 0) {
                  player.critInvulnTimer = 0.5; // 0.5 seconds of invuln
                  addFloatingText(player.x + player.w/2, player.y - 50, "üçÄ LUCKY!", "#ffff00", 1.0);
                }
              }
              
              // PYROMANCER: Create fire zone on ground
              if (player.className === "Pyromancer") {
                fireZones.push({
                  x: p.x,
                  y: p.y,
                  radius: 100,
                  damage: 15,
                  life: 5, // 5 seconds
                  color: "#ff4500"
                });
                
                // Visual fire burst
                for (let i = 0; i < 10; i++) {
                  particles.push({
                    x: p.x,
                    y: p.y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    radius: 4,
                    color: ["#ff4500", "#ff6347", "#ffa500"][Math.floor(Math.random() * 3)],
                    life: 1
                  });
                }
              }
              
              // SUPER UPGRADE: Freeze Bullets
              if (p.freeze) {
                // Progressive freeze system - each hit adds a freeze stack
                if (!e.freezeStacks) e.freezeStacks = 0;
                if (!e.maxFreezeStacks) e.maxFreezeStacks = 3;
                
                e.freezeStacks++;
                
                // Calculate slow effect based on stacks (caps at max stacks)
                const stackRatio = Math.min(e.freezeStacks / e.maxFreezeStacks, 1);
                e.slowEffect = stackRatio * 0.9; // Up to 90% slow
                e.slowDuration = 2; // Refresh duration
                
                // Visual feedback
                if (e.freezeStacks >= e.maxFreezeStacks) {
                  // Fully frozen - can't move
                  e.frozen = true;
                  e.frozenDuration = 2;
                  addFloatingText(e.x + e.w / 2, e.y - 50, "‚ùÑÔ∏è FROZEN!", "#00ffff");
                } else {
                  // Show progress
                  const percent = Math.floor((e.freezeStacks / e.maxFreezeStacks) * 100);
                  addFloatingText(e.x + e.w / 2, e.y - 30, `üßä ${percent}%`, "#88ffff");
                }
              }
              
              // FLAME BURST: Burn damage over time
              if (player.flameBurst) {
                if (!e.burnStacks) e.burnStacks = [];
                
                // Add burn stack
                e.burnStacks.push({
                  damage: player.burnDamage || 20,
                  duration: player.burnDuration || 3,
                  tickInterval: 0.5, // Damage every 0.5 seconds
                  timeSinceLastTick: 0
                });
                
                addFloatingText(e.x + e.w / 2, e.y - 50, "üî• BURNING!", "#ff4500");
                
                // SUPER UPGRADE: Inferno Chain - burn spreads to nearby enemies
                if (player.burnChain) {
                  for (const otherEnemy of enemies) {
                    if (otherEnemy === e) continue;
                    const dx = (otherEnemy.x + otherEnemy.w / 2) - (e.x + e.w / 2);
                    const dy = (otherEnemy.y + otherEnemy.h / 2) - (e.y + e.h / 2);
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < (player.burnChainRange || 150)) {
                      // Chain burn to this enemy!
                      if (!otherEnemy.burnStacks) otherEnemy.burnStacks = [];
                      otherEnemy.burnStacks.push({
                        damage: (player.burnDamage || 20) * 0.8, // 80% burn damage for chain
                        duration: player.burnDuration || 3,
                        tickInterval: 0.5,
                        timeSinceLastTick: 0
                      });
                      addFloatingText(otherEnemy.x + otherEnemy.w / 2, otherEnemy.y - 50, "üåã CHAIN!", "#ff6600");
                      
                      // Visual chain effect
                      spawnHitParticles((e.x + otherEnemy.x) / 2, (e.y + otherEnemy.y) / 2, "#ff4500", 8);
                    }
                  }
                }
              }
              
              // Knockback (Guardian Tank or other knockback sources)
              if (p.knockback && p.knockback > 0) {
                // Knockback resistance system - similar to freeze
                const currentTime = Date.now() / 1000; // Current time in seconds
                if (!e.lastKnockbackTime) e.lastKnockbackTime = 0;
                if (!e.knockbackResistance) e.knockbackResistance = 0;
                if (!e.knockbackHitCount) e.knockbackHitCount = 0;
                
                // Cooldown: 0.3 seconds between knockback applications
                if (currentTime - e.lastKnockbackTime >= 0.3) {
                  // Size-based max knockback resistance (similar to freeze stacks)
                  const maxResistance = e.isBoss ? 15 : e.isMiniBoss ? 8 : 5;
                  
                  if (e.knockbackResistance < maxResistance) {
                    const knockbackForce = p.knockback;
                    const dx = e.x + e.w/2 - (player.x + player.w/2);
                    const dy = e.y + e.h/2 - (player.y + player.h/2);
                    const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                    
                    // Resistance reduces knockback effectiveness
                    const resistanceMultiplier = 1 - (e.knockbackResistance / maxResistance);
                    const effectiveKnockback = knockbackForce * 0.8 * resistanceMultiplier;
                    
                    // Push enemy away (only if resistance not maxed)
                    if (effectiveKnockback > 0) {
                      e.x += (dx / dist) * effectiveKnockback;
                      e.y += (dy / dist) * effectiveKnockback;
                      
                      // Build resistance
                      e.knockbackResistance++;
                      e.knockbackHitCount++;
                      e.lastKnockbackTime = currentTime;
                      
                      // MAX LEVEL KNOCKBACK (5/5 or 75+): Send to spawn after 3 hits!
                      if (player.knockback >= 75 && e.knockbackHitCount >= 3 && e.hp > 0) {
                        // Send enemy back to spawn point
                        e.x = canvas.width + 50;
                        e.y = GROUND_Y - e.h - 10;
                        e.knockbackHitCount = 0; // Reset counter
                        addFloatingText(e.x + e.w / 2, e.y - 60, "üåÄ BANISHED!", "#ff00ff");
                        spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, "#ff00ff", 25);
                        screenShake += 3;
                      } else {
                        // Visual feedback
                        const resistancePercent = Math.floor((e.knockbackResistance / maxResistance) * 100);
                        if (e.knockbackResistance >= maxResistance) {
                          addFloatingText(e.x + e.w / 2, e.y - 40, "üí® IMMUNE!", "#87ceeb");
                        } else {
                          const hitText = player.knockback >= 75 ? ` (${e.knockbackHitCount}/3)` : "";
                          addFloatingText(e.x + e.w / 2, e.y - 40, `üí® ${resistancePercent}%${hitText}`, "#87ceeb");
                        }
                        spawnExplosion(p.x, p.y, "#87ceeb", 15);
                      }
                    }
                  }
                  
                  // Decay resistance over time (lose 1 resistance every 3 seconds)
                  if (currentTime - e.lastKnockbackTime >= 3) {
                    e.knockbackResistance = Math.max(0, e.knockbackResistance - 1);
                  }
                }
              }
              
              // Lifesteal
              if (player.lifesteal > 0) {
                const heal = actualDamage * player.lifesteal;
                if (player.shield < player.maxShield) {
                  player.shield = Math.min(player.shield + heal, player.maxShield);
                } else {
                  player.hp = Math.min(player.hp + heal, player.maxHP);
                }
              }
              
              // Upside Down lifesteal (50%)
              if (upsideDownActive) {
                const heal = actualDamage * 0.5;
                player.hp = Math.min(player.hp + heal, player.maxHP);
              }
              
              // Soul Harvest healing from poison
              if (soulHarvestActive && e.poisoned) {
                const heal = (e.poisonDamage || 5) * dt * 10;
                player.hp = Math.min(player.hp + heal, player.maxHP);
              }
              
              // Explosion
              if (p.explosive) {
                const explosionRadius = p.explosionRadius || 60;
                // Use custom explosion damage if specified (e.g., Bomber's 90 damage)
                // Otherwise use 50% of projectile damage
                const explosionDmg = p.explosionDamage || (actualDamage * 0.5);
                
                for (const otherEnemy of enemies) {
                  if (otherEnemy === e) continue;
                  const dx = (otherEnemy.x + otherEnemy.w / 2) - p.x;
                  const dy = (otherEnemy.y + otherEnemy.h / 2) - p.y;
                  const dist = Math.sqrt(dx * dx + dy * dy);
                  if (dist < explosionRadius) {
                    otherEnemy.hp -= explosionDmg;
                    addFloatingText(otherEnemy.x + otherEnemy.w / 2, otherEnemy.y - 20, "-" + Math.floor(explosionDmg), "#ff8800", 0.6);
                  }
                }
                spawnExplosion(p.x, p.y, "#ff8800", Math.min(15 + explosionRadius / 10, 30));
                screenShake += 2;
              }
              
              // Apply poison (Necromancer)
              if (p.poison && !e.poisonStacks) {
                e.poisonStacks = [];
              }
              if (p.poison) {
                e.poisonStacks.push({
                  damage: p.poison.damage,
                  duration: p.poison.duration
                });
              }
              
              // Check for Bagel clone hits (if enemy is Bagel boss)
              if (e.isBagel && e.bagelClones) {
                for (let cloneIdx = 0; cloneIdx < e.bagelClones.length; cloneIdx++) {
                  const clone = e.bagelClones[cloneIdx];
                  if (clone.hp > 0) {
                    const dx = p.x - clone.x;
                    const dy = p.y - clone.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 20 + p.radius) {
                      // Hit a clone!
                      let cloneDamage = actualDamage;
                      if (p.isCrit) {
                        cloneDamage *= p.critMultiplier;
                      }
                      
                      clone.hp -= cloneDamage;
                      addFloatingText(clone.x, clone.y - 20, `-${Math.floor(cloneDamage)}`, "#ff0000");
                      spawnHitParticles(clone.x, clone.y, p.color, 8);
                      
                      if (clone.hp <= 0) {
                        clone.hp = 0;
                        addFloatingText(clone.x, clone.y - 30, "CLONE DESTROYED!", "#ffff00");
                        spawnExplosion(clone.x, clone.y, "#F5DEB3", 15);
                      }
                      break;
                    }
                  }
                }
              }
              
              // Check for Spiderman leg hits (if enemy is Spiderman boss)
              if (e.isSpiderman && e.spiderLegs) {
                for (let legIdx = 0; legIdx < e.spiderLegs.length; legIdx++) {
                  const leg = e.spiderLegs[legIdx];
                  if (leg.hp > 0) {
                    const legX = e.x + e.w / 2 + Math.cos(leg.angle) * leg.distance;
                    const legY = e.y + e.h / 2 + Math.sin(leg.angle) * leg.distance;
                    
                    const dx = p.x - legX;
                    const dy = p.y - legY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 15 + p.radius) {
                      // Hit a leg!
                      let legDamage = actualDamage;
                      if (p.isCrit) {
                        legDamage *= p.critMultiplier;
                      }
                      
                      leg.hp -= legDamage;
                      addFloatingText(legX, legY - 20, `-${Math.floor(legDamage)}`, "#ff0000");
                      spawnHitParticles(legX, legY, p.color, 8);
                      
                      if (leg.hp <= 0) {
                        leg.hp = 0;
                        addFloatingText(legX, legY - 30, "LEG DOWN!", "#ffff00");
                        spawnExplosion(legX, legY, "#DC143C", 12);
                        screenShake += 2;
                      }
                      break;
                    }
                  }
                }
              }
              
              // Chain lightning
              if (p.chainLightning > 0 && !p.hasChained) {
                p.hasChained = true;
                let chainsLeft = p.chainLightning;
                let lastTarget = e;
                
                while (chainsLeft > 0) {
                  let nearestDist = 150;
                  let nearestEnemy = null;
                  
                  for (const otherEnemy of enemies) {
                    if (otherEnemy === lastTarget) continue;
                    const dx = (otherEnemy.x + otherEnemy.w / 2) - (lastTarget.x + lastTarget.w / 2);
                    const dy = (otherEnemy.y + otherEnemy.h / 2) - (lastTarget.y + lastTarget.h / 2);
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < nearestDist) {
                      nearestDist = dist;
                      nearestEnemy = otherEnemy;
                    }
                  }
                  
                  if (nearestEnemy) {
                    nearestEnemy.hp -= actualDamage * 0.6;
                    spawnHitParticles(nearestEnemy.x + nearestEnemy.w / 2, nearestEnemy.y + nearestEnemy.h / 2, "#00ffff", 6);
                    lastTarget = nearestEnemy;
                    chainsLeft--;
                  } else {
                    break;
                  }
                }
              }
              
              // Mark enemy for clone kill tracking
              if (p.isCloneProjectile && e.hp <= 0) {
                e.killedByClone = true;
              }
              
              if (p.pierce && p.pierceCount < 3) {
                p.pierceCount++;
              } else {
                projectiles.splice(i, 1);
              }
              
              if (!p.pierce) break;
            }
          }
        }
      }
    }

    // MINIONS (Summoner class)
    function spawnMinion() {
      minions.push({
        angle: Math.random() * Math.PI * 2,
        distance: 50 + Math.random() * 20,
        spinSpeed: 2 + Math.random(),
        tickTimer: 0
      });
    }

    function updateMinions(dt) {
      if (!player || player.className !== "Summoner") return;

      const px = player.x + player.w / 2;
      const py = player.y + player.h / 2 - 15;

      for (const m of minions) {
        m.angle += dt * m.spinSpeed;
        m.tickTimer += dt;

        if (m.tickTimer >= 0.3) {
          m.tickTimer = 0;
          const target = getTargetEnemy();
          if (target) {
            const mx = px + Math.cos(m.angle) * m.distance;
            const my = py + Math.sin(m.angle) * m.distance;

            let dx = target.x + target.w / 2 - mx;
            let dy = target.y + target.h / 2 - my;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            dx /= dist;
            dy /= dist;

            projectiles.push({
              x: mx, y: my,
              vx: dx * 6, vy: dy * 6,
              radius: 4,
              damage: player.damage * 0.5,
              color: "#88ff88",
              glowColor: "#88ff88",
              life: 2.5,
              trail: []
            });
          }
        }

        m.drawX = px + Math.cos(m.angle) * m.distance;
        m.drawY = py + Math.sin(m.angle) * m.distance;
      }
    }

    // HELPER STARS (Starcaller class)
    function updateHelperStars(dt) {
      if (!player || player.className !== "Starcaller") return;

      const px = player.x + player.w / 2;
      const py = player.y + player.h / 2;

      for (const star of helperStars) {
        // Orbit around player
        star.angle += dt * 3; // Orbit speed
        star.attackTimer += dt;

        // Attack nearest enemy
        if (star.attackTimer >= star.attackRate) {
          star.attackTimer = 0;
          const target = getTargetEnemy();
          if (target) {
            const sx = px + Math.cos(star.angle) * star.distance;
            const sy = py + Math.sin(star.angle) * star.distance;

            let dx = target.x + target.w / 2 - sx;
            let dy = target.y + target.h / 2 - sy;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            dx /= dist;
            dy /= dist;

            projectiles.push({
              x: sx, y: sy,
              vx: dx * 8, vy: dy * 8,
              radius: 6,
              damage: player.damage * 0.5, // 50% of player damage
              color: "#ffff00",
              glowColor: "#ffaa00",
              life: 2.5,
              trail: [],
              isEnemyProjectile: false
            });
          }
        }

        // Store position for rendering
        star.drawX = px + Math.cos(star.angle) * star.distance;
        star.drawY = py + Math.sin(star.angle) * star.distance;
      }
    }

    // XP & LEVELING
    function giveXP(amount) {
      if (!player || !player.alive) return;
      
      // Apply XP multiplier (Rookie gets 1.5x)
      const xpGained = amount * (player.xpMultiplier || 1.0);
      player.xp += xpGained;
      
      // Check for level up
      if (player.xp >= player.xpToNext) {
        player.level++;
        player.xp -= player.xpToNext;
        
        // Rookie special: At level 10+, XP requirement stays at level 10
        if (player.className === "Rookie" && player.level >= 10) {
          player.xpToNext = xpForLevel(10); // Always use level 10 requirement
        } else {
          player.xpToNext = xpForLevel(player.level);
        }
        
        showUpgradeScreen();
      }
    }

    let currentUpgradeOptions = []; // Store current options for shuffling

    function showUpgradeScreen() {
      gameState = "upgrading";
      upgradeScreen.classList.add("active");
      upgradeSubtitle.textContent = `Level ${player.level} - Choose Your Power-Up`;
      
      generateUpgradeOptions();
      
      // Update shuffle button
      shuffleCount.textContent = shufflesRemaining;
      if (shufflesRemaining > 0) {
        shuffleBtn.style.opacity = "1";
        shuffleBtn.style.cursor = "pointer";
        shuffleBtn.disabled = false;
      } else {
        shuffleBtn.style.opacity = "0.5";
        shuffleBtn.style.cursor = "not-allowed";
        shuffleBtn.disabled = true;
      }
    }

    function generateUpgradeOptions() {
      // Check for available legendary upgrades (when a stat is maxed)
      const availableLegendaries = Object.keys(LEGENDARY_UPGRADES).filter(key => {
        const legendary = LEGENDARY_UPGRADES[key];
        const requiredUpgrade = legendary.requiresMaxed;
        const isMaxed = UPGRADE_TYPES[requiredUpgrade] && 
                       UPGRADE_TYPES[requiredUpgrade].getCurrentLevel(player) >= UPGRADE_TYPES[requiredUpgrade].maxLevel;
        const notUnlocked = !player.legendaryUpgrades[key];
        return isMaxed && notUnlocked;
      });
      
      // Filter out maxed cards
      const availableUpgrades = Object.keys(UPGRADE_TYPES).filter(key => {
        const upgrade = UPGRADE_TYPES[key];
        const currentLevel = upgrade.getCurrentLevel(player);
        const isMaxed = currentLevel >= upgrade.maxLevel;
        
        // Only hide maxed upgrade if its legendary is currently available
        const legendaryAvailable = availableLegendaries.some(legKey => {
          return LEGENDARY_UPGRADES[legKey].requiresMaxed === key;
        });
        
        // Show if not maxed, OR if maxed but legendary not available yet
        return !isMaxed || !legendaryAvailable;
      });
      
      // Combine available legendary and normal upgrades
      let options = [];
      
      // Add legendary upgrades first (priority)
      if (availableLegendaries.length > 0) {
        options.push(...availableLegendaries.map(key => ({ type: 'legendary', key })));
      }
      
      // Add normal upgrades
      if (availableUpgrades.length > 0) {
        options.push(...availableUpgrades.map(key => ({ type: 'normal', key })));
      }
      
      // Check for super upgrades if no regular options
      if (options.length === 0) {
        const superUpgrades = Object.keys(UPGRADE_TYPES).filter(key => {
          const upgrade = UPGRADE_TYPES[key];
          return upgrade.superUpgrade && !player.superUpgrades[upgrade.superUpgrade.name.toLowerCase().replace(/[^a-z]/g, '')];
        });
        
        if (superUpgrades.length > 0) {
          options.push(...superUpgrades.map(key => ({ type: 'super', key })));
        } else {
          // Everything maxed!
          alert("üéâ ALL UPGRADES MAXED! You're unstoppable!");
          upgradeScreen.classList.remove("active");
          gameState = "playing";
          return;
        }
      }
      
      // Shuffle and pick 3
      const shuffled = options.sort(() => Math.random() - 0.5);
      currentUpgradeOptions = shuffled.slice(0, 3);
      
      upgradeOptions.innerHTML = "";
      
      // Add upgrade cards
      currentUpgradeOptions.forEach(option => {
        const card = document.createElement("div");
        card.className = "upgrade-card";
        
        if (option.type === 'legendary') {
          // Show legendary upgrade
          const legendary = LEGENDARY_UPGRADES[option.key];
          card.className = "upgrade-card legendary-card";
          card.innerHTML = `
            <div class="upgrade-card-icon" style="font-size: 48px;">${legendary.icon}</div>
            <div class="upgrade-card-title" style="color: #ffcc00; text-shadow: 0 0 10px #ffaa00;">${legendary.name}</div>
            <div class="upgrade-card-desc">${legendary.desc}</div>
            <div style="color: #ffaa00; font-size: 12px; margin-top: 5px; font-weight: bold;">‚ú® LEGENDARY ‚ú®</div>
          `;
          card.style.border = "2px solid #ffcc00";
          card.style.boxShadow = "0 0 20px rgba(255, 204, 0, 0.5)";
          card.onclick = () => selectLegendaryUpgrade(option.key);
        } else if (option.type === 'super') {
          // Show super upgrade
          const upgrade = UPGRADE_TYPES[option.key];
          card.innerHTML = `
            <div class="upgrade-card-icon">${upgrade.superUpgrade.icon}</div>
            <div class="upgrade-card-title">${upgrade.superUpgrade.name}</div>
            <div class="upgrade-card-desc">${upgrade.superUpgrade.desc}</div>
            <div style="color: #ffaa00; font-size: 11px; margin-top: 5px;">‚≠ê SUPER UPGRADE ‚≠ê</div>
          `;
          card.onclick = () => selectSuperUpgrade(option.key);
        } else {
          // Normal upgrade
          const upgrade = UPGRADE_TYPES[option.key];
          const currentLevel = upgrade.getCurrentLevel(player);
          const nextLevel = currentLevel + 1;
          const canSuper = currentLevel === upgrade.maxLevel && upgrade.superUpgrade;
          
          if (canSuper) {
            // Show super upgrade
            card.innerHTML = `
              <div class="upgrade-card-icon">${upgrade.superUpgrade.icon}</div>
              <div class="upgrade-card-title">${upgrade.superUpgrade.name}</div>
              <div class="upgrade-card-desc">${upgrade.superUpgrade.desc}</div>
              <div style="color: #ffaa00; font-size: 11px; margin-top: 5px;">‚≠ê SUPER UPGRADE ‚≠ê</div>
            `;
            card.onclick = () => selectSuperUpgrade(option.key);
          } else {
            // Normal level up
            card.innerHTML = `
              <div class="upgrade-card-icon">${upgrade.icon}</div>
              <div class="upgrade-card-title">${upgrade.name}</div>
              <div class="upgrade-card-desc">${upgrade.getDesc(nextLevel)}</div>
              <div style="color: #888; font-size: 11px; margin-top: 5px;">Level ${nextLevel}/${upgrade.maxLevel}</div>
            `;
            card.onclick = () => selectUpgrade(option.key);
          }
        }
        
        upgradeOptions.appendChild(card);
      });
      
      // Add 4th card: "No Power-Up" option
      const skipCard = document.createElement("div");
      skipCard.className = "upgrade-card upgrade-card-skip";
      skipCard.innerHTML = `
        <div class="upgrade-card-icon">‚ùå</div>
        <div class="upgrade-card-title">No Power-Up</div>
        <div class="upgrade-card-desc">Skip and continue playing</div>
      `;
      skipCard.onclick = () => {
        upgradeScreen.classList.remove("active");
        gameState = "playing";
        
        // Check for queued upgrades
        if (player.queuedUpgrades && player.queuedUpgrades > 0) {
          player.queuedUpgrades--;
          setTimeout(() => showUpgradeScreen(), 100);
        }
      };
      upgradeOptions.appendChild(skipCard);
    }

    function selectUpgrade(upgradeKey) {
      const upgrade = UPGRADE_TYPES[upgradeKey];
      const currentLevel = upgrade.getCurrentLevel(player);
      const nextLevel = currentLevel + 1;
      
      // Store pre-upgrade values for Rookie multiplier calculation
      const preUpgrade = {};
      if (player.powerUpMultiplier > 1.0) {
        preUpgrade.damage = player.damage;
        preUpgrade.maxHP = player.maxHP;
        preUpgrade.shield = player.shield || 0;
        preUpgrade.maxShield = player.maxShield || 0;
      }
      
      // Apply the upgrade at the next level
      upgrade.apply(player, nextLevel);
      
      // Apply Rookie power-up multiplier (20% bonus)
      if (player.powerUpMultiplier > 1.0) {
        const multiplier = player.powerUpMultiplier;
        
        // Apply multiplier to numeric increases
        if (upgradeKey === 'damage') {
          const increase = player.damage - preUpgrade.damage;
          player.damage = preUpgrade.damage + (increase * multiplier);
        } else if (upgradeKey === 'hp') {
          const increase = player.maxHP - preUpgrade.maxHP;
          player.maxHP = preUpgrade.maxHP + Math.floor(increase * multiplier);
          player.hp = player.maxHP; // Heal to new max
        } else if (upgradeKey === 'shield') {
          const shieldIncrease = (player.shield || 0) - preUpgrade.shield;
          const maxShieldIncrease = (player.maxShield || 0) - preUpgrade.maxShield;
          player.shield = preUpgrade.shield + Math.floor(shieldIncrease * multiplier);
          player.maxShield = preUpgrade.maxShield + Math.floor(maxShieldIncrease * multiplier);
        }
      }
      
      // Track shield upgrades for Guardian Tank unlock
      if (upgradeKey === 'shield') {
        shieldUpgradesChosen++;
        
        // Check if Guardian Tank should unlock
        if (shieldUpgradesChosen >= 5 && player.maxHP >= 200) {
          if (!gameData.unlockedClasses.includes("GuardianTank")) {
            gameData.unlockedClasses.push("GuardianTank");
            saveGameData();
            addFloatingText(canvas.width / 2, 150, "üõ°Ô∏è GUARDIAN TANK UNLOCKED! üõ°Ô∏è", "#4169e1");
            screenShake += 6;
            
            // Extra visual feedback
            for (let i = 0; i < 50; i++) {
              particles.push({
                x: canvas.width / 2,
                y: 200,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                radius: 5,
                color: "#4169e1",
                life: 2
              });
            }
          }
        }
      }
      
      upgradeScreen.classList.remove("active");
      gameState = "playing";
      
      // Check if there are queued upgrades from starting level
      if (player.queuedUpgrades && player.queuedUpgrades > 0) {
        player.queuedUpgrades--;
        // Show next upgrade screen after a brief delay
        setTimeout(() => {
          showUpgradeScreen();
        }, 100);
      }
      
      const displayName = upgrade.name + ` (Lv ${nextLevel})`;
      addFloatingText(player.x + player.w / 2, player.y - 30, displayName + "!", "#ffff00");
      spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, player.glowColor, 20);
    }
    
    function selectLegendaryUpgrade(legendaryKey) {
      const legendary = LEGENDARY_UPGRADES[legendaryKey];
      
      if (!legendary) return;
      
      // Apply legendary upgrade
      legendary.apply(player);
      
      upgradeScreen.classList.remove("active");
      gameState = "playing";
      
      // Check for queued upgrades
      if (player.queuedUpgrades && player.queuedUpgrades > 0) {
        player.queuedUpgrades--;
        setTimeout(() => showUpgradeScreen(), 100);
      }
      
      // Epic visual feedback for legendary upgrade!
      addFloatingText(canvas.width / 2, canvas.height / 2 - 60, legendary.name, "#ffcc00", 2);
      addFloatingText(canvas.width / 2, canvas.height / 2 - 20, "‚ú® LEGENDARY ‚ú®", "#ffaa00", 1.5);
      screenShake += 15;
      
      // Massive golden particle explosion
      for (let i = 0; i < 150; i++) {
        particles.push({
          x: player.x + player.w / 2,
          y: player.y + player.h / 2,
          vx: (Math.random() - 0.5) * 18,
          vy: (Math.random() - 0.5) * 18,
          radius: 10,
          color: ["#ffcc00", "#ffaa00", "#ff8800"][i % 3],
          life: 3
        });
      }
    }
    
    function selectSuperUpgrade(upgradeKey) {
      const upgrade = UPGRADE_TYPES[upgradeKey];
      
      if (!upgrade.superUpgrade) return;
      
      // Apply super upgrade
      upgrade.superUpgrade.apply(player);
      
      upgradeScreen.classList.remove("active");
      gameState = "playing";
      
      // Check for queued upgrades
      if (player.queuedUpgrades && player.queuedUpgrades > 0) {
        player.queuedUpgrades--;
        setTimeout(() => showUpgradeScreen(), 100);
      }
      
      // Epic visual feedback for super upgrade!
      addFloatingText(canvas.width / 2, canvas.height / 2 - 50, upgrade.superUpgrade.name, "#ff00ff");
      addFloatingText(canvas.width / 2, canvas.height / 2, "SUPER UPGRADE!", "#ffaa00");
      screenShake += 10;
      
      // Massive particle explosion
      for (let i = 0; i < 100; i++) {
        particles.push({
          x: player.x + player.w / 2,
          y: player.y + player.h / 2,
          vx: (Math.random() - 0.5) * 15,
          vy: (Math.random() - 0.5) * 15,
          radius: 8,
          color: ["#ff00ff", "#ffaa00", "#00ffff"][i % 3],
          life: 3
        });
      }
    }

    // Shuffle button listener
    shuffleBtn.addEventListener("click", () => {
      if (shufflesRemaining > 0) {
        shufflesRemaining--;
        generateUpgradeOptions();
        shuffleCount.textContent = shufflesRemaining;
        
        if (shufflesRemaining === 0) {
          shuffleBtn.style.opacity = "0.5";
          shuffleBtn.style.cursor = "not-allowed";
          shuffleBtn.disabled = true;
        }
      }
    });

    // Skip/Close upgrade button listener
    skipUpgradeBtn.addEventListener("click", () => {
      upgradeScreen.classList.remove("active");
      gameState = "playing"; // Resume game immediately
      // Continue playing without choosing an upgrade
    });

    // COMBO SYSTEM
    function updateCombo(dt) {
      if (combo > 0) {
        comboTimer -= dt;
        if (comboTimer <= 0) {
          combo = 0;
        }
      }
    }

    // PARTICLES & EFFECTS
    function spawnHitParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 4,
          vy: (Math.random() - 0.5) * 4,
          life: 0.5,
          color
        });
      }
    }

    function spawnExplosion(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 8,
          vy: (Math.random() - 0.5) * 8,
          life: 0.8,
          color
        });
      }
    }

    function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= dt;
        
        // Speed Demon trail particles damage enemies
        if (p.damageTrail && p.trailDamage) {
          enemies.forEach(enemy => {
            const dx = (enemy.x + enemy.w/2) - p.x;
            const dy = (enemy.y + enemy.h/2) - p.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 30) {
              enemy.hp -= p.trailDamage * dt;
            }
          });
        }
        
        if (p.life <= 0) {
          particles.splice(i, 1);
        }
      }
    }

    function addFloatingText(x, y, text, color) {
      floatingTexts.push({ x, y, text, color, life: 1.5, vy: -1.5 });
    }
    
    function floatingText(text, x, y, color, life = 1.5) {
      floatingTexts.push({ x, y, text, color, life, vy: -1.5 });
    }

    function updateFloatingTexts(dt) {
      for (let i = floatingTexts.length - 1; i >= 0; i--) {
        const t = floatingTexts[i];
        t.y += t.vy;
        t.life -= dt;
        if (t.life <= 0) {
          floatingTexts.splice(i, 1);
        }
      }
    }

    // ROUND BREAKS
    function startRoundBreak() {
      gameState = "roundBreak";
      roundBreakTimer = ROUND_BREAK_TIME;
      roundBreakScreen.classList.add("active");
      
      if (wave % 10 === 0) {
        breakTitle.textContent = "üî• BOSS WAVE INCOMING! üî•";
        breakInfo.innerHTML = `
          Prepare yourself!<br>
          A mighty boss approaches...<br>
          <br>Press SPACE to start immediately
        `;
      } else if (wave % 5 === 0) {
        breakTitle.textContent = "‚ö° MINI-BOSS WAVE! ‚ö°";
        breakInfo.innerHTML = `
          Get ready!<br>
          A powerful enemy is coming...<br>
          <br>Press SPACE to start immediately
        `;
      } else {
        breakTitle.textContent = `üéØ WAVE ${wave} COMPLETE! üéØ`;
        breakInfo.innerHTML = `
          Prepare for the next wave!<br>
          <br>Press SPACE to start immediately
        `;
      }
    }

    function endRoundBreak() {
      gameState = "playing";
      roundBreakScreen.classList.remove("active");
      enemiesToSpawn = calcEnemiesForWave(wave);
      spawnTimer = 0;
      
      // INCREASED BOSS FREQUENCY AT HIGH WAVES
      if (wave % 10 === 0) {
        // Boss every 10 waves
        spawnEnemy(true, false);
      } else if (wave % 5 === 0) {
        // Mini-boss every 5 waves
        spawnEnemy(false, true);
      } else if (wave >= 30 && wave % 3 === 0) {
        // Wave 30+: Additional mini-boss every 3 waves
        spawnEnemy(false, true);
      }
    }

    // GAME END
    function endGame() {
      gameRunning = false; // Stop game loop
      spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, player.color, 30);
      
      // Track Wave 18 restart for Dr.Sunshine unlock (kept for backwards compatibility)
      if (wave === 18) {
        if (!gameData.wave18Restarts) gameData.wave18Restarts = 0;
        gameData.wave18Restarts++;
        console.log(`‚òÄÔ∏è Wave 18 Restart #${gameData.wave18Restarts}/7 for Dr.Sunshine`);
      }
      
      // Update highest wave
      let newClassUnlocked = false;
      if (wave > gameData.highestWave) {
        gameData.highestWave = wave;
        
        // Unlock all waves up to current wave
        for (let w = 1; w <= wave; w++) {
          if (!gameData.unlockedWaves.includes(w)) {
            gameData.unlockedWaves.push(w);
          }
        }
      }
      
      // Unlock classes based on highest wave achieved (not just current wave)
      Object.entries(CLASSES).forEach(([name, data]) => {
        if (!data.purchasable && !data.challengeUnlock && !data.achievementUnlock && 
            data.unlockWave && gameData.highestWave >= data.unlockWave && 
            !gameData.unlockedClasses.includes(name)) {
          gameData.unlockedClasses.push(name);
          newClassUnlocked = true;
          console.log(`üîì CLASS UNLOCKED: ${name} (Wave ${data.unlockWave}) | Your highest wave: ${gameData.highestWave}`);
        }
      });
      
      // Log current unlocked classes for debugging
      console.log(`üìã All unlocked classes:`, gameData.unlockedClasses);
      console.log(`üìä Highest wave reached: ${gameData.highestWave}`);
      
      // Make sure all earned money is saved (should already be in gameData from collection)
      saveGameData();
      
      // Hide give up button
      giveUpBtn.style.display = "none";
      
      // Show game over screen with stats
      finalWave.textContent = wave;
      finalLevel.textContent = player.level;
      finalKills.textContent = enemiesKilled;
      finalCombo.textContent = maxCombo + "x";
      earnedCoins.textContent = sessionCoins;
      earnedGems.textContent = sessionGems;
      totalCoinsNow.textContent = gameData.totalCoins;
      totalGemsNow.textContent = gameData.totalGems;
      
      gameOverScreen.classList.add("active");
      
      // Start 10-second countdown timer
      let countdown = 10;
      countdownTimer.textContent = countdown;
      
      // Clear any existing countdown
      if (gameOverCountdownInterval) {
        clearInterval(gameOverCountdownInterval);
      }
      
      // Start new countdown
      gameOverCountdownInterval = setInterval(() => {
        countdown--;
        countdownTimer.textContent = countdown;
        
        if (countdown <= 0) {
          clearInterval(gameOverCountdownInterval);
          // Automatically return home
          returnToHome();
        }
      }, 1000);
      
      // Show class unlock notification if any
      if (newClassUnlocked) {
        setTimeout(() => {
          alert("üîì NEW CLASS UNLOCKED! Check the class selection!");
        }, 500);
      }
    }
    
    // Return to home screen function
    // PAUSE MENU FUNCTIONS
    function togglePause() {
      gamePaused = !gamePaused;
      const pauseMenu = document.getElementById('pauseMenu');
      
      if (gamePaused) {
        // SHOW pause menu - ensure it's visible
        pauseMenu.classList.add('active');
        pauseMenu.style.display = '';  // Use CSS default
        pauseMenu.style.visibility = '';
        pauseMenu.style.opacity = '';
        pauseMenu.style.zIndex = '';
        pauseMenu.style.pointerEvents = '';
        updatePauseStats();
        console.log('‚è∏Ô∏è Game paused - menu shown');
      } else {
        // HIDE pause menu
        pauseMenu.classList.remove('active');
        console.log('‚ñ∂Ô∏è Game unpaused - menu hidden');
      }
    }
    
    function updatePauseStats() {
      if (!player) return;
      const statsDiv = document.getElementById('pauseStats');
      statsDiv.innerHTML = `
        <div class="pause-stat">
          <span class="pause-stat-label">Class:</span>
          <span class="pause-stat-value">${player.className}</span>
        </div>
        <div class="pause-stat">
          <span class="pause-stat-label">HP:</span>
          <span class="pause-stat-value">${Math.ceil(player.hp)}/${player.maxHP}</span>
        </div>
        <div class="pause-stat">
          <span class="pause-stat-label">Level:</span>
          <span class="pause-stat-value">${player.level}</span>
        </div>
        <div class="pause-stat">
          <span class="pause-stat-label">Damage:</span>
          <span class="pause-stat-value">${Math.floor(player.damage)}</span>
        </div>
        <div class="pause-stat">
          <span class="pause-stat-label">Fire Rate:</span>
          <span class="pause-stat-value">${(1/player.fireRate).toFixed(2)}/sec</span>
        </div>
        <div class="pause-stat">
          <span class="pause-stat-label">Range:</span>
          <span class="pause-stat-value">${Math.floor(player.range)}</span>
        </div>
        <div class="pause-stat">
          <span class="pause-stat-label">Multi-Shot:</span>
          <span class="pause-stat-value">+${player.multiShot}</span>
        </div>
        <div class="pause-stat">
          <span class="pause-stat-label">Crit Chance:</span>
          <span class="pause-stat-value">${((player.critChance || 0) * 100).toFixed(0)}%</span>
        </div>
      `;
    }
    
    function setBrightness(value) {
      brightnessLevel = value / 100;
      canvas.style.filter = `brightness(${value}%)`;
      document.getElementById('brightnessValue').textContent = value + '%';
    }
    
    function setVolume(value) {
      volumeLevel = value / 100;
      document.getElementById('volumeValue').textContent = value + '%';
      // Future: Apply to sound effects
    }
    
    function returnToHome() {
      console.log('üè† Returning to home screen...');
      
      // Clear countdown interval
      if (gameOverCountdownInterval) {
        clearInterval(gameOverCountdownInterval);
        gameOverCountdownInterval = null;
      }
      
      // Stop the game completely
      gameRunning = false;
      gamePaused = false;
      gameState = "title";
      
      // Clear and hide canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#000000";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Reset ALL game objects
      player = null;
      enemies = [];
      projectiles = [];
      minions = [];
      particles = [];
      floatingTexts = [];
      currencyDrops = [];
      fireZones = [];
      vecnaMonsters = [];
      
      // Reset game variables
      wave = 1;
      enemiesToSpawn = 0;
      combo = 0;
      maxCombo = 0;
      screenShake = 0;
      
      // Hide all game screens
      gameOverScreen.classList.remove("active");
      classSelection.classList.remove("active");
      shopScreen.classList.remove("active");
      upgradeScreen.classList.remove("active");
      roundBreakScreen.classList.remove("active");
      document.getElementById('pauseMenu').classList.remove("active");
      
      // Hide ALL gameplay UI elements
      document.getElementById('giveUpBtn').style.display = 'none';
      document.getElementById('ability1Btn').style.display = 'none';
      document.getElementById('ability2Btn').style.display = 'none';
      document.getElementById('potionBar').style.display = 'none';
      
      // Force hide pause menu with all methods
      const pauseMenuElement = document.getElementById('pauseMenu');
      pauseMenuElement.classList.remove("active");
      pauseMenuElement.style.display = 'none';
      pauseMenuElement.style.visibility = 'hidden';
      pauseMenuElement.style.opacity = '0';
      pauseMenuElement.style.zIndex = '-100';
      pauseMenuElement.style.pointerEvents = 'none';
      
      // COMPLETELY hide canvas
      canvas.style.display = 'none';
      canvas.style.visibility = 'hidden';
      canvas.style.opacity = '0';
      canvas.style.zIndex = '-100';
      canvas.style.pointerEvents = 'none';
      
      // Hide ALL other screens
      classSelection.classList.remove("active");
      shopScreen.classList.remove("active");
      upgradeScreen.classList.remove("active");
      roundBreakScreen.classList.remove("active");
      gameOverScreen.classList.remove("active");
      document.getElementById('tutorialScreen').style.display = 'none';
      document.getElementById('evolAuraScreen').style.display = 'none';
      
      // Show title screen - REMOVE ALL INLINE STYLES
      titleScreen.classList.remove("hidden");
      titleScreen.removeAttribute('style'); // Nuclear option - remove ALL inline styles!
      
      // Update title screen stats
      updateTitleScreenDisplay();
      
      // Save game data
      saveGameData();
      
      console.log('‚úÖ Returned to home screen successfully');
      console.log('   - gameRunning:', gameRunning);
      console.log('   - gameState:', gameState);
      console.log('   - player:', player);
      console.log('   - titleScreen visible:', !titleScreen.classList.contains('hidden'));
      console.log('   - titleScreen inline styles removed');
    }
    
    // Continue button handler
    continueBtn.addEventListener("click", () => {
      returnToHome();
    });
    
    // Back arrow button handler
    gameOverBackBtn.addEventListener("click", () => {
      returnToHome();
    });
    
    // Retry button handler - restart with same class
    retryBtn.addEventListener("click", () => {
      // Clear countdown interval
      if (gameOverCountdownInterval) {
        clearInterval(gameOverCountdownInterval);
        gameOverCountdownInterval = null;
      }
      
      gameOverScreen.classList.remove("active");
      initGame(); // Restart game with same class
    });
    
    // Give up button handler
    giveUpBtn.addEventListener("click", function(e) {
      e.preventDefault();
      e.stopPropagation();
      
      if (confirm("Are you sure you want to give up? You'll keep all coins/gems earned so far.")) {
        // Stop game immediately
        gameRunning = false;
        player.alive = false;
        player.hp = 0;
        
        // Clear all timers and intervals
        waveTimerActive = false;
        waveTimer = 0;
        
        // End the game
        endGame();
      }
    });

    // MAIN UPDATE LOOP
    function update(dt) {
      if (!player || !player.alive) return;

      // Update player debuffs
      if (playerDebuffs.cursed) {
        playerDebuffs.cursedTimer -= dt;
        if (playerDebuffs.cursedTimer <= 0) {
          playerDebuffs.cursed = false;
          playerDebuffs.cursedTimer = 0;
        }
        // Curse effect: -30% damage
        player.damage *= 0.7;
      }
      
      if (playerDebuffs.poisoned) {
        playerDebuffs.poisonedTimer -= dt;
        if (playerDebuffs.poisonedTimer <= 0) {
          playerDebuffs.poisoned = false;
          playerDebuffs.poisonedTimer = 0;
        } else {
          // Poison effect: damage over time every 0.5s
          if (Math.floor(playerDebuffs.poisonedTimer * 2) !== Math.floor((playerDebuffs.poisonedTimer + dt) * 2)) {
            player.hp -= playerDebuffs.poisonDamage;
            addFloatingText(player.x + player.w/2, player.y - 20, `-${playerDebuffs.poisonDamage}`, "#00ff00");
            if (player.hp <= 0) {
              player.hp = 0;
              player.alive = false;
              endGame();
            }
          }
        }
      }

      // Update player sprite animation
      if (player && player.alive) {
        const keys = window.keys || {};
        if (keys['a'] || keys['d'] || keys['w'] || keys['s']) {
          // Moving - animate
          player.animFrame = ((player.animFrame || 0) + dt * 8) % 1;
        } else {
          // Standing still - reset to frame 0
          player.animFrame = 0;
        }
        
        // Track facing direction
        if (keys['a']) player.facingLeft = true;
        if (keys['d']) player.facingLeft = false;
      }

      if (gameState === "roundBreak") {
        roundBreakTimer -= dt;
        breakTimer.textContent = Math.ceil(roundBreakTimer);
        
        if (roundBreakTimer <= 0) {
          endRoundBreak();
        }
        
        updateParticles(dt);
        updateFloatingTexts(dt);
        updateCurrencyDrops(dt);
        screenShake *= 0.9;
        return;
      }

      if (gameState === "upgrading") {
        updateParticles(dt);
        updateFloatingTexts(dt);
        updateCurrencyDrops(dt);
        return;
      }

      handleShooting(dt);
      handleSpawning(dt);
      updateProjectiles(dt);
      updateEnemies(dt);
      updateMinions(dt);
      updateHelperStars(dt);
      updateParticles(dt);
      updateFloatingTexts(dt);
      updateCombo(dt);
      updateCurrencyDrops(dt);
      updatePotionEffects(dt);
      updatePotionCooldownDisplay();
      updateAbilities(dt);
      updateFireZones(dt);
      updateMiniSun(dt);
      
      // Regeneration
      if (player.regen > 0) {
        player.hp = Math.min(player.hp + player.regen * dt, player.maxHP);
      }
      
      // LEGENDARY: Lucky Streak - update crit invulnerability timer
      if (player.critInvulnTimer && player.critInvulnTimer > 0) {
        player.critInvulnTimer -= dt;
      }
      
      // LEGENDARY: Vampiric Aura - drain HP from nearby enemies
      if (player.legendaryUpgrades.vampiricAura && player.vampireAura) {
        enemies.forEach(enemy => {
          const dx = (enemy.x + enemy.w/2) - (player.x + player.w/2);
          const dy = (enemy.y + enemy.h/2) - (player.y + player.h/2);
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < (player.vampireAuraRange || 200)) {
            const drain = (player.vampireAuraDrain || 5) * dt;
            enemy.hp -= drain;
            if (player.hp < player.maxHP) {
              player.hp = Math.min(player.hp + drain, player.maxHP);
            }
          }
        });
      }
      
      // LEGENDARY: Speed Demon - leave damaging trail
      if (player.legendaryUpgrades.speedDemon && player.speedTrail) {
        // Create trail particles behind player
        if (Math.random() < 0.3) {
          particles.push({
            x: player.x + player.w/2,
            y: player.y + player.h/2,
            vx: (Math.random() - 0.5) * 2,
            vy: (Math.random() - 0.5) * 2,
            radius: 8,
            color: "#ffaa00",
            life: 0.5,
            damageTrail: true,
            trailDamage: player.trailDamage || 15
          });
        }
      }
      
      // BERSERK: Damage scales with HP lost (up to 3x at 0% HP)
      if (player.className === "Berserk") {
        const hpPercent = player.hp / player.maxHP;
        const damageMultiplier = 1 + (1 - hpPercent) * 2; // 1x at full, 3x at 0%
        player.damage = player.baseDamage * damageMultiplier;
      }
      
      // HOLYCLERIC: Auto-healing spell every 30 seconds
      if (player.className === "HolyCleric") {
        clericHealCooldown -= dt;
        if (clericHealCooldown <= 0) {
          clericHealCooldown = 30; // 30 second cooldown
          
          // Heal self
          player.hp = Math.min(player.hp + 40, player.maxHP);
          addFloatingText(player.x + player.w / 2, player.y - 50, "+40 HP ‚úùÔ∏è", "#ffd700");
          
          // Knockback enemies within 50 radius
          const px = player.x + player.w / 2;
          const py = player.y + player.h / 2;
          enemies.forEach(enemy => {
            const dx = enemy.x + enemy.w / 2 - px;
            const dy = enemy.y + enemy.h / 2 - py;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 200) { // 50 radius
              const knockbackForce = 60;
              enemy.x += (dx / dist) * knockbackForce;
              enemy.y += (dy / dist) * knockbackForce;
              addFloatingText(enemy.x, enemy.y - 20, "REPEL!", "#ffffe0");
            }
          });
          
          // Visual effect
          for (let i = 0; i < 30; i++) {
            particles.push({
              x: px,
              y: py,
              vx: Math.cos(i / 30 * Math.PI * 2) * 8,
              vy: Math.sin(i / 30 * Math.PI * 2) * 8,
              radius: 5,
              color: "#ffd700",
              life: 1.5
            });
          }
          screenShake += 5;
        }
      }
      
      // SUPER UPGRADE: Shield Regeneration (Invincible)
      if (player.shieldRegen > 0) {
        player.shield = Math.min((player.shield || 0) + player.shieldRegen * dt, player.maxShield);
      }
      
      // SUPER UPGRADE: Laser Beam (continuous damage)
      if (player.laserBeam) {
        enemies.forEach(enemy => {
          const dx = enemy.x - player.x;
          const dy = enemy.y - player.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < player.range) {
            const laserDmg = (player.laserDamage || player.damage * 0.5) * dt;
            enemy.hp -= laserDmg;
            
            // Visual: Add laser particles
            if (Math.random() < 0.3) {
              particles.push({
                x: enemy.x,
                y: enemy.y,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                radius: 3,
                color: player.bulletColor,
                life: 0.5
              });
            }
          }
        });
      }
      
      // SUPER UPGRADE: Gravity Well (pull enemies)
      if (player.gravityPull) {
        const pullStrength = 100 * dt;
        enemies.forEach(enemy => {
          const dx = player.x - enemy.x;
          const dy = player.y - enemy.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < player.gravityRadius) {
            enemy.x += (dx / dist) * pullStrength;
            enemy.y += (dy / dist) * pullStrength;
          }
        });
      }
      
      screenShake *= 0.9;
      if (screenShake < 0.1) screenShake = 0;

      // Check if wave is complete (all enemies spawned AND all enemies killed)
      // Start next wave IMMEDIATELY regardless of timer
      if (enemiesToSpawn === 0 && enemies.length === 0) {
        // Cancel wave timer if active
        if (waveTimerActive) {
          waveTimerActive = false;
          waveTimer = 0;
        }
        
        // Wave complete! Start next wave immediately
        wave++;
        
        // Reset enemy progress tracking for new wave
        enemiesThisWave = 0;
        enemiesKilledThisWave = 0;
        
        // SPECIAL WAVE 20 COMPLETION REWARD
        if (wave === 21) {
          // Just completed wave 20!
          gameState = "roundBreak";
          roundBreakTimer = 10; // 10 second wait
          breakTimer.style.display = "block";
          breakTitle.textContent = "üåü WAVE 20 COMPLETE! üåü";
          breakTitle.style.display = "block";
          
          // Give 1000 XP bonus
          giveXP(1000);
          addFloatingText(canvas.width / 2, 250, "+1000 XP BONUS!", "#FFD700", 2.0);
          addFloatingText(canvas.width / 2, 280, "Map changing to sunny day!", "#FFA500", 1.5);
          screenShake += 10;
        }
        
        // Check for map progression (every 20 waves)
        if (wave % 20 === 1 && wave > 1) {
          currentMap++;
          mapsCompleted++;
          shufflesRemaining = 4;
          addFloatingText(canvas.width / 2, 200, `üó∫Ô∏è MAP ${currentMap} üó∫Ô∏è`, "#ff00ff");
          addFloatingText(canvas.width / 2, 230, "SHUFFLES RESET!", "#00ffff");
          screenShake += 5;
        }
        
        // Give wave bonus XP
        const waveBonus = 50 + wave * 10;
        giveXP(waveBonus);
        addFloatingText(canvas.width / 2, 150, "WAVE " + wave + " COMPLETE!", "#00ff00");
        addFloatingText(canvas.width / 2, 180, "Starting Wave " + wave, "#00ffff");
        
        // Potion generation per wave (scales with wave number!)
        if (gameData.potionUpgrades.potionGeneration > 0) {
          // Base chance: 1% per wave (wave 1 = 1%, wave 10 = 10%, wave 50 = 50%)
          const baseChance = Math.min(wave * 0.01, 0.50); // Cap at 50%
          
          // Upgrade multiplier: Each level adds +50% to the chance
          // Level 1: 1.5x, Level 2: 2x, Level 3: 2.5x, etc.
          const upgradeMultiplier = 1 + (gameData.potionUpgrades.potionGeneration * 0.5);
          
          const totalChance = baseChance * upgradeMultiplier;
          
          if (Math.random() < totalChance) {
            // Generate a random potion
            const potionTypes = ['heal', 'shield', 'crit', 'damage', 'speed', 'dragon'];
            const randomType = potionTypes[Math.floor(Math.random() * potionTypes.length)];
            potions[randomType]++;
            
            addFloatingText(canvas.width / 2, 210, `üçÄ BONUS POTION! ${randomType.toUpperCase()}`, "#00ff00", 1.5);
            updatePotionDisplay(); // Update the display immediately
          }
        }
        
        // Potions DO NOT reset - Summoner ability only!
        
        // Reset Last Stand for new wave
        lastStandUsed = false;
        
        // Start next wave immediately
        enemiesToSpawn = calcEnemiesForWave(wave);
        spawnTimer = 0;
        
        // Spawn boss/mini-boss immediately if applicable
        // Mini-boss every 5 waves
        if (wave % 5 === 0 && wave % 10 !== 0) {
          spawnEnemy(false, true);
          enemiesToSpawn--;
        }
        // Boss every 10 waves
        if (wave % 10 === 0) {
          spawnEnemy(true, false);
          enemiesToSpawn--;
        }
      }

      // Wave timer system (30s after last enemy spawns)
      if (waveTimerActive) {
        waveTimer -= dt;
        
        // Check if wave timer expired
        if (waveTimer <= 0) {
          // Auto-start if enabled, otherwise wait for player to press Space
          if (!autoStartWave) {
            // Show message and wait - but don't return, let game continue
            // Player can press Space to start manually
          } else {
            // Auto-start enabled, start wave automatically
            wave++;
            waveTimerActive = false;
            
            // Check for map progression (every 20 waves)
            if (wave % 20 === 1 && wave > 1) {
              currentMap++;
              mapsCompleted++;
              shufflesRemaining = 4; // Reset shuffles on new map!
              
              addFloatingText(canvas.width / 2, 200, `üó∫Ô∏è MAP ${currentMap} üó∫Ô∏è`, "#ff00ff");
              addFloatingText(canvas.width / 2, 230, "SHUFFLES RESET!", "#00ffff");
              screenShake += 5;
            }
            
            // Give wave bonus XP
            const waveBonus = 50 + wave * 10;
            giveXP(waveBonus);
            addFloatingText(canvas.width / 2, 150, "WAVE " + wave + " START!", "#00ffff");
            
            // Potions DO NOT reset - Summoner ability only!
            
            // Reset Last Stand for new wave
            lastStandUsed = false;
            
            // Start next wave
            enemiesToSpawn = calcEnemiesForWave(wave);
            spawnTimer = 0;
            
            // Spawn boss/mini-boss immediately if applicable
            if (wave % 10 === 0) {
              spawnEnemy(true, false);
              enemiesToSpawn--; // Boss counts as one of the enemies
            } else if (wave % 5 === 0) {
              spawnEnemy(false, true);
              enemiesToSpawn--; // Mini-boss counts as one
            }
          }
        }
      }
    }

    // DRAWING
    function drawBackground() {
      // After wave 20, show sunny day background
      if (wave > 20) {
        // Sky blue gradient
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, "#87CEEB"); // Light blue
        gradient.addColorStop(1, "#E0F6FF"); // Very light blue
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Sun
        const time = Date.now() * 0.0001;
        ctx.shadowBlur = 30;
        ctx.shadowColor = "#FFA500";
        ctx.fillStyle = "#FFD700";
        ctx.beginPath();
        ctx.arc(canvas.width - 100, 80, 40, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // Clouds
        for (let i = 0; i < 5; i++) {
          const cloudX = ((i * 250 + time * 30) % (canvas.width + 100)) - 50;
          const cloudY = 50 + i * 40;
          ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
          ctx.beginPath();
          ctx.arc(cloudX, cloudY, 30, 0, Math.PI * 2);
          ctx.arc(cloudX + 25, cloudY, 35, 0, Math.PI * 2);
          ctx.arc(cloudX + 50, cloudY, 30, 0, Math.PI * 2);
          ctx.fill();
        }
      } else {
        // Original night background
        ctx.fillStyle = "#0a0015";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Stars
        const time = Date.now() * 0.0001;
        for (let i = 0; i < 50; i++) {
          const x = (i * 123.456 % canvas.width);
          const y = ((i * 78.9 + time * 20) % canvas.height);
          const brightness = (Math.sin(i + time * 3) + 1) * 0.5;
          ctx.fillStyle = `rgba(255, 255, 255, ${brightness * 0.5})`;
          ctx.fillRect(x, y, 2, 2);
        }
      }
    }

    function drawGround() {
      ctx.fillStyle = "#2a1a3a";
      ctx.fillRect(0, GROUND_Y, canvas.width, canvas.height - GROUND_Y);
      ctx.strokeStyle = "#00ffff";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, GROUND_Y);
      ctx.lineTo(canvas.width, GROUND_Y);
      ctx.stroke();
    }

    function drawPlayer() {
      if (!player) return;
      
      const x = player.x;
      const y = player.y;
      const w = player.w;
      const h = player.h;
      
      // PHANTOM CLONE: Appears at level 10+
      if (player.level >= 10) {
        drawPhantomClone(x, y, w, h);
      }

      // SPECIAL CHARACTER DESIGNS - Enhanced emoji-based sprites
      const enhancedClass = drawEnhancedClass(x, y, w, h, player.className);
      if (enhancedClass) return;

      // Try to draw sprite if available
      const sprite = characterSprites[player.className];
      
      if (sprite && spritesLoaded) {
        // DRAW SPRITE
        const frame = getSpriteFrame(player.animFrame || 0);
        const spriteWidth = sprite.width;
        const spriteHeight = sprite.height;
        const frameWidth = spriteWidth / 4; // 4 frames per sprite sheet
        
        ctx.save();
        
        // Flip sprite if facing left
        if (player.facingLeft) {
          ctx.scale(-1, 1);
          ctx.drawImage(
            sprite,
            frame * frameWidth, 0, // Source x, y
            frameWidth, spriteHeight, // Source width, height
            -(x + w), y, // Dest x, y (flipped)
            w, h // Dest width, height
          );
        } else {
          ctx.drawImage(
            sprite,
            frame * frameWidth, 0, // Source x, y
            frameWidth, spriteHeight, // Source width, height
            x, y, // Dest x, y
            w, h // Dest width, height
          );
        }
        
        ctx.restore();
      } else {
        // FALLBACK: Draw colored square (current system)
        ctx.shadowColor = player.glowColor;
        ctx.shadowBlur = 15;
        ctx.fillStyle = player.color;
        ctx.fillRect(x, y, w, h);

        ctx.shadowBlur = 0;
        ctx.fillStyle = player.accent;
        ctx.fillRect(x + 4, y + 4, w - 8, h - 8);

        ctx.fillStyle = "#ffd4a3";
        ctx.fillRect(x + w * 0.25, y - h * 0.3, w * 0.5, h * 0.3);

        ctx.fillStyle = player.glowColor;
        ctx.fillRect(x + w * 0.35, y - h * 0.18, 4, 4);
        ctx.fillRect(x + w * 0.55, y - h * 0.18, 4, 4);

        ctx.shadowBlur = 0;
      }
      
      // Draw Illusionist clone (positioned above player)
      if (illusionistClone && illusionistClone.hp > 0) {
        drawIllusionistClone();
      }
    }
    
    function drawThief(x, y, w, h) {
      ctx.save();
      
      // Stealth shimmer effect (subtle transparency pulse)
      const stealthPulse = Math.sin(Date.now() / 300) * 0.1 + 0.9;
      ctx.globalAlpha = stealthPulse;
      
      // Shadow trail effect (motion blur)
      for (let i = 3; i > 0; i--) {
        ctx.globalAlpha = 0.15 * (i / 3);
        const trailX = x - (i * 8);
        ctx.fillStyle = "#1a0033";
        ctx.fillRect(trailX, y, w, h);
      }
      ctx.globalAlpha = stealthPulse;
      
      // Main body - Dark ninja cloak
      ctx.shadowColor = "#8800ff";
      ctx.shadowBlur = 25;
      ctx.fillStyle = "#2a0050"; // Deep purple ninja suit
      ctx.fillRect(x, y, w, h);
      
      // Inner cloak accent
      ctx.shadowBlur = 15;
      ctx.fillStyle = "#4a0080";
      ctx.fillRect(x + 5, y + 5, w - 10, h - 10);
      
      // Belt with pouches (gold trim)
      ctx.fillStyle = "#ffd700";
      ctx.fillRect(x + 3, y + h * 0.5, w - 6, 4);
      
      // Pouch details
      for (let i = 0; i < 3; i++) {
        const pouchX = x + 8 + (i * 12);
        ctx.fillStyle = "#8b4513";
        ctx.fillRect(pouchX, y + h * 0.5 - 3, 8, 8);
      }
      
      // Hood/mask
      ctx.fillStyle = "#1a0033";
      ctx.beginPath();
      ctx.arc(x + w / 2, y + 8, 12, 0, Math.PI * 2);
      ctx.fill();
      
      // Ninja mask with glowing eyes
      ctx.shadowColor = "#ff00ff";
      ctx.shadowBlur = 10;
      ctx.fillStyle = "#ff00ff";
      ctx.fillRect(x + w * 0.3, y + 6, 4, 3); // Left eye
      ctx.fillRect(x + w * 0.6, y + 6, 4, 3); // Right eye
      
      // Eye glow streaks (intense stare)
      ctx.strokeStyle = "#ff00ff";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x + w * 0.3 - 3, y + 7);
      ctx.lineTo(x + w * 0.3 - 8, y + 7);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x + w * 0.6 + 7, y + 7);
      ctx.lineTo(x + w * 0.6 + 12, y + 7);
      ctx.stroke();
      
      // Dual daggers crossed on back
      ctx.shadowBlur = 8;
      ctx.strokeStyle = "#c0c0c0";
      ctx.lineWidth = 2.5;
      // Left dagger
      ctx.beginPath();
      ctx.moveTo(x + w * 0.3, y + h * 0.3);
      ctx.lineTo(x + w * 0.6, y + h * 0.7);
      ctx.stroke();
      // Right dagger
      ctx.beginPath();
      ctx.moveTo(x + w * 0.7, y + h * 0.3);
      ctx.lineTo(x + w * 0.4, y + h * 0.7);
      ctx.stroke();
      
      // Dagger hilts (gold)
      ctx.fillStyle = "#ffd700";
      ctx.fillRect(x + w * 0.3 - 2, y + h * 0.3 - 2, 4, 4);
      ctx.fillRect(x + w * 0.7 - 2, y + h * 0.3 - 2, 4, 4);
      
      // Coin sparkles around Thief (money aura)
      const time = Date.now() / 1000;
      for (let i = 0; i < 4; i++) {
        const angle = (time + i * Math.PI / 2) % (Math.PI * 2);
        const radius = 25;
        const sparkleX = x + w / 2 + Math.cos(angle) * radius;
        const sparkleY = y + h / 2 + Math.sin(angle) * radius;
        
        ctx.shadowColor = "#ffd700";
        ctx.shadowBlur = 15;
        ctx.fillStyle = "#ffd700";
        ctx.beginPath();
        ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Coin symbol
        ctx.shadowBlur = 5;
        ctx.font = "bold 10px Arial";
        ctx.fillStyle = "#ffff00";
        ctx.fillText("üí∞", sparkleX - 5, sparkleY + 3);
      }
      
      // Stealth smoke particles (randomly spawn)
      if (Math.random() < 0.15) {
        particles.push({
          x: x + Math.random() * w,
          y: y + h,
          vx: (Math.random() - 0.5) * 2,
          vy: -1 - Math.random() * 2,
          radius: 3 + Math.random() * 4,
          color: "#8800ff",
          life: 0.8,
          alpha: 0.6
        });
      }
      
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1.0;
      ctx.restore();
    }
    
    function drawEnhancedClass(x, y, w, h, className) {
      const time = Date.now() / 1000;
      
      switch(className) {
        case "Thief": return drawThief(x, y, w, h), true;
        case "DrSunshine": return drawDrSunshine(x, y, w, h), true;
        case "DrEclipse": return drawDrEclipse(x, y, w, h), true;
        case "Bomber": return drawBomber(x, y, w, h), true;
        case "Necromancer": return drawNecromancer(x, y, w, h), true;
        case "Pyromancer": return drawPyromancer(x, y, w, h), true;
        case "CryoSentinel": return drawCryoSentinel(x, y, w, h), true;
        case "LightningRanger": return drawLightningRanger(x, y, w, h), true;
        case "Hunter": return drawHunter(x, y, w, h, time), true;
        case "Knight": return drawKnight(x, y, w, h, time), true;
        case "Archer": return drawArcher(x, y, w, h, time), true;
        case "Assassin": return drawAssassin(x, y, w, h, time), true;
        case "Summoner": return drawSummoner(x, y, w, h, time), true;
        case "DarkMagician": return drawDarkMagician(x, y, w, h, time), true;
        case "Sniper": return drawSniper(x, y, w, h, time), true;
        case "Vecna": return drawVecna(x, y, w, h, time), true;
        case "PlagueDoctor": return drawPlagueDoctor(x, y, w, h, time), true;
        case "BloodReaver": return drawBloodReaver(x, y, w, h, time), true;
        case "CrystalGuardian": return drawCrystalGuardian(x, y, w, h, time), true;
        case "ShadowMonk": return drawShadowMonk(x, y, w, h, time), true;
        case "ArcWarden": return drawArcWarden(x, y, w, h, time), true;
        case "HolyCleric": return drawHolyCleric(x, y, w, h, time), true;
        case "TrickshotRogue": return drawTrickshotRogue(x, y, w, h, time), true;
        case "Starcaller": return drawStarcaller(x, y, w, h, time), true;
        case "VoidAssassin": return drawVoidAssassin(x, y, w, h, time), true;
        case "Shadowblade": return drawShadowblade(x, y, w, h, time), true;
        case "Illusionist": return drawIllusionistChar(x, y, w, h, time), true;
        default: return false;
      }
    }
    
    function drawHunter(x, y, w, h, time) {
      ctx.save();
      
      // Main body - forest green armor
      ctx.shadowColor = "#00ff88";
      ctx.shadowBlur = 18;
      ctx.fillStyle = "#00aa44";
      ctx.fillRect(x, y, w, h);
      
      // Inner tunic
      ctx.fillStyle = "#228b22";
      ctx.fillRect(x + 4, y + 4, w - 8, h - 8);
      
      // Leather belt
      ctx.fillStyle = "#8B4513";
      ctx.fillRect(x + 3, y + h * 0.5, w - 6, 4);
      
      // Quiver on back (3 arrows visible)
      for (let i = 0; i < 3; i++) {
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(x + w * 0.7 + i * 3, y + h * 0.2, 2, 12);
        ctx.fillStyle = "#FFD700";
        ctx.fillRect(x + w * 0.7 + i * 3, y + h * 0.2, 2, 3);
      }
      
      // Bow strapped on back
      ctx.strokeStyle = "#D2691E";
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.arc(x + w * 0.65, y + h * 0.5, 12, -Math.PI/4, Math.PI/4);
      ctx.stroke();
      
      // Bow string
      ctx.strokeStyle = "#FFFFFF";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x + w * 0.65 - 8, y + h * 0.5 - 8);
      ctx.lineTo(x + w * 0.65 - 8, y + h * 0.5 + 8);
      ctx.stroke();
      
      // Face/hood
      ctx.fillStyle = "#006633";
      ctx.beginPath();
      ctx.arc(x + w/2, y + h * 0.25, 10, 0, Math.PI * 2);
      ctx.fill();
      
      // Eyes
      ctx.fillStyle = "#00ff88";
      ctx.fillRect(x + w * 0.4, y + h * 0.22, 3, 2);
      ctx.fillRect(x + w * 0.55, y + h * 0.22, 3, 2);
      
      // Arrow emoji overlay
      ctx.shadowBlur = 10;
      ctx.font = "bold 20px Arial";
      ctx.textAlign = "center";
      ctx.fillStyle = "#00ff88";
      ctx.fillText("üèπ", x + w/2, y + h * 0.65);
      
      // Nature particles (leaves)
      if (Math.random() < 0.15) {
        particles.push({
          x: x + Math.random() * w,
          y: y + Math.random() * h,
          vx: (Math.random() - 0.5) * 1,
          vy: -0.5 - Math.random() * 1,
          radius: 2,
          color: "#00ff88",
          life: 0.8,
          alpha: 0.7
        });
      }
      
      ctx.shadowBlur = 0;
      ctx.restore();
      return true;
    }
    
    function drawKnight(x, y, w, h, time) {
      ctx.save();
      
      // Heavy armor glow
      const pulse = Math.sin(time * 2) * 0.15 + 1;
      ctx.shadowColor = "#4488ff";
      ctx.shadowBlur = 20 * pulse;
      
      // Main armor - blue steel
      ctx.fillStyle = "#3366cc";
      ctx.fillRect(x, y, w, h);
      
      // Plate armor segments
      ctx.fillStyle = "#5588ff";
      ctx.fillRect(x + 3, y + 3, w - 6, h * 0.4);
      ctx.fillRect(x + 3, y + h * 0.5, w - 6, h * 0.45);
      
      // Armor rivets
      ctx.fillStyle = "#C0C0C0";
      for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.arc(x + 8 + i * 10, y + 8, 2, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Large shield on body
      ctx.fillStyle = "#C0C0C0";
      ctx.beginPath();
      ctx.moveTo(x + w * 0.35, y + h * 0.3);
      ctx.lineTo(x + w * 0.25, y + h * 0.55);
      ctx.lineTo(x + w * 0.35, y + h * 0.75);
      ctx.lineTo(x + w * 0.45, y + h * 0.55);
      ctx.closePath();
      ctx.fill();
      
      // Shield emblem - cross
      ctx.strokeStyle = "#FFD700";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x + w * 0.35, y + h * 0.4);
      ctx.lineTo(x + w * 0.35, y + h * 0.65);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x + w * 0.3, y + h * 0.525);
      ctx.lineTo(x + w * 0.4, y + h * 0.525);
      ctx.stroke();
      
      // Sword on right side
      ctx.strokeStyle = "#C0C0C0";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(x + w * 0.7, y + h * 0.3);
      ctx.lineTo(x + w * 0.7, y + h * 0.75);
      ctx.stroke();
      
      // Sword hilt
      ctx.strokeStyle = "#8B4513";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(x + w * 0.65, y + h * 0.3);
      ctx.lineTo(x + w * 0.75, y + h * 0.3);
      ctx.stroke();
      
      // Helmet
      ctx.fillStyle = "#2244aa";
      ctx.beginPath();
      ctx.arc(x + w/2, y + h * 0.2, 12, 0, Math.PI * 2);
      ctx.fill();
      
      // Visor slit
      ctx.fillStyle = "#000";
      ctx.fillRect(x + w * 0.4, y + h * 0.18, w * 0.2, 3);
      
      // Sword emoji
      ctx.shadowBlur = 10;
      ctx.font = "bold 22px Arial";
      ctx.textAlign = "center";
      ctx.fillStyle = "#88aaff";
      ctx.fillText("‚öîÔ∏è", x + w * 0.6, y + h * 0.65);
      
      // Metal sparks
      if (Math.random() < 0.12) {
        particles.push({
          x: x + Math.random() * w,
          y: y + Math.random() * h,
          vx: (Math.random() - 0.5) * 2,
          vy: (Math.random() - 0.5) * 2,
          radius: 1.5,
          color: "#C0C0C0",
          life: 0.4,
          alpha: 1
        });
      }
      
      ctx.shadowBlur = 0;
      ctx.restore();
      return true;
    }
    
    function drawArcher(x, y, w, h, time) {
      ctx.save();
      
      // Rapid-fire archer glow
      ctx.shadowColor = "#32cd32";
      ctx.shadowBlur = 20;
      
      // Main body - forest ranger
      ctx.fillStyle = "#1a5a1a";
      ctx.fillRect(x, y, w, h);
      
      // Light green cloak
      ctx.fillStyle = "#228b22";
      ctx.fillRect(x + 3, y + 3, w - 6, h - 6);
      
      // Hood
      ctx.fillStyle = "#0f3a0f";
      ctx.beginPath();
      ctx.arc(x + w/2, y + h * 0.25, 11, 0, Math.PI * 2);
      ctx.fill();
      
      // Full quiver on back (5 arrows)
      ctx.fillStyle = "#654321";
      ctx.fillRect(x + w * 0.7, y + h * 0.25, 8, 18);
      
      for (let i = 0; i < 5; i++) {
        const arrowX = x + w * 0.68 + i * 2;
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(arrowX, y + h * 0.2, 1.5, 14);
        // Arrow tips
        ctx.fillStyle = "#C0C0C0";
        ctx.beginPath();
        ctx.moveTo(arrowX, y + h * 0.2);
        ctx.lineTo(arrowX + 1.5, y + h * 0.2 - 3);
        ctx.lineTo(arrowX + 3, y + h * 0.2);
        ctx.fill();
        // Fletching
        ctx.fillStyle = "#32cd32";
        ctx.fillRect(arrowX, y + h * 0.32, 1.5, 2);
      }
      
      // Bow held
      ctx.strokeStyle = "#8B4513";
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.arc(x + w * 0.25, y + h * 0.55, 14, -Math.PI/3, Math.PI/3);
      ctx.stroke();
      
      // Bow string (taut)
      ctx.strokeStyle = "#FFFFFF";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(x + w * 0.25 - 10, y + h * 0.55 - 12);
      ctx.lineTo(x + w * 0.25 - 10, y + h * 0.55 + 12);
      ctx.stroke();
      
      // Arrow nocked
      ctx.strokeStyle = "#8B4513";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x + w * 0.25 - 10, y + h * 0.55);
      ctx.lineTo(x + w * 0.15, y + h * 0.55);
      ctx.stroke();
      
      // Piercing eyes
      ctx.fillStyle = "#32cd32";
      ctx.shadowBlur = 12;
      ctx.fillRect(x + w * 0.43, y + h * 0.23, 3, 2);
      ctx.fillRect(x + w * 0.54, y + h * 0.23, 3, 2);
      
      // Focus lines (aiming)
      ctx.strokeStyle = "#32cd32";
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.5;
      for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.moveTo(x + w * 0.15 - 5 - i * 3, y + h * 0.55);
        ctx.lineTo(x + w * 0.15 - 8 - i * 3, y + h * 0.55);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      
      // Bow emoji
      ctx.shadowBlur = 8;
      ctx.font = "bold 18px Arial";
      ctx.textAlign = "center";
      ctx.fillStyle = "#32cd32";
      ctx.fillText("üèπ", x + w * 0.6, y + h * 0.7);
      
      // Wind arrows (rapid fire effect)
      if (Math.random() < 0.25) {
        particles.push({
          x: x - 5,
          y: y + h * 0.55 + (Math.random() - 0.5) * 10,
          vx: -3 - Math.random() * 2,
          vy: 0,
          radius: 2,
          color: "#32cd32",
          life: 0.5,
          alpha: 0.8
        });
      }
      
      ctx.shadowBlur = 0;
      ctx.restore();
      return true;
    }
    
    function drawAssassin(x, y, w, h, time) {
      ctx.save();
      
      // Ultra-fast shimmer effect
      const pulse = Math.sin(time * 6) * 0.3 + 0.7;
      ctx.globalAlpha = pulse;
      
      // Speed trail (afterimages)
      for (let i = 4; i > 0; i--) {
        ctx.globalAlpha = 0.1 * (i / 4);
        const trailX = x - (i * 6);
        ctx.fillStyle = "#8800ff";
        ctx.fillRect(trailX, y, w, h);
      }
      
      ctx.globalAlpha = pulse;
      
      // Main body - dark assassin garb
      ctx.shadowColor = "#ff00ff";
      ctx.shadowBlur = 25;
      ctx.fillStyle = "#aa00aa";
      ctx.fillRect(x, y, w, h);
      
      // Inner suit
      ctx.fillStyle = "#ff00ff";
      ctx.fillRect(x + 4, y + 4, w - 8, h - 8);
      
      // Assassin mask
      ctx.fillStyle = "#660066";
      ctx.beginPath();
      ctx.arc(x + w/2, y + h * 0.25, 11, 0, Math.PI * 2);
      ctx.fill();
      
      // Glowing eyes (intense)
      ctx.shadowBlur = 15;
      ctx.fillStyle = "#ff00ff";
      ctx.fillRect(x + w * 0.4, y + h * 0.22, 4, 3);
      ctx.fillRect(x + w * 0.56, y + h * 0.22, 4, 3);
      
      // Dual daggers crossed
      ctx.strokeStyle = "#C0C0C0";
      ctx.lineWidth = 2.5;
      ctx.shadowBlur = 10;
      // Left dagger
      ctx.beginPath();
      ctx.moveTo(x + w * 0.3, y + h * 0.35);
      ctx.lineTo(x + w * 0.55, y + h * 0.7);
      ctx.stroke();
      // Right dagger
      ctx.beginPath();
      ctx.moveTo(x + w * 0.7, y + h * 0.35);
      ctx.lineTo(x + w * 0.45, y + h * 0.7);
      ctx.stroke();
      
      // Dagger hilts
      ctx.fillStyle = "#FFD700";
      ctx.fillRect(x + w * 0.28, y + h * 0.33, 5, 5);
      ctx.fillRect(x + w * 0.68, y + h * 0.33, 5, 5);
      
      // Speed lines
      ctx.strokeStyle = "#ff00ff";
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.4;
      for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.moveTo(x + w + 5 + i * 5, y + h * 0.3 + i * 8);
        ctx.lineTo(x + w + 12 + i * 5, y + h * 0.3 + i * 8);
        ctx.stroke();
      }
      
      ctx.globalAlpha = 1;
      
      // Dagger emoji
      ctx.shadowBlur = 10;
      ctx.font = "bold 22px Arial";
      ctx.textAlign = "center";
      ctx.fillStyle = "#ff00ff";
      ctx.fillText("üó°Ô∏è", x + w/2, y + h * 0.65);
      
      // Speed particles
      if (Math.random() < 0.35) {
        particles.push({
          x: x + w + Math.random() * 10,
          y: y + Math.random() * h,
          vx: 4 + Math.random() * 3,
          vy: (Math.random() - 0.5) * 2,
          radius: 2,
          color: "#ff00ff",
          life: 0.4,
          alpha: 0.9
        });
      }
      
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      ctx.restore();
      return true;
    }
    
    function drawSummoner(x, y, w, h, time) {
      ctx.save();
      
      // Summoning aura
      ctx.shadowColor = "#88ff88";
      ctx.shadowBlur = 25;
      
      // Main robes - nature green
      ctx.fillStyle = "#449944";
      ctx.fillRect(x, y, w, h);
      
      // Lighter robe accent
      ctx.fillStyle = "#66bb66";
      ctx.fillRect(x + 4, y + 4, w - 8, h - 8);
      
      // Hood
      ctx.fillStyle = "#337733";
      ctx.beginPath();
      ctx.arc(x + w/2, y + h * 0.25, 12, 0, Math.PI * 2);
      ctx.fill();
      
      // Glowing eyes
      ctx.fillStyle = "#88ff88";
      ctx.shadowBlur = 15;
      ctx.fillRect(x + w * 0.42, y + h * 0.23, 3, 2);
      ctx.fillRect(x + w * 0.55, y + h * 0.23, 3, 2);
      
      // Staff with crystal
      ctx.strokeStyle = "#8B4513";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(x + w * 0.2, y + h * 0.35);
      ctx.lineTo(x + w * 0.2, y + h * 0.9);
      ctx.stroke();
      
      // Crystal on staff
      ctx.fillStyle = "#88ff88";
      ctx.shadowBlur = 20;
      ctx.beginPath();
      ctx.arc(x + w * 0.2, y + h * 0.32, 5, 0, Math.PI * 2);
      ctx.fill();
      
      // Summoning circle on ground
      ctx.strokeStyle = "#88ff88";
      ctx.lineWidth = 1.5;
      ctx.globalAlpha = 0.6;
      ctx.shadowBlur = 10;
      for (let i = 1; i <= 2; i++) {
        ctx.beginPath();
        ctx.arc(x + w/2, y + h + 5, 15 * i, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      
      // Spirit helpers orbiting (3 spirits)
      for (let i = 0; i < 3; i++) {
        const angle = time * 2 + i * (Math.PI * 2 / 3);
        const spiritX = x + w/2 + Math.cos(angle) * 22;
        const spiritY = y + h/2 + Math.sin(angle) * 22;
        
        ctx.shadowBlur = 15;
        ctx.globalAlpha = 0.8;
        ctx.fillStyle = "#88ff88";
        ctx.font = "14px Arial";
        ctx.fillText("‚ú®", spiritX - 7, spiritY + 5);
        
        // Spirit trail
        ctx.globalAlpha = 0.3;
        const trailX = x + w/2 + Math.cos(angle - 0.3) * 22;
        const trailY = y + h/2 + Math.sin(angle - 0.3) * 22;
        ctx.fillText("‚ú®", trailX - 7, trailY + 5);
      }
      
      ctx.globalAlpha = 1;
      
      // Main sparkle emoji
      ctx.shadowBlur = 12;
      ctx.font = "bold 24px Arial";
      ctx.textAlign = "center";
      ctx.fillStyle = "#88ff88";
      ctx.fillText("‚ú®", x + w/2, y + h * 0.65);
      
      // Magic particles
      if (Math.random() < 0.2) {
        particles.push({
          x: x + Math.random() * w,
          y: y + Math.random() * h,
          vx: (Math.random() - 0.5) * 2,
          vy: -1 - Math.random() * 2,
          radius: 2,
          color: "#88ff88",
          life: 0.9,
          alpha: 0.8
        });
      }
      
      ctx.shadowBlur = 0;
      ctx.restore();
      return true;
    }
    
    function drawDarkMagician(x, y, w, h, time) {
      ctx.save();
      
      // Powerful dark magic aura
      const pulse = Math.sin(time * 1.5) * 0.25 + 1;
      ctx.shadowColor = "#8800ff";
      ctx.shadowBlur = 30 * pulse;
      
      // Dark robes
      ctx.fillStyle = "#440088";
      ctx.fillRect(x, y, w, h);
      
      // Purple magical trim
      ctx.fillStyle = "#8800ff";
      ctx.fillRect(x + 4, y + 4, w - 8, h - 8);
      
      // Deep hood
      ctx.fillStyle = "#220044";
      ctx.beginPath();
      ctx.arc(x + w/2, y + h * 0.25, 13, 0, Math.PI * 2);
      ctx.fill();
      
      // Glowing purple eyes
      ctx.shadowBlur = 18;
      ctx.fillStyle = "#aa88ff";
      ctx.fillRect(x + w * 0.42, y + h * 0.22, 3, 3);
      ctx.fillRect(x + w * 0.55, y + h * 0.22, 3, 3);
      
      // Dark staff
      ctx.strokeStyle = "#2F0E4A";
      ctx.lineWidth = 3.5;
      ctx.beginPath();
      ctx.moveTo(x + w * 0.15, y + h * 0.3);
      ctx.lineTo(x + w * 0.15, y + h * 0.95);
      ctx.stroke();
      
      // Crystal ball on staff
      ctx.fillStyle = "#8800ff";
      ctx.shadowBlur = 25;
      ctx.beginPath();
      ctx.arc(x + w * 0.15, y + h * 0.27, 6, 0, Math.PI * 2);
      ctx.fill();
      
      // Dark spell runes floating
      ctx.globalAlpha = 0.6;
      const runeSymbols = ["‚óÜ", "‚òÖ", "‚ñ≤"];
      for (let i = 0; i < 3; i++) {
        const angle = time + i * Math.PI * 2 / 3;
        const runeX = x + w/2 + Math.cos(angle) * 20;
        const runeY = y + h * 0.6 + Math.sin(angle) * 15;
        ctx.font = "12px Arial";
        ctx.fillText(runeSymbols[i], runeX - 6, runeY);
      }
      ctx.globalAlpha = 1;
      
      // Crystal ball emoji
      ctx.shadowBlur = 15;
      ctx.font = "bold 26px Arial";
      ctx.textAlign = "center";
      ctx.fillStyle = "#8800ff";
      ctx.fillText("üîÆ", x + w * 0.6, y + h * 0.7);
      
      // Dark magic particles
      if (Math.random() < 0.18) {
        particles.push({
          x: x + Math.random() * w,
          y: y + Math.random() * h,
          vx: (Math.random() - 0.5) * 1.5,
          vy: -1 - Math.random() * 1.5,
          radius: 2.5,
          color: "#8800ff",
          life: 0.9,
          alpha: 0.8
        });
      }
      
      ctx.shadowBlur = 0;
      ctx.restore();
      return true;
    }
    
    function drawSniper(x, y, w, h, time) {
      ctx.save();
      
      // Precision aura
      ctx.shadowColor = "#00ffff";
      ctx.shadowBlur = 22;
      
      // Ghillie suit/camo
      ctx.fillStyle = "#006666";
      ctx.fillRect(x, y, w, h);
      
      // Tactical vest
      ctx.fillStyle = "#008888";
      ctx.fillRect(x + 4, y + h * 0.35, w - 8, h * 0.5);
      
      // Vest pockets
      ctx.fillStyle = "#004444";
      ctx.fillRect(x + 6, y + h * 0.4, 8, 8);
      ctx.fillRect(x + w - 14, y + h * 0.4, 8, 8);
      
      // Long rifle
      ctx.strokeStyle = "#333";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(x - 15, y + h * 0.55);
      ctx.lineTo(x + w * 0.4, y + h * 0.55);
      ctx.stroke();
      
      // Rifle scope
      ctx.fillStyle = "#000";
      ctx.fillRect(x - 10, y + h * 0.52, 8, 6);
      ctx.strokeStyle = "#00ffff";
      ctx.lineWidth = 1.5;
      ctx.strokeRect(x - 10, y + h * 0.52, 8, 6);
      
      // Scope lens glint
      ctx.fillStyle = "#00ffff";
      ctx.shadowBlur = 20;
      ctx.beginPath();
      ctx.arc(x - 6, y + h * 0.55, 2, 0, Math.PI * 2);
      ctx.fill();
      
      // Face/mask
      ctx.fillStyle = "#003333";
      ctx.beginPath();
      ctx.arc(x + w/2, y + h * 0.25, 10, 0, Math.PI * 2);
      ctx.fill();
      
      // Focused eye
      ctx.fillStyle = "#00ffff";
      ctx.shadowBlur = 15;
      ctx.fillRect(x + w * 0.52, y + h * 0.23, 4, 2);
      
      // Laser sight line
      ctx.strokeStyle = "#ff0000";
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.6;
      ctx.setLineDash([3, 3]);
      ctx.beginPath();
      ctx.moveTo(x - 15, y + h * 0.55);
      ctx.lineTo(x - 40, y + h * 0.55);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.globalAlpha = 1;
      
      // Crosshairs overlay
      ctx.strokeStyle = "#00ffff";
      ctx.lineWidth = 1.5;
      ctx.globalAlpha = 0.4;
      ctx.beginPath();
      ctx.moveTo(x + w/2, y + h * 0.5 - 15);
      ctx.lineTo(x + w/2, y + h * 0.5 + 15);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x + w/2 - 15, y + h * 0.5);
      ctx.lineTo(x + w/2 + 15, y + h * 0.5);
      ctx.stroke();
      ctx.globalAlpha = 1;
      
      // Target emoji
      ctx.shadowBlur = 12;
      ctx.font = "bold 26px Arial";
      ctx.textAlign = "center";
      ctx.fillStyle = "#00ffff";
      ctx.fillText("üéØ", x + w * 0.65, y + h * 0.7);
      
      ctx.shadowBlur = 0;
      ctx.restore();
      return true;
    }
    
    function drawVecna(x, y, w, h, time) {
      ctx.save();
      const pulse = Math.sin(time * 2) * 0.3 + 1;
      ctx.shadowColor = "#FF0000";
      ctx.shadowBlur = 30 * pulse;
      ctx.fillStyle = "#8B0000";
      ctx.fillRect(x, y, w, h);
      ctx.fillStyle = "#FF0000";
      ctx.fillRect(x + 5, y + 5, w - 10, h - 10);
      // Dark energy
      ctx.fillStyle = "#000";
      ctx.fillRect(x + w * 0.4, y + h * 0.25, 4, 4);
      ctx.font = "28px Arial";
      ctx.textAlign = "center";
      ctx.fillText("üëÅÔ∏è", x + w/2, y + h/2 + 10);
      ctx.shadowBlur = 0;
      ctx.restore();
      return true;
    }
    
    function drawPlagueDoctor(x, y, w, h, time) {
      ctx.save();
      ctx.shadowColor = "#32cd32";
      ctx.shadowBlur = 20;
      ctx.fillStyle = "#32cd32";
      ctx.fillRect(x, y, w, h);
      ctx.fillStyle = "#90ee90";
      ctx.fillRect(x + 5, y + 5, w - 10, h - 10);
      // Plague mask
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.moveTo(x + w/2, y + h * 0.3);
      ctx.lineTo(x + w * 0.6, y + h * 0.4);
      ctx.stroke();
      ctx.font = "24px Arial";
      ctx.textAlign = "center";
      ctx.fillText("ü¶†", x + w/2, y + h/2 + 8);
      // Poison drops
      if (Math.random() < 0.2) {
        particles.push({
          x: x + Math.random() * w,
          y: y + h,
          vx: 0,
          vy: 1,
          radius: 2,
          color: "#32cd32",
          life: 0.5,
          alpha: 0.8
        });
      }
      ctx.shadowBlur = 0;
      ctx.restore();
      return true;
    }
    
    function drawBloodReaver(x, y, w, h, time) {
      ctx.save();
      ctx.shadowColor = "#dc143c";
      ctx.shadowBlur = 22;
      ctx.fillStyle = "#8b0000";
      ctx.fillRect(x, y, w, h);
      ctx.fillStyle = "#dc143c";
      ctx.fillRect(x + 5, y + 5, w - 10, h - 10);
      // Blood drops
      for (let i = 0; i < 2; i++) {
        ctx.fillStyle = "#8b0000";
        ctx.beginPath();
        ctx.arc(x + w * (0.3 + i * 0.4), y + h * 0.7, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.font = "24px Arial";
      ctx.textAlign = "center";
      ctx.fillText("ü©∏", x + w/2, y + h/2 + 8);
      ctx.shadowBlur = 0;
      ctx.restore();
      return true;
    }
    
    function drawCrystalGuardian(x, y, w, h, time) {
      ctx.save();
      const pulse = Math.sin(time * 2) * 0.2 + 1;
      ctx.shadowColor = "#ba55d3";
      ctx.shadowBlur = 20 * pulse;
      ctx.fillStyle = "#9370db";
      ctx.fillRect(x, y, w, h);
      ctx.fillStyle = "#ba55d3";
      ctx.fillRect(x + 5, y + 5, w - 10, h - 10);
      // Crystal shards
      ctx.strokeStyle = "#ba55d3";
      ctx.lineWidth = 2;
      for (let i = 0; i < 3; i++) {
        const shardX = x + 8 + i * 10;
        ctx.beginPath();
        ctx.moveTo(shardX, y + h * 0.5);
        ctx.lineTo(shardX + 3, y + h * 0.4);
        ctx.lineTo(shardX + 6, y + h * 0.5);
        ctx.stroke();
      }
      ctx.font = "26px Arial";
      ctx.textAlign = "center";
      ctx.fillText("üíé", x + w/2, y + h/2 + 10);
      ctx.shadowBlur = 0;
      ctx.restore();
      return true;
    }
    
    function drawShadowMonk(x, y, w, h, time) {
      ctx.save();
      ctx.shadowColor = "#696969";
      ctx.shadowBlur = 15;
      ctx.fillStyle = "#2f4f4f";
      ctx.fillRect(x, y, w, h);
      ctx.fillStyle = "#696969";
      ctx.fillRect(x + 5, y + 5, w - 10, h - 10);
      // Martial arts stance lines
      ctx.strokeStyle = "#696969";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x + w * 0.3, y + h * 0.6);
      ctx.lineTo(x + w * 0.4, y + h * 0.4);
      ctx.stroke();
      ctx.font = "24px Arial";
      ctx.textAlign = "center";
      ctx.fillText("ü•ã", x + w/2, y + h/2 + 8);
      ctx.shadowBlur = 0;
      ctx.restore();
      return true;
    }
    
    function drawArcWarden(x, y, w, h, time) {
      ctx.save();
      const pulse = Math.sin(time * 5) * 0.3 + 1;
      ctx.shadowColor = "#6495ed";
      ctx.shadowBlur = 25 * pulse;
      ctx.fillStyle = "#4169e1";
      ctx.fillRect(x, y, w, h);
      ctx.fillStyle = "#6495ed";
      ctx.fillRect(x + 5, y + 5, w - 10, h - 10);
      // Electric arc
      ctx.strokeStyle = "#FFD700";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x + w * 0.3, y + h * 0.3);
      ctx.quadraticCurveTo(x + w/2, y + h * 0.5, x + w * 0.7, y + h * 0.3);
      ctx.stroke();
      ctx.font = "24px Arial";
      ctx.textAlign = "center";
      ctx.fillText("‚ö°", x + w/2, y + h/2 + 8);
      ctx.shadowBlur = 0;
      ctx.restore();
      return true;
    }
    
    function drawHolyCleric(x, y, w, h, time) {
      ctx.save();
      const pulse = Math.sin(time * 2) * 0.2 + 1;
      ctx.shadowColor = "#ffffe0";
      ctx.shadowBlur = 25 * pulse;
      ctx.fillStyle = "#ffd700";
      ctx.fillRect(x, y, w, h);
      ctx.fillStyle = "#ffffe0";
      ctx.fillRect(x + 5, y + 5, w - 10, h - 10);
      // Healing aura rings
      ctx.strokeStyle = "#FFD700";
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.5;
      for (let i = 1; i <= 2; i++) {
        ctx.beginPath();
        ctx.arc(x + w/2, y + h/2, 15 * i, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      ctx.font = "24px Arial";
      ctx.textAlign = "center";
      ctx.fillText("‚úùÔ∏è", x + w/2, y + h/2 + 8);
      ctx.shadowBlur = 0;
      ctx.restore();
      return true;
    }
    
    function drawTrickshotRogue(x, y, w, h, time) {
      ctx.save();
      ctx.shadowColor = "#ff69b4";
      ctx.shadowBlur = 18;
      ctx.fillStyle = "#ff1493";
      ctx.fillRect(x, y, w, h);
      ctx.fillStyle = "#ff69b4";
      ctx.fillRect(x + 5, y + 5, w - 10, h - 10);
      // Ricochet lines
      ctx.strokeStyle = "#FFD700";
      ctx.lineWidth = 1;
      ctx.setLineDash([2, 2]);
      ctx.beginPath();
      ctx.moveTo(x + w * 0.3, y + h * 0.3);
      ctx.lineTo(x + w * 0.7, y + h * 0.5);
      ctx.lineTo(x + w * 0.4, y + h * 0.7);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.font = "24px Arial";
      ctx.textAlign = "center";
      ctx.fillText("üé≤", x + w/2, y + h/2 + 8);
      ctx.shadowBlur = 0;
      ctx.restore();
      return true;
    }
    
    function drawStarcaller(x, y, w, h, time) {
      ctx.save();
      ctx.shadowColor = "#ba55d3";
      ctx.shadowBlur = 25;
      ctx.fillStyle = "#9400d3";
      ctx.fillRect(x, y, w, h);
      ctx.fillStyle = "#ba55d3";
      ctx.fillRect(x + 5, y + 5, w - 10, h - 10);
      // Orbiting stars
      for (let i = 0; i < 3; i++) {
        const angle = time * 1.5 + i * Math.PI * 2 / 3;
        const starX = x + w/2 + Math.cos(angle) * 18;
        const starY = y + h/2 + Math.sin(angle) * 18;
        ctx.font = "10px Arial";
        ctx.fillText("‚≠ê", starX - 5, starY + 3);
      }
      ctx.font = "26px Arial";
      ctx.textAlign = "center";
      ctx.fillText("üåü", x + w/2, y + h/2 + 10);
      ctx.shadowBlur = 0;
      ctx.restore();
      return true;
    }
    
    function drawVoidAssassin(x, y, w, h, time) {
      ctx.save();
      const pulse = Math.sin(time * 3) * 0.2 + 0.8;
      ctx.globalAlpha = pulse;
      ctx.shadowColor = "#483d8b";
      ctx.shadowBlur = 25;
      ctx.fillStyle = "#191970";
      ctx.fillRect(x, y, w, h);
      ctx.fillStyle = "#483d8b";
      ctx.fillRect(x + 5, y + 5, w - 10, h - 10);
      // Void tendrils
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      for (let i = 0; i < 2; i++) {
        ctx.beginPath();
        ctx.moveTo(x + w * (0.3 + i * 0.4), y + h * 0.7);
        ctx.lineTo(x + w * (0.2 + i * 0.5), y + h);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      ctx.font = "24px Arial";
      ctx.textAlign = "center";
      ctx.fillText("üåë", x + w/2, y + h/2 + 8);
      ctx.shadowBlur = 0;
      ctx.restore();
      return true;
    }
    
    function drawShadowblade(x, y, w, h, time) {
      ctx.save();
      ctx.shadowColor = "#696969";
      ctx.shadowBlur = 20;
      ctx.fillStyle = "#000000";
      ctx.fillRect(x, y, w, h);
      ctx.fillStyle = "#696969";
      ctx.fillRect(x + 5, y + 5, w - 10, h - 10);
      // Dark blade
      ctx.strokeStyle = "#C0C0C0";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x + w * 0.6, y + h * 0.3);
      ctx.lineTo(x + w * 0.4, y + h * 0.7);
      ctx.stroke();
      ctx.font = "24px Arial";
      ctx.textAlign = "center";
      ctx.fillText("‚öîÔ∏è", x + w/2, y + h/2 + 8);
      // Curse particles
      if (Math.random() < 0.15) {
        particles.push({
          x: x + Math.random() * w,
          y: y + h,
          vx: (Math.random() - 0.5) * 2,
          vy: -1 - Math.random() * 2,
          radius: 2,
          color: "#696969",
          life: 0.6,
          alpha: 0.7
        });
      }
      ctx.shadowBlur = 0;
      ctx.restore();
      return true;
    }
    
    function drawIllusionistChar(x, y, w, h, time) {
      ctx.save();
      const pulse = Math.sin(time * 3) * 0.15 + 0.85;
      ctx.globalAlpha = pulse;
      ctx.shadowColor = "#BA55D3";
      ctx.shadowBlur = 22;
      ctx.fillStyle = "#9370DB";
      ctx.fillRect(x, y, w, h);
      ctx.fillStyle = "#BA55D3";
      ctx.fillRect(x + 5, y + 5, w - 10, h - 10);
      // Mirror effect
      ctx.strokeStyle = "#FFFFFF";
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.3;
      ctx.strokeRect(x + 8, y + 8, w - 16, h - 16);
      ctx.globalAlpha = 1;
      ctx.font = "24px Arial";
      ctx.textAlign = "center";
      ctx.fillText("üé≠", x + w/2, y + h/2 + 8);
      ctx.shadowBlur = 0;
      ctx.restore();
      return true;
    }
    
    function drawDrSunshine(x, y, w, h) {
      ctx.save();
      
      // Radiant sun aura
      const time = Date.now() / 1000;
      const pulse = Math.sin(time * 3) * 0.2 + 1;
      
      // Outer sun glow
      ctx.shadowColor = "#FFD700";
      ctx.shadowBlur = 30 * pulse;
      ctx.fillStyle = "#FFA500";
      ctx.beginPath();
      ctx.arc(x + w/2, y + h/2, w * 0.6, 0, Math.PI * 2);
      ctx.fill();
      
      // Main body - bright yellow
      ctx.shadowBlur = 20;
      ctx.fillStyle = "#FFD700";
      ctx.fillRect(x, y, w, h);
      
      // Inner glow
      ctx.fillStyle = "#FFFF00";
      ctx.fillRect(x + 5, y + 5, w - 10, h - 10);
      
      // Sun rays (rotating)
      ctx.strokeStyle = "#FF8C00";
      ctx.lineWidth = 3;
      for (let i = 0; i < 8; i++) {
        const angle = (time + i * Math.PI / 4) % (Math.PI * 2);
        const rayLength = 20 + Math.sin(time * 2 + i) * 5;
        const startX = x + w/2 + Math.cos(angle) * (w * 0.5);
        const startY = y + h/2 + Math.sin(angle) * (h * 0.5);
        const endX = x + w/2 + Math.cos(angle) * (w * 0.5 + rayLength);
        const endY = y + h/2 + Math.sin(angle) * (h * 0.5 + rayLength);
        
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
      }
      
      // Sun emoji overlay
      ctx.shadowBlur = 10;
      ctx.font = "bold 24px Arial";
      ctx.fillStyle = "#FFFF00";
      ctx.textAlign = "center";
      ctx.fillText("‚òÄÔ∏è", x + w/2, y + h/2 + 8);
      
      // Heat wave particles
      if (Math.random() < 0.2) {
        particles.push({
          x: x + Math.random() * w,
          y: y + h,
          vx: (Math.random() - 0.5) * 1,
          vy: -2 - Math.random() * 2,
          radius: 2 + Math.random() * 3,
          color: "#FF8C00",
          life: 0.6,
          alpha: 0.8
        });
      }
      
      ctx.shadowBlur = 0;
      ctx.restore();
    }
    
    function drawDrEclipse(x, y, w, h) {
      ctx.save();
      
      // Dark eclipse aura
      const time = Date.now() / 1000;
      const pulse = Math.sin(time * 2) * 0.15 + 0.85;
      
      // Outer dark aura
      ctx.shadowColor = "#9D8BC9";
      ctx.shadowBlur = 25;
      ctx.fillStyle = "#2C1E4A";
      ctx.beginPath();
      ctx.arc(x + w/2, y + h/2, w * 0.6, 0, Math.PI * 2);
      ctx.fill();
      
      // Main body - deep purple
      ctx.shadowBlur = 15;
      ctx.fillStyle = "#4A2C6A";
      ctx.fillRect(x, y, w, h);
      
      // Inner mysterious glow
      ctx.fillStyle = "#6A4C8A";
      ctx.fillRect(x + 5, y + 5, w - 10, h - 10);
      
      // Crescent moon patterns
      ctx.fillStyle = "#9D8BC9";
      ctx.beginPath();
      ctx.arc(x + w * 0.3, y + h * 0.3, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + w * 0.7, y + h * 0.3, 6, 0, Math.PI * 2);
      ctx.fill();
      
      // Eclipse effect - partially covered circle
      ctx.fillStyle = "#2C1E4A";
      ctx.beginPath();
      ctx.arc(x + w * 0.35, y + h * 0.3, 7, 0, Math.PI * 2);
      ctx.fill();
      
      // Moon emoji overlay
      ctx.shadowBlur = 10;
      ctx.font = "bold 24px Arial";
      ctx.fillStyle = "#9D8BC9";
      ctx.textAlign = "center";
      ctx.fillText("üåô", x + w/2, y + h/2 + 8);
      
      // Stars orbiting
      for (let i = 0; i < 3; i++) {
        const angle = (time * 1.5 + i * Math.PI * 2 / 3) % (Math.PI * 2);
        const radius = 20;
        const starX = x + w/2 + Math.cos(angle) * radius;
        const starY = y + h/2 + Math.sin(angle) * radius;
        
        ctx.shadowColor = "#9D8BC9";
        ctx.shadowBlur = 10;
        ctx.fillStyle = "#FFFFFF";
        ctx.font = "12px Arial";
        ctx.fillText("‚≠ê", starX - 6, starY + 4);
      }
      
      // Gravity wave particles
      if (Math.random() < 0.15) {
        particles.push({
          x: x + w/2,
          y: y + h/2,
          vx: (Math.random() - 0.5) * 3,
          vy: (Math.random() - 0.5) * 3,
          radius: 2 + Math.random() * 2,
          color: "#9D8BC9",
          life: 0.7,
          alpha: 0.7
        });
      }
      
      ctx.shadowBlur = 0;
      ctx.restore();
    }
    
    function drawBomber(x, y, w, h) {
      ctx.save();
      
      // Explosive aura
      const time = Date.now() / 1000;
      const pulse = Math.sin(time * 4) * 0.3 + 1;
      
      // Main body - orange/red
      ctx.shadowColor = "#ff8800";
      ctx.shadowBlur = 20 * pulse;
      ctx.fillStyle = "#ff8800";
      ctx.fillRect(x, y, w, h);
      
      // Accent
      ctx.fillStyle = "#ffaa44";
      ctx.fillRect(x + 4, y + 4, w - 8, h - 8);
      
      // Dynamite sticks on back
      for (let i = 0; i < 3; i++) {
        const stickX = x + 8 + i * 10;
        ctx.fillStyle = "#8B0000";
        ctx.fillRect(stickX, y + h * 0.3, 6, h * 0.5);
        
        // Fuse
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(stickX + 3, y + h * 0.3);
        ctx.lineTo(stickX + 3, y + h * 0.2);
        ctx.stroke();
        
        // Spark
        ctx.fillStyle = "#FFD700";
        ctx.fillRect(stickX + 2, y + h * 0.2 - 2, 2, 2);
      }
      
      // Bomb emoji
      ctx.shadowBlur = 5;
      ctx.font = "bold 26px Arial";
      ctx.textAlign = "center";
      ctx.fillText("üí£", x + w/2, y + h/2 + 10);
      
      // Explosion sparks
      if (Math.random() < 0.25) {
        particles.push({
          x: x + Math.random() * w,
          y: y + Math.random() * h,
          vx: (Math.random() - 0.5) * 4,
          vy: (Math.random() - 0.5) * 4,
          radius: 2 + Math.random() * 2,
          color: "#ff8800",
          life: 0.5,
          alpha: 1
        });
      }
      
      ctx.shadowBlur = 0;
      ctx.restore();
    }
    
    function drawNecromancer(x, y, w, h) {
      ctx.save();
      
      // Dark necromantic aura
      const time = Date.now() / 1000;
      
      // Shadow cloak
      ctx.shadowColor = "#9933ff";
      ctx.shadowBlur = 20;
      ctx.fillStyle = "#4B0082";
      ctx.fillRect(x, y, w, h);
      
      // Purple robe trim
      ctx.fillStyle = "#9933ff";
      ctx.fillRect(x + 3, y + 3, w - 6, h - 6);
      
      // Hood
      ctx.fillStyle = "#2F0E4A";
      ctx.beginPath();
      ctx.arc(x + w/2, y + h * 0.25, 12, 0, Math.PI * 2);
      ctx.fill();
      
      // Glowing purple eyes
      ctx.shadowBlur = 15;
      ctx.fillStyle = "#9933ff";
      ctx.fillRect(x + w * 0.35, y + h * 0.2, 3, 3);
      ctx.fillRect(x + w * 0.6, y + h * 0.2, 3, 3);
      
      // Skull staff
      ctx.strokeStyle = "#8B4513";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(x + w * 0.2, y + h * 0.4);
      ctx.lineTo(x + w * 0.2, y + h);
      ctx.stroke();
      
      // Skull on staff
      ctx.font = "16px Arial";
      ctx.fillStyle = "#FFFFFF";
      ctx.fillText("üíÄ", x + w * 0.15, y + h * 0.4);
      
      // Floating souls
      for (let i = 0; i < 2; i++) {
        const angle = time + i * Math.PI;
        const soulX = x + w/2 + Math.cos(angle) * 20;
        const soulY = y + h * 0.6 + Math.sin(angle * 2) * 10;
        
        ctx.globalAlpha = 0.6;
        ctx.fillStyle = "#00FF00";
        ctx.font = "12px Arial";
        ctx.fillText("üëª", soulX - 6, soulY);
      }
      
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
      ctx.restore();
    }
    
    function drawPyromancer(x, y, w, h) {
      ctx.save();
      
      // Fire aura
      const time = Date.now() / 1000;
      const pulse = Math.sin(time * 5) * 0.3 + 1;
      
      // Main body - red/orange
      ctx.shadowColor = "#ff4500";
      ctx.shadowBlur = 25 * pulse;
      ctx.fillStyle = "#ff4500";
      ctx.fillRect(x, y, w, h);
      
      // Inner flame
      ctx.fillStyle = "#ff6347";
      ctx.fillRect(x + 5, y + 5, w - 10, h - 10);
      
      // Flame patterns
      ctx.fillStyle = "#FFD700";
      for (let i = 0; i < 3; i++) {
        const flameY = y + h * 0.3 + i * 10;
        ctx.beginPath();
        ctx.moveTo(x + w * 0.3, flameY);
        ctx.lineTo(x + w * 0.5, flameY - 8);
        ctx.lineTo(x + w * 0.7, flameY);
        ctx.fill();
      }
      
      // Fire emoji
      ctx.shadowBlur = 15;
      ctx.font = "bold 28px Arial";
      ctx.textAlign = "center";
      ctx.fillStyle = "#FF4500";
      ctx.fillText("üî•", x + w/2, y + h/2 + 10);
      
      // Fire particles
      if (Math.random() < 0.3) {
        particles.push({
          x: x + Math.random() * w,
          y: y + h,
          vx: (Math.random() - 0.5) * 2,
          vy: -3 - Math.random() * 2,
          radius: 3 + Math.random() * 3,
          color: Math.random() > 0.5 ? "#ff4500" : "#FFD700",
          life: 0.6,
          alpha: 1
        });
      }
      
      ctx.shadowBlur = 0;
      ctx.restore();
    }
    
    function drawCryoSentinel(x, y, w, h) {
      ctx.save();
      
      // Ice aura
      const time = Date.now() / 1000;
      
      // Frost shell
      ctx.shadowColor = "#00bfff";
      ctx.shadowBlur = 20;
      ctx.fillStyle = "#4682B4";
      ctx.fillRect(x, y, w, h);
      
      // Ice crystals
      ctx.fillStyle = "#87ceeb";
      ctx.fillRect(x + 4, y + 4, w - 8, h - 8);
      
      // Ice shard patterns
      ctx.strokeStyle = "#00bfff";
      ctx.lineWidth = 2;
      for (let i = 0; i < 4; i++) {
        const shardX = x + 10 + i * 8;
        ctx.beginPath();
        ctx.moveTo(shardX, y + h * 0.4);
        ctx.lineTo(shardX + 4, y + h * 0.3);
        ctx.lineTo(shardX + 8, y + h * 0.4);
        ctx.stroke();
      }
      
      // Snowflake emoji
      ctx.shadowBlur = 10;
      ctx.font = "bold 24px Arial";
      ctx.textAlign = "center";
      ctx.fillStyle = "#FFFFFF";
      ctx.fillText("‚ùÑÔ∏è", x + w/2, y + h/2 + 8);
      
      // Frost particles
      if (Math.random() < 0.2) {
        particles.push({
          x: x + Math.random() * w,
          y: y + Math.random() * h,
          vx: (Math.random() - 0.5) * 1,
          vy: -1 - Math.random() * 1,
          radius: 2 + Math.random() * 2,
          color: "#87ceeb",
          life: 0.8,
          alpha: 0.7
        });
      }
      
      ctx.shadowBlur = 0;
      ctx.restore();
    }
    
    function drawLightningRanger(x, y, w, h) {
      ctx.save();
      
      // Electric aura
      const time = Date.now() / 1000;
      const pulse = Math.sin(time * 6) * 0.4 + 1;
      
      // Main body - yellow/gold
      ctx.shadowColor = "#ffd700";
      ctx.shadowBlur = 25 * pulse;
      ctx.fillStyle = "#DAA520";
      ctx.fillRect(x, y, w, h);
      
      // Electric core
      ctx.fillStyle = "#ffff00";
      ctx.fillRect(x + 5, y + 5, w - 10, h - 10);
      
      // Lightning bolts on body
      ctx.strokeStyle = "#FFFFFF";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x + w * 0.3, y + h * 0.2);
      ctx.lineTo(x + w * 0.4, y + h * 0.5);
      ctx.lineTo(x + w * 0.35, y + h * 0.5);
      ctx.lineTo(x + w * 0.45, y + h * 0.8);
      ctx.stroke();
      
      // Lightning emoji
      ctx.shadowBlur = 15;
      ctx.font = "bold 26px Arial";
      ctx.textAlign = "center";
      ctx.fillStyle = "#FFD700";
      ctx.fillText("‚ö°", x + w/2, y + h/2 + 10);
      
      // Electric sparks
      if (Math.random() < 0.35) {
        particles.push({
          x: x + Math.random() * w,
          y: y + Math.random() * h,
          vx: (Math.random() - 0.5) * 5,
          vy: (Math.random() - 0.5) * 5,
          radius: 1 + Math.random() * 2,
          color: "#ffff00",
          life: 0.3,
          alpha: 1
        });
      }
      
      ctx.shadowBlur = 0;
      ctx.restore();
    }
    
    function drawIllusionistClone() {
      if (!illusionistClone) return;
      
      const x = illusionistClone.x;
      const y = illusionistClone.y;
      const w = illusionistClone.w;
      const h = illusionistClone.h;
      
      // Semi-transparent to show it's a clone
      ctx.globalAlpha = 0.85;
      
      // Try sprite first
      const sprite = characterSprites[illusionistClone.className];
      
      if (sprite && spritesLoaded) {
        const frame = getSpriteFrame(illusionistClone.animFrame || 0);
        const spriteWidth = sprite.width;
        const spriteHeight = sprite.height;
        const frameWidth = spriteWidth / 4;
        
        ctx.save();
        
        if (illusionistClone.facingLeft) {
          ctx.scale(-1, 1);
          ctx.drawImage(sprite, frame * frameWidth, 0, frameWidth, spriteHeight, -(x + w), y, w, h);
        } else {
          ctx.drawImage(sprite, frame * frameWidth, 0, frameWidth, spriteHeight, x, y, w, h);
        }
        
        ctx.restore();
      } else {
        // Fallback colored square
        ctx.shadowColor = illusionistClone.glowColor;
        ctx.shadowBlur = 12;
        ctx.fillStyle = illusionistClone.color;
        ctx.fillRect(x, y, w, h);
        ctx.shadowBlur = 0;
        
        ctx.fillStyle = illusionistClone.accent;
        ctx.fillRect(x + 4, y + 4, w - 8, h - 8);
      }
      
      ctx.globalAlpha = 1.0;
      
      // HP bar above clone
      const barWidth = w;
      const barHeight = 4;
      const barX = x;
      const barY = y - 10;
      
      ctx.fillStyle = "#000000";
      ctx.fillRect(barX, barY, barWidth, barHeight);
      
      const hpPercent = illusionistClone.hp / illusionistClone.maxHP;
      ctx.fillStyle = hpPercent > 0.5 ? "#00ff00" : hpPercent > 0.25 ? "#ffff00" : "#ff0000";
      ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);
      
      // XP bar above HP bar
      const xpBarY = y - 16;
      const xpNeeded = xpForLevel(illusionistClone.level);
      const xpPercent = illusionistClone.xp / xpNeeded;
      
      ctx.fillStyle = "#222222";
      ctx.fillRect(barX, xpBarY, barWidth, 3);
      
      ctx.fillStyle = "#BA55D3";
      ctx.fillRect(barX, xpBarY, barWidth * xpPercent, 3);
      
      // Level indicator
      ctx.fillStyle = "#ffffff";
      ctx.font = "12px Arial";
      ctx.textAlign = "center";
      ctx.fillText(`Lv${illusionistClone.level}`, x + w/2, y - 21);
    }

    function drawEnemies() {
      for (const e of enemies) {
        ctx.shadowColor = e.glowColor;
        ctx.shadowBlur = e.isBoss ? 25 : e.isMiniBoss ? 18 : 12;

        const wobble = Math.sin(e.animFrame * Math.PI * 2) * 2;
        ctx.fillStyle = e.color;
        
        // Draw different shapes based on enemy type
        if (e.shape === "triangle") {
          // Triangle shape
          ctx.beginPath();
          ctx.moveTo(e.x + e.w / 2, e.y + wobble); // Top point
          ctx.lineTo(e.x + e.w, e.y + e.h + wobble); // Bottom right
          ctx.lineTo(e.x, e.y + e.h + wobble); // Bottom left
          ctx.closePath();
          ctx.fill();
        } else if (e.shape === "circle") {
          // Circle shape
          ctx.beginPath();
          ctx.arc(e.x + e.w / 2, e.y + e.h / 2 + wobble, e.w / 2, 0, Math.PI * 2);
          ctx.fill();
        } else {
          // Square shape (default)
          ctx.fillRect(e.x + 2, e.y + wobble, e.w - 4, e.h - 4);
        }

        ctx.shadowBlur = 0;
        
        // Labels
        if (e.pattern) {
          ctx.fillStyle = "#ffffff";
          ctx.font = "bold 12px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText(e.pattern.name.toUpperCase(), e.x + e.w / 2, e.y - 22);
        } else if (e.isBoss) {
          ctx.fillStyle = "#ffffff";
          ctx.font = "bold 12px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText("BOSS", e.x + e.w / 2, e.y - 22);
        } else if (e.isMiniBoss) {
          ctx.fillStyle = "#ffff00";
          ctx.font = "bold 10px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText("MINI-BOSS", e.x + e.w / 2, e.y - 22);
        } else if (e.type === "triangle") {
          ctx.fillStyle = "#ffff00";
          ctx.font = "bold 8px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText("SPEEDY", e.x + e.w / 2, e.y - 22);
        } else if (e.type === "circle") {
          ctx.fillStyle = "#00ff88";
          ctx.font = "bold 8px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText("HEALER", e.x + e.w / 2, e.y - 22);
        } else if (e.type === "jumper") {
          ctx.fillStyle = "#ff00ff";
          ctx.font = "bold 8px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText("JUMPER", e.x + e.w / 2, e.y - 22);
        } else if (e.type === "kamikaze") {
          ctx.fillStyle = "#ff8800";
          ctx.font = "bold 8px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText("BOMBER", e.x + e.w / 2, e.y - 22);
        } else if (e.isRanged) {
          ctx.fillStyle = "#ffaa00";
          ctx.font = "bold 8px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText("SHOOTER", e.x + e.w / 2, e.y - 22);
        } else if (e.hasShield && e.shieldHP > 0) {
          ctx.fillStyle = "#00aaff";
          ctx.font = "bold 8px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText("SHIELDED", e.x + e.w / 2, e.y - 22);
        }
        ctx.textAlign = "left";
        
        // Eyes
        ctx.fillStyle = "#ffff00";
        const eyeSize = e.isBoss ? 8 : e.isMiniBoss ? 6 : 5;
        ctx.fillRect(e.x + e.w * 0.25, e.y + e.h * 0.2, eyeSize, eyeSize);
        ctx.fillRect(e.x + e.w * 0.65, e.y + e.h * 0.2, eyeSize, eyeSize);

        // Shield bar
        if (e.hasShield && e.maxShieldHP > 0) {
          const shieldRatio = e.shieldHP / e.maxShieldHP;
          const barWidth = e.w;
          ctx.fillStyle = "rgba(0, 40, 80, 0.8)";
          ctx.fillRect(e.x, e.y - 14, barWidth, 4);
          
          ctx.fillStyle = "#00aaff";
          ctx.fillRect(e.x, e.y - 14, barWidth * shieldRatio, 4);
        }

        // HP bar
        const hpRatio = e.hp / e.maxHP;
        const barWidth = e.w;
        const barHeight = e.isBoss ? 8 : e.isMiniBoss ? 6 : 5;
        ctx.fillStyle = "rgba(60, 0, 0, 0.8)";
        ctx.fillRect(e.x, e.y - 8, barWidth, barHeight);
        
        const hpColor = hpRatio > 0.5 ? "#44ff44" : hpRatio > 0.25 ? "#ffaa44" : "#ff4444";
        ctx.fillStyle = hpColor;
        ctx.fillRect(e.x, e.y - 8, barWidth * hpRatio, barHeight);
        
        // Draw Bagel boss clones
        if (e.isBagel && e.bagelClones) {
          e.bagelClones.forEach(clone => {
            if (clone.hp > 0) {
              ctx.shadowColor = "#F5DEB3";
              ctx.shadowBlur = 15;
              ctx.fillStyle = "#F5DEB3";
              
              // Draw clone body
              ctx.beginPath();
              ctx.arc(clone.x, clone.y, 20, 0, Math.PI * 2);
              ctx.fill();
              
              ctx.shadowBlur = 0;
              
              // Clone HP bar
              const cloneHpRatio = clone.hp / clone.maxHP;
              const cloneBarWidth = 40;
              const cloneBarHeight = 4;
              
              ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
              ctx.fillRect(clone.x - cloneBarWidth/2, clone.y - 30, cloneBarWidth, cloneBarHeight);
              
              const cloneHpColor = cloneHpRatio > 0.6 ? "#00ff00" : cloneHpRatio > 0.3 ? "#ffaa00" : "#ff0000";
              ctx.fillStyle = cloneHpColor;
              ctx.fillRect(clone.x - cloneBarWidth/2, clone.y - 30, cloneBarWidth * cloneHpRatio, cloneBarHeight);
            }
          });
        }
        
        // Draw Spiderman boss legs
        if (e.isSpiderman && e.spiderLegs) {
          const centerX = e.x + e.w / 2;
          const centerY = e.y + e.h / 2;
          
          e.spiderLegs.forEach((leg, idx) => {
            if (leg.hp > 0) {
              const legX = centerX + Math.cos(leg.angle) * leg.distance;
              const legY = centerY + Math.sin(leg.angle) * leg.distance;
              
              // Draw leg connection to body
              ctx.strokeStyle = "rgba(139, 0, 0, 0.6)";
              ctx.lineWidth = 4;
              ctx.beginPath();
              ctx.moveTo(centerX, centerY);
              ctx.lineTo(legX, legY);
              ctx.stroke();
              
              // Draw leg body
              ctx.shadowColor = "#DC143C";
              ctx.shadowBlur = 12;
              ctx.fillStyle = "#8B0000";
              
              ctx.beginPath();
              ctx.arc(legX, legY, 12, 0, Math.PI * 2);
              ctx.fill();
              
              ctx.shadowBlur = 0;
              
              // Leg HP bar
              const legHpRatio = leg.hp / leg.maxHP;
              const legBarWidth = 24;
              const legBarHeight = 3;
              
              ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
              ctx.fillRect(legX - legBarWidth/2, legY - 18, legBarWidth, legBarHeight);
              
              const legHpColor = legHpRatio > 0.5 ? "#00ff00" : legHpRatio > 0.25 ? "#ffaa00" : "#ff0000";
              ctx.fillStyle = legHpColor;
              ctx.fillRect(legX - legBarWidth/2, legY - 18, legBarWidth * legHpRatio, legBarHeight);
              
              // Leg number
              ctx.fillStyle = "#ffffff";
              ctx.font = "bold 8px Arial";
              ctx.textAlign = "center";
              ctx.fillText(idx + 1, legX, legY + 3);
            }
          });
          
          ctx.textAlign = "left";
        }
        
        // Draw carrier's carried enemy
        if (e.isCarrier && e.carriedEnemy && !e.hasDropped) {
          ctx.fillStyle = e.carriedEnemy.color;
          ctx.shadowColor = e.carriedEnemy.color;
          ctx.shadowBlur = 8;
          
          const carriedSize = e.carriedEnemy.size;
          ctx.fillRect(e.x + e.w/2 - carriedSize/2, e.y + e.h + 5, carriedSize, carriedSize);
          ctx.shadowBlur = 0;
        }
      }
      ctx.shadowBlur = 0;
    }

    function drawProjectiles() {
      for (const p of projectiles) {
        // Special rendering for dragon beam
        if (p.isDragonBeam) {
          ctx.save();
          
          // Thick glowing laser
          ctx.shadowColor = p.glowColor;
          ctx.shadowBlur = 30;
          ctx.strokeStyle = p.color;
          ctx.lineWidth = p.radius * 2;
          ctx.globalAlpha = 0.8;
          ctx.beginPath();
          ctx.moveTo(0, p.y);
          ctx.lineTo(canvas.width, p.y);
          ctx.stroke();
          
          // Inner bright beam
          ctx.shadowBlur = 20;
          ctx.strokeStyle = "#ffff00";
          ctx.lineWidth = p.radius;
          ctx.beginPath();
          ctx.moveTo(0, p.y);
          ctx.lineTo(canvas.width, p.y);
          ctx.stroke();
          
          ctx.restore();
          continue;
        }
        
        // Special rendering for Guardian Tank shield
        if (p.isShield) {
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rotation || 0);
          
          // Draw rotating shield
          ctx.shadowColor = p.glowColor || "#87ceeb";
          ctx.shadowBlur = 20;
          ctx.fillStyle = p.color;
          ctx.fillRect(-12, -12, 24, 24);
          
          // Shield border
          ctx.strokeStyle = "#87ceeb";
          ctx.lineWidth = 3;
          ctx.strokeRect(-12, -12, 24, 24);
          
          // Shield emblem (cross)
          ctx.strokeStyle = "#ffffff";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(0, -8);
          ctx.lineTo(0, 8);
          ctx.moveTo(-8, 0);
          ctx.lineTo(8, 0);
          ctx.stroke();
          
          ctx.restore();
          continue;
        }
        
        // Special rendering for Thief daggers
        if (player && player.className === "Thief" && !p.isEnemyProjectile) {
          ctx.save();
          
          // Spinning dagger effect
          if (!p.daggerRotation) p.daggerRotation = 0;
          p.daggerRotation += 0.3;
          
          ctx.translate(p.x, p.y);
          ctx.rotate(p.daggerRotation);
          
          // Purple shadow trail
          ctx.shadowColor = "#8800ff";
          ctx.shadowBlur = 20;
          
          // Dagger blade (silver)
          ctx.fillStyle = "#c0c0c0";
          ctx.beginPath();
          ctx.moveTo(-3, -10); // Tip
          ctx.lineTo(3, -10);
          ctx.lineTo(2, 8); // Base
          ctx.lineTo(-2, 8);
          ctx.closePath();
          ctx.fill();
          
          // Blade shine
          ctx.fillStyle = "#ffffff";
          ctx.fillRect(-1, -8, 1, 12);
          
          // Hilt (gold with purple gem)
          ctx.fillStyle = "#ffd700";
          ctx.fillRect(-4, 8, 8, 3);
          
          // Purple gem in hilt
          ctx.shadowBlur = 10;
          ctx.fillStyle = "#8800ff";
          ctx.beginPath();
          ctx.arc(0, 9.5, 2, 0, Math.PI * 2);
          ctx.fill();
          
          // Sparkle particles
          if (Math.random() < 0.3) {
            particles.push({
              x: p.x,
              y: p.y,
              vx: (Math.random() - 0.5) * 2,
              vy: (Math.random() - 0.5) * 2,
              radius: 2,
              color: "#8800ff",
              life: 0.3
            });
          }
          
          ctx.restore();
          continue;
        }
        
        // Normal projectile rendering
        ctx.globalAlpha = 0.3;
        ctx.strokeStyle = p.color;
        ctx.lineWidth = p.radius;
        ctx.beginPath();
        for (let i = 0; i < p.trail.length; i++) {
          const t = p.trail[i];
          if (i === 0) ctx.moveTo(t.x, t.y);
          else ctx.lineTo(t.x, t.y);
        }
        ctx.stroke();
        ctx.globalAlpha = 1.0;

        ctx.shadowColor = p.glowColor;
        ctx.shadowBlur = 15;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }

    function drawMinions() {
      if (!player || player.className !== "Summoner") return;
      
      for (const m of minions) {
        ctx.shadowColor = "#88ff88";
        ctx.shadowBlur = 15;
        ctx.fillStyle = "#88ff88";
        ctx.beginPath();
        ctx.arc(m.drawX, m.drawY, 8, 0, Math.PI * 2);
        ctx.fill();

        ctx.shadowBlur = 0;
        ctx.fillStyle = "#ffffff";
        ctx.beginPath();
        ctx.arc(m.drawX, m.drawY, 4, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;
    }
    
    // Draw helper stars (Starcaller)
    function drawHelperStars() {
      if (helperStars.length === 0) return;
      
      for (const star of helperStars) {
        // Outer glow
        ctx.shadowColor = "#ffaa00";
        ctx.shadowBlur = 20;
        ctx.fillStyle = "#ffff00";
        ctx.beginPath();
        ctx.arc(star.drawX, star.drawY, 10, 0, Math.PI * 2);
        ctx.fill();

        // Inner bright core
        ctx.shadowBlur = 0;
        ctx.fillStyle = "#ffffff";
        ctx.beginPath();
        ctx.arc(star.drawX, star.drawY, 5, 0, Math.PI * 2);
        ctx.fill();
        
        // Star points
        ctx.fillStyle = "#ffff00";
        for (let i = 0; i < 5; i++) {
          const angle = (i / 5) * Math.PI * 2 + (Date.now() / 500);
          const px = star.drawX + Math.cos(angle) * 12;
          const py = star.drawY + Math.sin(angle) * 12;
          ctx.beginPath();
          ctx.arc(px, py, 2, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      ctx.shadowBlur = 0;
    }

    function drawParticles() {
      for (const p of particles) {
        // Use custom alpha if provided (for stealth smoke)
        const alpha = p.alpha !== undefined ? (p.alpha * (p.life / 0.8)) : (p.life * 0.8);
        ctx.globalAlpha = alpha;
        
        // Add glow for magical particles
        if (p.color === "#8800ff" || p.color === "#ffd700") {
          ctx.shadowColor = p.color;
          ctx.shadowBlur = 8;
        }
        
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius || 2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.shadowBlur = 0;
      }
      ctx.globalAlpha = 1.0;
    }
    
    function drawFireZones() {
      fireZones.forEach(zone => {
        ctx.save();
        
        // Pulsing fire effect
        const pulse = Math.sin(Date.now() / 100) * 0.2 + 0.8;
        ctx.globalAlpha = 0.6 * pulse;
        
        // Outer glow
        const gradient = ctx.createRadialGradient(zone.x, zone.y, 0, zone.x, zone.y, zone.radius);
        gradient.addColorStop(0, "#ff8800");
        gradient.addColorStop(0.5, "#ff4400");
        gradient.addColorStop(1, "rgba(255, 68, 0, 0)");
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Inner hot spot
        ctx.globalAlpha = 0.8;
        ctx.fillStyle = "#ffff00";
        ctx.beginPath();
        ctx.arc(zone.x, zone.y, zone.radius * 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Fire particles
        if (Math.random() < 0.3) {
          particles.push({
            x: zone.x + (Math.random() - 0.5) * zone.radius,
            y: zone.y + (Math.random() - 0.5) * zone.radius,
            vx: 0,
            vy: -2,
            radius: 3,
            color: Math.random() < 0.5 ? "#ff4400" : "#ff8800",
            life: 0.5
          });
        }
        
        ctx.restore();
      });
    }
    
    function drawMiniSun() {
      if (!player.miniSun) return;
      
      const sun = player.miniSun;
      ctx.save();
      
      // Pulsing glow effect
      const pulse = Math.sin(Date.now() / 150) * 0.3 + 0.7;
      
      // Burn radius (faint outer glow)
      ctx.globalAlpha = 0.15;
      const burnGradient = ctx.createRadialGradient(sun.x, sun.y, 0, sun.x, sun.y, sun.burnRadius);
      burnGradient.addColorStop(0, "#FFD700");
      burnGradient.addColorStop(1, "rgba(255, 215, 0, 0)");
      ctx.fillStyle = burnGradient;
      ctx.beginPath();
      ctx.arc(sun.x, sun.y, sun.burnRadius, 0, Math.PI * 2);
      ctx.fill();
      
      // Main sun glow
      ctx.globalAlpha = 0.7 * pulse;
      const glowGradient = ctx.createRadialGradient(sun.x, sun.y, 0, sun.x, sun.y, sun.radius * 1.5);
      glowGradient.addColorStop(0, "#FFFF00");
      glowGradient.addColorStop(0.4, "#FFD700");
      glowGradient.addColorStop(0.8, "#FFA500");
      glowGradient.addColorStop(1, "rgba(255, 165, 0, 0)");
      ctx.fillStyle = glowGradient;
      ctx.beginPath();
      ctx.arc(sun.x, sun.y, sun.radius * 1.5, 0, Math.PI * 2);
      ctx.fill();
      
      // Sun core
      ctx.globalAlpha = 1.0;
      const coreGradient = ctx.createRadialGradient(sun.x, sun.y, 0, sun.x, sun.y, sun.radius);
      coreGradient.addColorStop(0, "#FFFFFF");
      coreGradient.addColorStop(0.3, "#FFFF00");
      coreGradient.addColorStop(0.7, "#FFD700");
      coreGradient.addColorStop(1, "#FFA500");
      ctx.fillStyle = coreGradient;
      ctx.beginPath();
      ctx.arc(sun.x, sun.y, sun.radius, 0, Math.PI * 2);
      ctx.fill();
      
      // Sun flares (rotating rays)
      ctx.globalAlpha = 0.6 * pulse;
      const rotation = Date.now() / 1000;
      for (let i = 0; i < 8; i++) {
        const angle = (rotation + i * Math.PI / 4);
        const x1 = sun.x + Math.cos(angle) * sun.radius;
        const y1 = sun.y + Math.sin(angle) * sun.radius;
        const x2 = sun.x + Math.cos(angle) * (sun.radius * 1.8);
        const y2 = sun.y + Math.sin(angle) * (sun.radius * 1.8);
        
        ctx.strokeStyle = "#FFD700";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
      
      ctx.restore();
    }
    
    function drawEclipseMoon() {
      if (!eclipseMoon) return;
      
      ctx.save();
      
      // Pulsing effect
      const pulse = Math.sin(Date.now() / 200) * 0.2 + 0.8;
      
      // Gravity radius (faint purple glow)
      ctx.globalAlpha = 0.1;
      const gravityGradient = ctx.createRadialGradient(eclipseMoon.x, eclipseMoon.y, 0, eclipseMoon.x, eclipseMoon.y, eclipseMoon.gravityRadius);
      gravityGradient.addColorStop(0, "#9D8BC9");
      gravityGradient.addColorStop(1, "rgba(157, 139, 201, 0)");
      ctx.fillStyle = gravityGradient;
      ctx.beginPath();
      ctx.arc(eclipseMoon.x, eclipseMoon.y, eclipseMoon.gravityRadius, 0, Math.PI * 2);
      ctx.fill();
      
      // Moon glow
      ctx.globalAlpha = 0.6 * pulse;
      const glowGradient = ctx.createRadialGradient(eclipseMoon.x, eclipseMoon.y, 0, eclipseMoon.x, eclipseMoon.y, eclipseMoon.radius * 1.8);
      glowGradient.addColorStop(0, "#DDDDFF");
      glowGradient.addColorStop(0.4, "#9D8BC9");
      glowGradient.addColorStop(0.8, "#4A2C6A");
      glowGradient.addColorStop(1, "rgba(74, 44, 106, 0)");
      ctx.fillStyle = glowGradient;
      ctx.beginPath();
      ctx.arc(eclipseMoon.x, eclipseMoon.y, eclipseMoon.radius * 1.8, 0, Math.PI * 2);
      ctx.fill();
      
      // Moon surface
      ctx.globalAlpha = 1.0;
      const moonGradient = ctx.createRadialGradient(
        eclipseMoon.x - eclipseMoon.radius * 0.3, 
        eclipseMoon.y - eclipseMoon.radius * 0.3, 
        0, 
        eclipseMoon.x, 
        eclipseMoon.y, 
        eclipseMoon.radius
      );
      moonGradient.addColorStop(0, "#E0E0FF");
      moonGradient.addColorStop(0.5, "#B0B0D0");
      moonGradient.addColorStop(1, "#6A6A90");
      ctx.fillStyle = moonGradient;
      ctx.beginPath();
      ctx.arc(eclipseMoon.x, eclipseMoon.y, eclipseMoon.radius, 0, Math.PI * 2);
      ctx.fill();
      
      // Moon craters (dark spots)
      ctx.globalAlpha = 0.4;
      ctx.fillStyle = "#4A4A6A";
      ctx.beginPath();
      ctx.arc(eclipseMoon.x + 10, eclipseMoon.y - 5, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(eclipseMoon.x - 12, eclipseMoon.y + 8, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(eclipseMoon.x + 5, eclipseMoon.y + 12, 5, 0, Math.PI * 2);
      ctx.fill();
      
      // Gravity particles swirling around moon
      ctx.globalAlpha = 0.5;
      const rotation = Date.now() / 500;
      for (let i = 0; i < 12; i++) {
        const angle = rotation + (i * Math.PI / 6);
        const dist = eclipseMoon.radius * 1.3;
        const px = eclipseMoon.x + Math.cos(angle) * dist;
        const py = eclipseMoon.y + Math.sin(angle) * dist;
        
        ctx.fillStyle = "#9D8BC9";
        ctx.beginPath();
        ctx.arc(px, py, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.restore();
    }

    function drawFloatingTexts() {
      for (const t of floatingTexts) {
        ctx.globalAlpha = t.life;
        ctx.fillStyle = t.color;
        ctx.font = "bold 14px 'Courier New'";
        ctx.textAlign = "center";
        ctx.fillText(t.text, t.x, t.y);
      }
      ctx.globalAlpha = 1.0;
      ctx.textAlign = "left";
    }

    function drawCurrency() {
      for (const drop of currencyDrops) {
        ctx.globalAlpha = Math.min(drop.life, 1.0);
        
        if (drop.type === "coin") {
          ctx.shadowColor = "#ffff00";
          ctx.shadowBlur = 10;
          ctx.fillStyle = "#ffff00";
          ctx.font = "bold 16px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText("üí∞", drop.x, drop.y);
        } else {
          ctx.shadowColor = "#00ffff";
          ctx.shadowBlur = 10;
          ctx.fillStyle = "#00ffff";
          ctx.font = "bold 16px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText("üíé", drop.x, drop.y);
        }
        
        ctx.shadowBlur = 0;
      }
      ctx.globalAlpha = 1.0;
      ctx.textAlign = "left";
    }

    function drawHUD() {
      if (!player) return;

      // Main HUD
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(10, 10, 300, 130); // Increased from 110 to 130
      
      ctx.strokeStyle = "#00ffff";
      ctx.lineWidth = 2;
      ctx.strokeRect(10, 10, 300, 130); // Increased from 110 to 130

      ctx.fillStyle = "#00ffff";
      ctx.font = "bold 14px 'Courier New'";
      ctx.fillText("‚öîÔ∏è " + player.className, 20, 30);
      ctx.fillText("üó∫Ô∏è Map: " + currentMap, 20, 50);
      ctx.fillText("üåä Wave: " + wave, 130, 50);
      ctx.fillText("‚≠ê Level: " + player.level, 230, 50);
      
      // Enemy Progress Bar
      if (enemiesThisWave > 0) {
        ctx.fillStyle = "#00ffff";
        ctx.font = "bold 12px 'Courier New'";
        ctx.fillText("üëæ Enemies: " + enemiesKilledThisWave + "/" + enemiesThisWave, 350, 30);
        
        // Progress bar background
        ctx.fillStyle = "rgba(0, 40, 80, 0.8)";
        ctx.fillRect(350, 35, 150, 12);
        
        // Progress bar fill
        const progress = enemiesKilledThisWave / enemiesThisWave;
        const barColor = progress < 0.33 ? "#ff4444" : progress < 0.66 ? "#ffaa00" : "#00ff00";
        ctx.fillStyle = barColor;
        ctx.fillRect(350, 35, 150 * progress, 12);
        
        // Progress bar border
        ctx.strokeStyle = "#00ffff";
        ctx.lineWidth = 2;
        ctx.strokeRect(350, 35, 150, 12);
      }
      
      // Currency display (bottom of HUD, below XP bar)
      ctx.fillStyle = "#ffff00";
      ctx.fillText("üí∞ " + gameData.totalCoins, 20, 125); // Moved from 105 to 125
      ctx.fillStyle = "#00ffff";
      ctx.fillText("üíé " + gameData.totalGems, 160, 125); // Moved from 105 to 125
      
      // Debuff indicators
      let debuffX = 350;
      if (playerDebuffs.cursed) {
        ctx.fillStyle = "rgba(153, 50, 204, 0.8)";
        ctx.fillRect(debuffX, 55, 70, 25);
        ctx.strokeStyle = "#9932CC";
        ctx.lineWidth = 2;
        ctx.strokeRect(debuffX, 55, 70, 25);
        ctx.fillStyle = "#ffffff";
        ctx.font = "bold 10px 'Courier New'";
        ctx.fillText("CURSED", debuffX + 5, 67);
        ctx.fillText(Math.ceil(playerDebuffs.cursedTimer) + "s", debuffX + 5, 77);
        debuffX += 75;
      }
      if (playerDebuffs.poisoned) {
        ctx.fillStyle = "rgba(0, 255, 0, 0.8)";
        ctx.fillRect(debuffX, 55, 75, 25);
        ctx.strokeStyle = "#00ff00";
        ctx.lineWidth = 2;
        ctx.strokeRect(debuffX, 55, 75, 25);
        ctx.fillStyle = "#000000";
        ctx.font = "bold 10px 'Courier New'";
        ctx.fillText("POISONED", debuffX + 3, 67);
        ctx.fillText(Math.ceil(playerDebuffs.poisonedTimer) + "s", debuffX + 20, 77);
      }
      
      // Auto-start indicator (top-right)
      ctx.fillStyle = autoStartWave ? "rgba(0, 255, 0, 0.8)" : "rgba(255, 0, 0, 0.8)";
      ctx.fillRect(canvas.width - 160, 10, 150, 30);
      ctx.strokeStyle = autoStartWave ? "#00ff00" : "#ff0000";
      ctx.lineWidth = 2;
      ctx.strokeRect(canvas.width - 160, 10, 150, 30);
      ctx.fillStyle = "#000000";
      ctx.font = "bold 12px 'Courier New'";
      ctx.fillText("‚ö° Auto-Start: " + (autoStartWave ? "ON" : "OFF"), canvas.width - 150, 28);
      ctx.fillStyle = "#ffff00";
      ctx.font = "10px 'Courier New'";
      ctx.fillText("[R] to toggle", canvas.width - 150, 38);
      
      // Game speed indicator
      ctx.fillStyle = gameSpeed === 2 ? "rgba(255, 136, 0, 0.8)" : "rgba(100, 100, 100, 0.8)";
      ctx.fillRect(canvas.width - 160, 45, 150, 30);
      ctx.strokeStyle = gameSpeed === 2 ? "#ff8800" : "#666666";
      ctx.lineWidth = 2;
      ctx.strokeRect(canvas.width - 160, 45, 150, 30);
      ctx.fillStyle = gameSpeed === 2 ? "#ffffff" : "#cccccc";
      ctx.font = "bold 12px 'Courier New'";
      ctx.fillText("‚è© Speed: " + gameSpeed + "x", canvas.width - 150, 63);
      ctx.fillStyle = "#ffff00";
      ctx.font = "10px 'Courier New'";
      ctx.fillText("[F] to toggle", canvas.width - 150, 73);

      // Shield bar
      if (player.maxShield > 0) {
        const shieldRatio = player.shield / player.maxShield;
        ctx.fillStyle = "#00ffff";
        ctx.fillText("üõ°Ô∏è Shield", 20, 70);
        ctx.fillStyle = "rgba(0, 40, 80, 0.8)";
        ctx.fillRect(70, 60, 230, 8);
        
        ctx.fillStyle = "#00aaff";
        ctx.fillRect(70, 60, 230 * shieldRatio, 8);
        
        ctx.strokeStyle = "#00ffff";
        ctx.strokeRect(70, 60, 230, 8);
        
        // Shield numbers on bar
        ctx.fillStyle = "#ffffff";
        ctx.font = "bold 10px 'Courier New'";
        ctx.fillText(Math.floor(player.shield) + "/" + player.maxShield, 155, 67);
      }

      // HP bar
      const hpRatio = player.hp / player.maxHP;
      ctx.fillStyle = "#00ffff";
      const hpY = player.maxShield > 0 ? 84 : 70;
      const hpBarY = player.maxShield > 0 ? 74 : 60;
      ctx.fillText("‚ù§Ô∏è HP", 20, hpY);
      ctx.fillStyle = "rgba(60, 0, 0, 0.8)";
      ctx.fillRect(70, hpBarY, 230, 12);
      
      ctx.fillStyle = hpRatio > 0.5 ? "#44ff44" : hpRatio > 0.25 ? "#ffaa44" : "#ff4444";
      ctx.fillRect(70, hpBarY, 230 * hpRatio, 12);
      
      ctx.strokeStyle = "#ff4444";
      ctx.strokeRect(70, hpBarY, 230, 12);
      
      // HP numbers on bar
      ctx.fillStyle = "#ffffff";
      ctx.font = "bold 11px 'Courier New'";
      ctx.fillText(Math.floor(player.hp) + "/" + player.maxHP, 155, hpBarY + 9);

      // XP bar
      const xpRatio = player.xp / player.xpToNext;
      ctx.fillStyle = "#00ffff";
      ctx.fillText("‚ú® XP", 20, 102);
      ctx.fillStyle = "rgba(0, 50, 80, 0.8)";
      ctx.fillRect(70, 92, 230, 10);
      
      ctx.fillStyle = "#0088ff";
      ctx.fillRect(70, 92, 230 * xpRatio, 10);
      
      ctx.strokeStyle = "#00ffff";
      ctx.strokeRect(70, 92, 230, 10);
      
      // XP numbers on bar
      ctx.fillStyle = "#ffffff";
      ctx.font = "bold 10px 'Courier New'";
      ctx.fillText(Math.floor(player.xp) + "/" + player.xpToNext, 155, 100);

      
      // Combo
      if (combo > 0) {
        ctx.fillStyle = "#ff8800";
        ctx.font = "bold 16px 'Courier New'";
        ctx.fillText("üî• COMBO: " + combo + "x", canvas.width - 200, 80);
      }
      
      // Wave timer
      if (waveTimerActive) {
        ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
        ctx.fillRect(canvas.width / 2 - 100, 10, 200, 50);
        ctx.strokeStyle = "#ffff00";
        ctx.lineWidth = 3;
        ctx.strokeRect(canvas.width / 2 - 100, 10, 200, 50);
        
        ctx.fillStyle = "#ffff00";
        ctx.font = "bold 18px 'Courier New'";
        ctx.textAlign = "center";
        ctx.fillText("‚è∞ Next Wave In:", canvas.width / 2, 30);
        ctx.font = "bold 24px 'Courier New'";
        ctx.fillStyle = waveTimer <= 5 ? "#ff0000" : "#00ff00";
        ctx.fillText(Math.ceil(waveTimer) + "s", canvas.width / 2, 52);
        ctx.textAlign = "left";
      }
      
      // Active potion effects
      let effectY = canvas.height - 140;
      if (potionEffects.critActive) {
        ctx.fillStyle = "rgba(255, 0, 0, 0.8)";
        ctx.fillRect(10, effectY, 180, 30);
        ctx.strokeStyle = "#ff0000";
        ctx.lineWidth = 2;
        ctx.strokeRect(10, effectY, 180, 30);
        ctx.fillStyle = "#ffff00";
        ctx.font = "bold 14px 'Courier New'";
        ctx.fillText("üí• CRIT BOOST: " + Math.ceil(potionEffects.critTimer) + "s", 20, effectY + 20);
        effectY -= 35;
      }
      
      if (potionEffects.damageActive) {
        ctx.fillStyle = "rgba(255, 136, 0, 0.8)";
        ctx.fillRect(10, effectY, 180, 30);
        ctx.strokeStyle = "#ff8800";
        ctx.lineWidth = 2;
        ctx.strokeRect(10, effectY, 180, 30);
        ctx.fillStyle = "#ffff00";
        ctx.font = "bold 14px 'Courier New'";
        ctx.fillText("‚öîÔ∏è DAMAGE UP: " + Math.ceil(potionEffects.damageTimer) + "s", 20, effectY + 20);
        effectY -= 35;
      }
      
      if (potionEffects.speedActive) {
        ctx.fillStyle = "rgba(255, 255, 0, 0.8)";
        ctx.fillRect(10, effectY, 180, 30);
        ctx.strokeStyle = "#ffff00";
        ctx.lineWidth = 2;
        ctx.strokeRect(10, effectY, 180, 30);
        ctx.fillStyle = "#000000";
        ctx.font = "bold 14px 'Courier New'";
        ctx.fillText("‚ö° SPEED UP: " + Math.ceil(potionEffects.speedTimer) + "s", 20, effectY + 20);
        effectY -= 35;
      }
      
      // Potion inventory display at bottom center
      const potionBarY = canvas.height - 60;
      const potionBarWidth = 540; // Increased width to fit all potions
      const potionBarX = (canvas.width - potionBarWidth) / 2;
      
      ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
      ctx.fillRect(potionBarX, potionBarY, potionBarWidth, 50);
      ctx.strokeStyle = "#00ffff";
      ctx.lineWidth = 2;
      ctx.strokeRect(potionBarX, potionBarY, potionBarWidth, 50);
      
      const potionSlotWidth = 75;
      const potionsList = [
        { key: '1', icon: '‚ù§Ô∏è', name: 'Heal', count: potions.heal, color: '#ff4444' },
        { key: '2', icon: 'üõ°Ô∏è', name: 'Shield', count: potions.shield, color: '#4444ff' },
        { key: '3', icon: 'üí•', name: 'Crit', count: potions.crit, color: '#ff0000' },
        { key: '4', icon: '‚öîÔ∏è', name: 'Damage', count: potions.damage, color: '#ff8800' },
        { key: '5', icon: '‚ö°', name: 'Speed', count: potions.speed, color: '#ffff00' },
        { key: '6', icon: 'üêâ', name: 'Dragon', count: potions.dragon, color: '#ff00ff' },
        { key: '7', icon: '‚ú®', name: 'Cleanse', count: potions.cleanse, color: '#FFD700' }
      ];
      
      potionsList.forEach((potion, i) => {
        const slotX = potionBarX + 10 + (i * potionSlotWidth);
        const slotY = potionBarY + 5;
        
        // Draw slot
        ctx.fillStyle = potion.count > 0 ? "rgba(0, 50, 50, 0.8)" : "rgba(50, 50, 50, 0.5)";
        ctx.fillRect(slotX, slotY, 70, 40);
        ctx.strokeStyle = potion.count > 0 ? potion.color : "#444444";
        ctx.lineWidth = 2;
        ctx.strokeRect(slotX, slotY, 70, 40);
        
        // Draw icon and count
        ctx.fillStyle = potion.count > 0 ? "#ffffff" : "#666666";
        ctx.font = "20px 'Courier New'";
        ctx.textAlign = "center";
        ctx.fillText(potion.icon, slotX + 20, slotY + 28);
        
        ctx.fillStyle = potion.count > 0 ? "#00ff00" : "#666666";
        ctx.font = "bold 16px 'Courier New'";
        ctx.fillText("√ó" + potion.count, slotX + 50, slotY + 28);
        
        // Draw hotkey
        ctx.fillStyle = "#ffff00";
        ctx.font = "10px 'Courier New'";
        ctx.fillText("[" + potion.key + "]", slotX + 35, slotY + 38);
      });
      
      ctx.textAlign = "left";
    }
    
    function drawAbilityEffects() {
      // Upside Down dimension effect
      if (upsideDownActive) {
        ctx.save();
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = "#8B0000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.globalAlpha = 1;
        ctx.restore();
        
        // Distorted text
        ctx.save();
        ctx.fillStyle = "#ff0000";
        ctx.font = "bold 24px 'Courier New'";
        ctx.textAlign = "center";
        ctx.fillText("üåÄ UPSIDE DOWN üåÄ", canvas.width / 2, 50);
        ctx.fillStyle = "#ffff00";
        ctx.font = "16px 'Courier New'";
        ctx.fillText(`${Math.ceil(upsideDownTimer)}s remaining`, canvas.width / 2, 75);
        ctx.restore();
      }
      
      // Hive Mind links
      if (hiveMindActive) {
        ctx.save();
        ctx.strokeStyle = "#ff0000";
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        
        for (let i = 0; i < enemies.length; i++) {
          for (let j = i + 1; j < enemies.length; j++) {
            if (enemies[i].hiveMindLinked && enemies[j].hiveMindLinked) {
              ctx.beginPath();
              ctx.moveTo(enemies[i].x, enemies[i].y);
              ctx.lineTo(enemies[j].x, enemies[j].y);
              ctx.stroke();
            }
          }
        }
        
        ctx.setLineDash([]);
        ctx.restore();
        
        // Display text
        ctx.save();
        ctx.fillStyle = "#ff0000";
        ctx.font = "bold 24px 'Courier New'";
        ctx.textAlign = "center";
        ctx.fillText("üëÅÔ∏è HIVE MIND ACTIVE üëÅÔ∏è", canvas.width / 2, 50);
        ctx.fillStyle = "#ffff00";
        ctx.font = "16px 'Courier New'";
        ctx.fillText(`${Math.ceil(hiveMindTimer)}s remaining`, canvas.width / 2, 75);
        ctx.restore();
      }
      
      // Blade Storm effect
      if (bladeStormActive && player) {
        ctx.save();
        ctx.strokeStyle = "#9933ff";
        ctx.lineWidth = 3;
        const numBlades = 8;
        const time = Date.now() / 100;
        
        for (let i = 0; i < numBlades; i++) {
          const angle = (Math.PI * 2 / numBlades) * i + time;
          const x1 = player.x + Math.cos(angle) * 100;
          const y1 = player.y + Math.sin(angle) * 100;
          const x2 = player.x + Math.cos(angle + 0.5) * 150;
          const y2 = player.y + Math.sin(angle + 0.5) * 150;
          
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }
        ctx.restore();
      }
      
      // Time Freeze effect
      if (timeFreezeActive) {
        ctx.save();
        ctx.strokeStyle = "#00ffff";
        ctx.lineWidth = 2;
        
        enemies.forEach(e => {
          if (e.frozen) {
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.radius + 5, 0, Math.PI * 2);
            ctx.stroke();
          }
        });
        
        ctx.fillStyle = "#00ffff";
        ctx.font = "bold 24px 'Courier New'";
        ctx.textAlign = "center";
        ctx.fillText("‚ùÑÔ∏è TIME FROZEN ‚ùÑÔ∏è", canvas.width / 2, 50);
        ctx.restore();
      }
      
      // Vecna monsters
      vecnaMonsters.forEach(m => {
        ctx.save();
        ctx.fillStyle = m.color;
        ctx.beginPath();
        ctx.arc(m.x, m.y, m.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // HP bar
        const barWidth = 30;
        const barHeight = 4;
        const hpPercent = m.hp / m.maxHP;
        
        ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
        ctx.fillRect(m.x - barWidth / 2, m.y - m.radius - 10, barWidth, barHeight);
        
        ctx.fillStyle = "#00ff00";
        ctx.fillRect(m.x - barWidth / 2, m.y - m.radius - 10, barWidth * hpPercent, barHeight);
        
        ctx.restore();
      });
    }

    function drawUpgradePopup() {
      const popupW = 300;
      const popupH = 350;
      const popupX = upgradePopup.x;
      const popupY = upgradePopup.y;
      
      // Background
      ctx.fillStyle = "rgba(0, 0, 0, 0.9)";
      ctx.fillRect(popupX, popupY, popupW, popupH);
      
      // Border
      ctx.strokeStyle = "#00ffff";
      ctx.lineWidth = 3;
      ctx.strokeRect(popupX, popupY, popupW, popupH);
      
      // Close button
      ctx.fillStyle = "#ff0000";
      ctx.fillRect(popupX + popupW - 30, popupY + 10, 20, 20);
      ctx.fillStyle = "#ffffff";
      ctx.font = "bold 16px Arial";
      ctx.textAlign = "center";
      ctx.fillText("X", popupX + popupW - 20, popupY + 25);
      
      // Title
      const titles = {
        'clone': "UPGRADE CLONE",
        'sun': "UPGRADE SUN",
        'turret': "UPGRADE TURRET",
        'root': "UPGRADE ROOT"
      };
      ctx.fillStyle = "#ffff00";
      ctx.font = "bold 20px 'Courier New'";
      ctx.fillText(titles[upgradePopup.type], popupX + popupW / 2, popupY + 40);
      
      // Stats display
      const target = upgradePopup.target;
      ctx.fillStyle = "#ffffff";
      ctx.font = "14px 'Courier New'";
      ctx.textAlign = "left";
      
      let yPos = popupY + 80;
      if (upgradePopup.type === 'clone') {
        ctx.fillText(`Damage: ${Math.round(target.damage || 10)}`, popupX + 20, yPos);
        ctx.fillText(`Fire Rate: ${Math.round(target.fireRate || 1000)}ms`, popupX + 20, yPos + 25);
        ctx.fillText(`HP: ${Math.round(target.hp)}/${Math.round(target.maxHp)}`, popupX + 20, yPos + 50);
      } else if (upgradePopup.type === 'sun') {
        ctx.fillText(`Damage: ${Math.round(target.damage || 25)}/sec`, popupX + 20, yPos);
        ctx.fillText(`Radius: ${Math.round(target.radius || 40)}`, popupX + 20, yPos + 25);
        ctx.fillText(`Burn Radius: ${Math.round(target.burnRadius || 150)}`, popupX + 20, yPos + 50);
        ctx.fillText(`Speed: ${Math.round(target.speed || 200)}`, popupX + 20, yPos + 75);
      } else if (upgradePopup.type === 'turret') {
        ctx.fillText(`Damage: ${Math.round(target.damage || 15)}`, popupX + 20, yPos);
        ctx.fillText(`Fire Rate: ${Math.round(target.fireRate || 1000)}ms`, popupX + 20, yPos + 25);
        ctx.fillText(`Range: ${Math.round(target.range || 200)}`, popupX + 20, yPos + 50);
      } else if (upgradePopup.type === 'root') {
        ctx.fillText(`Damage: ${Math.round(target.damage || 5)}`, popupX + 20, yPos);
        ctx.fillText(`Slow: ${Math.round((target.slow || 0.5) * 100)}%`, popupX + 20, yPos + 25);
        ctx.fillText(`Duration: ${Math.round(target.duration || 3000)}ms`, popupX + 20, yPos + 50);
      }
      
      ctx.fillText(`Level: ${target.upgradeLevel || 0}`, popupX + 20, yPos + 100);
      
      // Upgrade buttons
      const cost = 500 + ((target.upgradeLevel || 0) * 250);
      const buttonLabels = {
        'clone': ['Damage +15%', 'Fire Rate -10%', 'HP +20%'],
        'sun': ['Damage +10%', 'Radius +25', 'Speed +10%'],
        'turret': ['Damage +15%', 'Fire Rate -10%', 'Range +10%'],
        'root': ['Damage +20%', 'Slow +10%', 'Duration +15%']
      };
      
      const buttonY = [popupY + 200, popupY + 250, popupY + 300];
      for (let i = 0; i < 3; i++) {
        // Button background
        ctx.fillStyle = coins >= cost ? "#00aa00" : "#555555";
        ctx.fillRect(popupX + 20, buttonY[i], popupW - 40, 35);
        
        // Button border
        ctx.strokeStyle = "#00ffff";
        ctx.lineWidth = 2;
        ctx.strokeRect(popupX + 20, buttonY[i], popupW - 40, 35);
        
        // Button text
        ctx.fillStyle = "#ffffff";
        ctx.font = "bold 14px 'Courier New'";
        ctx.textAlign = "center";
        ctx.fillText(buttonLabels[upgradePopup.type][i], popupX + popupW / 2, buttonY[i] + 22);
        
        // Cost
        ctx.font = "12px 'Courier New'";
        ctx.fillStyle = coins >= cost ? "#ffff00" : "#ff0000";
        ctx.fillText(`${cost} coins`, popupX + popupW / 2, buttonY[i] + 33);
      }
      
      ctx.textAlign = "left";
    }
    
    function drawTurretCraftUI() {
      const craftX = canvas.width / 2 - 150;
      const craftY = canvas.height / 2 - 100;
      const craftW = 300;
      const craftH = 200;
      
      if (turretCraftUI.dragging) {
        // Show placement preview
        const mouseX = turretCraftUI.dragX || player.x;
        const mouseY = turretCraftUI.dragY || player.y;
        const dx = mouseX - player.x;
        const dy = mouseY - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        // Draw range circle
        ctx.strokeStyle = dist <= 250 ? "#00ff00" : "#ff0000";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(player.x, player.y, 250, 0, Math.PI * 2);
        ctx.stroke();
        
        // Draw turret preview
        ctx.fillStyle = dist <= 250 ? "rgba(0, 255, 0, 0.5)" : "rgba(255, 0, 0, 0.5)";
        ctx.beginPath();
        ctx.arc(mouseX, mouseY, 15, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = "#ffffff";
        ctx.font = "12px 'Courier New'";
        ctx.textAlign = "center";
        ctx.fillText(turretCraftUI.selectedType === 'shield' ? "SHIELD" : "DPS", mouseX, mouseY - 25);
        ctx.fillText(`${Math.round(dist)}/250`, mouseX, mouseY + 35);
        
        return;
      }
      
      // Background
      ctx.fillStyle = "rgba(0, 0, 0, 0.9)";
      ctx.fillRect(craftX, craftY, craftW, craftH);
      
      // Border
      ctx.strokeStyle = "#ffaa00";
      ctx.lineWidth = 3;
      ctx.strokeRect(craftX, craftY, craftW, craftH);
      
      // Close button
      ctx.fillStyle = "#ff0000";
      ctx.fillRect(craftX + craftW - 30, craftY + 10, 20, 20);
      ctx.fillStyle = "#ffffff";
      ctx.font = "bold 16px Arial";
      ctx.textAlign = "center";
      ctx.fillText("X", craftX + craftW - 20, craftY + 25);
      
      // Title
      ctx.fillStyle = "#ffaa00";
      ctx.font = "bold 20px 'Courier New'";
      ctx.fillText("CRAFT TURRET", craftX + craftW / 2, craftY + 35);
      
      // Shield Turret button
      ctx.fillStyle = coins >= 500 ? "#4444ff" : "#333333";
      ctx.fillRect(craftX + 20, craftY + 50, craftW - 40, 40);
      ctx.strokeStyle = "#00ffff";
      ctx.lineWidth = 2;
      ctx.strokeRect(craftX + 20, craftY + 50, craftW - 40, 40);
      
      ctx.fillStyle = "#ffffff";
      ctx.font = "bold 16px 'Courier New'";
      ctx.textAlign = "center";
      ctx.fillText("üõ°Ô∏è SHIELD TURRET", craftX + craftW / 2, craftY + 70);
      ctx.font = "12px 'Courier New'";
      ctx.fillText("Low damage, fast fire, short range", craftX + craftW / 2, craftY + 85);
      
      // DPS Turret button
      ctx.fillStyle = coins >= 500 ? "#ff4444" : "#333333";
      ctx.fillRect(craftX + 20, craftY + 100, craftW - 40, 40);
      ctx.strokeStyle = "#00ffff";
      ctx.lineWidth = 2;
      ctx.strokeRect(craftX + 20, craftY + 100, craftW - 40, 40);
      
      ctx.fillStyle = "#ffffff";
      ctx.font = "bold 16px 'Courier New'";
      ctx.fillText("‚öîÔ∏è DPS TURRET", craftX + craftW / 2, craftY + 120);
      ctx.font = "12px 'Courier New'";
      ctx.fillText("High damage, slow fire, long range", craftX + craftW / 2, craftY + 135);
      
      // Cost
      ctx.fillStyle = coins >= 500 ? "#ffff00" : "#ff0000";
      ctx.font = "bold 14px 'Courier New'";
      ctx.fillText("Cost: 500 coins each", craftX + craftW / 2, craftY + 165);
      
      ctx.fillText("Click to drag and place within 250 range", craftX + craftW / 2, craftY + 185);
      
      ctx.textAlign = "left";
    }
    
    function drawTurrets() {
      turrets.forEach(turret => {
        ctx.save();
        
        // Turret base
        ctx.fillStyle = turret.type === 'shield' ? "#4444ff" : "#ff4444";
        ctx.shadowBlur = 10;
        ctx.shadowColor = turret.type === 'shield' ? "#4444ff" : "#ff4444";
        
        ctx.beginPath();
        ctx.arc(turret.x, turret.y, 15, 0, Math.PI * 2);
        ctx.fill();
        
        // Turret gun
        ctx.fillStyle = "#888888";
        ctx.fillRect(turret.x - 3, turret.y - 20, 6, 15);
        
        // Icon
        ctx.shadowBlur = 0;
        ctx.fillStyle = "#ffffff";
        ctx.font = "14px Arial";
        ctx.textAlign = "center";
        ctx.fillText(turret.type === 'shield' ? "üõ°Ô∏è" : "‚öîÔ∏è", turret.x, turret.y + 5);
        
        // Level indicator
        if (turret.upgradeLevel > 0) {
          ctx.fillStyle = "#ffff00";
          ctx.font = "bold 10px 'Courier New'";
          ctx.fillText(`Lv${turret.upgradeLevel}`, turret.x, turret.y - 25);
        }
        
        ctx.restore();
      });
    }
    
    function drawRootBarriers() {
      rootBarriers.forEach(root => {
        ctx.save();
        
        // Root visual
        ctx.fillStyle = "#228B22";
        ctx.shadowBlur = 8;
        ctx.shadowColor = "#00ff00";
        
        for (let i = 0; i < root.w; i += 10) {
          const height = 15 + Math.sin(Date.now() / 200 + i) * 5;
          ctx.fillRect(root.x + i, root.y + root.h - height, 8, height);
        }
        
        ctx.shadowBlur = 0;
        
        // Level indicator
        if (root.upgradeLevel > 0) {
          ctx.fillStyle = "#ffff00";
          ctx.font = "bold 10px 'Courier New'";
          ctx.textAlign = "center";
          ctx.fillText(`Lv${root.upgradeLevel}`, root.x + root.w / 2, root.y - 5);
        }
        
        ctx.restore();
      });
    }

    function draw() {
      // Only draw game elements when actually playing
      if (!gameRunning || gameState === "title") {
        return;
      }
      
      ctx.save();
      if (screenShake > 0) {
        const shakeX = (Math.random() - 0.5) * screenShake;
        const shakeY = (Math.random() - 0.5) * screenShake;
        ctx.translate(shakeX, shakeY);
      }

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      drawBackground();
      drawGround();
      drawFireZones();
      drawRootBarriers();
      drawTurrets();
      if (player) drawPlayer();
      drawMiniSun(); // Dr.Sunshine's mini sun
      drawEclipseMoon(); // Dr.Eclipse's moon
      drawIllusionistClone(); // Illusionist's clone
      drawEnemies();
      drawProjectiles();
      drawMinions();
      drawHelperStars();
      drawParticles();
      drawFloatingTexts();
      drawCurrency();
      drawHUD();
      
      // Special ability visual effects
      drawAbilityEffects();

      ctx.restore();
      
      // Draw UI overlays (not affected by screen shake)
      if (upgradePopup.active) drawUpgradePopup();
      if (turretCraftUI.active) drawTurretCraftUI();
    }

    function gameLoop(timestamp) {
      const baseDt = Math.min((timestamp - lastTime) / 1000, 0.1);
      const dt = baseDt * gameSpeed; // Apply game speed multiplier
      lastTime = timestamp;

      if (gameRunning && !gamePaused) {
        update(dt);
      }
      
      draw();
      requestAnimationFrame(gameLoop);
    }

    // Load character sprites
    loadCharacterSprites();

    // Start draw loop
    draw();
  </script>
</body>
</html>