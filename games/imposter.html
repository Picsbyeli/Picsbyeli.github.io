<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chameleon Game - Multiplayer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            max-width: 800px;
            width: 90%;
            text-align: center;
        }

        h1 {
            color: #333;
            margin-bottom: 20px;
            font-size: 2.5em;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .screen {
            display: none;
        }

        .screen.active {
            display: block;
        }

        .input-group {
            margin: 20px 0;
        }

        .input-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: #333;
        }

        input[type="text"] {
            width: 100%;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 16px;
            border-radius: 10px;
            cursor: pointer;
            margin: 10px;
            transition: transform 0.2s;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: linear-gradient(45deg, #ffeaa7, #fab1a0);
        }

        .btn-danger {
            background: linear-gradient(45deg, #fd79a8, #e84393);
        }

        .room-code {
            background: #f8f9fa;
            border: 2px dashed #667eea;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            font-size: 1.5em;
            font-weight: bold;
            color: #667eea;
        }

        .players-list {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: left;
        }

        .player-item {
            padding: 10px;
            margin: 5px 0;
            background: white;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .game-info {
            background: #e8f4f8;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .word-chart {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .word-cell {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            transition: all 0.3s;
        }

        .word-cell.highlighted {
            background: #ffeb3b;
            border: 3px solid #ff5722;
            font-weight: bold;
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(255, 87, 34, 0.3);
        }

        .category-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .category-btn {
            padding: 20px;
            background: linear-gradient(45deg, #00cec9, #55a3ff);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: transform 0.2s;
        }

        .category-btn:hover {
            transform: translateY(-2px);
        }

        .category-btn.voted {
            background: linear-gradient(45deg, #fdcb6e, #e17055);
        }

        .clue-item {
            background: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            border-left: 4px solid #00cec9;
            text-align: left;
        }

        .voting-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .vote-btn {
            padding: 15px;
            background: linear-gradient(45deg, #00cec9, #55a3ff);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            transition: transform 0.2s;
        }

        .vote-btn:hover {
            transform: translateY(-2px);
        }

        .results {
            background: #dff0d8;
            border: 1px solid #d6e9c6;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .error {
            background: #f2dede;
            border: 1px solid #ebccd1;
            color: #a94442;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }

        .status {
            background: #d9edf7;
            border: 1px solid #bce8f1;
            color: #31708f;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }

        .turn-indicator {
            background: #fff3cd;
            border: 2px solid #ffc107;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            font-weight: bold;
        }

        .category-votes {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .timer-display {
            background: linear-gradient(45deg, #ff6b6b, #ee5a6f);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            font-size: 2em;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(255, 107, 107, 0.3);
        }

        .timer-display.warning {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .vote-count {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            margin-left: 10px;
            font-size: 14px;
        }

        .final-guess-container {
            background: #fff3cd;
            border: 3px solid #ffc107;
            padding: 25px;
            border-radius: 15px;
            margin: 20px 0;
        }

        .final-guess-container h3 {
            color: #856404;
            margin-bottom: 15px;
        }

        .scoreboard {
            background: #e8f5e9;
            border: 2px solid #4caf50;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            margin: 5px 0;
            background: white;
            border-radius: 8px;
        }

        .score-value {
            font-weight: bold;
            color: #4caf50;
            font-size: 1.2em;
        }

        .bonus-points {
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #333;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: bold;
            display: inline-block;
            margin: 10px 0;
        }

        .back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255,255,255,0.2);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .back-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-btn">‚Üê Back to Games</a>
    
    <div class="game-container">
        <h1>ü¶é Chameleon Game</h1>
        <p class="subtitle">Word Chart Edition</p>

        <!-- Home Screen -->
        <div id="home-screen" class="screen active">
            <div class="input-group">
                <label for="player-name">Your Name:</label>
                <input type="text" id="player-name" placeholder="Enter your name" maxlength="20">
            </div>
            
            <button class="btn" onclick="showCreateRoom()">üéÆ Create New Game Room</button>
            <button class="btn btn-secondary" onclick="showJoinRoom()">üö™ Join Existing Room</button>
            
            <div class="status">
                <strong>How to Play:</strong><br>
                1. Create or join a room<br>
                2. Vote on a category together<br>
                3. Everyone sees a chart with 20 words<br>
                4. One word is highlighted (except for the chameleon!)<br>
                5. Take turns giving clues about the word<br>
                6. Vote to find the chameleon<br>
                7. Caught chameleon gets one final guess for bonus points!
            </div>
        </div>

        <!-- Create Room Screen -->
        <div id="create-room-screen" class="screen">
            <h2>Create Game Room</h2>
            <button class="btn" onclick="createRoom()">üé≤ Generate Room Code</button>
            <button class="btn btn-secondary" onclick="showHome()">‚Üê Back</button>
        </div>

        <!-- Join Room Screen -->
        <div id="join-room-screen" class="screen">
            <h2>Join Game Room</h2>
            <div class="input-group">
                <label for="room-code-input">Room Code:</label>
                <input type="text" id="room-code-input" placeholder="Enter room code" maxlength="6">
            </div>
            <button class="btn" onclick="joinRoom()">üö™ Join Room</button>
            <button class="btn btn-secondary" onclick="showHome()">‚Üê Back</button>
        </div>

        <!-- Waiting Room Screen -->
        <div id="waiting-room-screen" class="screen">
            <h2>Game Room</h2>
            <div class="room-code">
                Room Code: <span id="current-room-code"></span>
            </div>
            
            <div class="players-list">
                <h3>Players in Room:</h3>
                <div id="players-container"></div>
            </div>
            
            <button class="btn" onclick="startGame()" id="start-game-btn">üéÆ Start Game</button>
            <button class="btn btn-danger" onclick="leaveRoom()">üö™ Leave Room</button>
        </div>

        <!-- Category Voting Screen -->
        <div id="category-screen" class="screen">
            <h2>üìä Vote for a Category</h2>
            <p>Choose which category you want to play with:</p>
            
            <div class="timer-display" id="category-timer">30</div>
            
            <div class="category-votes" id="category-votes-display"></div>
            
            <div class="category-grid" id="category-container"></div>
            
            <div class="status">Vote now! Game starts when everyone votes or timer expires...</div>
        </div>

        <!-- Game Screen -->
        <div id="game-screen" class="screen">
            <div class="game-info">
                <h3 id="game-phase">Game in Progress</h3>
                <div id="role-info"></div>
            </div>

            <!-- Word Chart Display -->
            <div id="word-chart-container">
                <h3 id="chart-title">Word Chart</h3>
                <div class="word-chart" id="word-chart"></div>
            </div>

            <!-- Turn Indicator -->
            <div id="turn-indicator" class="turn-indicator" style="display: none;"></div>

            <!-- Clue Submission Phase -->
            <div id="clue-phase" style="display: none;">
                <div class="input-group">
                    <input type="text" id="clue-input" placeholder="Enter your clue" maxlength="50">
                </div>
                <button class="btn" onclick="submitClue()">üìù Submit Clue</button>
            </div>

            <!-- Clues Display -->
            <div id="clues-display" style="display: none;">
                <h3>Submitted Clues:</h3>
                <div id="clues-container"></div>
            </div>

            <!-- Voting Phase -->
            <div id="voting-phase" style="display: none;">
                <h3>Vote for the Chameleon!</h3>
                <p>Who do you think doesn't know the secret word?</p>
                <div class="voting-grid" id="voting-container"></div>
            </div>

            <!-- Final Guess Phase -->
            <div id="final-guess-phase" style="display: none;">
                <div class="final-guess-container">
                    <h3>üéØ Chameleon's Last Chance!</h3>
                    <p id="final-guess-message"></p>
                    <div class="input-group" id="imposter-guess-input" style="display: none;">
                        <input type="text" id="guess-input" placeholder="Enter your guess for the secret word" maxlength="50">
                        <button class="btn" onclick="submitFinalGuess()">üé≤ Submit Guess</button>
                    </div>
                    <div id="waiting-for-guess" style="display: none;">
                        <p>‚è≥ Waiting for the chameleon to make their final guess...</p>
                    </div>
                </div>
            </div>

            <!-- Results Phase -->
            <div id="results-phase" style="display: none;">
                <div class="scoreboard" id="scoreboard-display"></div>
                <div class="results" id="game-results"></div>
                <button class="btn" onclick="playAgain()">üéÆ Play Again</button>
                <button class="btn btn-secondary" onclick="leaveRoom()">üö™ Leave Game</button>
            </div>
        </div>

        <div id="error-message" class="error" style="display: none;"></div>
        <div id="status-message" class="status" style="display: none;"></div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

    <script>
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBFBrWDLyNPHHwnllI9Pz4-QlNhylP3ub4",
            authDomain: "imposters-912d1.firebaseapp.com",
            databaseURL: "https://imposters-912d1-default-rtdb.firebaseio.com",
            projectId: "imposters-912d1",
            storageBucket: "imposters-912d1.firebasestorage.app",
            messagingSenderId: "558821621021",
            appId: "1:558821621021:web:c31a12816dbed520c2b5f4",
            measurementId: "G-QR5RP6JJ8D"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();

        // Game state
        let currentRoom = null;
        let currentPlayer = null;
        let gameState = null;
        let categoryTimerInterval = null;
        let votingEndTime = null;

        // Word categories with 20 words each
        const categories = {
            'Movies': [
                'Jurassic Park', 'Jaws', 'Raiders of the Lost Ark', 'The Avengers',
                'Transformers', 'Toy Story', 'Home Alone', 'Titanic',
                'E.T.', 'The Wizard of Oz', 'King Kong', 'The Matrix',
                'Shrek', 'The Godfather', 'Finding Nemo', 'Avatar',
                'Frozen', 'Star Wars', 'Harry Potter', 'The Lion King'
            ],
            'Food': [
                'Pizza', 'Burger', 'Sushi', 'Tacos',
                'Pasta', 'Ice Cream', 'Chocolate', 'Salad',
                'Steak', 'Chicken', 'Rice', 'Bread',
                'Cheese', 'Eggs', 'Bacon', 'Pancakes',
                'Soup', 'Sandwich', 'Cookies', 'Cake'
            ],
            'Vacation Spots': [
                'Paris', 'Tokyo', 'New York', 'London',
                'Hawaii', 'Bali', 'Rome', 'Dubai',
                'Sydney', 'Barcelona', 'Maldives', 'Iceland',
                'Egypt', 'Greece', 'Thailand', 'Switzerland',
                'Venice', 'Amsterdam', 'Prague', 'Santorini'
            ],
            'Famous Characters': [
                'Mickey Mouse', 'Superman', 'Batman', 'Spider-Man',
                'Mario', 'Pikachu', 'Elsa', 'Darth Vader',
                'Iron Man', 'Wonder Woman', 'Hulk', 'Thor',
                'Captain America', 'Yoda', 'Simba', 'Buzz Lightyear',
                'Sonic', 'Link', 'Pac-Man', 'Snoopy'
            ],
            'Sports': [
                'Soccer', 'Basketball', 'Tennis', 'Baseball',
                'Football', 'Swimming', 'Golf', 'Volleyball',
                'Boxing', 'Hockey', 'Cricket', 'Rugby',
                'Skiing', 'Surfing', 'Cycling', 'Running',
                'Gymnastics', 'Wrestling', 'Bowling', 'Skateboarding'
            ],
            'Animals': [
                'Lion', 'Elephant', 'Giraffe', 'Dolphin',
                'Panda', 'Tiger', 'Penguin', 'Kangaroo',
                'Koala', 'Zebra', 'Monkey', 'Eagle',
                'Shark', 'Bear', 'Wolf', 'Fox',
                'Owl', 'Turtle', 'Butterfly', 'Octopus'
            ]
        };

        // Utility functions
        function generateRoomCode() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById(screenId).classList.add('active');
        }

        function showError(message) {
            const errorEl = document.getElementById('error-message');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
            setTimeout(() => errorEl.style.display = 'none', 5000);
        }

        function showStatus(message) {
            const statusEl = document.getElementById('status-message');
            statusEl.textContent = message;
            statusEl.style.display = 'block';
            setTimeout(() => statusEl.style.display = 'none', 3000);
        }

        // Screen navigation
        function showHome() {
            showScreen('home-screen');
            if (currentRoom) leaveRoom();
        }

        function showCreateRoom() {
            const playerName = document.getElementById('player-name').value.trim();
            if (!playerName) {
                showError('Please enter your name first!');
                return;
            }
            currentPlayer = { id: Date.now().toString(), name: playerName };
            showScreen('create-room-screen');
        }

        function showJoinRoom() {
            const playerName = document.getElementById('player-name').value.trim();
            if (!playerName) {
                showError('Please enter your name first!');
                return;
            }
            currentPlayer = { id: Date.now().toString(), name: playerName };
            showScreen('join-room-screen');
        }

        // Room management
        async function createRoom() {
            try {
                const roomCode = generateRoomCode();
                const roomData = {
                    code: roomCode,
                    host: currentPlayer.id,
                    players: { [currentPlayer.id]: currentPlayer },
                    phase: 'waiting',
                    createdAt: firebase.database.ServerValue.TIMESTAMP
                };

                await database.ref(`rooms/${roomCode}`).set(roomData);
                currentRoom = roomCode;
                listenToRoom(roomCode);
                
                document.getElementById('current-room-code').textContent = roomCode;
                showScreen('waiting-room-screen');
                showStatus('Room created successfully!');
            } catch (error) {
                showError('Failed to create room: ' + error.message);
            }
        }

        async function joinRoom() {
            try {
                const roomCode = document.getElementById('room-code-input').value.trim().toUpperCase();
                if (!roomCode) {
                    showError('Please enter a room code!');
                    return;
                }

                const roomSnapshot = await database.ref(`rooms/${roomCode}`).once('value');
                if (!roomSnapshot.exists()) {
                    showError('Room not found!');
                    return;
                }

                await database.ref(`rooms/${roomCode}/players/${currentPlayer.id}`).set(currentPlayer);
                currentRoom = roomCode;
                listenToRoom(roomCode);
                
                document.getElementById('current-room-code').textContent = roomCode;
                showScreen('waiting-room-screen');
                showStatus('Joined room successfully!');
            } catch (error) {
                showError('Failed to join room: ' + error.message);
            }
        }

        function listenToRoom(roomCode) {
            database.ref(`rooms/${roomCode}`).on('value', (snapshot) => {
                if (!snapshot.exists()) {
                    showError('Room has been deleted!');
                    showHome();
                    return;
                }

                const roomData = snapshot.val();
                updatePlayersDisplay(roomData.players || {});
                
                // Handle different phases
                if (roomData.phase === 'waiting') {
                    // Show waiting room
                    if (document.getElementById('waiting-room-screen').classList.contains('active')) {
                        // Already on waiting screen, just update
                    }
                } else if (roomData.phase === 'category-voting') {
                    // Show category voting for ALL players
                    displayCategoryVoting(roomData);
                } else if (roomData.phase === 'game' && roomData.gameState) {
                    // Show game screen for ALL players
                    gameState = roomData.gameState;
                    if (!document.getElementById('game-screen').classList.contains('active')) {
                        showScreen('game-screen');
                    }
                    updateGameDisplay();
                }

                const startBtn = document.getElementById('start-game-btn');
                if (startBtn) {
                    startBtn.style.display = roomData.host === currentPlayer.id ? 'block' : 'none';
                }
            });
        }

        function updatePlayersDisplay(players) {
            const container = document.getElementById('players-container');
            if (!container) return;

            container.innerHTML = '';
            Object.values(players).forEach(player => {
                const playerEl = document.createElement('div');
                playerEl.className = 'player-item';
                playerEl.innerHTML = `<strong>${player.name}</strong>${player.id === currentPlayer.id ? ' (You)' : ''}`;
                container.appendChild(playerEl);
            });
        }

        async function startGame() {
            try {
                if (!currentRoom) return;

                const roomSnapshot = await database.ref(`rooms/${currentRoom}`).once('value');
                const roomData = roomSnapshot.val();
                const players = Object.values(roomData.players || {});

                if (players.length < 3) {
                    showError('Need at least 3 players to start!');
                    return;
                }

                // Get server timestamp and calculate voting end time (30 seconds from now)
                const serverTimeOffset = await getServerTimeOffset();
                const votingEndTimestamp = Date.now() + serverTimeOffset + 30000; // 30 seconds

                await database.ref(`rooms/${currentRoom}`).update({
                    phase: 'category-voting',
                    categoryVotes: {},
                    votingEndTime: votingEndTimestamp
                });

                showScreen('category-screen');
                displayCategoryOptions();
            } catch (error) {
                showError('Failed to start game: ' + error.message);
            }
        }

        async function getServerTimeOffset() {
            const offsetRef = database.ref('.info/serverTimeOffset');
            const snapshot = await offsetRef.once('value');
            return snapshot.val() || 0;
        }

        function displayCategoryOptions() {
            const container = document.getElementById('category-container');
            container.innerHTML = '';

            Object.keys(categories).forEach(category => {
                const btn = document.createElement('button');
                btn.className = 'category-btn';
                btn.textContent = category;
                btn.onclick = () => voteCategory(category);
                container.appendChild(btn);
            });
        }

        async function voteCategory(category) {
            try {
                await database.ref(`rooms/${currentRoom}/categoryVotes/${currentPlayer.id}`).set({
                    category: category,
                    voterName: currentPlayer.name
                });

                showStatus(`Voted for ${category}!`);

                // Check if all players have voted
                const roomSnapshot = await database.ref(`rooms/${currentRoom}`).once('value');
                const roomData = roomSnapshot.val();
                const playerCount = Object.keys(roomData.players || {}).length;
                const voteCount = Object.keys(roomData.categoryVotes || {}).length;

                // If everyone voted, start game immediately (only host triggers this)
                if (voteCount >= playerCount && roomData.host === currentPlayer.id) {
                    if (categoryTimerInterval) {
                        clearInterval(categoryTimerInterval);
                        categoryTimerInterval = null;
                    }
                    setTimeout(() => determineCategory(roomData.categoryVotes), 1000);
                }
            } catch (error) {
                showError('Failed to vote: ' + error.message);
            }
        }

        function displayCategoryVoting(roomData) {
            // ALWAYS show category screen for ALL players when in this phase
            if (!document.getElementById('category-screen').classList.contains('active')) {
                showScreen('category-screen');
            }
            
            // Start timer if not already running
            if (!categoryTimerInterval && roomData.votingEndTime) {
                startCategoryTimer(roomData.votingEndTime);
            }
            
            const votesDisplay = document.getElementById('category-votes-display');
            if (!votesDisplay) return;

            const votes = roomData.categoryVotes || {};
            const voteCounts = {};

            Object.values(votes).forEach(vote => {
                voteCounts[vote.category] = (voteCounts[vote.category] || 0) + 1;
            });

            votesDisplay.innerHTML = '<h4>Current Votes:</h4>';
            if (Object.keys(voteCounts).length === 0) {
                votesDisplay.innerHTML += '<p>No votes yet...</p>';
            } else {
                Object.entries(voteCounts).forEach(([cat, count]) => {
                    votesDisplay.innerHTML += `<p>${cat}: <span class="vote-count">${count}</span></p>`;
                });
            }

            // Make sure category options are displayed
            if (document.getElementById('category-container').children.length === 0) {
                displayCategoryOptions();
            }
        }

        function startCategoryTimer(endTime) {
            const timerDisplay = document.getElementById('category-timer');
            
            if (categoryTimerInterval) {
                clearInterval(categoryTimerInterval);
            }

            categoryTimerInterval = setInterval(() => {
                const now = Date.now();
                const timeLeft = Math.max(0, Math.ceil((endTime - now) / 1000));
                
                if (timerDisplay) {
                    timerDisplay.textContent = `${timeLeft}s`;
                    
                    if (timeLeft <= 10) {
                        timerDisplay.classList.add('warning');
                    } else {
                        timerDisplay.classList.remove('warning');
                    }
                }

                if (timeLeft <= 0) {
                    clearInterval(categoryTimerInterval);
                    categoryTimerInterval = null;
                    
                    // Only host should trigger the category determination
                    database.ref(`rooms/${currentRoom}/host`).once('value', (snapshot) => {
                        if (snapshot.val() === currentPlayer.id) {
                            finalizeCategoryVoting();
                        }
                    });
                }
            }, 100);
        }

        async function finalizeCategoryVoting() {
            try {
                const roomSnapshot = await database.ref(`rooms/${currentRoom}`).once('value');
                const roomData = roomSnapshot.val();
                const votes = roomData.categoryVotes || {};

                if (Object.keys(votes).length === 0) {
                    // No votes, pick random category
                    const categories = Object.keys(categories);
                    const randomCategory = categories[Math.floor(Math.random() * categories.length)];
                    await determineCategory({ [currentPlayer.id]: { category: randomCategory } });
                } else {
                    await determineCategory(votes);
                }
            } catch (error) {
                console.error('Error finalizing category voting:', error);
            }
        }

        async function determineCategory(votes) {
            const voteCounts = {};
            Object.values(votes).forEach(vote => {
                voteCounts[vote.category] = (voteCounts[vote.category] || 0) + 1;
            });

            // Find category with most votes
            let winningCategory = null;
            let maxVotes = 0;
            
            Object.entries(voteCounts).forEach(([cat, count]) => {
                if (count > maxVotes) {
                    maxVotes = count;
                    winningCategory = cat;
                }
            });

            // If no winner (tie or no votes), pick random
            if (!winningCategory) {
                const categoryKeys = Object.keys(categories);
                winningCategory = categoryKeys[Math.floor(Math.random() * categoryKeys.length)];
            }

            const roomSnapshot = await database.ref(`rooms/${currentRoom}`).once('value');
            const roomData = roomSnapshot.val();
            const players = Object.keys(roomData.players || {});
            
            const detective = players[0];
            const imposter = players[Math.floor(Math.random() * players.length)];
            const words = categories[winningCategory];
            const secretWord = words[Math.floor(Math.random() * words.length)];

            const newGameState = {
                phase: 'clue-submission',
                category: winningCategory,
                words: words,
                players: roomData.players,
                detective: detective,
                imposter: imposter,
                secretWord: secretWord,
                clues: [],
                currentTurn: 0,
                turnOrder: players.filter(p => p !== detective),
                votes: {},
                startedAt: firebase.database.ServerValue.TIMESTAMP
            };

            // Clear timer
            if (categoryTimerInterval) {
                clearInterval(categoryTimerInterval);
                categoryTimerInterval = null;
            }

            // Update Firebase - this will trigger all clients to update via the listener
            await database.ref(`rooms/${currentRoom}`).update({
                phase: 'game',
                gameState: newGameState,
                votingEndTime: null
            });

            // The listenToRoom function will handle showing the game screen for all players
        }

        function updateGameDisplay() {
            if (!gameState || !currentPlayer) return;

            const phaseEl = document.getElementById('game-phase');
            const roleEl = document.getElementById('role-info');

            displayWordChart();

            document.querySelectorAll('#game-screen > div[id*="-phase"]').forEach(el => {
                el.style.display = 'none';
            });

            switch (gameState.phase) {
                case 'clue-submission':
                    phaseEl.textContent = `Category: ${gameState.category}`;
                    
                    if (gameState.detective === currentPlayer.id) {
                        roleEl.innerHTML = '<strong>üîç You are the Detective!</strong> Watch the clues carefully!';
                        document.getElementById('clue-phase').style.display = 'none';
                    } else {
                        if (gameState.imposter === currentPlayer.id) {
                            roleEl.innerHTML = '<strong>ü¶é You are the Chameleon!</strong> Try to blend in!';
                        } else {
                            roleEl.innerHTML = '<strong>‚úÖ You know the secret word!</strong> Give helpful clues!';
                        }

                        const currentTurnPlayer = gameState.turnOrder[gameState.currentTurn];
                        const turnIndicator = document.getElementById('turn-indicator');
                        
                        if (currentTurnPlayer === currentPlayer.id) {
                            turnIndicator.textContent = "üéØ It's your turn to give a clue!";
                            turnIndicator.style.display = 'block';
                            document.getElementById('clue-phase').style.display = 'block';
                        } else {
                            const playerName = gameState.players[currentTurnPlayer]?.name || 'Someone';
                            turnIndicator.textContent = `‚è≥ Waiting for ${playerName} to give a clue...`;
                            turnIndicator.style.display = 'block';
                            document.getElementById('clue-phase').style.display = 'none';
                        }
                    }

                    if (gameState.clues && gameState.clues.length > 0) {
                        displayClues();
                    }
                    break;

                case 'voting':
                    phaseEl.textContent = 'Voting Phase';
                    document.getElementById('voting-phase').style.display = 'block';
                    displayVoting();
                    displayClues();
                    document.getElementById('turn-indicator').style.display = 'none';
                    break;

                case 'final-guess':
                    phaseEl.textContent = "Imposter's Last Chance!";
                    document.getElementById('final-guess-phase').style.display = 'block';
                    displayFinalGuessPhase();
                    displayClues();
                    document.getElementById('turn-indicator').style.display = 'none';
                    break;

                case 'results':
                    phaseEl.textContent = 'Game Results';
                    document.getElementById('results-phase').style.display = 'block';
                    displayScoreboard();
                    displayResults();
                    document.getElementById('turn-indicator').style.display = 'none';
                    break;
            }
        }

        function displayWordChart() {
            const chartContainer = document.getElementById('word-chart');
            const chartTitle = document.getElementById('chart-title');
            
            if (!chartContainer || !gameState) return;

            chartTitle.textContent = `${gameState.category} - Word Chart`;
            chartContainer.innerHTML = '';

            gameState.words.forEach(word => {
                const cell = document.createElement('div');
                cell.className = 'word-cell';
                cell.textContent = word;
                
                if (word === gameState.secretWord && gameState.imposter !== currentPlayer.id) {
                    cell.classList.add('highlighted');
                }
                
                chartContainer.appendChild(cell);
            });
        }

        async function submitClue() {
            try {
                const clueInput = document.getElementById('clue-input');
                const clue = clueInput.value.trim();
                
                if (!clue) {
                    showError('Please enter a clue!');
                    return;
                }

                const clueData = {
                    playerId: currentPlayer.id,
                    playerName: currentPlayer.name,
                    clue: clue,
                    submittedAt: firebase.database.ServerValue.TIMESTAMP
                };

                const newClues = [...(gameState.clues || []), clueData];
                const nextTurn = gameState.currentTurn + 1;

                if (nextTurn >= gameState.turnOrder.length) {
                    await database.ref(`rooms/${currentRoom}/gameState`).update({
                        clues: newClues,
                        phase: 'voting'
                    });
                } else {
                    await database.ref(`rooms/${currentRoom}/gameState`).update({
                        clues: newClues,
                        currentTurn: nextTurn
                    });
                }

                clueInput.value = '';
                showStatus('Clue submitted!');
            } catch (error) {
                showError('Failed to submit clue: ' + error.message);
            }
        }

        function displayClues() {
            const container = document.getElementById('clues-container');
            const display = document.getElementById('clues-display');
            
            if (!container || !gameState.clues) return;

            container.innerHTML = '';
            gameState.clues.forEach(clueData => {
                const clueEl = document.createElement('div');
                clueEl.className = 'clue-item';
                clueEl.innerHTML = `<strong>${clueData.playerName}:</strong> "${clueData.clue}"`;
                container.appendChild(clueEl);
            });

            display.style.display = 'block';
        }

        function displayVoting() {
            const container = document.getElementById('voting-container');
            if (!container || !gameState.players) return;

            container.innerHTML = '';
            Object.values(gameState.players).forEach(player => {
                if (player.id === currentPlayer.id) return;

                const voteBtn = document.createElement('button');
                voteBtn.className = 'vote-btn';
                voteBtn.textContent = `Vote for ${player.name}`;
                voteBtn.onclick = () => submitVote(player.id);
                
                if (gameState.votes && gameState.votes[currentPlayer.id]) {
                    voteBtn.disabled = true;
                    if (gameState.votes[currentPlayer.id].votedFor === player.id) {
                        voteBtn.textContent = `‚úì Voted for ${player.name}`;
                    }
                }
                
                container.appendChild(voteBtn);
            });
        }

        async function submitVote(playerId) {
            try {
                const voteData = {
                    votedFor: playerId,
                    voterName: currentPlayer.name
                };

                await database.ref(`rooms/${currentRoom}/gameState/votes/${currentPlayer.id}`).set(voteData);
                showStatus('Vote submitted!');

                const playerCount = Object.keys(gameState.players).length;
                const voteCount = Object.keys(gameState.votes || {}).length + 1;
                
                if (voteCount >= playerCount) {
                    setTimeout(() => calculateResults(), 2000);
                }
            } catch (error) {
                showError('Failed to submit vote: ' + error.message);
            }
        }

        async function calculateResults() {
            try {
                const votes = gameState.votes || {};
                const voteCounts = {};

                Object.values(votes).forEach(vote => {
                    voteCounts[vote.votedFor] = (voteCounts[vote.votedFor] || 0) + 1;
                });

                let mostVotedPlayer = null;
                let maxVotes = 0;
                Object.entries(voteCounts).forEach(([playerId, count]) => {
                    if (count > maxVotes) {
                        maxVotes = count;
                        mostVotedPlayer = playerId;
                    }
                });

                if (mostVotedPlayer === gameState.imposter) {
                    await database.ref(`rooms/${currentRoom}/gameState`).update({
                        phase: 'final-guess',
                        votingResults: {
                            mostVotedPlayer,
                            voteCounts,
                            imposterCaught: true
                        }
                    });
                } else {
                    await finalizeResults(mostVotedPlayer, voteCounts, false, null);
                }
            } catch (error) {
                showError('Failed to calculate results: ' + error.message);
            }
        }

        function displayFinalGuessPhase() {
            const messageEl = document.getElementById('final-guess-message');
            const guessInputDiv = document.getElementById('imposter-guess-input');
            const waitingDiv = document.getElementById('waiting-for-guess');

            if (currentPlayer.id === gameState.imposter) {
                messageEl.innerHTML = `<strong>You were caught!</strong><br>You have one last chance to guess the secret word and win bonus points!`;
                guessInputDiv.style.display = 'block';
                waitingDiv.style.display = 'none';
            } else {
                const chameleonName = gameState.players[gameState.imposter]?.name || 'The chameleon';
                messageEl.innerHTML = `<strong>${chameleonName} was caught!</strong><br>They have one last chance to guess the secret word.`;
                guessInputDiv.style.display = 'none';
                waitingDiv.style.display = 'block';
            }
        }

        async function submitFinalGuess() {
            try {
                const guessInput = document.getElementById('guess-input');
                const guess = guessInput.value.trim();

                if (!guess) {
                    showError('Please enter your guess!');
                    return;
                }

                const isCorrect = guess.toLowerCase() === gameState.secretWord.toLowerCase();

                await database.ref(`rooms/${currentRoom}/gameState/finalGuess`).set({
                    guess: guess,
                    isCorrect: isCorrect,
                    submittedAt: firebase.database.ServerValue.TIMESTAMP
                });

                guessInput.value = '';
                showStatus('Guess submitted!');

                setTimeout(() => {
                    finalizeResults(
                        gameState.votingResults.mostVotedPlayer,
                        gameState.votingResults.voteCounts,
                        true,
                        isCorrect
                    );
                }, 1000);
            } catch (error) {
                showError('Failed to submit guess: ' + error.message);
            }
        }

        async function finalizeResults(mostVotedPlayer, voteCounts, imposterCaught, imposterGuessedCorrect) {
            try {
                let winner;
                let pointsAwarded = {};

                Object.keys(gameState.players).forEach(playerId => {
                    pointsAwarded[playerId] = 0;
                });

                if (!imposterCaught) {
                    winner = 'imposter';
                    pointsAwarded[gameState.imposter] = 2;
                } else if (imposterGuessedCorrect) {
                    winner = 'imposter';
                    pointsAwarded[gameState.imposter] = 3;
                } else {
                    winner = 'detectives';
                    Object.keys(gameState.players).forEach(playerId => {
                        if (playerId !== gameState.imposter) {
                            pointsAwarded[playerId] = 1;
                        }
                    });
                }

                const results = {
                    mostVotedPlayer,
                    imposter: gameState.imposter,
                    detective: gameState.detective,
                    secretWord: gameState.secretWord,
                    category: gameState.category,
                    voteCounts,
                    winner,
                    imposterCaught,
                    imposterGuessedCorrect,
                    finalGuess: gameState.finalGuess?.guess || null,
                    pointsAwarded
                };

                const currentScores = (await database.ref(`rooms/${currentRoom}/scores`).once('value')).val() || {};
                Object.keys(pointsAwarded).forEach(playerId => {
                    currentScores[playerId] = (currentScores[playerId] || 0) + pointsAwarded[playerId];
                });

                await database.ref(`rooms/${currentRoom}`).update({ scores: currentScores });
                await database.ref(`rooms/${currentRoom}/gameState`).update({
                    phase: 'results',
                    results
                });
            } catch (error) {
                showError('Failed to finalize results: ' + error.message);
            }
        }

        function displayScoreboard() {
            const container = document.getElementById('scoreboard-display');
            if (!container) return;

            database.ref(`rooms/${currentRoom}/scores`).once('value', (snapshot) => {
                const scores = snapshot.val() || {};
                
                container.innerHTML = '<h3>üèÜ Scoreboard</h3>';
                
                const sortedScores = Object.entries(scores)
                    .map(([playerId, score]) => ({
                        playerId,
                        name: gameState.players[playerId]?.name || 'Unknown',
                        score
                    }))
                    .sort((a, b) => b.score - a.score);

                sortedScores.forEach(player => {
                    container.innerHTML += `
                        <div class="score-item">
                            <span><strong>${player.name}</strong></span>
                            <span class="score-value">${player.score} points</span>
                        </div>
                    `;
                });

                Object.values(gameState.players).forEach(player => {
                    if (!scores[player.id]) {
                        container.innerHTML += `
                            <div class="score-item">
                                <span><strong>${player.name}</strong></span>
                                <span class="score-value">0 points</span>
                            </div>
                        `;
                    }
                });
            });
        }

        function displayResults() {
            const container = document.getElementById('game-results');
            if (!container || !gameState.results) return;

            const results = gameState.results;
            const chameleonName = gameState.players[results.imposter]?.name || 'Unknown';
            const mostVotedName = gameState.players[results.mostVotedPlayer]?.name || 'Unknown';

            let resultHTML = `
                <h3>üéâ Round Results</h3>
                <p><strong>Category:</strong> ${results.category}</p>
                <p><strong>Secret Word:</strong> ${results.secretWord}</p>
                <p><strong>The Chameleon was:</strong> ${chameleonName}</p>
                <p><strong>Most Voted Player:</strong> ${mostVotedName}</p>
            `;

            if (results.imposterCaught) {
                resultHTML += `<p>‚úÖ <strong>The chameleon was caught!</strong></p>`;
                
                if (results.imposterGuessedCorrect) {
                    resultHTML += `
                        <div class="bonus-points">
                            üéØ ${chameleonName} guessed "${results.finalGuess}" correctly!<br>
                            +3 BONUS POINTS!
                        </div>
                        <p><strong>Winner:</strong> ü¶é ${chameleonName} (Chameleon)</p>
                    `;
                } else {
                    resultHTML += `
                        <p>‚ùå ${chameleonName} guessed "${results.finalGuess}" - Incorrect!</p>
                        <p><strong>Winner:</strong> üïµÔ∏è Detectives Win! (+1 point each)</p>
                    `;
                }
            } else {
                resultHTML += `
                    <p>‚ùå <strong>The chameleon was NOT caught!</strong></p>
                    <p><strong>Winner:</strong> ü¶é ${chameleonName} (Chameleon) (+2 points)</p>
                `;
            }

            resultHTML += `
                <h4>Vote Results:</h4>
                ${Object.entries(results.voteCounts).map(([playerId, count]) => 
                    `<p>${gameState.players[playerId]?.name}: ${count} vote(s)</p>`
                ).join('')}
                
                <h4>Points This Round:</h4>
                ${Object.entries(results.pointsAwarded).map(([playerId, points]) => 
                    points > 0 ? `<p>${gameState.players[playerId]?.name}: +${points} point${points > 1 ? 's' : ''}</p>` : ''
                ).join('')}
            `;

            container.innerHTML = resultHTML;
        }

        async function playAgain() {
            try {
                // Clear any existing timer
                if (categoryTimerInterval) {
                    clearInterval(categoryTimerInterval);
                    categoryTimerInterval = null;
                }

                // Get server timestamp and calculate new voting end time
                const serverTimeOffset = await getServerTimeOffset();
                const votingEndTimestamp = Date.now() + serverTimeOffset + 30000;

                await database.ref(`rooms/${currentRoom}`).update({
                    phase: 'category-voting',
                    categoryVotes: {},
                    gameState: null,
                    votingEndTime: votingEndTimestamp
                });

                showScreen('category-screen');
                displayCategoryOptions();
                showStatus('Starting new round!');
            } catch (error) {
                showError('Failed to start new game: ' + error.message);
            }
        }

        async function leaveRoom() {
            try {
                // Clear timer
                if (categoryTimerInterval) {
                    clearInterval(categoryTimerInterval);
                    categoryTimerInterval = null;
                }

                if (currentRoom && currentPlayer) {
                    await database.ref(`rooms/${currentRoom}/players/${currentPlayer.id}`).remove();
                    
                    const roomSnapshot = await database.ref(`rooms/${currentRoom}/players`).once('value');
                    if (!roomSnapshot.exists() || Object.keys(roomSnapshot.val() || {}).length === 0) {
                        await database.ref(`rooms/${currentRoom}`).remove();
                    }
                }
                
                currentRoom = null;
                gameState = null;
                showHome();
                showStatus('Left the room');
            } catch (error) {
                showError('Failed to leave room: ' + error.message);
            }
        }

        window.addEventListener('beforeunload', () => {
            if (categoryTimerInterval) {
                clearInterval(categoryTimerInterval);
            }
            if (currentRoom && currentPlayer) {
                database.ref(`rooms/${currentRoom}/players/${currentPlayer.id}`).remove();
            }
        });
    </script>
</body>
</html>