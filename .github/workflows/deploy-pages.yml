name: Deploy to GitHub Pages

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      include_audio:
        description: 'Set to true to include and compress audio in the Pages publish (default: false)'
        required: false
        default: 'false'
      audio_bitrate:
        description: 'Bitrate to compress audio to (e.g., 64k, 96k). Used only when include_audio=true.'
        required: false
        default: '64k'

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pages: write
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit --no-fund

      - name: Build (if needed)
        run: |
          # If you have a build step (e.g., static site generator), run it here.
          # For a plain static site (HTML/CSS/JS) this can be a no-op.
          echo "No build step defined; publishing repo root"

      - name: Prepare Pages artifact
        env:
          INCLUDE_AUDIO: ${{ github.event.inputs.include_audio || 'false' }}
          AUDIO_BITRATE: ${{ github.event.inputs.audio_bitrate || '64k' }}
        run: |
          set -eux
          rm -rf ./.publish
          mkdir -p ./.publish
          # Copy the site files only by default. Audio is optional to keep Pages light.
          cp ./standalone.html ./.publish/ || true
          if [ -d ./assets ]; then
            mkdir -p ./.publish/assets
            # Copy css and other assets, but skip the audio directory by default
            if [ -d ./assets/css ]; then cp -r ./assets/css ./.publish/assets/; fi
            if [ -d ./assets/image ]; then cp -r ./assets/image ./.publish/assets/; fi
          fi

          # If the workflow was triggered with include_audio=true, compress and include audio
          if [ "${INCLUDE_AUDIO}" = "true" ] && [ -d ./assets/audio ]; then
            echo "Including audio files and compressing to bitrate: ${AUDIO_BITRATE}"
            # install ffmpeg (Ubuntu runner)
            apt-get update -y && apt-get install -y ffmpeg
            mkdir -p ./.publish/assets/audio
            for f in ./assets/audio/*; do
              if [ -f "$f" ]; then
                filename=$(basename "$f")
                # Re-encode to target bitrate and mono/downsample to reduce size
                ffmpeg -y -i "$f" -b:a "${AUDIO_BITRATE}" -ar 22050 -ac 1 ./.publish/assets/audio/"${filename}"
              fi
            done
          else
            echo "Skipping audio files (INCLUDE_AUDIO=${INCLUDE_AUDIO})"
          fi

      - name: Deploy to GitHub Pages (via peaceiris)
        uses: peaceiris/actions-gh-pages@v3
        with:
          publish_dir: ./.publish
          # Prefer the built-in GITHUB_TOKEN. If your repo has branch protections
          # that prevent token-based pushes, create a personal access token with
          # `repo` scope and store it as the secret `DEPLOY_PERSONAL_TOKEN`.
          # The action will use `personal_token` if provided, otherwise GITHUB_TOKEN.
          personal_token: ${{ secrets.DEPLOY_PERSONAL_TOKEN || secrets.GITHUB_TOKEN }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Purge Cloudflare cache (optional)
        if: ${{ env.CLOUDFLARE_API_TOKEN != '' && env.CLOUDFLARE_ZONE_ID != '' }}
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
        run: |
          echo "Purging Cloudflare cache for zone $CLOUDFLARE_ZONE_ID"
          set -euo pipefail
          ATTEMPTS=3
          for i in $(seq 1 $ATTEMPTS); do
            if curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/purge_cache" \
              -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data '{"purge_everything":true}' | jq -r '.success' | grep -q true; then
              echo "Cloudflare purge succeeded"; break
            else
              echo "Cloudflare purge attempt $i failed"
              if [ $i -lt $ATTEMPTS ]; then sleep $((2**i)); else echo "All attempts failed"; fi
            fi
          done

      - name: Call generic CDN purge webhook (optional)
        if: ${{ env.CDN_PURGE_URL != '' }}
        env:
          CDN_PURGE_URL: ${{ secrets.CDN_PURGE_URL }}
          CDN_PURGE_SECRET: ${{ secrets.CDN_PURGE_SECRET }}
        run: |
          echo "Calling CDN purge webhook"
          set -euo pipefail
          HEADER_ARGS=( -H 'Content-Type: application/json' )
          if [ -n "$CDN_PURGE_SECRET" ]; then
            HEADER_ARGS+=( -H "X-CDN-Purge-Secret: $CDN_PURGE_SECRET" )
          fi
          ATTEMPTS=3
          for i in $(seq 1 $ATTEMPTS); do
            if curl -s -X POST "$CDN_PURGE_URL" "${HEADER_ARGS[@]}" -d '{"source":"github-pages","ref":"'${GITHUB_REF}'"}' ; then
              echo "Webhook purge succeeded"; break
            else
              echo "Webhook purge attempt $i failed"
              if [ $i -lt $ATTEMPTS ]; then sleep $((2**i)); else echo "All attempts failed"; fi
            fi
          done
