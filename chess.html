<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chess vs Bot</title>

  <!-- Chessboard.js stylesheet (must load before board render) -->
  <link rel="stylesheet" href="https://unpkg.com/chessboardjs@1.0.0/www/css/chessboard-1.0.0.min.css">

  <style>
    :root { --bg:#0f1115; --panel:#181b22; --text:#e8e8ea; --accent:#6ee7b7; --subtle:#9aa1ad; }
    * { box-sizing:border-box; }
    body { margin:0; font-family:system-ui,sans-serif; background:var(--bg); color:var(--text); display:grid; place-items:center; min-height:100vh; padding:20px; }
    .wrap { width:min(1100px,95vw); display:grid; grid-template-columns:1fr 340px; gap:18px; }
    #board { width:100%; max-width:720px; border-radius:14px; overflow:hidden; box-shadow:0 10px 30px rgba(0,0,0,.35); }
    .side { background:var(--panel); border:1px solid #222733; border-radius:14px; padding:16px; position:relative; }
    h2 { margin:0 0 8px; font-size:20px; }
    .row { display:flex; gap:10px; align-items:center; margin:10px 0; flex-wrap:wrap; }
    .row-column { flex-direction:column; align-items:stretch; }
    select,button,input[type=number] { background:#12161f; color:var(--text); border:1px solid #262b38; border-radius:10px; padding:8px 10px; font-size:14px; }
    button { cursor:pointer; }
    button.primary { background:var(--accent); color:#0b1220; border:none; font-weight:700; }
    .log { height:220px; overflow:auto; font-family:monospace; background:#0d1117; border:1px solid #1f2430; border-radius:10px; padding:10px; font-size:13px; }
    .score { font-variant-numeric:tabular-nums; }
    .highlight-square { box-shadow:inset 0 0 3px 3px rgba(255,255,0,0.65); }
    .highlight-last { box-shadow:inset 0 0 3px 3px rgba(255,140,0,0.85); }
    @media (max-width:940px) { .wrap { grid-template-columns:1fr; } }
  </style>
</head>
<body>
  <div class="wrap">
    <div id="board" aria-label="Chess board" role="application"></div>

    <aside class="side" aria-label="Game controls and status">
      <h2>Play vs Bot</h2>

      <div class="row">
        <label for="color">Your side</label>
        <select id="color">
          <option value="white">White</option>
          <option value="black">Black</option>
        </select>
      </div>

      <div class="row">
        <label for="difficulty">Difficulty</label>
        <select id="difficulty">
          <option value="1">Easy</option>
          <option value="2">Medium</option>
          <option value="3">Hard</option>
          <option value="4">Expert</option>
        </select>
      </div>

      <div class="row">
        <button id="newgame" class="primary">New Game</button>
        <button id="undo">Undo</button>
        <button id="flip">Flip</button>
      </div>

      <div class="row">
        <label for="delay">Bot delay (ms)</label>
        <input id="delay" type="number" min="0" step="50" value="350">
      </div>

      <div class="row">Score: <span id="score" class="score">0.00</span></div>

      <div class="row row-column">
        <label>Move log</label>
        <div id="log" class="log" aria-live="polite"></div>
      </div>

      <div id="status" aria-live="polite" style="position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden;">
        Game status updates.
      </div>
    </aside>
  </div>

  <!-- Dependencies (order matters) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.13.4/chess.min.js"></script>
  <script src="https://unpkg.com/chessboardjs@1.0.0/www/js/chessboard-1.0.0.min.js"></script>

  <script>
    // Core state
    const game = new Chess();
    let board, thinking = false, humanColor = 'w';
    let lastMoveSquares = [], hintSquares = [];

    // Elements
    const colorSel = document.getElementById('color');
    const diffSel = document.getElementById('difficulty');
    const delayInput = document.getElementById('delay');
    const logEl = document.getElementById('log');
    const scoreEl = document.getElementById('score');
    const statusEl = document.getElementById('status');

    // Persistence helpers
    const LS = { set:(k,v)=>localStorage.setItem(k,v), get:(k,d)=>localStorage.getItem(k)||d };
    colorSel.value = LS.get('chess_color','white');
    diffSel.value = LS.get('chess_diff','2');
    delayInput.value = LS.get('chess_delay','350');

    function saveSettings(){
      LS.set('chess_color', colorSel.value);
      LS.set('chess_diff', diffSel.value);
      LS.set('chess_delay', delayInput.value);
    }

    // Evaluation
    const VALUES = { p:100, n:320, b:330, r:500, q:900, k:20000 };
    function evaluateBoard(c){
      if(c.isCheckmate()) return c.turn()==='w' ? -99999 : 99999;
      if(c.isDraw()) return 0;
      let sum=0; for(const row of c.board()) for(const p of row){ if(!p) continue; sum += (p.color==='w'?1:-1)*VALUES[p.type]; }
      return sum;
    }

    function updateEval(){ scoreEl.textContent = (evaluateBoard(game)/100).toFixed(2); }

    // Move highlighting
    function clearHintHighlights(){ hintSquares.forEach(s=>{ const el=document.querySelector(`#board .square-${s}`); if(el) el.classList.remove('highlight-square'); }); hintSquares=[]; }
    function clearLastHighlights(){ lastMoveSquares.forEach(s=>{ const el=document.querySelector(`#board .square-${s}`); if(el) el.classList.remove('highlight-last'); }); lastMoveSquares=[]; }
    function highlightMoves(square){ clearHintHighlights(); const moves = game.moves({ square, verbose:true }); moves.forEach(m=>{ const el=document.querySelector(`#board .square-${m.to}`); if(el){ el.classList.add('highlight-square'); hintSquares.push(m.to); } }); }
    function highlightLastMove(from,to){ clearLastHighlights(); [''+from,''+to].forEach(s=>{ const el=document.querySelector(`#board .square-${s}`); if(el){ el.classList.add('highlight-last'); lastMoveSquares.push(s); } }); }

    // Simple negamax search
    function negamax(c, depth){ if(depth===0 || c.game_over()) return evaluateBoard(c); let max=-Infinity; for(const m of c.moves()){ c.move(m); const val = -negamax(c, depth-1); c.undo(); if(val>max) max=val; } return max; }

    // Opening book (small seed)
    const openingBook = {
      'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1':'e4',
      'rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq - 0 1':'c5'
    };

    function botMove(){
      if(game.game_over()) { announceResult(); return; }
      thinking = true;
      saveSettings();
      const diff = parseInt(diffSel.value,10);
      // Opening shortcut
      const fenKey = game.fen().split(' ').slice(0,6).join(' '); // full FEN (safer for book)
      if(openingBook[fenKey]) {
        game.move(openingBook[fenKey]);
      } else {
        let best=null, max=-Infinity;
        for(const m of game.moves()) {
          game.move(m);
          const val = -negamax(game, diff-1);
            game.undo();
          if(val>max){ max=val; best=m; }
        }
        game.move(best);
      }
      const hist = game.history({ verbose:true });
      const mv = hist[hist.length-1];
      pushMove(mv);
      highlightLastMove(mv.from, mv.to);
      board.position(game.fen());
      thinking = false;
      if(game.game_over()) announceResult();
    }

    function pushMove(move){ logEl.innerHTML += move.san + ' '; logEl.scrollTop = logEl.scrollHeight; updateEval(); }

    function announceResult(){
      let msg='Game over.';
      if(game.isCheckmate()) msg = 'Checkmate! ' + (game.turn()==='w'?'Black':'White') + ' wins';
      else if(game.isDraw()) msg='Draw.';
      statusEl.textContent = msg; logEl.innerHTML += `<br><b>${msg}</b>`; }

    function getDelay(){ return parseInt(delayInput.value,10) || 0; }

    function newGame(){
      game.reset();
      clearHintHighlights();
      clearLastHighlights();
      logEl.innerHTML='';
      updateEval();
      humanColor = colorSel.value === 'black' ? 'b' : 'w';
      board.start();
      if(humanColor==='b') setTimeout(botMove, Math.max(50,getDelay()));
    }

    function undo(){ if(thinking) return; game.undo(); game.undo(); board.position(game.fen()); updateEval(); clearLastHighlights(); }

    function initBoard(){
      board = Chessboard('board', {
        position:'start', draggable:true,
        pieceTheme:'https://unpkg.com/chessboardjs@1.0.0/www/img/chesspieces/wikipedia/{piece}.png',
        onDragStart:(source,piece)=>{
          if(thinking||game.game_over()) return false;
          if((humanColor==='w' && piece[0]==='b') || (humanColor==='b' && piece[0]==='w')) return false;
          highlightMoves(source);
        },
        onDrop:(s,t)=>{
          clearHintHighlights();
          const move = game.move({ from:s, to:t, promotion:'q' });
          if(!move) return 'snapback';
          pushMove(move); highlightLastMove(s,t); board.position(game.fen());
          setTimeout(()=>{ if((humanColor==='w' && game.turn()==='b') || (humanColor==='b' && game.turn()==='w')) botMove(); }, getDelay());
        }
      });
    }

    // Controls
    document.getElementById('newgame').onclick = newGame;
    document.getElementById('undo').onclick = undo;
    document.getElementById('flip').onclick = () => board.flip();
    colorSel.onchange = saveSettings;
    diffSel.onchange = saveSettings;
    delayInput.onchange = saveSettings;

    // Boot
    window.addEventListener('load', () => { initBoard(); newGame(); });
  </script>
</body>
</html>
